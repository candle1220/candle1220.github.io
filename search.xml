<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>8.排序</title>
      <link href="/post/8893.html"/>
      <url>/post/8893.html</url>
      
        <content type="html"><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>排序就是重新排列表中的元素，使表中的元素满足按关键字有序的过程</p><p>稳定性：在排序前相同的的两个元素，在排序后如果前后顺序没有改变，则是稳定，如果发生了改变，则不稳定</p><p>排序可以分为内部排序和外部排序，内部排序的数据都在内存中，考虑时空复杂度，而外部排序发生在磁盘和内存中，要考虑到尽可能降低读写次数</p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><p><img src="https://s2.loli.net/2022/05/24/QrpMRnlZd9TkYHw.gif" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> x[],<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp, j, i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)     </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (x[i] &lt; x[i - <span class="number">1</span>]) &#123;  <span class="comment">//如果x[i]小于前驱,保证了稳定性</span></span><br><span class="line">temp = x[i];              <span class="comment">//暂存x[i]</span></span><br><span class="line"><span class="keyword">for</span> (j = i ; j &gt;<span class="number">0</span> &amp;&amp; x[j<span class="number">-1</span>] &gt; temp; j--)<span class="comment">//在之前的序列中，找到x[i]的位置，如果x[j-1]&lt;=x[i]了，那么j正好就是插入位置 </span></span><br><span class="line">&#123;                     </span><br><span class="line">x[j] = x[j<span class="number">-1</span>];             <span class="comment">//大于x[i]的数向后移位</span></span><br><span class="line">&#125;</span><br><span class="line">x[j] = temp;                   <span class="comment">//插入</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法存在优化空间，可以用二分查找的思路来查找插入位置，但是时间复杂度并没有改变</p><p>空间复杂度：O(1)</p><p>时间复杂度：O(n²)</p><p>算法稳定性：稳定</p><hr><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li></ul><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录”基本有序”时，再对全体记录进行依次直接插入排序</p><p><img src="https://s2.loli.net/2022/05/25/pH1SIeK3zTRDG79.gif" alt="img"></p><p>可以说希尔排序也就是插入排序的升级版，代码非常相似，就是在外面加了层嵌套</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span> x[],<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp, j, i,gap;</span><br><span class="line"><span class="keyword">for</span> (gap = n/<span class="number">2</span>; gap &gt; <span class="number">0</span>; gap/=<span class="number">2</span>)   <span class="comment">//逐渐减少增量</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (i = gap; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (x[i] &lt; x[i - gap]) &#123;  <span class="comment">//如果x[i]小于前驱</span></span><br><span class="line">temp = x[i];              <span class="comment">//暂存x[i]</span></span><br><span class="line"><span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; x[j - gap] &gt; temp; j-=gap)<span class="comment">//在之前的序列中，找到x[i]的位置，如果x[j-1]&lt;=x[i]了，那么j正好就是插入位置 </span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">x[j] = x[j - gap];             <span class="comment">//大于x[i]的数向后移位</span></span><br><span class="line">&#125;</span><br><span class="line">x[j] = temp;                   <span class="comment">//插入</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间复杂度：O(1)</p><p>时间复杂度：O(n²)</p><p>算法稳定性：不稳定</p><p>只适用于顺序表</p><hr><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢”浮”到数列的顶端。</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, temp;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)   <span class="comment">//只用比较n-1次</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)   <span class="comment">//从前往后比，当然从后往前也是可以的</span></span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;   <span class="comment">//交换</span></span><br><span class="line">     swap(arr[j],arr[j+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间复杂度：O(1)</p><p>时间复杂度：O(n²)</p><p>算法稳定性：稳定</p><hr><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，<strong>快速排序应该算是在冒泡排序基础上的递归分治法</strong></p><p><img src="https://s2.loli.net/2022/05/25/pyF8DNqUowLg3dn.gif" alt="img"></p><p> 算法步骤</p><ol><li>从数列中挑出一个元素，称为 “基准”（pivot）;</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Paritition1</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> pivot = A[low];    <span class="comment">//选定low位置上的数作为枢轴，low空缺</span></span><br><span class="line">   <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">     <span class="keyword">while</span> (low &lt; high &amp;&amp; A[high] &gt;= pivot) &#123; </span><br><span class="line">       --high;                 <span class="comment">// 直到找到小于枢轴的数</span></span><br><span class="line">     &#125;  </span><br><span class="line">     A[low] = A[high];         <span class="comment">//把小于枢轴的数换到low的位置去，此时high空缺</span></span><br><span class="line">     <span class="keyword">while</span> (low &lt; high &amp;&amp; A[low] &lt;= pivot) &#123;</span><br><span class="line">       ++low;                   <span class="comment">// 直到找到大于枢轴的数</span></span><br><span class="line">     &#125;</span><br><span class="line">     A[high] = A[low];        <span class="comment">//把大于枢轴的数换到high的位置去，此时low空缺</span></span><br><span class="line">   &#125;</span><br><span class="line">   A[low] = pivot;            <span class="comment">//high=low时结束，此时将枢轴的值放到该中间位置</span></span><br><span class="line">   <span class="keyword">return</span> low;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> <span class="comment">//快排母函数</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">     <span class="keyword">int</span> pivot = Paritition1(A, low, high);</span><br><span class="line">     QuickSort(A, low, pivot - <span class="number">1</span>);   <span class="comment">//递归</span></span><br><span class="line">     QuickSort(A, pivot + <span class="number">1</span>, high);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>空间复杂度：$O(log_2n)到O(n)$，取决于递归树的深度</p><p>时间复杂度：$O(nlog_2n)$  递归次数是$log_2n$，完成排序操作是n</p><p>算法稳定性：不稳定</p><hr><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。</p><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。重复第二步，直到所有元素均排序完毕。</p><p><img src="https://s2.loli.net/2022/05/25/tzxDLsJ9Bd6HcgR.gif" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span> <span class="comment">//交换两个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; len - <span class="number">1</span> ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">           <span class="keyword">int</span> min = i;</span><br><span class="line">           <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; len; j++)     <span class="comment">//遍历未排序的元素</span></span><br><span class="line">                  <span class="keyword">if</span> (arr[j] &lt; arr[min])     <span class="comment">//找到目前最小值</span></span><br><span class="line">                  &#123;                  </span><br><span class="line">                       min = j;    <span class="comment">//记录最小值</span></span><br><span class="line">                       swap(&amp;arr[min], &amp;arr[i]);    <span class="comment">//交换</span></span><br><span class="line">                  &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间复杂度：O(1)</p><p>时间复杂度：O(n²)</p><p>算法稳定性：不稳定</p><hr><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p><ol><li>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</li><li>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</li></ol><p>首先需要回忆完全二叉树的顺序存储的性质：</p><p><img src="https://s2.loli.net/2022/05/25/uyijC7QprLnOHF2.png" alt="image-20220525162107152" style="zoom:67%;" /></p><p>数组0位置是空，然后按层级遍历顺序存储， <code>i</code>的左孩子结点是<code>2i</code>，<code>i</code>的右孩子结点是<code>2i+1</code>，<code>i</code>的父节点是<code>[i/2]</code>,而<code>n</code>是数组长度，<code>n/2</code>是最后一个非叶子结点位置</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/heapSort.gif" alt="img"></p><p>先建立大根堆，堆顶元素即是最大元素，然后交换堆顶和堆底元素，将堆顶元素移出堆外，重新构建堆，形成递增序列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>* r, <span class="keyword">int</span> dad, <span class="keyword">int</span> end)</span> <span class="comment">//k~end为调整的范围 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ch = <span class="number">2</span> * dad; <span class="comment">//ch为dad的左孩子 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (ch &lt;= end)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//让指针j选出左、右孩子中较大者 </span></span><br><span class="line"><span class="keyword">if</span> (ch &lt; end &amp;&amp; r[ch] &lt; r[ch + <span class="number">1</span>]) <span class="comment">//&quot;lch&lt;end&quot;表示i还有右孩子 ,若右孩子大，则让指针j指向右孩子// </span></span><br><span class="line">&#123;</span><br><span class="line">ch++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根节点与左、右孩子中的较大者 进行比较，进一步筛选出较大者，并将其换到根节点的位置上去 </span></span><br><span class="line"><span class="keyword">if</span> (r[dad] &lt; r[ch])</span><br><span class="line">&#123;</span><br><span class="line">swap(&amp;r[dad], &amp;r[ch]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若发生了，则可能需要对其孩子进行二次调整 </span></span><br><span class="line">dad = ch;</span><br><span class="line">ch = <span class="number">2</span> * dad;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> r[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="comment">//构建堆：由下至上 （由第一个非叶子结点开始） </span></span><br><span class="line"><span class="keyword">for</span> (k = n / <span class="number">2</span>; k &gt;= <span class="number">1</span>; k--)        <span class="comment">// n/2即是由下到上的第一个非叶子结点</span></span><br><span class="line">&#123;</span><br><span class="line">heapify(r, k, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调整堆：由上至下 </span></span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span>; k &lt; n; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//移走堆顶元素 </span></span><br><span class="line">swap(&amp;r[<span class="number">1</span>], &amp;r[n - k +<span class="number">1</span>]);   <span class="comment">//r[1]是堆顶元素，即最大的元素，与堆最小的元素进行交换</span></span><br><span class="line"><span class="comment">//调整堆 </span></span><br><span class="line">heapify(r, <span class="number">1</span>, n - k);        <span class="comment">//每次都让堆顶元素出局，再重新构建堆</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆的插入：新元素放到堆底部（表尾），然后按照堆的要求不断上升，上升只用对比父节点一次关键字</p><p>堆的删除：被删除元素用堆底部元素表示（表尾），然后按堆的要求不断下坠，下坠有可能需要比较两次，也有可能只比一次</p><p>空间复杂度：O(1)</p><p>时间复杂度：$O(nlog_2n)$  堆顶的交换次数是n，堆的调整的时间复杂度是$log_2n$</p><p>算法稳定性：不稳定</p><hr><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p><p> 算法步骤</p><ol><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li><li>重复步骤 3 直到某一指针达到序列尾；</li><li>将另一序列剩下的所有元素直接复制到合并序列尾。</li></ol><p><img src="https://s2.loli.net/2022/05/26/7RV1pseHcr5AFdN.gif" alt="img"></p><p>数组的归并操作就是两个有序数组（链表）的合并，就是合并<code>low-mid</code>，<code>mid+1-high</code>两个数组</p><p><img src="https://s2.loli.net/2022/05/26/dEgJkj5YolsS6DW.png" alt="image-20220526143706541"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> low ,<span class="keyword">int</span> mid,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *b=(<span class="keyword">int</span>*) <span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));       <span class="comment">//创建辅助数组b</span></span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">for</span>(k=low;k&lt;=high;k++)                <span class="comment">//将数组a复制到数组b中</span></span><br><span class="line">    &#123;</span><br><span class="line">        b[k]=a[k];   </span><br><span class="line">    &#125;</span><br><span class="line">    i=low;                 <span class="comment">//i指向第一组起始位置，j指向第二组</span></span><br><span class="line">    j=mid+<span class="number">1</span>               <span class="comment">//low~mid以及mid+1~high内都是有序的</span></span><br><span class="line">     <span class="keyword">for</span>(k=i;i&lt;=mid&amp;&amp;j&lt;=high;k++)   <span class="comment">//k是指向数组a起始位置</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">if</span>(b[i]&lt;=b[j])     <span class="comment">//比较i，j指针数的值，保证稳定性</span></span><br><span class="line">         &#123;            <span class="comment">//结果会替代a[k]位置的值，并且i或者j指针加一，继续比较</span></span><br><span class="line">           a[k]=b[i];     <span class="comment">//直到某一组数都比较完</span></span><br><span class="line">           i++;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           a[k]=b[j];</span><br><span class="line">           j++;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;     </span><br><span class="line">     <span class="keyword">while</span>(i&lt;=mid) a[k++]=b[i++];    <span class="comment">//将剩下的另一组数填到k后</span></span><br><span class="line">     <span class="keyword">while</span>(j&lt;=high) a[k++]=b[j++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> low ,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(low+high)/<span class="number">2</span>;      <span class="comment">//从中间划分</span></span><br><span class="line">        MergeSort(A,low,mid);      <span class="comment">//对左半部分进行归并排序</span></span><br><span class="line">        MergeSort(A,mid+<span class="number">1</span>,high);   <span class="comment">//对右半部分进行归并排序</span></span><br><span class="line">        Merge(A,low,mid,high);     <span class="comment">//归并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间复杂度：O(n) 来自辅助数组</p><p>时间复杂度：$O(nlog_2n)$   归并次数是$log_2n$，每次归并的时间复杂度是n</p><p>算法稳定性：稳定</p><hr><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数</p><p><img src="https://s2.loli.net/2022/05/26/yhf4DlQZ9BsS6qP.gif" alt="img"></p><p>假设要比较很多两位位整数的大小，首先需要建立队列，第一趟先比较各个数个位大小，个位大的先入队，然后出队，按十位大的先入队，十位相同的两个数，由于第一趟排序后，个位大的排在前面，所以个位大的先入队，当数都入队后，再出队</p><p>一般使用链式队列来存储数据，需要r个队列，r为进制位数</p><p>空间复杂度：O(r)</p><p>时间复杂度：O(d(n+r))   一次排序需要O(r)，总共有d次分配，收集</p><p>稳定性：稳定</p><hr><h2 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h2><p>由于数据元素过多，无法一次全部读入内存进行排序，所以需要在内存和磁盘之间进行操作</p><p><strong>外部排序的核心还是归并排序</strong>，在内存中最少只需要3块大小的缓冲区就能对任意大小的文件进行排序归并</p><p><img src="https://s2.loli.net/2022/05/26/TKF7zQklHfmJ32X.png" alt="image-20220526160856370"></p><p>每次读入两块数据到缓冲区，然后进行归并排序，结果到输出缓冲区写入到磁盘中去，如果输入缓冲区空了就再加入一块新数据</p><p>步骤：</p><ol><li>生成r个初始归并段</li><li>进行S趟k路归并 $S=[log_kr]$</li></ol><p>外部排序时间开销=读写外存的时间+内部排序所需时间+内部归并所需时间</p><p>优化思路：</p><ol><li>可以多加2个缓冲区，这样就是4路归并，减少读写磁盘的时间（败者树）</li><li>减少初始归并段（置换-选择排序）</li></ol><hr><p><strong>败者树</strong></p><p>多加了缓冲区后，内部排序需要对比关键字的次数也增加了，为了减少内部排序的对比次数，可以采用败者树的形式</p><p><img src="https://s2.loli.net/2022/05/26/ATPRwE6Cj9uzOBL.png" alt="image-20220526163640881"></p><p>接下来的对比，只需要对比分支结点里面记录的败者归并段的首元素就行了，只需要对比关键字$log_2k$次</p><hr><p><strong>置换-选择排序</strong></p><p><img src="https://s2.loli.net/2022/05/26/vifFZz1JR7rmgWu.png" alt="image-20220526164455552"></p><p>将初始待排序文件集中放在一起，然后进入内存工作区，内部排序得到最小的值，输出该元素，并记录该元素的值为MIN，添加新元素，每次离开内存工作区的元素要比MIN大，并且会成为新的MIN</p><p>如果工作区所有的数都比MIN小，就新开一个归并段</p><hr><p><strong>最佳归并树</strong></p><p>在进行归并的时候，将每个初始归并段看做一个叶子结点，归并段的长度作为结点权值，那么利用哈夫曼树的性质就能实现最少归并次数</p><p><img src="https://s2.loli.net/2022/05/26/YqtJXW5QUSdxApH.png" alt="image-20220526165915036"></p><p>归并过程中磁盘I/O次数=归并树WPL×2</p><p>对于K叉归并，如果初始归并段的数量无法构成严格的k叉归并树，就需要补充几个长度为0的虚段，至于虚段的计算，参照二叉树的性质</p><div class="note primary simple"><p>已知树的结点数=总度数+1 即$n=n_1+2n_2+1$，同时$n=n_0+n_1+n_2$，所以可以推出$n_0=n_2+1$</p></div><p>补充了虚段的最佳归并树的结点只有两种类型，叶子结点和度为k的结点，叶子结点由归并段结点和虚段结点组成，那么可根据树的性质推导</p><ul><li><p>$1+k×n_k=n$  即 1+树的总度数=树的结点总数</p></li><li><p>$n_0+n_k=n$   即 叶子结点+度为k的结点=树的结点总数</p></li><li>$n_0=n_v+n_s$  即 叶子结点=虚段结点+归并段结点</li></ul><p>根据这三个公式推出：$n_v+n_s+n_k=1+k×n_k$，</p><p>即$n_k=\frac{(n_v+n_s-1)}{k-1}$</p><p>需要补充的虚段就是满足这一条件的最小正整数</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.查找</title>
      <link href="/post/12586.html"/>
      <url>/post/12586.html</url>
      
        <content type="html"><![CDATA[<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><p>在数据集合中寻找满足某种条件的数据元素的过程称为查找</p><p>平均查找长度：所有查找过程中进行关键字的比较次数的平均值</p><hr><h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><p>就是从头到尾依次查找</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"> <span class="keyword">int</span> *elem;</span><br><span class="line"> <span class="keyword">int</span>  length;</span><br><span class="line">&#125;<span class="function">table</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_Seq</span><span class="params">(table st,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==key)&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以添加“哨兵“，就不必担心越界问题</p><p>如果查找的是有序表的话，如果查找到比关键字大的数的话，可提前结束查找</p><p>时间复杂度：<code>O(n)</code></p><hr><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>仅适用于有序的顺序表，每次查找从顺序表的一半开始</p><p><img src="https://s2.loli.net/2022/05/24/sLNTz1P6EU8oite.png" alt="image-20220524142406209"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"> <span class="keyword">int</span> *elem;</span><br><span class="line"> <span class="keyword">int</span>  length;</span><br><span class="line">&#125;<span class="function">table</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(table st,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid,high,low;</span><br><span class="line">high=st.length<span class="number">-1</span>;</span><br><span class="line">low=<span class="number">0</span>;</span><br><span class="line">whlie(low&lt;=high)&#123;</span><br><span class="line">mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(st.elem[mid]==key)&#123;</span><br><span class="line">     <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(L.elem[mid]&gt;key)</span><br><span class="line">        high=mid<span class="number">-1</span>; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        low=mid+<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>；</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>折半查找如果是向下取整，则判定树的右子树结点数-左子树结点数=0或1，折半查找如果是向上取整，则判定树的左子树结点数-右子树结点数=0或1   观察树形是否是折半查找判定树，需要注意一整树的所有结点是否都符合</p><p>判定树高为$log_2(n+1)$</p><p>时间复杂度：$O(log_2n)$</p><hr><h2 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h2><p>建立索引表，保存每个分块的最大关键字和分块的存储区间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType maxValue;</span><br><span class="line">    <span class="keyword">int</span> low,high;</span><br><span class="line">&#125;Index;</span><br><span class="line">Elemtype <span class="built_in">list</span>[<span class="number">100</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/05/24/IQcHgMAbRymNqCh.png" alt="image-20220524145733262"></p><p>在索引表中确定待查记录所属的分块（可顺序，可折半），在块内顺序查找</p><p>若索引表中不包含目标关键字，则折半查找索引表最终停在了low&gt;high，要在low的分块中查找</p><p>如果长度为n的查找表被均匀地分为了b块，每块s个元素</p><p>$ASL=L_1+L_S$，当$s=\sqrt{n}$时，$ASL$有最小值$\sqrt{n}+1$</p><hr><h2 id="二叉排序树（BST）"><a href="#二叉排序树（BST）" class="headerlink" title="二叉排序树（BST）"></a>二叉排序树（BST）</h2><p>之前介绍过，是左节点值&lt;根节点值&lt;右节点值</p><h3 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在二叉排序树T中查找包含关键字key的元素的结点 </span></span><br><span class="line"><span class="function">BSTree <span class="title">SearchBST</span><span class="params">(<span class="keyword">const</span> BSTree T, <span class="keyword">int</span>  k)</span> </span>&#123;</span><br><span class="line">    BSTree p = T;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == p-&gt;data ) &#123;</span><br><span class="line">            <span class="keyword">return</span> p;<span class="comment">//查找成功 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; p-&gt;data ) &#123;</span><br><span class="line">            p = p-&gt;Lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p = p-&gt;Rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//查找失败，返回空值 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertBST</span><span class="params">(BSTree* treePtr, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化根节点*/</span></span><br><span class="line">    <span class="keyword">if</span> (*treePtr == <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">        *treePtr = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (*treePtr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            (*treePtr)-&gt;data = value;</span><br><span class="line">            (*treePtr)-&gt;Lchild = <span class="literal">NULL</span>;</span><br><span class="line">            (*treePtr)-&gt;Rchild = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d not inserted. No memory available.\n&quot;</span>, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归实现</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 在左子树中插入 */</span></span><br><span class="line">        <span class="keyword">if</span> (value &lt; (*treePtr)-&gt;data) &#123;</span><br><span class="line">            InsertBST(&amp;((*treePtr)-&gt;Lchild), value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 在右子树中插入*/</span></span><br><span class="line">            <span class="keyword">if</span> (value &gt; (*treePtr)-&gt;data) &#123;</span><br><span class="line">                InsertBST(&amp;((*treePtr)-&gt;Rchild), value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;the element is exists&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>有多种情况</p><ol><li>如果是叶子结点，那么直接删除即可</li><li>如果是只有一棵子树，那么让子树代替即可</li><li>如果有两棵子树，那么需要找到被删除结点的直接前驱或后继，代替其位置即可</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BSTree <span class="title">DeleteBST</span><span class="params">(BSTree T, <span class="keyword">int</span>  k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//BSTree p, fatherp, fatherpre, pre;//设指针p指向待删除的节点，q为p的父节点指针</span></span><br><span class="line">                   <span class="comment">//pre为p的直接前驱，fatherpre为pre的父结点 </span></span><br><span class="line">    BSTree p,fatherp,pre,fatherpre;</span><br><span class="line">    p = T;</span><br><span class="line">    fatherp=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;<span class="comment">//寻找被删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> (k == p-&gt;data )<span class="keyword">break</span>;<span class="comment">//找到被删除的节点，退出 </span></span><br><span class="line">        fatherp = p;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; p-&gt;data ) &#123;</span><br><span class="line">            p = p-&gt;Lchild;<span class="comment">//在左子树中查找 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p = p-&gt;Rchild;<span class="comment">//在右子树中查找 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)<span class="keyword">return</span> T;<span class="comment">//没有找到</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;Lchild == <span class="literal">NULL</span>) &#123;<span class="comment">//p无左子树时</span></span><br><span class="line">        <span class="keyword">if</span> (fatherp== <span class="literal">NULL</span>) &#123;</span><br><span class="line">            T = p-&gt;Rchild;<span class="comment">//p为根，删除后，其右子为根 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (fatherp-&gt;Lchild == p) &#123;<span class="comment">//p为q的左子树时，将p的右子树给q的左子树 </span></span><br><span class="line">            fatherp-&gt;Lchild = p-&gt;Rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//p为q的右子树时，将p的右子树给q的右子树 </span></span><br><span class="line">            fatherp-&gt;Rchild = p-&gt;Rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//当p的左子树存在时，寻找p在中序的直接前驱pre</span></span><br><span class="line">        fatherpre = p;</span><br><span class="line">        pre = p-&gt;Lchild;</span><br><span class="line">        <span class="keyword">while</span> (pre-&gt;Rchild) &#123;</span><br><span class="line">            fatherpre = pre;</span><br><span class="line">            pre = pre-&gt;Rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;data = pre-&gt;data;<span class="comment">//以pre节点代替p结点，相当于删除p结点</span></span><br><span class="line">        <span class="keyword">if</span> (fatherpre!= p) &#123;</span><br><span class="line">            fatherpre-&gt;Rchild = pre-&gt;Lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            fatherpre-&gt;Lchild = pre-&gt;Lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(pre);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找效率分析</p><p>在查找运算中，需要对比关键字的次数称为查找长度</p><p><img src="https://s2.loli.net/2022/05/12/spiB7H3OoC1jXUT.png" alt="image-20220512143616816" style="zoom:67%;" /></p><p>查找失败的平均查找长度ASL=(3×7+4×2)/9=3.22</p><p>因为没有要求BST平衡，所以查找和插入的时间复杂度在<code>O(n)</code>（最坏情况下形成单枝树)</p><hr><h2 id="平衡二叉树（AVL）"><a href="#平衡二叉树（AVL）" class="headerlink" title="平衡二叉树（AVL）"></a>平衡二叉树（AVL）</h2><p>平衡二叉树，首先是二叉排序树，然后树上任一结点的左子树和右子树的高度之差不超过1</p><p>平衡因子：左子树高-右子树高</p><p>平衡二叉树的平衡因子只有可能是-1,0,1</p><p>定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义二叉排序树</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">int</span> bf;<span class="comment">//balance flag</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span>* <span class="title">lchild</span>, * <span class="title">rchild</span>;</span></span><br><span class="line">&#125;*BSTree, BSTNode;</span><br></pre></td></tr></table></figure><p>让AVL维持平衡是重点，根据不同的插入位置，AVL维持平衡的方法也有不同</p><ol><li><p><strong>LL型</strong></p><p>即在AVL的左孩子的左子树上插入了新节点</p><p>调整方法：<strong>①将A的左孩子B提升为新的根结点；②将原来的根结点A降为B的右孩子；③各子树按大小关系连接(BL和AR不变，BR调整为A的左子树)</strong></p><p><img src="https://s2.loli.net/2022/05/12/4VXsFpGtlIQOD7b.png" alt="image-20220512135105861"></p><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 右旋操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R_Rotate</span><span class="params">(BSTNode *p)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//结合图中理解，P是结点A，而lc是结点B</span></span><br><span class="line">    BSTree lc = p-&gt;lchild;   <span class="comment">//定义为根节点的左孩子</span></span><br><span class="line">    p-&amp;gt;lchild = lc-&gt;gtrchild;   <span class="comment">//此时lc的右孩子是null，也就是将A与B断开</span></span><br><span class="line">    lc-&amp;gt;rchild = p;            <span class="comment">//让B的右孩子为A</span></span><br><span class="line">    p = lc;                   <span class="comment">//让B取代A成为根节点</span></span><br><span class="line">&#125;-</span><br></pre></td></tr></table></figure></li><li><p><strong>RR型</strong></p><p>即在AVL的右孩子的右子树上插入了新节点</p><p>调整方法：<strong>①将A的右孩子B提升为新的根结点；②将原来的根结点A降为B的左孩子；③各子树按大小关系连接(AL和BR不变，AR调整为A的右子树)</strong></p><p><img src="https://s2.loli.net/2022/05/12/evykRxLC7tAQT21.png" alt="image-20220512141059711"></p><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左旋操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">L_Rotate</span><span class="params">(BSTNode *p)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//结合图中理解，P是结点A，而lc是结点B</span></span><br><span class="line">    BSTree rc = p-&gt;rchild;   <span class="comment">//定义为根节点的右孩子</span></span><br><span class="line">    p-&gt;rchild = rc-&gt;lchild;   <span class="comment">//此时lc的左孩子是null，也就是将A与B断开</span></span><br><span class="line">    lc-&gt;lchild = p;            <span class="comment">//让B的左孩子为A</span></span><br><span class="line">    p = rc;                   <span class="comment">//让B取代A成为根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>LR型</strong></p><p>即在AVL的左孩子的右子树上插入了结点，导致不平衡</p><p><strong>①将B的左孩子C提升为新的根结点；②将原来的根结点A降为C的右孩子；③各子树按大小关系连接(BL和AR不变，CL和CR分别调整为B的右子树和A的左子树)</strong></p><p><img src="https://s2.loli.net/2022/05/12/qrSL8R49mxQtsgK.png" alt="image-20220512141340932"></p><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先对B子树做左旋处理，再对A子树做右旋处理</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LR_Rotate</span><span class="params">(BSTNode *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> BSTree lc = p-&gt;lchild;   <span class="comment">//定义为根结点的左孩子</span></span><br><span class="line"> p-&gt;lchild=L_Rotate(lc);   <span class="comment">// 将根节点的左子树左旋</span></span><br><span class="line"> p=R_Rotate(p);           <span class="comment">//整个根节点右旋</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p><strong>RL型</strong></p><p>即在AVL的右孩子的左子树上插入了结点，导致不平衡</p><p><strong>①将B的左孩子C提升为新的根结点；②将原来的根结点A降为C的左孩子；③各子树按大小关系连接(AL和BR不变，CL和CR分别调整为A的右子树和B的左子树)</strong></p><p><img src="https://s2.loli.net/2022/05/12/fBTH63qac9Kpory.png" alt="image-20220512142406409"></p><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先对B子树做右旋处理，再对A子树做左旋处理</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RL_Rotate</span><span class="params">(BSTNode *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> BSTree rc = p-&gt;rchild;   <span class="comment">//定义为根结点的右孩子</span></span><br><span class="line"> p-&gt;rchild=R_Rotate(rc);   <span class="comment">// 将根节点的右子树右旋</span></span><br><span class="line"> p=L_Rotate(p);           <span class="comment">//整个根节点左旋</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>不平衡的子树就是需要进行操作树，如果整体不平衡，那就调整整体</strong></p></li></ol><p>求二叉树的平衡因子,即分别求树左子树和右子树的深度，相减即是平衡因子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Factor_Depth_Make</span><span class="params">(Tree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> left,right;</span><br><span class="line">left=right=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(T-&gt;llink)</span><br><span class="line">left=Factor_Depth_Make(T-&gt;llink);</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;rlink)</span><br><span class="line">right=Factor_Depth_Make(T-&gt;rlink);</span><br><span class="line">        T-&gt;bf=left-right;</span><br><span class="line">        T-&gt;depth+=(left&gt;right?left:right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> T-&gt;depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找的时间复杂度不可能超过$O(h)$,平均查找长度为$O(log_2n)$</p><hr><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p><img src="https://s2.loli.net/2022/05/26/95jlsYqomO3thk7.png" alt="image-20220524153449378"></p><p>AVL虽然相较于BST的查找效率有所提升，但是对AVL的操作需要频繁调整树的形态，计算平衡因子，找到最小不平衡子树，再进行旋转操作</p><p>红黑树牺牲了平衡性，换来的是不需要频繁调整树的形态，在适用于<strong>频繁插入，删除</strong>的场景，实用性更强，如果单论查找，AVL更好</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rbnode</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> key;</span><br><span class="line">Rbnode *paraent;  <span class="comment">//父节点指针</span></span><br><span class="line">Rbnode *lchild;   </span><br><span class="line">Rbnode* rchild;</span><br><span class="line"><span class="keyword">int</span> color;       <span class="comment">//结点颜色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/05/24/k6IZvxHrXCFTlny.png" alt="image-20220524155152233"></p><p>性质：</p><ol><li>每个结点是红色的或者黑色的</li><li>根结点是黑色的</li><li>每个叶结点(NIL)是黑色的</li><li>不存在两个相邻的红结点</li><li>对于每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点</li><li>新加入的结点是红色结点</li></ol><p>推论：</p><ol><li><strong>从根节点到叶子节点的最长路径不大于最短路径的2倍</strong>，当红色节点和黑色节点数量相同时，就是最长路径，也就是黑色节点（或红色节点）* 2</li><li>有n个内部结点的红黑树高度$h&lt;2log_2(n+1)$</li></ol><hr><h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>又称多路平衡查找树，B树中所有结点的孩子的个数的最大值称为B树的阶，通常用m表示，一棵m阶B树应满足以下性质：</p><ol><li>树中每个结点至多有m棵子树，即至多有m-1个关键字</li><li>若根节点不是终端结点，则至少有两棵子树</li><li>除根节点外的所有非叶结点至少有[m/2]棵子树，即至少有[m/2]-1个关键字</li><li>所有叶节点出现在同一层次上，并不带信息</li></ol><p><img src="https://s2.loli.net/2022/05/24/r8CPnDkG9m35BHp.png" alt="image-20220524162027943"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    ElemType keys[<span class="number">4</span>]; <span class="comment">//4个关键字</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">child</span>[5];</span>  <span class="comment">//5个孩子</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B树：为磁盘而生</p><p>传统用来搜索的平衡二叉树有很多，如 AVL 树，红黑树等。这些树在一般情况下查询性能非常好，但当数据非常大的时候它们就无能为力了。原因当数据量非常大时，内存不够用，大部分数据只能存放在磁盘上，只有需要的数据才加载到内存中。一般而言内存访问的时间约为 50 ns，而磁盘在 10 ms 左右。速度相差了近 5 个数量级，磁盘读取时间远远超过了数据在内存中比较的时间。这说明程序大部分时间会阻塞在磁盘 IO 上。那么我们如何提高程序性能？减少磁盘 IO 次数，像 AVL 树，红黑树这类平衡二叉树从设计上无法“迎合”磁盘</p><p><strong>平衡二叉树是通过旋转来保持平衡的，而旋转是对整棵树的操作，若部分加载到内存中则无法完成旋转操作。</strong>其次平衡二叉树的高度相对较大为$log_2n$，<strong>这样逻辑上很近的节点实际可能非常远，无法很好的利用磁盘预读（局部性原理）</strong>，所以这类平衡二叉树在数据库和文件系统上的选择就被 pass 了</p><p>B树多叉的好处非常明显，有效的降低了B-树的高度，为底数很大的$logn$，底数大小与节点的子节点数目有关，一般一棵B-树的高度在 3 层左右。层数低，每个节点区确定的范围更精确，范围缩小的速度越快（<strong>比二叉树深层次的搜索肯定快很多</strong>）</p><hr><p><strong>插入操作</strong></p><p><img src="https://s2.loli.net/2022/05/24/cvP1rSfs298AhEk.png" alt="image-20220524163844052"></p><p>一定是插入到底层结点，如果插入key后导致原结点关键字数超过上限，则从中间位置<strong>[m/2]</strong>，将其中关键字分为两部分，左部分包含关键字放在原结点中，右部分包含关键字放在新结点中，而中间位置[m/2]插入原结点的父节点</p><hr><p><strong>删除操作</strong></p><p>若被删除关键字在终端节点，则直接删除该关键字，如果删后关键字低于下限，则找右兄弟或左兄弟借，如果都不够借，则进行合并</p><p>若被删除的关键字在非终端节点，则用直接前驱或直接后继来替代被删除的关键字</p><hr><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>B+树是B-树的变体，也是一种多路搜索树, 它与 B- 树的不同之处在于:</p><ol><li>所有关键字存储在叶子节点出现,内部节点(非叶子节点并不存储真正的 data)</li><li>为所有叶子结点增加了一个链指针</li></ol><p><img src="https://s2.loli.net/2022/05/24/uf3dTG4OScx9H6Z.png" alt="image-20220524164949895"></p><p>所有叶节点包含全部关键字以及指向相应记录的指针，并且相邻叶节点按大小顺序相互链接起来，支持顺序查找</p><p>和B树的不同之处在于：</p><ol><li><strong>B+树内节点不存储数据，所有 data 存储在叶节点导致查询时间复杂度固定为 log n。而B-树查询时间复杂度不固定，与 key 在树中的位置有关，最好为O(1)。</strong></li><li><strong>B+树叶节点两两相连可大大增加区间访问性，可使用在范围查询等，而B-树每个节点 key 和 data 在一起，则无法区间查找。</strong></li><li><strong>B+树更适合外部存储。由于内节点无 data 域，每个节点能索引的范围更大更精确</strong></li></ol><p><img src="https://s2.loli.net/2022/05/24/5nxKTdSNh7JwoiP.png" alt="image-20220524165633725"></p><hr><h2 id="散列查找"><a href="#散列查找" class="headerlink" title="散列查找"></a>散列查找</h2><p>散列表(Hash Table)：又称哈希表，是一种数据结构，特点是数据元素的关键字和存储地址直接相关</p><p>通过<strong>散列函数</strong>建立关键字和存储地址的联系</p><p><img src="https://s2.loli.net/2022/05/24/GNVe31b7tYoZmcq.png" alt="image-20220524193048839"></p><p>常见的散列函数有：</p><ol><li><p>除留余数法</p><p>$H(key)=key\%b$     取一个不大于m但最接近或等于m的质数p</p></li><li><p>直接定址法</p><p>$H(key)=a×key+b$      </p><p> a和b是常数，适合关键字的分布基本连续的情况</p></li><li><p>数字分析法</p><p>设关键字是r进制数，而r个数码在各位上出现的频率不一定相同，可能在某些位上分布更加均匀，可以选取更加均匀地若干位作为散列地址</p></li><li><p>平方取中法</p><p>取关键字的平方值的中间几位作为散列地址，这种方法的散列地址与关键字的每位都有关系</p></li></ol><p>如果不同的关键字通过散列函数映射到同一个值，则称位同义词，通过散列函数确定的位置已经存放了其他元素，则称这种情况为冲突</p><p>处理这种冲突有多种方法：</p><ol><li><p>拉链法</p><p>把所有同义词存储在一个链表中</p><p><img src="https://s2.loli.net/2022/05/24/16mOidTcQl7RXDI.png" alt="image-20220524193148870"></p><p><strong>$ASL_{失败}$=装填因子$\alpha$=表中记录数/散列表长度</strong></p></li><li><p>开放定址法</p><p>就是可存放的空闲地址既向同义词表项开放，又向非同义词表项开放</p><p>而线性探测法，就是当发生冲突时，就将表项往后移动一个单位即可，对散列表的查找，<strong>如果查找到空位置则查找失败，对空位置的判断也要算作是一次比较</strong></p><p><img src="https://s2.loli.net/2022/05/26/P5qHdhMGQOUXwWn.png" alt="image-20220524201123667"></p><p>散列函数为key%7</p><p>$ASL_{成功}=(1+1+1+1+1+1+1+2)/8=1.125$</p><p>因为H(key)肯定是在0~6之间的，所以只用考虑在这区间内的查找失败情况</p><p>$ASL_{失败}=(9+8+7+6+5+4+3)/7=6$</p></li></ol><p>   采用开放定址法，删除结点不能简单地将被删结点置空，而是应该做一个标志，方便继续向后查找</p><p>   线性探测法很容易造成同义词和非同义词的<strong>堆积</strong>，影响查找效率</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.图</title>
      <link href="/post/39739.html"/>
      <url>/post/39739.html</url>
      
        <content type="html"><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>图</strong>是由顶点的有穷非空集合和顶点之间边的集合组成， 通常表示为: G（V，E）， 其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合</p><p><img src="https://s2.loli.net/2022/05/12/OLvaXWJd3z5qGgx.png" alt="image-20220512210137535"></p><p>线性表可以是空表，树可以是空树，但是图不可以是空，即V一定是非空集</p><hr><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p><img src="https://s2.loli.net/2022/05/12/z1KmcbnPL4iZDrw.png" alt="image-20220512210442402"></p><p><strong>无向图</strong>：如果E是由无向边的有限集合时，则图G为无向图</p><p><strong>度</strong>：对于无向图，顶点的度指依附于该顶点的边的条数</p><p><strong>无向完全图</strong>：在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。含有n个顶点的无向完全图有$\frac{n(n+1)}{2}$条边</p><p><img src="https://s2.loli.net/2022/05/12/mqi15snV4zdSKaA.png" alt="image-20220512210814592"></p><p><strong>有向图</strong>：若E是有向边(弧)的有限集合时，则图G为有向图，弧是顶点的有序对，记为<em><v,w></em>，其中v,w是顶点，<em>v</em>称为弧尾，<em>w</em>称为弧头，<em><v,w></em>称为从顶点<em>v</em>到顶点<em>w</em>的弧，<em><v,w>≠<w,v></em>；</p><p><strong>入度，出度</strong>：对于有向图，入度是以顶点为终点的有向边的数目，记为ID(<em>v</em>)，出度是以顶点为起点的有向边的数目，记为OD(<em>v</em>)，顶点的度等于其入度和出度之和，对于有向图，图的总入度和总出度肯定是相同的</p><p><strong>有向完全图</strong>：在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。含有n个顶点的有向完全图有<code>n× (n-1)</code>条边</p><hr><p><strong>子图</strong>： 假设有两个图<code>G= (V，&#123;E&#125;</code>)和<code>G&#39;= (V&#39;，&#123;E&#39;&#125;)</code>，如果V’是V的子集，且E’是E的子集，则称G’为G的子图。如下图带底纹的图均为左侧无向图与有向图的子图。</p><p><strong>路径和路径的长度</strong>：从顶点A到顶点B的路径是一个顶点序列。路径的长度是路径上的边或弧的数目。有向图的路径也是有向的</p><p><strong>回路</strong>：第一个顶点和最后一个顶点相同的路径称为回路</p><p><strong>简单路径、简单回路或简单环</strong>：序列中顶点不重复出现的路径称为简单路径。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环</p><p><strong>点与点的距离</strong>：从顶点u出发到顶点v的最短路径若存在，则此路径的长度称为从u到v的距离，若不存在路径，则记该距离为无穷($\infty$)</p><hr><p><img src="https://s2.loli.net/2022/05/17/QeLfHRSBV56qz2U.png" alt="image-20220517160124855" style="zoom:67%;" /></p><p><strong>连通、连通图和连通分量</strong>：在无向图G中，如果从顶点v到顶点v’有路径，则称v和v’是连通的。 如果对于图中任意两个顶点vi、vj ∈E， vi，和vj都是连通的，则称G是连通图</p><p><strong>无向图</strong>中的<strong>极大连通子图</strong>称为<strong>连通分量</strong>。注意连通分量的概念，它强调:</p><ul><li>要是子图；</li><li>子图要是连通的；</li><li>连通子图含有极大顶点数；</li><li>具有极大顶点数的连通子图包含依附于这些顶点的所有边。</li></ul><p>图2，图3，图4都是无向图1的子图，图2是极大连通子图，图3也极大连通子图，图4不满足极大的特点</p><p><img src="https://s2.loli.net/2022/05/17/TS2H3xYQXLJDGuE.png" alt="image-20220517160843870" style="zoom:67%;" /></p><p><strong>强连通图和强连通分量</strong>：在有向图G中，如果对于每一对vi，vj属于E，从vi到vj和vj 到vi都有路径，则称G是强连通图。有向图中的极大强连通子图称作有向图的强连通分量。</p><p>即ABCDE组成了一个强连通分量，而F缺乏到B的路径，没有包含在内，F和G单独为一个强连通分量</p><p>每一个孤立结点都构成连通分量</p><hr><p><strong>生成树</strong>：一个极小的连通子图， 它含有图中全部的n个顶点，但只有足以构成一棵树的n-1条边，简而言之就是用最少的边连接所有顶点</p><p><strong>权和网</strong>：有些图的边或弧具有与它相关的数字，这种与图的边或弧相关的数叫做权。这些权可以表示从一个顶点到另一个顶点的距离或耗费。这种带权的图通常称为网</p><p><strong>树</strong>是一种不存在回路，且连通的无向图</p><hr><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>无向图边数的2倍等于各顶点的度数的总和</p><hr><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="邻接矩阵法"><a href="#邻接矩阵法" class="headerlink" title="邻接矩阵法"></a>邻接矩阵法</h3><p>图的邻接矩阵存储方式是用<strong>两个数组来表示图</strong>。一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息</p><p>定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VertexMax 100 <span class="comment">//最大顶点数为100</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxInt 32767 <span class="comment">//表示最大整数，表示 ∞</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Maxsize 100 <span class="comment">//队列最大元素个数100 </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VertexType; <span class="comment">//每个顶点数据类型为字符型</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">int</span> dataType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">VertexType Vertex[VertexMax];<span class="comment">//存放顶点元素的一维数组,VertexType表示元素的数据类型</span></span><br><span class="line"><span class="keyword">int</span> AdjMatrix[VertexMax][VertexMax];<span class="comment">//邻接矩阵二维数组 </span></span><br><span class="line"><span class="keyword">int</span> vexnum, arcnum;<span class="comment">//图的顶点数和边数</span></span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找元素v在一维数组 Vertex[] 中的下标，并返回下标 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateVex</span><span class="params">(MGraph* G, VertexType v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (v == G-&gt;Vertex[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;No Such Vertex!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结点数为n的图G中，邻接矩阵是<code>n×n</code>大小的，初始化数值为<code>0</code>，如果<code>i</code>行<code>j</code>列数值为<code>1</code>，表示第<code>i</code>个元素到第<code>j</code>个元素存在路径，在无向图中，是双向的，即<code>i</code>行<code>j</code>列以及<code>j</code>行<code>i</code>列数值都会为<code>1</code>，而在有向图中，是单向的</p><p>无向图：</p><p><img src="https://s2.loli.net/2022/05/17/LyCzKNQmqZjD64B.png" alt="image-20220517170049835"></p><p>有向图：</p><p><img src="https://s2.loli.net/2022/05/17/4G9PYVzwNU3Mqds.png" alt="image-20220517170107887"></p><p>创建邻接矩阵</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无向图和有向图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateUDG</span><span class="params">(MGraph* G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="comment">//1.输入顶点数和边数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入顶点个数和边数(用逗号隔开)：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>, &amp;G-&gt;vexnum, &amp;G-&gt;arcnum);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.输入顶点元素 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入顶点元素(无需空格隔开)：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, G-&gt;Vertex);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="comment">//3.矩阵初始化</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G-&gt;vexnum; j++)</span><br><span class="line">&#123;</span><br><span class="line">G-&gt;AdjMatrix[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.构建邻接矩阵</span></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">VertexType v1, v2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入边的信息：\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;arcnum; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot; %c%c&quot;</span>, &amp;v1, &amp;v2);</span><br><span class="line">n = LocateVex(G, v1); <span class="comment">//获取v1所对应的在Vertex数组中的坐标 </span></span><br><span class="line">m = LocateVex(G, v2); <span class="comment">//获取v2所对应的在Vertex数组中的坐标</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">-1</span> || m == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NO This Vertex!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">G-&gt;AdjMatrix[n][m] = <span class="number">1</span>;   <span class="comment">// 创建有向图</span></span><br><span class="line"><span class="comment">//G-&gt;AdjMatrix[m][n] = 1;      创建无向图</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>对于带权图（网）来说，将矩阵里面的值初始化为<code>∞</code>，如果存在路径，则路径的值为权值</p><p>无向网：</p><p><img src="https://s2.loli.net/2022/05/17/Hzq8dinVEOs7myg.png" alt="image-20220517171039499"></p><p>有向网：</p><p><img src="https://s2.loli.net/2022/05/17/VcxEn2s5zFteZrM.png" alt="image-20220517171059855"></p><p>创建邻接矩阵</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateUDN</span><span class="params">(MGraph* G)</span><span class="comment">//构建无向网（Undirected Network）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="comment">//1.输入顶点数和边数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入顶点个数和边数(用逗号隔开)：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>, &amp;G-&gt;vexnum, &amp;G-&gt;arcnum);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.输入顶点元素 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入顶点元素(无需空格隔开)：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, G-&gt;Vertex);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="comment">//3.矩阵初始化</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G-&gt;vexnum; j++)</span><br><span class="line">&#123;</span><br><span class="line">G-&gt;AdjMatrix[i][j] = MaxInt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.构建邻接矩阵</span></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">VertexType v1, v2;</span><br><span class="line"><span class="keyword">int</span> w;<span class="comment">//v1-&gt;v2的权值 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入边的信息：\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;arcnum; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot; %c%c,%d&quot;</span>, &amp;v1, &amp;v2, &amp;w);</span><br><span class="line">n = LocateVex(G, v1); <span class="comment">//获取v1所对应的在Vertex数组中的坐标 </span></span><br><span class="line">m = LocateVex(G, v2); <span class="comment">//获取v2所对应的在Vertex数组中的坐标</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">-1</span> || m == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NO This Vertex!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">G-&gt;AdjMatrix[n][m] = w;</span><br><span class="line"><span class="comment">//G-&gt;AdjMatrix[m][n] = w;//无向网仅此处不同 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>对有向图来说</p><p>第<code>i</code>个结点的出度=第<code>i</code>行非零元素个数</p><p>第<code>i</code>个结点的入度=第<code>i</code>列非零元素个数</p><p>第<code>i</code>个结点的度=第<code>i</code>行，第<code>i</code>列非零元素个数之和</p><p>邻接矩阵法求顶点的度的时间复杂度为<code>O(n)</code>，空间复杂度为<code>O(n²)</code>，之和顶点数有关，和实际边数无关，适用用于存储稠密图，而且无向图的邻接矩阵是对称矩阵，可以压缩存储</p><p>设图G的邻接矩阵为A，则$A^n$的元素$A^n[i][j]$等于由顶点<code>i</code>到顶点<code>j</code>的长度为<code>n</code>的路径的数目</p><hr><h3 id="邻接表法"><a href="#邻接表法" class="headerlink" title="邻接表法"></a>邻接表法</h3><p>邻接表由顶点表和边表组成，顶点表是结构体数组，边表是一环一环的链节</p><p><img src="https://s2.loli.net/2022/05/18/ZiDEqIHxLljbrnQ.png" alt="image-20220518144342896"></p><p>顶点表是结构体数组，其中的每个元素有两个域：数据域（用于存放顶点元素如V1、V2、V3或A、B、C之类的）。指针域，用于连接边表。</p><p>边表是结构体，其中每个结点也有两个域：下标域，存储的是对应元素在顶点表中的下标。指针域，用于连接后续结点</p><p>（邻接表法和树的孩子表示法一模一样，都是顺序+链式存储）</p><p>定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>//边表 </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> adjvex;<span class="comment">//存储的是该顶点在顶点数组即AdjList[]中的位置 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span> //单个顶点 </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">VertexType vertex;  <span class="comment">//数据域</span></span><br><span class="line"><span class="comment">//int weight；//存储网的时候需要添加此项</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">firstarc</span>;</span>   <span class="comment">//第一个孩子节点</span></span><br><span class="line">&#125;VNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> //顶点表 </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">VNode AdjList[VertexMax];<span class="comment">//由顶点构成的结构体数组 </span></span><br><span class="line"><span class="keyword">int</span> vexnum,arcnum; <span class="comment">//顶点数n和边数e </span></span><br><span class="line">&#125;ALGraph;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/05/18/EnHsg9ONylz8rBI.png" alt="image-20220518144643827"></p><p><img src="https://s2.loli.net/2022/05/18/qRZ6A4sWnladHtx.png" alt="image-20220518150702207"></p><p>对于无向图，边节点的数量是2n，整体空间复杂度为V+2n</p><p>对于有向图，边节点的数量是n，整体空间复杂度为V+n</p><p>在无向图中，如果要求节点的度，遍历节点的边表即可，在有向图中，如果要找有向边的入度，那么需要遍历所有结点</p><p>图的邻接表表示并不唯一，空间复杂度低，适合存放稀疏图</p><hr><h3 id="十字链表法"><a href="#十字链表法" class="headerlink" title="十字链表法"></a>十字链表法</h3><p>邻接表法容易求顶点的出度，但不容易求顶点的入度</p><p>如果我们更改邻接表的定义，将有向图中指向该结点的弧记录为孩子，那么就变成了逆邻接表，容易求顶点的入度，但不容易求顶点的出度</p><p>如果把邻接表和逆邻接表结合起来，既可以方便求入度，也可以方便求出度，这就是十字链表法</p><p>顶点结点：</p><p><img src="https://s2.loli.net/2022/05/18/4I9fbS8hveVa5Tr.png" alt="image-20220518154636296" style="zoom:67%;" /></p><p>弧结点：</p><p><img src="https://s2.loli.net/2022/05/18/Srt9pvRxMNOZBsQ.png" alt="image-20220518154311640" style="zoom:67%;" /></p><p>相比于邻接表法，顶点表多了一个firstin区域，用于记录指向结点的弧</p><p>边表扩充了一倍，同时记录了弧头顶点编号和弧头相同的下一条弧（橙色部分）</p><p><img src="https://s2.loli.net/2022/05/18/nRTih6tqUpdE9xu.png" alt="image-20220518155636604"></p><p>（如果把橙色区域以及指针全去了，就是邻接表法）</p><p>空间复杂度为V+n，只适合存储有向图</p><hr><h3 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h3><p>因为邻接表法在存储无向图的时候会存储冗余数据，所以利用十字链表的方法，使用邻接多重表来存储无向图</p><p>比起十字链表法，邻接多重表只有边表被扩充了</p><p><img src="https://s2.loli.net/2022/05/26/yl4YrtRKDTAaqiM.png" alt="image-20220518160212613" style="zoom:67%;" /></p><p><img src="https://s2.loli.net/2022/05/18/VeQGfR4NdKtcig5.png" alt="image-20220518160235586"></p><p>空间复杂度V+n，而且删除边和节点操作变得简单，只适合用存储无向图</p><hr><p><img src="https://s2.loli.net/2022/05/18/dUvxYiXfDN2jtVJ.png" alt="image-20220518161142466"></p><hr><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p><img src="https://s2.loli.net/2022/05/18/JSxVpUYeB7lKvg9.gif" alt="img"></p><h3 id="广度优先遍历-BFS"><a href="#广度优先遍历-BFS" class="headerlink" title="广度优先遍历(BFS)"></a>广度优先遍历(BFS)</h3><p>类似于树的层次遍历</p><p>即先从某个结点开始，先遍历最离其最近的结点，再遍历到深层的结点</p><p><img src="https://s2.loli.net/2022/05/18/dlCsAfBb1SkPnOI.png" alt="image-20220518163613467"></p><p>基本步骤：</p><ol><li><p>设置全局变量visited数组并初始化为全0，代表所有节点均未被访问</p></li><li><p>设置起始点：包括对起始点进行<strong>输出、标记成已访问、入队</strong></p></li><li><p>对后续结点进行操作：由起始点开始，对后续结点进行操作（<strong>输出、标记成已访问、入队</strong>）<br>（步骤2-3为<strong>广度优先搜索</strong>）</p></li><li><p>循环重复2-3的操作避免有“孤岛”结点被遗漏。<br>（步骤4 循环执行广度优先搜索避免遗漏“孤岛”结点，就是广度优先遍历）</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接矩阵法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> visitedBFS[VertexMax];<span class="comment">//定义&quot;标志&quot;数组为全局变量 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(MGraph *G,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line">CyQueue q;    <span class="comment">//队列</span></span><br><span class="line">create(&amp;q);   <span class="comment">//初始化队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.设置起始点 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,G-&gt;Vertex[i]);<span class="comment">//1.输出起始结点 </span></span><br><span class="line">visited[i]=<span class="number">1</span>;<span class="comment">//2.将已访问的结点标志成1</span></span><br><span class="line">EnQueue(&amp;q,i);<span class="comment">//3.将第一个结点入队 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.由起始点开始，对后续结点进行操作 </span></span><br><span class="line"><span class="keyword">while</span>(!QueueEmpty(&amp;q))<span class="comment">//队列非空</span></span><br><span class="line">&#123;</span><br><span class="line">DeQueue(&amp;q,&amp;i);  <span class="comment">//出队  i的值根据出队的元素在变</span></span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G-&gt;vexnum;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(G-&gt;AdjMatrix[i][j]==<span class="number">1</span>&amp;&amp;visited[j]==<span class="number">0</span>) <span class="comment">//如果矩阵内存在路径</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,G-&gt;Vertex[j]);<span class="comment">//输出符合条件的顶点 </span></span><br><span class="line">            visitedBFS[j]=<span class="number">1</span>;<span class="comment">//设置成已访问状态1 </span></span><br><span class="line">            EnQueue(&amp;q,j);<span class="comment">//入队 j的值根据入队的元素在变</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//为了避免孤岛结点无法被遍历到，需要确认visit数组都为1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(MGraph *G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组初始化为全0 </span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;vexnum;i++)</span><br><span class="line">&#123;</span><br><span class="line">visited[i]=<span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;vexnum;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(visited[i]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">BFS(G,i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于BFS，邻接矩阵的遍历序列唯一，邻接表不唯一</p><p>对于无向图，调用BFS函数的次数等于连通分量的次数</p><p>空间复杂度：来自于辅助队列，大小为<code>O(n)</code></p><p>时间复杂度：</p><p>对于邻接矩阵：针对每一个元素<code>i</code>，都会扫描<code>j</code>列来确定是否邻接，所以其时间复杂度为<code>O(n²)</code></p><p>对于邻接表：针对每一个元素<code>i</code>，只需要找其边表即可确定邻接的点，所以时间复杂度为<code>O(n)</code></p><hr><h3 id="深度优先遍历-DFS"><a href="#深度优先遍历-DFS" class="headerlink" title="深度优先遍历(DFS)"></a>深度优先遍历(DFS)</h3><p>类似于树的先序遍历</p><p>基本步骤</p><ol><li>设置全局变量visited数组并初始化为全0，代表所有节点均未被访问</li><li>选取初始端点：对初始端点进行访问，并在visited数值中标记成已访问状态（代码演示的初始端点是G-&gt;Vertex[i]，此时i=0）</li><li>循环对所有节点都执行步骤2，前提是该节点未被访问！（对应函数DFSTraverse，主要用于非连通图能访问到每一个结点）</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> visitedDFS[VertexMax];<span class="comment">//定义&quot;标志&quot;数组为全局变量 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(MGraph* G, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.处理起始点 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, G-&gt;Vertex[i]);<span class="comment">//1.输出起始结点 </span></span><br><span class="line">visitedDFS[i] = <span class="number">1</span>;<span class="comment">//2.将已访问的结点标志成1</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//2.由起始点开始，对后续结点进行操作</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G-&gt;vexnum; j++)<span class="comment">//依次搜索vi的邻接点 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (G-&gt;AdjMatrix[i][j] == <span class="number">1</span> &amp;&amp; visitedDFS[j] == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//当满足有边且未被访问过时，递归调用去查找该邻接点 </span></span><br><span class="line">&#123;</span><br><span class="line">DFS(G, j);<span class="comment">//注意此处的G已经是指针类型，不需要再&amp;G </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(MGraph* G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="comment">//初始化&quot;标志&quot;数组为0，代表未访问</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i++)</span><br><span class="line">&#123;</span><br><span class="line">visitedDFS[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (visitedDFS[i] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">DFS(G, i);<span class="comment">//注意此处的G已经是指针类型，不需要再&amp;G </span></span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于BFS，邻接矩阵的遍历序列唯一，邻接表不唯一</p><p>空间复杂度：来自于递归调用工作栈，大小为<code>O(n)</code></p><p>时间复杂度：</p><p>对于邻接矩阵：针对每一个元素<code>i</code>，都会扫描<code>j</code>列来确定是否邻接，所以其时间复杂度为<code>O(n²)</code></p><p>对于邻接表：针对每一个元素<code>i</code>，只需要找其边表即可确定邻接的点，所以时间复杂度为<code>O(n)</code></p><hr><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>在无向网中，所有路径的权值之和最小的生成树，称为最小生成树(Minimum Cost Spanning Tree)</p><h3 id="普里姆算法-Prim"><a href="#普里姆算法-Prim" class="headerlink" title="普里姆算法(Prim)"></a>普里姆算法(Prim)</h3><p>对<strong>顶点</strong>操作，在<strong>最小生成树的顶点集U</strong>和<strong>待处理顶点集V-U</strong>中，不断地寻找<strong>最短边(代价最小变)</strong>，找到后将对应顶点<strong>加入集合U</strong>，直到所有顶点均处理完毕(V-U里没有剩余顶点)</p><ol><li><p>首先我们需要一个结构体数组：最短路径数组<strong>shortedge</strong>来存储当前各个顶点之间的最短路径信息，其中的adjvex用于存储最短边的邻接点，lowcost是其对应权值，也就是当前最小的代价</p></li><li><p>对shortedge数组写入初始化信息，将起始点放入集合U中，即 <code>shortedge[k].lowcost=0;</code>lowcost为0表示该顶点属于U集合,k是起始点的位置</p></li><li><p>求最小值的函数（minimal）：只需要在当前shortage数组中比较出lowcost最小的元素，返回它的下标loc即可在Vertex数组中找到该元素。</p></li><li><p>对后续顶点处理：通过minimal函数找到最小路径所对应的的顶点， 将此路径对应的顶点放入集合U中（将其对应的lowcost改为0），更新shortedge数组（集合U中加入新的顶点，阵营U中有可能生成新的最小路径到达阵营V-U中）</p><p><img src="https://s2.loli.net/2022/05/18/xpSlz9HwgGi3mkd.png" alt="image-20220518203726957"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//1.结构体数组存储最短路径</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>//最短路径数组结构体(候选最短边) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">VertexType adjvex;<span class="comment">//候选最短边的邻接点 </span></span><br><span class="line"><span class="keyword">int</span> lowcost;<span class="comment">//候选最短边的权值 </span></span><br><span class="line">&#125;ShortEdge;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 求最小值的函数(minimal):只需要在当前shortage数组中比较出lowcost最小的元素</span></span><br><span class="line"><span class="comment">//    返回它的下标loc即可在Vertex数组中找到该元素。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimal</span><span class="params">(MGraph* G, ShortEdge* shortedge)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> min, loc;</span><br><span class="line"></span><br><span class="line">min = MaxInt;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; G-&gt;vexnum; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (min &gt; shortedge[i].lowcost &amp;&amp; shortedge[i].lowcost != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">min = shortedge[i].lowcost;</span><br><span class="line">loc = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> loc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MiniSpanTree_Prim</span><span class="params">(MGraph* G, VertexType start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, k;</span><br><span class="line">ShortEdge shortedge[VertexMax];</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.处理起始点start，写入初始信息</span></span><br><span class="line">k = LocateVex(G, start);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i++)</span><br><span class="line">&#123;</span><br><span class="line">shortedge[i].adjvex = start;</span><br><span class="line">shortedge[i].lowcost = G-&gt;AdjMatrix[k][i];</span><br><span class="line">&#125;</span><br><span class="line">shortedge[k].lowcost = <span class="number">0</span>;<span class="comment">//lowcost为0表示该顶点属于U集合 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.处理后续结点 </span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;vexnum - <span class="number">1</span>; i++)<span class="comment">//对集合U，去找最短路径的顶点 </span></span><br><span class="line">&#123;</span><br><span class="line">k = minimal(G, shortedge);<span class="comment">//找最短路径的顶点 </span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%c-&gt;%c,%d\n&quot;</span>, shortedge[k].adjvex, G-&gt;Vertex[k], shortedge[k].lowcost);</span><br><span class="line">        <span class="comment">//输出找到的最短路径顶，及路径权值 </span></span><br><span class="line">shortedge[k].lowcost = <span class="number">0</span>;<span class="comment">//将找到的最短路径顶点加入集合U中 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G-&gt;vexnum; j++)</span><br><span class="line">            <span class="comment">//U中加入了新节点，可能出现新的最短路径，故更新shortedge数组 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (G-&gt;AdjMatrix[k][j] &lt; shortedge[j].lowcost)</span><br><span class="line">                <span class="comment">//有更短路径出现时，将其替换进shortedge数组 </span></span><br><span class="line">&#123;</span><br><span class="line">shortedge[j].lowcost = G-&gt;AdjMatrix[k][j];</span><br><span class="line">shortedge[j].adjvex = G-&gt;Vertex[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>时间复杂度：<code>O(n²)</code>，显然有个嵌套，第一个嵌套是遍历n-1个节点，时间复杂度是<code>O(n)</code>，第二个嵌套中，先要找到最短路径的顶点，即miniaml函数，时间复杂度是<code>O(n)</code>，找到后需要更新shortedge数组，时间复杂度是<code>O(n)</code>，共<code>O(2n)</code>，所有总时间复杂度为O(n²)</p><p>适合于稠密图</p><hr><h3 id="克鲁斯卡尔算法-Kruskal"><a href="#克鲁斯卡尔算法-Kruskal" class="headerlink" title="克鲁斯卡尔算法(Kruskal)"></a>克鲁斯卡尔算法(Kruskal)</h3><p><strong>每次选取最短边，但不能构成回路</strong></p><p>如果用邻接矩阵和邻接表，每次寻找最短边都要搜索所有边，故邻接矩阵和邻接表均不合适，所以最终选用了边集数组</p><p><strong>边集数组edge</strong>是一个结构体数组，每一个单元包含起点、终点、权值</p><p><img src="https://s2.loli.net/2022/05/18/HvqWrK6ynBQFa43.png" alt="image-20220518205130127" style="zoom:67%;" /></p><p>定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">VertexType begin;<span class="comment">//起点</span></span><br><span class="line">VertexType end;<span class="comment">//终点</span></span><br><span class="line"><span class="keyword">int</span> weight;</span><br><span class="line">&#125;Edge;<span class="comment">//边集数组edge[]的单元 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">VertexType Vertex[VertexMax];<span class="comment">//顶点数组 </span></span><br><span class="line">Edge edge[VertexMax];<span class="comment">//边集数组 </span></span><br><span class="line"><span class="keyword">int</span> vexnum;<span class="comment">//顶点数 </span></span><br><span class="line"><span class="keyword">int</span> edgenum;<span class="comment">//边数 </span></span><br><span class="line">&#125;EdgeGraph;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>选取最短边的关键：排序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选用简单排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(EdgeGraph *E)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line">Edge temp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;E-&gt;edgenum<span class="number">-1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;E-&gt;edgenum;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(E-&gt;edge[i].weight&gt;E-&gt;edge[j].weight)</span><br><span class="line">&#123;</span><br><span class="line">temp=E-&gt;edge[i];</span><br><span class="line">E-&gt;edge[i]=E-&gt;edge[j];</span><br><span class="line">E-&gt;edge[j]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>检查回路：只需要看两个顶点所属的树是否有相同的根节点，使用了<strong>并查集</strong>判断是否成环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindRoot</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> parent[])</span><span class="comment">//t接收到是结点在Vertex数组中的下标 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(parent[t]&gt;<span class="number">-1</span>)<span class="comment">//parent=-1表示没有双亲，即没有根节点 </span></span><br><span class="line">&#123;</span><br><span class="line">t=parent[t];<span class="comment">//逐代查找根节点 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> t;<span class="comment">//将找到的根节点返回，若没有根节点返回自身 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MiniSpanTree_Kruskal</span><span class="params">(EdgeGraph *E)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> num;<span class="comment">//生成边计数器，当num=顶点数-1 就代表最小生成树生成完毕 </span></span><br><span class="line"><span class="keyword">int</span> root1,root2; </span><br><span class="line"><span class="keyword">int</span> LocVex1,LocVex2; </span><br><span class="line"><span class="keyword">int</span> parent[VertexMax];</span><br><span class="line">    <span class="comment">//用于查找顶点的双亲，判断两个顶点间是否有共同的双亲，来判断生成树是否会成环 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.按权值从小到大排序 </span></span><br><span class="line">sort(E);</span><br><span class="line">print(E);</span><br><span class="line"><span class="comment">//2.初始化parent数组 </span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;E-&gt;vexnum;i++)</span><br><span class="line">&#123;</span><br><span class="line">parent[i]=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n 最小生成树(Kruskal):\n\n&quot;</span>);</span><br><span class="line"><span class="comment">//3.</span></span><br><span class="line"><span class="keyword">for</span>(num=<span class="number">0</span>,i=<span class="number">0</span>;i&lt;E-&gt;edgenum;i++)</span><br><span class="line">&#123;</span><br><span class="line">LocVex1=LocateVex(E,E-&gt;edge[i].begin);</span><br><span class="line">LocVex2=LocateVex(E,E-&gt;edge[i].end);</span><br><span class="line">root1=FindRoot(LocVex1,parent);</span><br><span class="line">root2=FindRoot(LocVex2,parent);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(root1!=root2)<span class="comment">//若不会成环，则在最小生成树中构建此边 </span></span><br><span class="line">&#123;</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;\t\t%c-%c w=%d\n&quot;</span>,E-&gt;edge[i].begin,E-&gt;edge[i].end,E&gt;edge[i].weight);</span><br><span class="line">            <span class="comment">//输出此边 </span></span><br><span class="line">parent[root2]=root1;<span class="comment">//合并生成树</span></span><br><span class="line">num++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(num==E-&gt;vexnum<span class="number">-1</span>)<span class="comment">//若num=顶点数-1，代表树生成完毕，提前返回 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>排序算法决定了克鲁斯卡尔算法的时间复杂度。若采用插入排序，时间复杂度为$O(n²)$ ，若采用堆排序或者快速排序，那么时间复杂度为$O(nlog_2n)$ [注：n为边数]，也就是说克鲁斯卡尔算法的时间复杂度取决于边数，所以适合稀疏图</p><hr><h2 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h2><p>最短路径算法</p><ul><li>对于网（带权图）而言，求两点之间的最短路径有两种算法：迪杰斯特拉（Dijkstra算法）和 弗洛伊德（Floyd算法）</li></ul><ol><li>单源最短路径—迪杰斯特拉算法：从一个起始点出发，到达一个终点</li><li>多源最短路径—弗洛伊德算法：求每一对顶点之间的最短路径</li></ol><h3 id="迪杰斯特拉算法-Dijkstra"><a href="#迪杰斯特拉算法-Dijkstra" class="headerlink" title="迪杰斯特拉算法(Dijkstra)"></a>迪杰斯特拉算法(Dijkstra)</h3><p><strong>迪杰斯特拉算</strong>法处处可见<strong>普里姆算法</strong>的影子，大体上两者都是在寻找当前情况下的最短边，而不同之处在于，迪杰斯特拉算法做了路程的累加</p><p><img src="https://s2.loli.net/2022/05/23/Nc1AOkTHBLmiXZy.png" alt="image-20220523141139432"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindMinDist</span><span class="params">(<span class="keyword">int</span> dist[],<span class="keyword">int</span> s[],<span class="keyword">int</span> vexnum)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> loc;</span><br><span class="line"><span class="keyword">int</span> min=MaxInt+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;vexnum;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s[i]==<span class="number">0</span>)<span class="comment">//只对s[i]=0的顶点进行查找 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dist[i]&lt;min)</span><br><span class="line">&#123;</span><br><span class="line">min=dist[i];</span><br><span class="line">loc=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> loc;<span class="comment">//返回dist中最小元素的下标 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShortestPath_Dijkstra</span><span class="params">(MGraph *G,VertexType start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,num;</span><br><span class="line"><span class="keyword">int</span> loc;</span><br><span class="line"><span class="keyword">int</span> min;</span><br><span class="line"><span class="keyword">int</span> dist[VertexMax];<span class="comment">//最短路径长度数组 </span></span><br><span class="line"><span class="keyword">int</span> path[VertexMax];<span class="comment">//最短路径数组 </span></span><br><span class="line"><span class="keyword">int</span> s[VertexMax];</span><br><span class="line">    <span class="comment">//代表集合S（1代表该顶点已处理，属于集合S；0代表该顶点未处理，不属于集合S，属于集合V-S） </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.初始化dist和path数组 </span></span><br><span class="line">loc=LocateVex(G,start);<span class="comment">//获取源点的下标位置 </span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;vexnum;i++)</span><br><span class="line">&#123;</span><br><span class="line">dist[i]=G-&gt;AdjMatrix[loc][i];<span class="comment">//初始化dist数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dist[i]!=MaxInt)<span class="comment">//初始化path数组</span></span><br><span class="line">&#123;</span><br><span class="line">path[i]=loc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">path[i]=<span class="number">-1</span>;</span><br><span class="line">&#125;  </span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line"><span class="comment">//2.初始化S数组(s数组：代表集合S，1代表该元素属于集合S(已处理的顶点),0该元素不属于集合S(未处理的顶点)) </span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;vexnum;i++)</span><br><span class="line">&#123;</span><br><span class="line">s[i]=<span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line">s[loc]=<span class="number">1</span>;<span class="comment">//代表起始点(源点)以处理完毕 </span></span><br><span class="line">num=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.</span></span><br><span class="line"><span class="keyword">while</span>(num&lt;G-&gt;vexnum)</span><br><span class="line">&#123;</span><br><span class="line">min=FindMinDist(dist,s,G-&gt;vexnum);</span><br><span class="line">        <span class="comment">//在dist数组中查找其对应s[i]=0，即未处理的最小值元素 </span></span><br><span class="line">s[min]=<span class="number">1</span>;<span class="comment">//将找到的最短边所对应的的顶点加入集合S</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;vexnum;i++)<span class="comment">//加入新的顶点后，更新dist和path数组 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((s[i]==<span class="number">0</span>)&amp;&amp;(dist[i]&gt;dist[min]+G-&gt;AdjMatrix[min][i]))<span class="comment">//路径累加</span></span><br><span class="line">&#123;</span><br><span class="line">dist[i]=dist[min]+G-&gt;AdjMatrix[min][i];</span><br><span class="line">path[i]=min;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    num++;</span><br><span class="line">&#125;    </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>时间复杂度：<code>O(n²)</code></p><hr><h3 id="弗洛伊德算法（Floyd）"><a href="#弗洛伊德算法（Floyd）" class="headerlink" title="弗洛伊德算法（Floyd）"></a>弗洛伊德算法（Floyd）</h3><p>多源点意为多起始点，也就是图中所有顶点都将作为起始点，求此顶点到达图中其他所有顶点的最短路径</p><p>在之前学习的Dijskra算法，我们知道Dijskra算法是求解<strong>单源点最短路径</strong>的算法，使用Dijskra算法可以求出一个源点到其他所有顶点的最短路径，那么我们将Dijskra算法循环执行n次（n为顶点数），每次带入图中的一个顶点，不就实现了求解多源最短路吗？</p><p>Dijskra算法执行单次的时间复杂度为$O(n^2)$，其中n为顶点个数，循环执行n次，那么使用Dijskra算法求解多源点最短路径的整体时间复杂度为$O(n^3)$</p><p>此次我们引入的求解多源点最短路径问题的算法是——Floyd算法，时间复杂度也为$O(n^3)$，但是在算法构造和算法可读性上优于执行n次的Dijskra算法</p><p>弗洛伊德的核心思想是：对于网中的任意两个顶点（例如顶点 A 到顶点 B）来说，之间的最短路径不外乎有 2 种情况：</p><ol><li>直接从顶点 A 到顶点 B 的边的权值为顶点 A 到顶点 B 的最短路径。</li><li>从顶点 A 开始，经过若干个顶点，最终达到顶点 B，期间经过的边的权值和为顶点 A 到顶点 B 的最短路径</li></ol><p>所以，弗洛伊德算法的核心为：对于从顶点 A 到顶点 B 的最短路径，拿出网中所有的顶点进行如下判断：<br><code>Dist（A，K）+ Dist（K，B）&lt; Dist（A，B）</code><br>其中，K 表示网中所有的顶点；Dist（A，B） 表示顶点 A 到顶点 B 的距离</p><p>也就是说，拿出所有的顶点 K，判断经过顶点 K 是否存在一条可行路径比直达的路径的权值小，如果式子成立，说明确实存在 一条权值更小的路径，此时只需要更新记录的权值和即可</p><p><img src="https://s2.loli.net/2022/05/23/w5vzrhAyQ8L6cZV.png" alt="image-20220523142527193"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dist[VertexMax][VertexMax];</span><br><span class="line"><span class="keyword">int</span> path[VertexMax][VertexMax];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShortestPath_Floyd</span><span class="params">(MGraph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,k;</span><br><span class="line">    <span class="comment">//初始化部分</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;j++)</span><br><span class="line">&#123;</span><br><span class="line">dist[i][j]=G.AdjMatrix[i][j];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dist[i][j]!=MaxInt)</span><br><span class="line">            &#123;</span><br><span class="line">              path[i][j]=i;<span class="comment">//存入前驱 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> path[i][j]=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//Floyd算法核心部分</span></span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;G.vexnum;k++)<span class="comment">//拿出每个顶点作为遍历条件</span></span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">  <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;j++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span>(dist[i][j]&gt;dist[i][k]+dist[k][j])</span><br><span class="line">       &#123;</span><br><span class="line">       dist[i][j]=dist[i][k]+dist[k][j];</span><br><span class="line">       path[i][j]=path[k][j];<span class="comment">//存入前驱 </span></span><br><span class="line">&#125; </span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/05/23/coYdWz1hGAVp2B7.png" alt="image-20220523142855434"></p><hr><h2 id="有向无环图描述表达式"><a href="#有向无环图描述表达式" class="headerlink" title="有向无环图描述表达式"></a>有向无环图描述表达式</h2><ol><li>把各个操作数不重复地排成一排</li><li>标出各个运算符的生效顺序</li><li>按顺序加入运算符，注意分层</li><li>从底向上逐层检查同层的运算符是否可以合体</li></ol><p><img src="https://s2.loli.net/2022/05/23/CUnbVxqmprfkwL5.png" alt="image-20220523144808573" style="zoom:67%;" /></p><hr><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>AOV网（Activity On Vertex NetWork）：用顶点表示活动，边表示活动发生的 <strong>先后关系</strong></p><p><img src="https://s2.loli.net/2022/05/23/CLkYwEX1WgKHPoN.png" alt="image-20220523152946305"></p><p>拓扑序列：在AOV网（无环图）中，由顶点$V_i$到顶点$V_j$有一条路径，则在该线性序列中的顶点$V_i$必定在顶点$V_j$之前。</p><p>拓扑排序：将AOV网中的顶点序列排成拓扑序列就叫拓扑排序。</p><p>拓扑排序条件：必须是<strong>有向无环图</strong>（Directed Acycline Graph），AOV网满足有向无环图条件，若是有向成环图，则会进入死循环。</p><p>拓扑排序的执行过程相当于每次 删去<strong>入度为0的顶点</strong>和<strong>这个顶点发射出去的边</strong>，那么我们每次删去一个顶点和其发射边，就会生成一个新图，在这个新图上继续执行删去<strong>入度为0的顶点</strong>和<strong>这个顶点发射出去的边</strong>，直到所有顶点都被删完。删除每个顶点的顺序，就是拓扑序列</p><p>步骤：</p><ol><li>我们首先找到入度为0的顶点，然后对其进行输出，接着根据邻接表的邻接关系，找到与其邻接的其他顶点，再去对其他顶点进行相同的处理，由此往复。</li><li>我们需要一个 <strong>临时存取空间space</strong>，我们每次把入度为0的顶点放入space中，然后按顺序（顺序可以从头开始、从尾开始、甚至可以任意取）从space中取出，然后进行<strong>步骤1</strong>的处理，再将更新后入度为0的顶点放入space中，直到space中的元素被取空，即拓扑排序结束。</li><li><strong>临时存取空间space的存取顺序可以是任意的</strong>，所以，这个space可以是栈结构，队列结构，也可以是一个数组，甚至可以是其他（源代码用数组模拟栈结构）。由此可见，存取顺序的不同，直接导致了拓扑排序结果不唯一。</li><li>总结一下拓扑排序在程序中的执行流程：首先我们搞了一个<strong>临时存储空间space</strong>，然后将入度为0的顶点放入space，再按顺序取出，每去取出一次，就根据邻接表的邻接关系，查找当前取出的顶点的邻接点，对每个邻接点入度-1，更新完入度后，看看有没有出现新的入度为0的结点，将其放入space中，直到space为空时，即所有顶点处理完毕，输出的序列就是拓扑序列。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>//边表 </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> adjvex;<span class="comment">//存储的是该顶点在顶点数组即AdjList[]中的位置 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span> //单个顶点 </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> data;  <span class="comment">//数据域</span></span><br><span class="line"><span class="comment">//int weight；//存储网的时候需要添加此项</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">firstarc</span>;</span>   <span class="comment">//第一个孩子节点</span></span><br><span class="line">&#125;VNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> //顶点表 </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">VNode AdjList[<span class="number">10</span>];<span class="comment">//由顶点构成的结构体数组 </span></span><br><span class="line"><span class="keyword">int</span> vexnum,arcnum; <span class="comment">//顶点数n和边数e </span></span><br><span class="line">&#125;ALGraph;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TopologicalSort</span><span class="params">(ALGraph *G)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//文中说的space就是此处的栈结构</span></span><br><span class="line"> <span class="comment">//此处的栈结构我用的是数组来模拟的</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> top=<span class="number">-1</span>;<span class="comment">//栈顶指针 </span></span><br><span class="line"><span class="keyword">int</span> Gettop;<span class="comment">//用于存储/获取栈的栈顶元素 </span></span><br><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"> <span class="comment">//用于统计拓扑排序生成的结点数（若生成结点数 &lt; 图的结点数，则代表图中有环，拓扑排序不成功） </span></span><br><span class="line"> <span class="comment">//顺便检测了图中是否存在环</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//栈 </span></span><br><span class="line"><span class="keyword">int</span> indegree[<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//入度数组 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">p</span>;</span><span class="comment">//临时变量 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.计算顶点入度，并存入indegree数组中</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;vexnum;i++)</span><br><span class="line">     &#123;</span><br><span class="line">     <span class="keyword">if</span>(G-&gt;AdjList[i].firstarc!=<span class="literal">NULL</span>)     <span class="comment">//AdjList[i]作为弧尾</span></span><br><span class="line">     &#123;</span><br><span class="line">     p=G-&gt;AdjList[i].firstarc;     <span class="comment">//AdjList[i]的第一条弧</span></span><br><span class="line">     <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">     &#123;</span><br><span class="line">     indegree[p-&gt;adjvex]++;   <span class="comment">//弧头结点所在位置的入度++</span></span><br><span class="line">     p=p-&gt;next;              <span class="comment">//到下一条与AdjList[i]的弧</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//2.初始化部分：将初始入度为0的顶点入栈</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;vexnum;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(indegree[i]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">stack</span>[++top]=i;<span class="comment">//先将指针加一在进行存储 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.拓扑排序</span></span><br><span class="line"><span class="keyword">while</span>(top!=<span class="number">-1</span>)<span class="comment">//栈不为空 </span></span><br><span class="line">&#123;</span><br><span class="line">Gettop=<span class="built_in">stack</span>[top--];<span class="comment">//获取栈顶元素，并且栈顶指针减一 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; %c&quot;</span>,G-&gt;AdjList[Gettop].vertex);<span class="comment">//输出栈顶元素 </span></span><br><span class="line">count++;</span><br><span class="line"> </span><br><span class="line">p=G-&gt;AdjList[Gettop].firstarc;   <span class="comment">//p为栈顶元素的第一条边</span></span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">indegree[p-&gt;adjvex]--;   </span><br><span class="line">     <span class="comment">// A-&gt;B ,即Gettop的是A，p是这条边，而p-&gt;adjvex指的是B这个顶点的位置，2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(indegree[p-&gt;adjvex]==<span class="number">0</span>)  <span class="comment">//如果入度为0了，那就进</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">stack</span>[++top]=p-&gt;adjvex;</span><br><span class="line">&#125;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//4.判断拓扑排序是否成功（生成结点数 &lt; 图的结点数，则代表图中有环，拓扑排序不成功） </span></span><br><span class="line"><span class="keyword">if</span>(count&lt;G-&gt;vexnum) </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;TopologicalSort Failed!\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span>;     </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>逆拓扑排序：根据拓扑排序的思路，如果用逆邻接表来存储图，先输出出度为为0的结点，自然构成了逆拓扑排序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(MGraph* G, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.处理起始点 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, G-&gt;Vertex[i]);</span><br><span class="line">visitedDFS[i] = <span class="number">1</span>;<span class="comment">//2.将已访问的结点标志成1</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//2.由起始点开始，对后续结点进行操作</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G-&gt;vexnum; j++)<span class="comment">//依次搜索vi的邻接点 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (G-&gt;AdjMatrix[i][j] == <span class="number">1</span> &amp;&amp; visitedDFS[j] == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//当满足有边且未被访问过时，递归调用去查找该邻接点 </span></span><br><span class="line">&#123;</span><br><span class="line">DFS(G, j);<span class="comment">//注意此处的G已经是指针类型，不需要再&amp;G </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, G-&gt;Vertex[i]);<span class="comment">//逆拓扑排序，在出栈时输出 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此，DFS当然也可以用于拓扑排序，只要把逆拓扑排序的结构存入一个栈，然后再输出栈，不就变成了正序了</p><p>时间复杂度：邻接表：<code>O(V+E)</code>  邻接矩阵：<code>O(V²)</code></p><hr><h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h2><p><strong>AOE网（Activity On Edge NetWork）</strong>：在带权有向图中若以顶点表示事件，有向边表示活动，边上的权值表示该活动持续的时间，AOE网通常用于 <strong>估算事件/工程完成的工期（时间）</strong></p><p>从定义上来看，很容易看出两种网的不同，AOV网的活动以顶点表示，而AOE网的活动以有向边来表示，<strong>AOV网的有向边仅仅表示活动的先后次序</strong>。纵观这两种网图，其实它们总体网络结构是一样的，仅仅是活动所表示的方式不同，因此可以猜想从AOV网转换成AOE网应该是可行的</p><p><strong>关键路径</strong>：在AOE网中仅有一个入度为0的点，称为开始顶点，它表示整个工程的开始，也仅有一个出度为0的点，称为结束顶点，代表整个工程的结束，这两个点之间的距离有很多条，在所有路径中，具有最大路径长度的路径称为关键路径，而把关键路径上的活动称为关键活动</p><p><img src="https://s2.loli.net/2022/05/23/Uckt7lqYhPpGEK8.png" alt="image-20220523160028568"></p><ol><li>事件$v_i$的最早发生时间ve(i)：事件$v_i$的最早发生时间是等待$v_i$之前的所有活动都完成，所以ve(i)是从源点到vi的最长路径长度。起始点（源点）的最早发生时间为0。（$v_k$是$v_i$的前驱事件）<br>所以可以推出：<br><code>ve(0) = 0;</code>（源点的<strong>最早发生时间</strong>为0）<br><code>i∈[1,n]时，ve(i) = Max&#123; ve(k) + weight（k-&gt;i）&#125; ;</code></li><li>事件$v_i$的最晚发生时间vl(i)：不拖延工期的前提下，事件vi被允许的最晚发生时间。（$v_k$是$v_i$的后续事件）活动ai=&lt;$v_i$,$v_k$&gt;,$v_i$的最晚发生时间，取决于这个活动<strong>被允许的最晚结束时间</strong>，而所被<strong>允许的最晚结束时间</strong>也正是vk的最晚开始时间，也就是vl（k），所以我们就得到等式:<br><code>最晚发生时间vl（i）+ 活动持续时间weight = 最晚结束时间vl（k）</code><br>所以可以推出：<br><code>vl(n-1) = ve(n-1);</code>（汇点的<strong>最早发生时间</strong>与<strong>最晚发生时间</strong>相等）<br><code>i∈[0,n-2]时，vl(i) = Min&#123; vl(k) - weight（i-&gt;k）&#125; ;</code></li></ol><hr><p>步骤：</p><ol><li>求出事件最早发生时间ve[i]：顺拓扑序</li><li>求出事件最晚发生时间vl[i]：逆拓扑序</li><li>通过ve[i]和vl[i]计算出活动最早开始时间（e） 与 活动最晚开始时间（l）</li><li>若<code>e(i)==l(i)</code>则当前i所指向的活动是关键活动（Critical Activity）</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CriticalPath</span><span class="params">(ALGraph *G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> j,k;<span class="comment">// &lt;Vj,Vk&gt;</span></span><br><span class="line"><span class="keyword">int</span> e,l;<span class="comment">//活动最早开始时间/活动最晚开始时间  </span></span><br><span class="line"><span class="keyword">int</span> topo[VertexMax];<span class="comment">//拓扑数组，用于存储拓扑排序结果（存储内容是每个结点的坐标） </span></span><br><span class="line"><span class="keyword">int</span> ve[VertexMax]; <span class="comment">//事件vi的最早发生时间 </span></span><br><span class="line"><span class="keyword">int</span> vl[VertexMax]; <span class="comment">//事件vi的最晚发生时间 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.调用拓扑排序，检测图是否存在环 </span></span><br><span class="line"><span class="keyword">if</span>(!TopologicalSort(G,topo))<span class="comment">//若拓扑排序成功，topo数组也将处理完毕 </span></span><br><span class="line"> <span class="keyword">return</span>; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//2.正拓扑排序，求出事件最早发生时间 </span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;vexnum;i++)</span><br><span class="line">    ve[i]=<span class="number">0</span>;<span class="comment">//所有ve都初始化为0</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;vexnum;i++)</span><br><span class="line">&#123;</span><br><span class="line">j=topo[i];<span class="comment">//j为起始点，k为终点 </span></span><br><span class="line">p=G-&gt;AdjList[j].firstarc;<span class="comment">//用指针p去依次寻找j的每一个邻接点 </span></span><br><span class="line"><span class="keyword">while</span>(p)</span><br><span class="line">&#123;</span><br><span class="line">k=p-&gt;adjvex;</span><br><span class="line"><span class="keyword">if</span>(ve[k]&lt;ve[j]+p-&gt;weight)</span><br><span class="line">             <span class="comment">//根据j的邻接点k，不断更新ve[]的值（选出最大值，原理类似于选择排序） </span></span><br><span class="line">&#123;</span><br><span class="line">ve[k]=ve[j]+p-&gt;weight;</span><br><span class="line">&#125;</span><br><span class="line">p=p-&gt;next;    </span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//3.逆拓扑排序，求出事件最迟发生时间 </span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;vexnum;i++)</span><br><span class="line">    vl[i]=ve[G-&gt;vexnum<span class="number">-1</span>];<span class="comment">//所有vl都初始化为ve[G-&gt;vexnum-1]</span></span><br><span class="line"><span class="keyword">for</span>(i=G-&gt;vexnum<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">j=topo[i];</span><br><span class="line">p=G-&gt;AdjList[j].firstarc;<span class="comment">//让p去依次查找邻接点 </span></span><br><span class="line"><span class="keyword">while</span>(p)</span><br><span class="line">&#123;</span><br><span class="line">k=p-&gt;adjvex;</span><br><span class="line"><span class="keyword">if</span>(vl[j]&gt;vl[k]-p-&gt;weight)</span><br><span class="line">               <span class="comment">//根据j的邻接点k，不断更新vl[]的值（选出最小值，原理类似于选择排序）</span></span><br><span class="line">&#123;</span><br><span class="line">vl[j]=vl[k]-p-&gt;weight;</span><br><span class="line">&#125;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;       </span><br><span class="line"><span class="comment">//4.计算e和l，通过判断e是否等于l确定该活动是否是关键活动，从而确定关键路径</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;vexnum;i++)</span><br><span class="line">&#123;</span><br><span class="line">p=G-&gt;AdjList[i].firstarc;<span class="comment">//让p去依次查找邻接点 </span></span><br><span class="line"><span class="keyword">while</span>(p)</span><br><span class="line">&#123;</span><br><span class="line">j=p-&gt;adjvex;</span><br><span class="line">e=ve[i];<span class="comment">//计算活动最早开始时间 e </span></span><br><span class="line">l=vl[j]-p-&gt;weight;<span class="comment">//计算活动最晚开始时间 l </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(e==l)<span class="comment">//如果e=l，说明该活动是关键活动 </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//把每个关键活动输出，即是关键路径</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t%c-&gt;%c(%d)\n&quot;</span>,G-&gt;AdjList[i].vertex,G-&gt;AdjList[j].vertex,p-&gt;weight);</span><br><span class="line">&#125;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.树</title>
      <link href="/post/30685.html"/>
      <url>/post/30685.html</url>
      
        <content type="html"><![CDATA[<h1 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h1><h2 id="树的逻辑结构"><a href="#树的逻辑结构" class="headerlink" title="树的逻辑结构"></a>树的逻辑结构</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>树形结构，即是从树根生长，逐级分支的结构</p><p>结点数为0的树称为空树，非空树的特性是：有且仅有一个根节点，除了根节点外，任何一个结点都有且仅有一个前驱</p><p><img src="https://s2.loli.net/2022/05/09/R5oDNluqSA8rGvg.png" alt="image-20220509152907265"></p><p>子树：树可以分为m个互不相交的有限集合，其中每个集合本身又是一棵树，并且称为根节点的子树</p><p>树是一种<strong>递归定义</strong>的数据结构</p><p>结点的度：即结点孩子的数量</p><p>树的度：各结点的度的最大值</p><p>森林：m棵互不相交的树的集合</p><hr><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ol><li><p><strong>结点数=总度数+1</strong></p><p>这个较好理解，总度数就是除了根节点之外的结点数，或者说，总度数就是树的”树枝“</p><p><strong>对于森林来说，结点数=总度数+树的数量</strong></p></li><li><p>度为m的树是指结点的度的最大值，而m叉树是指，每个结点最多只能有m个孩子，实际上即使没有也可以</p></li><li><p>度为m的树的第i层至多有$m^{i-1}$个结点</p><p><img src="https://s2.loli.net/2022/05/09/TKCe5tsk2WDAil1.png" alt="image-20220509154338974"></p></li><li><p>由3可知，把每层的结点加起来，根据等比数列求和，高度为h的m叉树最多有$\frac{m^h-1}{m-1}$个结点</p></li><li><p>高度为h的m叉树至少有h个结点，高度为h，度为m的树至少有h+m-1个结点</p><p><img src="https://s2.loli.net/2022/05/09/bd8ErWAmqXPDTRh.png" alt="image-20220509154723746"></p></li></ol><hr><h2 id="二叉树的逻辑结构"><a href="#二叉树的逻辑结构" class="headerlink" title="二叉树的逻辑结构"></a>二叉树的逻辑结构</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>二叉树是n个结点的有限集合，n为0时是空二叉树，n&gt;0时是由一个根节点和两个互不相交的被称为根的左子树和右子树组成</p><p>特点：每个结点至少只有两棵子树，左右子树不能颠倒</p><p>几种特殊的二叉树：</p><ol><li><p><strong>满二叉树</strong></p><p>一颗高度为h，且含有$2^h-1$个结点的二叉树</p><p><img src="https://s2.loli.net/2022/05/09/gNfn1iuyLDh3drF.png" alt="image-20220509155321356"></p><p>只有最后一层有叶子结点，而且不存在度为1的结点</p></li><li><p><strong>完全二叉树</strong></p><p>当且仅当每个结点都与高度为h的满二叉树中编号为1~n的结点一一对应时，称为完全二叉树</p><p><img src="https://s2.loli.net/2022/05/09/7fYEilKtCsFPLV6.png" alt="image-20220509160245884"></p><p>最多只有一个度为1的结点，$i≤[n/2]$为分支结点，$i＞[n/2]$为叶子结点</p></li><li><p><strong>二叉排序树（BST）</strong></p><p>左子树上所有结点的关键字均小于根节点的关键字</p><p>右节点上所有结点的关键字均大于根节点的关键字</p><p>左子树和右子树又均是一颗二叉排序树</p><p><img src="https://s2.loli.net/2022/05/09/f8hml1qnVjBiLIA.png" alt="image-20220509160730761"></p></li><li><p><strong>平衡二叉树（AVL）</strong></p><p>树上任一结点的左子树和右子树的深度之差不超过1</p></li></ol><hr><h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h3><p>设非空二叉树中度为0,1,2的结点个数分别为$n_0,n_1,n_2$，则$n_0=n_2+1$，即叶子结点比二分支结点多一个</p><p>推导过程：已知树的结点数=总度数+1 即$n=n_1+2n_2+1$，同时$n=n_0+n_1+n_2$，所以可以推出$n_0=n_2+1$</p><hr><p>完全二叉树</p><ol><li>具有n个结点的完全二叉树的高度h为$log_2(n+1)$或$[log_2n]+1$</li><li>对于完全二叉树， 已知其最多只有一个度为1的结点，$n_1=0或1$，而二叉树有性质$n_0=n_2+1$,所以$n=n_1+2n_2+1$，如果完全二叉树有偶数个结点，那么$n_1$为1，奇数个为0</li></ol><hr><h2 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h2><h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><p><strong>定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    ElemType value;</span><br><span class="line">    <span class="keyword">bool</span> isEmpty;</span><br><span class="line">&#125;;</span><br><span class="line">TreeNode t[MaxSize];</span><br></pre></td></tr></table></figure><p>用数组存储二叉树的结点，一定要把二叉树的结点编号与完全二叉树对应起来</p><p><img src="https://s2.loli.net/2022/05/09/WlhZY4pvMJS9cNt.png" alt="image-20220509165446882"></p><p><img src="https://s2.loli.net/2022/05/09/pTdJBoPuywaltMh.png" alt="image-20220509165426378"></p><p>在最坏的情况下，二叉树为右单枝树，也至少需要$2^h-1$个存储单元，结论是二叉树的顺序存储结构，只适合存储完全二叉树</p><hr><h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h3><p><strong>定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>* <span class="title">lchild</span>, * <span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode, * BiTree;</span><br></pre></td></tr></table></figure><p><del>（有两个指针域的链表罢了)</del></p><p><img src="https://s2.loli.net/2022/05/09/mvu7osSFTx81dfJ.png" alt="image-20220509170458898"></p><p>n个结点的二叉链表共有n+1个空链域</p><hr><p><strong>创建二叉树</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBiTree</span><span class="params">(BiTree* T)</span>  <span class="comment">// 双重指针，因为需要修改根节点的指向，就是需要修改root的值，所以应该传入指向root的地址，这样在被调用的函数中，对*T的操作等价于操作root</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;ch);</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">        *T = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        *T = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">        <span class="keyword">if</span> (!*T)</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        (*T)-&gt;data = ch;</span><br><span class="line">        CreateBiTree(&amp;(*T)-&gt;lchild);<span class="comment">// 递归创建</span></span><br><span class="line">        CreateBiTree(&amp;(*T)-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>遍历：按照某种次序把所有结点都访问一遍</p><p>一共有4种遍历</p><ol><li><strong>先序遍历</strong>：对于二叉树和其子树，先访问二叉树的根节点，然后是左孩子，然后是右孩子</li><li><strong>中序遍历</strong>：对于二叉树和其子树，先访问二叉树的左孩子，然后是根节点，然后是右孩子</li><li><strong>后序遍历</strong>：对于二叉树和其子树，先访问二叉树的右孩子，然后是根节点，然后是左孩子</li><li><strong>层序遍历</strong>：按照二叉树的分层，从左到右依次访问</li></ol><p>先序，中序，后序遍历的代码实现（递归）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的先序，中序，后序遍历(递归)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">//  printf(&quot;%c &quot;, T-&gt;data);  先序</span></span><br><span class="line">    PreOrderTraverse(T-&gt;lchild);</span><br><span class="line">  <span class="comment">//  printf(&quot;%c &quot;, T-&gt;data);  中序</span></span><br><span class="line">    PreOrderTraverse(T-&gt;rchild);</span><br><span class="line">  <span class="comment">//  printf(&quot;%c &quot;, T-&gt;data);  后序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以很明显的看出，三种遍历方式的不同之处在于，在何时对二叉树结点进行操作</p><p><img src="https://s2.loli.net/2022/05/10/kxyqeUEHIM42uBP.png" alt="image-20220510140133236"></p><p>对二叉树进行遍历，模拟访问路径，红色路线表示第一次访问，绿色路线表示第二次访问，紫色表示第三次访问</p><p>可以看出，第一次访问就出栈是前序遍历，第二次访问就出栈是中序遍历，第三次访问就出栈是后序遍历</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////非递归利用顺序栈来进行前序遍历</span></span><br><span class="line"><span class="comment">// 栈的顺序结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    BiTree data[MAX];</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125;Stack;  <span class="comment">//用栈来存储结点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    Stack s;</span><br><span class="line">    s.top = <span class="number">-1</span>;</span><br><span class="line">    BiTree p = T;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> || s.top != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            s.data[++s.top] = p;</span><br><span class="line">         <span class="comment">//   printf(&quot;%c &quot;, p-&gt;data); 入栈时，访问输出,前序遍历</span></span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p = s.data[s.top--];</span><br><span class="line">         <span class="comment">//   printf(&quot;%c &quot;, p-&gt;data); 出栈时，访问输出,中序遍历</span></span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于第三次访问，则需要增加一个辅助栈来记录访问次数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归利用顺序栈来进行后序遍历</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>  data[MAX];</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125;Stack1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    Stack s;</span><br><span class="line">    s.top = <span class="number">-1</span>;</span><br><span class="line">    Stack1 flagStack;   <span class="comment">//记录每个节点访问次数栈</span></span><br><span class="line">    BiTree p = T;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> || s.top != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;     <span class="comment">//第一次访问，flag置1，入栈</span></span><br><span class="line">            s.data[++s.top] = p;</span><br><span class="line">            flagStack.data[s.top] = <span class="number">1</span>;</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//（p == NULL）</span></span><br><span class="line">            <span class="keyword">if</span> (flagStack.data[s.top] == <span class="number">1</span>) &#123;  <span class="comment">//第二次访问，flag置2，取栈顶元素但不出栈</span></span><br><span class="line">                p = s.data[s.top];</span><br><span class="line">                flagStack.data[s.top] = <span class="number">2</span>;</span><br><span class="line">                p = p-&gt;rchild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;         <span class="comment">//第三次访问，出栈</span></span><br><span class="line">                p = s.data[s.top--];</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, p-&gt;data);    <span class="comment">//出栈时，访问输出</span></span><br><span class="line">                p = <span class="literal">NULL</span>;      <span class="comment">//p置空，以便继续退栈</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>层序遍历</strong></p><p><img src="https://s2.loli.net/2022/05/10/le5gPTWnYANc6Ei.png" alt="image-20220510144707198"></p><p>需要构造一个辅助队列，如队列非空，则队头结点出队，访问该结点，并将其左右孩子插入队尾，直到队列为空</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义层次遍历中辅助队列的结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">queue</span> &#123;</span></span><br><span class="line">    BiTree data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">queue</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode,*PNODE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义辅助队列的队头队尾指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    LinkNode* front, * rear;</span><br><span class="line">&#125;LinkQueue,*PQUEUE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化队列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(PQUEUE Q)</span> </span>&#123;</span><br><span class="line">    Q-&gt;front = Q-&gt;rear = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode)); </span><br><span class="line">    Q-&gt;front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进队操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(PQUEUE Q, BiTree x)</span> </span>&#123;</span><br><span class="line">    PNODE s = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Q-&gt;rear-&gt;next = s;</span><br><span class="line">    Q-&gt;rear = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队操作</span></span><br><span class="line"><span class="function">BiTree <span class="title">DeQueue</span><span class="params">(PQUEUE Q)</span> </span>&#123;</span><br><span class="line">    PNODE p = Q-&gt;front-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">    Q-&gt;front-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;rear == p)</span><br><span class="line">        Q-&gt;rear = Q-&gt;front;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 层次遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    InitQueue(&amp;Q);</span><br><span class="line">    BiTree p=<span class="literal">NULL</span>;</span><br><span class="line">    EnQueue(&amp;Q, T);</span><br><span class="line">    <span class="keyword">while</span> (Q.front!=Q.rear) &#123;  <span class="comment">//判断是否队空</span></span><br><span class="line">        p=DeQueue(&amp;Q);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, p-&gt;data);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">            EnQueue(&amp;Q, p-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">            EnQueue(&amp;Q, p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据遍历构造二叉树</p><p>根据一种遍历顺序是无法得到二叉树结构的，需要<strong>中序和其他任一遍历序列</strong>才能构造出二叉树</p><hr><h3 id="线索化二叉树"><a href="#线索化二叉树" class="headerlink" title="线索化二叉树"></a>线索化二叉树</h3><p>二叉树的问题：</p><ol><li>建立二叉树时，<code>n</code>个结点的二叉树总共有<code>2n</code>个指针域，会有<code>n+1</code>个指针域被浪费</li><li>在创建二叉树的时候，大部分算法都是用递归实现，实现起来简单，然而系统运行起来却很吃力，很占用系统资源。当我们在建立好二叉树之后我们需要频繁的查找某个单元，就得频繁的调用遍历递归去查找，这显然并不高效</li></ol><p>结合这两个问题，解决办法是<strong>用这些空指针域，存放一些有用的指向信息，从而尽量的将一棵二叉树线性化成双向链表</strong>，我们把这些<strong>指向信息</strong>称之为<strong>线索</strong>，<strong>也就是说线索二叉树等效成双向链表</strong></p><p>中序遍历</p><p><img src="https://s2.loli.net/2022/05/11/DjkWZq3w1GSBbQR.png" alt="image-20220511141151393" style="zoom:67%;" /></p><p>先序遍历</p><p><img src="https://s2.loli.net/2022/05/11/bBamOZNiFM9jcIx.png" alt="image-20220511163802955" style="zoom:67%;" /></p><p>后序遍历</p><p><img src="https://s2.loli.net/2022/05/11/jDtMLRZykrbA75W.png" alt="image-20220511163932656" style="zoom:67%;" /></p><hr><p>结点的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将原来的三个域扩展到五个域</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">dataType data; <span class="comment">//根节点的值 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">lchild</span>;</span> <span class="comment">//左孩子 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">rchild</span>;</span> <span class="comment">//右孩子 </span></span><br><span class="line"><span class="keyword">int</span> ltag; <span class="comment">//左标记</span></span><br><span class="line"><span class="keyword">int</span> rtag; <span class="comment">//右标记</span></span><br><span class="line">&#125;BiTree; </span><br></pre></td></tr></table></figure><hr><p>创建并初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BiTree *<span class="title">creat</span><span class="params">()</span> <span class="comment">//二叉树的创建及初始化(初始化左右标记为0) </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dataType value;</span><br><span class="line">BiTree *t;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;value);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(value==<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">t=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">t=(BiTree *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTree));</span><br><span class="line">t-&gt;data=value;</span><br><span class="line">t-&gt;ltag=<span class="number">0</span>;<span class="comment">//初始化左标记为0 </span></span><br><span class="line">t-&gt;rtag=<span class="number">0</span>;<span class="comment">//初始化右标记为0 </span></span><br><span class="line">t-&gt;lchild=creat();</span><br><span class="line">t-&gt;rchild=creat();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p>中序化二叉树</p><ul><li>利用两个指针<code>p</code>和<code>pre</code>，让其在中序遍历的过程中分别指向一前一后，也就是说始终保持p是<code>pre</code>的后继，<code>pre</code>是<code>p</code>的前驱；那么在处理到<code>p</code>结点的时候，我们可以根据p节点是否有左孩子来判断，<code>p-&gt;lchild</code>是否要指向<strong>前驱</strong>，若<code>p</code>指向的节点没有左孩子，则直接让<code>p-&gt;lchild=pre;</code>并将<code>p-&gt;ltag</code>赋值为1，即可完成将结点的左孩子指向<strong>前驱结点</strong>。<code>pre</code>也一个道理，若<code>pre</code>所指向的节点没有右孩子，将<code>pre-&gt;rchild=p;</code>并即将<code>pre-&gt;rtag</code>赋值为1，即可完成该结点的右孩子指向<strong>后继节点</strong></li><li>整体思路就是：<strong>通过<code>p</code>来处理左孩子指向前驱（左孩子为空的情况下），通过<code>pre</code>来处理右孩子指向后继（右孩子为空的情况下）</strong></li></ul><p><code>pre</code>与<code>p</code>指针功能相同，但定义却不相同，<code>p</code>是线索化函数内的局部变量，而<code>pre</code>为了保证在每一次递归序列中能够正确返回当前值，必须定义成全局变量 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为我们是以中序遍历的顺序给二叉树填上线索，所以，整个线索化的函数是套用在中序遍历的框架下的。</span></span><br><span class="line"><span class="comment">// 线索化二叉树就是给二叉树的基础上，添加能完整表示出二叉树节点前驱后继的指针</span></span><br><span class="line">BiTree *pre=<span class="literal">NULL</span>; <span class="comment">//定义全局变量pre</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThreaded</span><span class="params">(BiTree* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//  后序化二叉树</span></span><br><span class="line">   <span class="comment">//InThreaded(p-&gt;lchild);  递归遍历右子树</span></span><br><span class="line">       <span class="comment">//InThreaded(p-&gt;rchild);  递归线索化左子树</span></span><br><span class="line"></span><br><span class="line">InThreaded(p-&gt;lchild); <span class="comment">// 递归线索化左子树，直到找到首结点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p-&gt;lchild==<span class="literal">NULL</span>)   <span class="comment">//如果当前结点没有左子树，那么需要给其添加前驱的指针</span></span><br><span class="line">&#123;</span><br><span class="line">p-&gt;ltag = <span class="number">1</span>;       <span class="comment">//标志为1，表示其前驱</span></span><br><span class="line">p-&gt;lchild = pre;    <span class="comment">// 那么当前结点的前驱就是pre</span></span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">// 如果上个结点没有右子树，那么他的后继就是p，即当前结点</span></span><br><span class="line"><span class="keyword">if</span> (pre!=<span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild==<span class="literal">NULL</span>) </span><br><span class="line">            <span class="comment">// 如果当前结点的前驱不是NULL，或者前驱的右孩子不存在</span></span><br><span class="line">&#123;</span><br><span class="line">pre-&gt;rtag = <span class="number">1</span>;              <span class="comment">// 标志为1，表示为后继    </span></span><br><span class="line">pre-&gt;rchild = p;            <span class="comment">// 那么前驱的后继就是当前结点</span></span><br><span class="line">&#125;</span><br><span class="line">pre = p;    <span class="comment">//下一个结点</span></span><br><span class="line"><span class="comment">/*  先序化二叉树</span></span><br><span class="line"><span class="comment">    InThreaded(p-&gt;rchild);  //递归遍历右子树</span></span><br><span class="line"><span class="comment">                if(p.ltag==0)&#123;    //为了避免循环</span></span><br><span class="line"><span class="comment">         InThreaded(p-&gt;lchild); // 递归线索化左子树</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>查找后继</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BiTree* <span class="title">Next</span><span class="params">(BiTree* t)</span> <span class="comment">//已知节点t找t的&quot;后继&quot;结点位置 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (t-&gt;rtag == <span class="number">1</span>) <span class="comment">//右标志为1，可以直接得到&quot;后继&quot;结点 </span></span><br><span class="line">&#123;</span><br><span class="line">t = t-&gt;rchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">/*右标志为0，不能直接的到&quot;后继&quot;结点，</span></span><br><span class="line"><span class="comment">   则需要找到右子树最左下角的节点*/</span></span><br><span class="line">&#123;</span><br><span class="line">t = t-&gt;rchild;</span><br><span class="line"><span class="keyword">while</span> (t-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">t = t-&gt;lchild;</span><br><span class="line">&#125; <span class="comment">//while</span></span><br><span class="line">&#125;<span class="comment">//else</span></span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>查找前驱</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BiTree* <span class="title">Prior</span><span class="params">(BiTree* t)</span><span class="comment">//已知节点t找t的&quot;前驱&quot;结点位置 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (t-&gt;ltag == <span class="number">1</span>)<span class="comment">//左标志为1，可以直接找到&quot;前驱&quot;结点的位置 </span></span><br><span class="line">&#123;</span><br><span class="line">t = t-&gt;lchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">/*左标志为0，不能直接的到&quot;前驱&quot;结点，</span></span><br><span class="line"><span class="comment">   则需要找到左子树最右下角的节点*/</span></span><br><span class="line">&#123;</span><br><span class="line">t = t-&gt;lchild;</span><br><span class="line"><span class="keyword">while</span> (t-&gt;rtag == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">t = t-&gt;rchild;</span><br><span class="line">&#125; <span class="comment">//while</span></span><br><span class="line">&#125; <span class="comment">//else</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>利用线索实现中序遍历</p><p>但是需要注意的一点是，我们creat函数中输入是以先序的次序输入端，故p一开始指向的节点是先序的第一个节点，而不是中序的第一个结点，所以要先查找第一个节点，在用Next中的线索查找后续结点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InorderTraverse</span><span class="params">(BiTree *t)</span><span class="comment">//利用线索实现中序遍历 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(t-&gt;ltag==<span class="number">0</span>)<span class="comment">//查找第一个节点 </span></span><br><span class="line"><span class="comment">//因为二叉树的创建creat是以先序遍历序列创建，所以t所指向的第一个结点并不是中序遍历所要访问的第一个结点 </span></span><br><span class="line">&#123;</span><br><span class="line">t=t-&gt;lchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,t-&gt;data);<span class="comment">//访问第一个结点</span></span><br><span class="line"><span class="keyword">while</span>(t-&gt;rchild)</span><br><span class="line"><span class="comment">// 此处以&quot;t的右孩子不为空&quot;为循环条件，是因为，先前设定了最后一个结点的&quot;后继&quot;为空，表示结束 </span></span><br><span class="line">&#123;               <span class="comment">//根据线索访问后续结点 </span></span><br><span class="line">t=Next(t);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,t-&gt;data); </span><br><span class="line">&#125;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><hr><p>在中序遍历中，左根右的顺序，任意一结点可以找到前驱和后继</p><p>在前序遍历中，根左右的顺序，有左孩子的结点是无法找到其前驱的</p><p>在后序遍历中，左右根的顺序，有右孩子的结点是无法找到其后继的</p><p><img src="https://s2.loli.net/2022/05/11/cP7R8ZCwGYoHq92.png" alt="image-20220511164049416"></p><hr><h2 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h2><h3 id="双亲表示法（顺序存储）"><a href="#双亲表示法（顺序存储）" class="headerlink" title="双亲表示法（顺序存储）"></a>双亲表示法（顺序存储）</h3><p>每个结点中保存自身数据以及指向父节点的位置</p><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><img src="https://s2.loli.net/2022/05/11/caKy84qPre7vkYp.png" width="400"/></td><td><img src="https://s2.loli.net/2022/05/11/ELTwHDmsVIhKGBj.png" width="150"/></td></tr></tbody></table></div><p>定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line">    ElemType data;  <span class="comment">//数据元素</span></span><br><span class="line">    <span class="keyword">int</span> parent;     <span class="comment">//双亲位置域</span></span><br><span class="line">&#125;TreeNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Ptree</span>&#123;</span>         <span class="comment">//存放树的顺序表</span></span><br><span class="line">    TreeNode nodes[size];   <span class="comment">//双亲表示</span></span><br><span class="line">    <span class="keyword">int</span> n;               <span class="comment">//结点数</span></span><br><span class="line">&#125;PTree</span><br></pre></td></tr></table></figure><p>优点：查指定结点的双亲很方便</p><p>缺点：查指定结点的孩子只能从头遍历</p><hr><h3 id="孩子表示法（顺序＋链式）"><a href="#孩子表示法（顺序＋链式）" class="headerlink" title="孩子表示法（顺序＋链式）"></a>孩子表示法（顺序＋链式）</h3><p>顺序存储各个结点，每个结点中保存孩子链表头指针</p><div class="table-container"><table><thead><tr><th><img src="https://s2.loli.net/2022/05/11/caKy84qPre7vkYp.png" width="450"/></th><th><img src="https://s2.loli.net/2022/05/11/h5qr4RGtYKZA3uN.png" width="300"/></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>&#123;</span>     </span><br><span class="line">    <span class="keyword">int</span> child ;       <span class="comment">//孩子结点在数组中的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span> <span class="comment">//下一个孩子</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>              <span class="comment">//结点定义，包括数据和孩子的链表</span></span><br><span class="line"> ElemType data;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">firstChild</span> ;</span>  <span class="comment">//第一个孩子</span></span><br><span class="line">&#125;CTBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>                     <span class="comment">//存放结点的顺序表</span></span><br><span class="line">    CTBox nodes[MAXSIZE];</span><br><span class="line">    <span class="keyword">int</span> n,r;               <span class="comment">//结点数和根的位置</span></span><br><span class="line">&#125;CTree;    </span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>优点：查指定结点的孩子很方便</p><p>缺点：查指定结点的父节点只能从头遍历</p><hr><h3 id="孩子兄弟表示法（链式存储）"><a href="#孩子兄弟表示法（链式存储）" class="headerlink" title="孩子兄弟表示法（链式存储）"></a>孩子兄弟表示法（链式存储）</h3><p>其定义和二叉树一模一样，不过是指针域指向的对象不一样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>  *<span class="title">firstchild</span>,*<span class="title">nextsibling</span>;</span>   <span class="comment">//第一个孩子和右兄弟</span></span><br><span class="line">&#125;CSNode,*CSTree;</span><br></pre></td></tr></table></figure><p>关键在于，这种表示法可以将树转化为二叉树，从而可以用熟悉的二叉树的操作来操作树</p><p><img src="https://s2.loli.net/2022/05/11/UmqcOFuXkGprAWE.png" alt="image-20220511171632428"></p><p>而对森林来说，则可以将几颗树的头结点相连，再用孩子兄弟表示法表示即可</p><hr><h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><p><strong>先根遍历</strong></p><p>如果树非空，先访问根节点，然后依次访问其子树，对树的先根遍历和对其转换二叉树的先序遍历结果是一样的</p><p><strong>后根遍历</strong></p><p>若树非空，先依次对每棵树进行后根遍历，最后再访问根节点，对树的后根遍历和对其转换二叉树的中序遍历结果是一样的</p><p><strong>层序遍历</strong></p><p>按照层次访问树，可以看做对树的广度优先遍历（BFS）</p><p><img src="https://s2.loli.net/2022/05/11/WhYmdgBzZDUeO5T.png" alt="image-20220511184038119"></p><hr><h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>当有 n 个结点（都做叶子结点且都有各自的权值）构建一棵树时，如果构建的这棵树的<strong>带权路径长度(WPL)最小</strong>，称这棵树为“<strong>最优二叉树</strong>”，有时也叫“<strong>哈夫曼树</strong>“</p><p>权值可以理解为是访问频率，而<code>带权路径长度=权值 x 该节点到树根的路径长度</code></p><p><code>树的带权路径长度=所有叶节点的带权路径之和WPL(Weighted Path Length)</code></p><h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><ol><li><p>选取并合并：选取取值最小的两个结点合并成一棵树（根节点为权值之和）</p></li><li><p>删除并加入：从序列中删除上述选取的两个两个最小结点，加入新合并的树</p></li><li><p>重复：重复上述操作即可得到哈夫曼树</p><p><img src="https://s2.loli.net/2022/05/12/2soR9tZbMDeNTuz.png" alt="image-20220512161945398"></p></li></ol><p>哈夫曼树并不唯一，但是WPL的值肯定是唯一的</p><hr><h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><p>将字符集中的每个字符作为一个叶子结点，各个字符出现的频率作为结点的权值，可用于数据压缩</p><hr><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>并指合并操作，查指查找操作，集指采用集合这种逻辑结构，并查集就是可以进行合并和查找的集合</p><p><img src="https://s2.loli.net/2022/05/23/H4byXdltWRsLeED.png" alt="image-20220523195741382"></p><p>森林就将各个元素划分为若干个互不相交的子集</p><p>在森林中，查指在森林中查找某一结点属于那个集合，并指两棵树的合并</p><hr><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>存储结构采取双亲表示法可以方便地实现并查</p><p><img src="https://s2.loli.net/2022/05/23/Eqj9peVwGPbF4cx.png" alt="image-20220523200019796"></p><p>用一个数组就可以表示集合关系</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 13</span></span><br><span class="line"><span class="keyword">int</span> UFSets[SIZE];</span><br><span class="line"><span class="comment">// 初始化并查集</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Initial</span><span class="params">(<span class="keyword">int</span> S[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;SIZE;i++)&#123;</span><br><span class="line">    S[i]=<span class="number">-1</span>;         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Find 查操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> S[],<span class="keyword">int</span> x)</span></span>&#123; </span><br><span class="line">    <span class="keyword">while</span>(S[x]&gt;=<span class="number">0</span>)   <span class="comment">////循环查找x的根</span></span><br><span class="line">    &#123;   </span><br><span class="line">    x=S[x];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Union 并操作  将两个集合合并成一个</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> S[],<span class="keyword">int</span> Root1,<span class="keyword">int</span> Root2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Root1==Root2)&#123;</span><br><span class="line">          <span class="keyword">return</span> ;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       S[Root2]=Root1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>并操作给出了两棵树的根节点，合并的时间复杂度只需要O(1)</p><p>查操作的时间复杂度在O(n)</p><hr><p>查操作的时间复杂度和树的高度有关，可以优化并的操作，让小树成为大树的子树，从而尽量不增加树的高度</p><p><img src="https://s2.loli.net/2022/05/23/TwX68epWarSMhLm.png" alt=""></p><p>优化思路：在每次Union操作构建树的时候，用根的绝对值表示树的结点总数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Union 并操作  将两个集合合并成一个</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> S[],<span class="keyword">int</span> Root1,<span class="keyword">int</span> Root2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Root1==Root2)&#123;</span><br><span class="line">          <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(S[Root2]&gt;S[Root1]&#123;  <span class="comment">//Root2结点数更少</span></span><br><span class="line">       S[Root1]+=S[Root2];  <span class="comment">//累加结点总数</span></span><br><span class="line">       S[Root2]=Root1;     <span class="comment">//合并</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        S[Root2]+=S[Root1];</span><br><span class="line">        S[Root1]=Root2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化后find操作的最坏时间复杂度为$O(log_2n)$</p><hr><p>Find操作可以继续优化，如果不考虑保持树的结构，可以将尽可能多的树挂靠在根节点之下，从而可以更快查到根节点</p><p><img src="https://s2.loli.net/2022/05/23/B2zEkdHwUXgbxqs.png" alt="image-20220523202958232"></p><p>压缩路径可以将被查找节点到根节点路径中的所有结点都挂靠在根节点之下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Find 查操作 压缩路径</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> S[],<span class="keyword">int</span> x)</span></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> root =x;</span><br><span class="line">    <span class="keyword">while</span>(S[root]&gt;=<span class="number">0</span>)   <span class="comment">////循环查找x的根</span></span><br><span class="line">    &#123;   </span><br><span class="line">    root =S[root];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(x!=root)&#123;   <span class="comment">//压缩路径</span></span><br><span class="line">        <span class="keyword">int</span> t=S[x];   <span class="comment">//t指向x的父节点</span></span><br><span class="line">        S[x]=root;    <span class="comment">//x挂到根节点下</span></span><br><span class="line">        x=t;          <span class="comment">//回到x的父节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.字符串</title>
      <link href="/post/5702.html"/>
      <url>/post/5702.html</url>
      
        <content type="html"><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>字符串是由零个或多个字符组成的有限序列</p><p>字符的个数n就是字符串的长度，n=0时称为空串</p><h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><p>串是一种特殊的线性表，数据元素之间呈线性关系</p><p><img src="https://s2.loli.net/2022/05/07/dsMW7i5cSgXLZC4.png" alt="image-20220507203329378" style="zoom: 67%;" /></p><hr><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>赋值，复制，求串的长度，连接串，求子串，定位，比较</p><hr><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><p>字符串是线性表，所以可以用顺序存储的方式，就是在定义中，把数组的类型规定为<code>char</code>类型即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体定义 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> *data;  <span class="comment">//存放顺序表元素的数组 </span></span><br><span class="line"><span class="keyword">int</span> length; <span class="comment">//存放顺序表的长度 </span></span><br><span class="line"> &#125;Sqlist;<span class="comment">//顺序表类型的定义 </span></span><br></pre></td></tr></table></figure><hr><h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h3><p>同理也可以使用链式存储</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">NEXT</span>;</span></span><br><span class="line">&#125;Node, *LinkList;  </span><br></pre></td></tr></table></figure><p>不过这样的存储密度很低，建议每个结点存储多个字符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> data[<span class="number">4</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">NEXT</span>;</span></span><br><span class="line">&#125;Node, *LinkList;  </span><br></pre></td></tr></table></figure><hr><h2 id="字符串的模式匹配"><a href="#字符串的模式匹配" class="headerlink" title="字符串的模式匹配"></a>字符串的模式匹配</h2><p>在主串中找到与模式串相同的子串，并返回其所在位置</p><h3 id="朴素模式匹配算法"><a href="#朴素模式匹配算法" class="headerlink" title="朴素模式匹配算法"></a>朴素模式匹配算法</h3><p><img src="https://s2.loli.net/2022/05/07/1JSgIpFbWGBqVXk.png" alt="image-20220507211122668"></p><p>主串长度为<code>n</code>，模式串长度为<code>m</code></p><p>朴素模式匹配算法：将主串中所有长度为<code>m</code>的子串依次与模式串对比，直到找到一个完全匹配的子串或所有的子串都不匹配为止。（很朴素）</p><p>如果子串匹配失败，则主串指针指向下一个子串的第一个位置，模式串指针回到模式串第一个位置</p><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxsize 100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index_BF</span><span class="params">(<span class="keyword">char</span> S[],<span class="keyword">char</span> T[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(S[i]!=<span class="string">&#x27;\0&#x27;</span>&amp;&amp;T[j]!=<span class="string">&#x27;\0&#x27;</span>)<span class="comment">//S[i]==&#x27;\0&#x27;则为匹配失败，T[i]==‘\0’为匹配成功！</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(S[i]==T[j])  <span class="comment">//某一字符匹配成功</span></span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">i=i-j+<span class="number">1</span>;<span class="comment">//i回溯到下一位置</span></span><br><span class="line">j=<span class="number">0</span>;<span class="comment">//j回溯</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(T[j]==<span class="string">&#x27;\0&#x27;</span>)<span class="comment">//对应上面循环条件匹配成功</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Match succeed!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> i-j; <span class="comment">//返回第一位的下标</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//对应上面循环条件S[i]==&#x27;\0&#x27;匹配失败</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Match failed!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码很容易理解，注意一点，<code>i</code>和<code>j</code>的默认是0，而王道上默认是1，其实都可以，不过默认是0的方便一点</p><p>主串长度为<code>n</code>，模式串长度为<code>m</code>，最坏的时间复杂度是<code>O(mn)</code>，最好时间复杂度是<code>O(n)</code></p><hr><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><p>KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt提出的，简称KMP算法。KMP算法的<strong>核心是利用匹配失败后的信息</strong>，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是通过一个NEXT()函数实现，函数本身包含了模式串的局部匹配信息</p><p>KMP算法是基于朴素算法的，对比朴素识别和KMP算法：</p><p><img src="https://s2.loli.net/2022/05/08/mBN5hYC4x26ZWrR.png" alt="image-20220508194629894"></p><p>最大的差别在于，else里面的<code>j=NEXT[j]</code>，也就是匹配失败后，<strong><code>i</code>不会回溯</strong>，而是<code>j</code>回溯到<code>NEXT[j]</code>的位置，而不是从0开始</p><p>而KMP的核心正是利用NEXT数组来存储匹配失败后的信息以减少匹配次数</p><hr><p>而求取NEXT数组的值，成为了KMP算法的关键</p><p>在此之间，需要先介绍“”最大长度“”Length数组，该数组的作用是用来存放一个字符串的最长前缀和最长后缀相同的长度，按每一位下标将对应长度值存于数组Length中</p><p>比如模式串“ababaca”的Length数组就是{0，0，1，2，3，0，1}</p><p>之所以需要这个Length数组，是因为Length数组的下标与模式串T的下标是一致的（也就是下标 <code>j</code>），也就是模式串T中每一位都可以对应其下标<code>j</code>在Length数组中找到该位<strong>当前前缀与后缀的最长匹配长度</strong>，那么也就知道了，在当前位置下（也就是后缀）是否与模式串的开头（也就是前缀）有相同的部分、相同的部分是几位，这就是利用前缀匹配失败的信息</p><p><img src="https://s2.loli.net/2022/05/08/yK58x6BkF1mA4sH.png" alt="image-20220508205033697"></p><p>那么也就是说，有了Length数组，我们只需要知道下标就可以知道，当前的前后缀的最长匹配长度。而当<code>j</code>位发生不匹配，需要回溯时，我们要看前一位也就是<code>j-1</code>位的前后缀匹配情况也就是<strong>Length[j-1]</strong>，可以知道要从<code>j</code>位回溯到Length[j-1]位</p><p>但是，有个问题，第<code>j</code>位的回溯位置需要看第<code>j-1</code>位的信息，为了让第<code>j</code>位的回溯信息可以直接到第<code>j</code>位去找，我们可以把Length数组整体后移一位，这就是<strong>NEXT数组</strong></p><p><img src="https://s2.loli.net/2022/05/08/oFg86aZ1T5DYdOu.png" alt="image-20220508205735375"></p><ul><li>NEXT数组也正是KMP算法的精髓所在，<strong>充分记录并利用探路人</strong>（后缀）获取的信息（已匹配信息），让算法能绕过很多不必要的匹配项，少走很多弯路</li></ul><hr><p><img src="https://s2.loli.net/2022/05/08/vm2TyDLjuSYkAnZ.png" alt="image-20220508210350464"></p><p>观察求NEXT数组的代码，可以发现，与KMP算法的代码相似性极高，那么其实<strong>求NEXT数组就是让模式串T的前缀和后缀相匹配，那么也就是一个自我匹配的过程</strong>，用前缀去匹配后缀。</p><p>那么不同之处在于<strong>当匹配成功时</strong>，我们不但要把指针（下标）向后推一位，还同时需要<strong>对应当前下标记录下当前的最佳匹配长度</strong>，也就是<code>NEXT[j]=k</code>,表示的是模式串T的<strong>前缀的前k项</strong>与<strong>后缀的前k项</strong>相匹配，那么k也正是当前的匹配长度</p><p>而先<code>j++</code>后将k的值存放在NEXT数组中，正好对应了将Length数组右移一位变成NEXT数组的过程</p><p><img src="https://s2.loli.net/2022/05/08/hSHkaTYZe1sJXzL.png" alt="image-20220508214230678"></p><p>同时k++，j++，的原因也很简单，既然模式串T的<strong>前缀的前k项</strong>与<strong>后缀的前k项</strong>，那么k+1项和j+1项会不会也匹配？</p><p><img src="https://s2.loli.net/2022/05/08/2ifAdOUypXrwSWs.png" alt="image-20220508214316318"></p><p>如果在前k项与后k项相同的情况下，<strong>第k+1项失配</strong>，也就是下图所视情况，T[k]≠T[j] ，那么我们的前缀指针k是不是要回溯，在此处使用BF算法的回溯思路，从零开始重新找前后缀匹配长度，固然可以，但是我们如果用kmp算法的回溯思路，是不是可以更快找到呢？</p><p>为什么在NEXT数组没有完全成型之前就用NEXT数组来回溯呢，因为在求NEXT数组的算法中，<strong>K永远比J小</strong></p><p><img src="https://s2.loli.net/2022/05/08/GDZ4jJQWUAiguwH.png" alt="image-20220508214556007"></p><hr><p>算法漏洞</p><p><img src="https://s2.loli.net/2022/05/08/n9TjR5sF1LdhIuA.png" alt="image-20220508214955963"></p><p>我们发现这个算法其实还是存在漏洞，如下图的情况，第2步的情况是完全没有必要的，因为在第1步时已经判断过“B”≠”D”,第2步又判断了一次“B”≠”D”。那有没有办法可以省掉，或者是跳过这个多余步骤呢？</p><p>其实我们只需要加一个判断就可以了，当if判断完前<code>k</code>项与后<code>k</code>项相匹配后，<code>j++；k++;</code>此时<code>j</code>和<code>k</code>都向后推了一位，分别指向下一位，那么这时我们不着急记录长度<code>k</code>于NEXT数组，而是加一个判断，预判断一下下一位（这里的下一位是指<code>j++；k++;</code>之前的下一位）是否相等，也就是<code>T[j]</code>与<code>T[k]</code>是否相等，如果不相等，我们记录<code>k</code>的值于NEXT数组；<strong>如果相等的话</strong>，就会出现上述多余重复匹配的现象，那么我们在这里通过<strong>连续的两次回溯，来跳过它</strong>，也就是<code>k = NEXT[NEXT[k]];</code>(<code>NEXT[j]=NEXT[k];</code>将NEXT[k]的值存于NEXT[j]也是一样的道理），<strong>回溯完之后不进行匹配判断就进行下一次回溯，即是跳过了他的匹配步骤</strong></p><p>完整代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxsize 100 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Nextval</span><span class="params">(<span class="keyword">char</span> T[],<span class="keyword">int</span> *next)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> lenT=<span class="built_in">strlen</span>(T);</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">-1</span>;<span class="comment">//前缀 </span></span><br><span class="line"><span class="keyword">int</span> j=<span class="number">0</span>;<span class="comment">//后缀 </span></span><br><span class="line">next[<span class="number">0</span>]=<span class="number">-1</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(j&lt;lenT)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">-1</span>||T[j]==T[k])</span><br><span class="line">&#123;</span><br><span class="line">j++;</span><br><span class="line">k++;</span><br><span class="line"><span class="comment">//较之前next数组求法，改动在下面4行</span></span><br><span class="line"><span class="keyword">if</span>(T[j]!=T[k])</span><br><span class="line">&#123;</span><br><span class="line">next[j]=k;<span class="comment">//之前只有这一行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">next[j]=next[k];<span class="comment">//为不能出现T[j] = T[ next[j ]]，</span></span><br><span class="line">            <span class="comment">//所以当出现时连续进行两次回溯，k = next[next[k]] </span></span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">k=next[k];</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="keyword">char</span> S[],<span class="keyword">char</span> T[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,lenS,lenT;</span><br><span class="line">lenS=<span class="built_in">strlen</span>(S);</span><br><span class="line">lenT=<span class="built_in">strlen</span>(T);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> next[maxsize];</span><br><span class="line">Nextval(T,next);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i&lt;lenS&amp;&amp;j&lt;lenT)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(j==<span class="number">-1</span>||S[i]==T[j])</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123; </span><br><span class="line">j=next[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(j==lenT)</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Match succeed!\n&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> i-j;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Match failed!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> S[maxsize],T[maxsize];</span><br><span class="line">    <span class="keyword">int</span> target;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(S,<span class="string">&quot;AAAAAAAAAAttract&quot;</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(T,<span class="string">&quot;Attract&quot;</span>);</span><br><span class="line"></span><br><span class="line">target=KMP(S,T);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Position is %d\n&quot;</span>,target);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.栈和队列</title>
      <link href="/post/43592.html"/>
      <url>/post/43592.html</url>
      
        <content type="html"><![CDATA[<h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>栈是只允许在一端进行插入和删除操作的线性表</p><p>特点是<strong>先进后出</strong></p><p><img src="https://s2.loli.net/2022/05/07/1cZ4JMLoKFYEUm7.png" alt="image-20220507151516634"></p><p>n个不同元素进栈，出栈元素不同排列的个数为$\frac{1}{n+1}C^n_{2n}$(卡特兰数)</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>创建，元素进栈，出栈，获取栈顶元素</p><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><h4 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h4><p>定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data[MaxSize];  <span class="comment">//栈的最大值</span></span><br><span class="line"><span class="keyword">int</span> top;             <span class="comment">//栈顶指针</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><p>初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(SqStack  *S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">S-&gt;top=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进栈</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(SqStack* S, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">S-&gt;data[S-&gt;top] = x;</span><br><span class="line">S-&gt;top++;              <span class="comment">//栈顶指针永远指向下一个元素进来的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出栈</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">(SqStack* S,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">S-&gt;top--;</span><br><span class="line">x = S-&gt;data[S-&gt;top];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取栈顶元素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gettop</span><span class="params">(SqStack* S,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t=S-&gt;top<span class="number">-1</span></span><br><span class="line">x = S-&gt;data[t];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h4><p>头插法创建链表就是链式栈</p><hr><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="逻辑结构-1"><a href="#逻辑结构-1" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>队列是只允许在一端进行插入，在另一端进行删除的线性表</p><p>特点是先进先出</p><p><img src="https://s2.loli.net/2022/05/07/TiYU9nbxOwN3HBp.png" alt="image-20220507155526596"></p><hr><h3 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h3><p>创建，初始化，入队，出队，读队头元素</p><hr><h3 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h3><h4 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h4><p>定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data[MaxSize];  <span class="comment">//静态数组存放队列元素</span></span><br><span class="line"><span class="keyword">int</span> front, rear;    <span class="comment">//队头元素和队尾元素</span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure><p>初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(SqQueue* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">q-&gt;front = <span class="number">0</span>;    <span class="comment">//队头和队尾指针为0</span></span><br><span class="line">q-&gt;rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>入队</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">Insert</span><span class="params">(SqQueue *q,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">q-&gt;data[q-&gt;rear] = x;    <span class="comment">//插入到队尾</span></span><br><span class="line">q-&gt;rear = q-&gt;rear + <span class="number">1</span>;   <span class="comment">//队尾指针加1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出队</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除一个队头元素，并用x返回</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">DeQueue</span><span class="params">(SqQueue* q,<span class="keyword">int</span> *x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (((q-&gt;rear) + <span class="number">1</span>) % MaxSize == q-&gt;front) &#123;   <span class="comment">// 需要牺牲一个空间来判断是否满队列</span></span><br><span class="line">                         <span class="comment">// 不能用rear=front判断，因为判空就是根据指针相同</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;full&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">x = q-&gt;data[q-&gt;front];</span><br><span class="line">q-&gt;front = (q-&gt;front + <span class="number">1</span>) % MaxSize;    <span class="comment">// MOD元素让队列变成了循环队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队满：</p><p><code>(q-&gt;rear) + 1) % MaxSize == q-&gt;front</code></p><p><img src="https://s2.loli.net/2022/05/07/Svc5UbYE9l1xdiL.png" alt="image-20220507161556684" style="zoom:67%;" /></p><p>队空：</p><p><code>q-&gt;rear == q-&gt;front</code></p><p><img src="https://s2.loli.net/2022/05/07/2WCFB6stYpiOhzE.png" alt="image-20220507161801286" style="zoom: 80%;" /></p><p>为了区别队空和队满时的状态，除了牺牲一个空间以外，也可以用标志位tag进行判断</p><hr><h4 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h4><p><img src="https://s2.loli.net/2022/05/07/uiWR8srZXqkyF24.png" alt="image-20210323153544209"></p><p>定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">    ElemType data ;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    LinkNode *front,*rear;</span><br><span class="line">&#125;LinkQueue</span><br></pre></td></tr></table></figure><p>初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化时front和rear都指向头结点</span></span><br><span class="line">    Q.front=Q.rear=(LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    Q.front-&gt;next=null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>入队</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q,ElemType x)</span></span>&#123;</span><br><span class="line">    LinkNode *s=(LinkNode *)<span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    s-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next=s;   <span class="comment">//让新节点变为rear</span></span><br><span class="line">    Q.rear=s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出队</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span> <span class="params">(LinkQueue &amp;Q,ElemType &amp;x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(Q.front==Q.rear)&#123;          <span class="comment">// 如果front=rear则队空</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> LinKNode *p=Q.front-&gt;next;</span><br><span class="line"> x=p-&gt;data;</span><br><span class="line"> Q.front-&gt;next=p-&gt;next;</span><br><span class="line">  <span class="keyword">if</span>(Q.rear==p)           <span class="comment">//如果rear=p,那么队空了</span></span><br><span class="line">  &#123;</span><br><span class="line">      Q.rear=Q.front;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链式一般不会队满，所以不需要考虑</p><hr><h4 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h4><p>允许从双端插入，双端删除的队列</p><hr><h2 id="栈和队列的应用"><a href="#栈和队列的应用" class="headerlink" title="栈和队列的应用"></a>栈和队列的应用</h2><p>栈和队列相对来说应用较少，栈一般用来解决成对元素消去的问题</p><h3 id="括号匹配问题"><a href="#括号匹配问题" class="headerlink" title="括号匹配问题"></a>括号匹配问题</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">pairs</span><span class="params">(<span class="keyword">char</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="string">&#x27;&#125;&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;&#123;&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="string">&#x27;]&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="string">&#x27;)&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> stk[n + <span class="number">1</span>], top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch = pairs(s[i]);</span><br><span class="line">        <span class="keyword">if</span> (ch) &#123;</span><br><span class="line">            <span class="keyword">if</span> (top == <span class="number">0</span> || stk[top - <span class="number">1</span>] != ch) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            top--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stk[top++] = s[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> top == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="中缀转为后缀表达式"><a href="#中缀转为后缀表达式" class="headerlink" title="中缀转为后缀表达式"></a>中缀转为后缀表达式</h3><p>算数表达式由操作数（数字），运算符（+ - × ÷），界限符（括号）组成</p><p>运算符在两个操作数后面就称为后缀表达式</p><p>手算：</p><ol><li><p>先确定中缀表达式中各个运算符的运算顺序，</p></li><li><p>选择下一个运算符，按照[左操作数 右操作数 运算符]的方式组成一个新的操作数</p></li></ol><p>机算：</p><ol><li><p>遇到<strong>左括号</strong>直接入栈，遇到<strong>右括号</strong>将栈中<strong>左括号</strong>之后入栈的运算符全部弹栈输出，同时<strong>左括号出栈但是不输出</strong>。</p></li><li><p>遇到<strong>乘号和除号</strong>直接入栈，直到遇到<strong>优先级</strong>比它更低的运算符，依次弹栈。</p></li><li><p>遇到<strong>加号和减号</strong>，如果此时<strong>栈空</strong>，则<strong>直接入栈</strong>，否则，将栈中<strong>优先级高</strong>的运算符依次弹栈（注意：加号和减号属于同一个优先级，所以也依次弹栈）直到<strong>栈空或则遇到左括号</strong>为止，停止弹栈。（因为左括号要匹配右括号时才弹出）。</p></li><li><p>获取完后，将栈中剩余的运算符号依次弹栈输出</p></li></ol><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*中缀转后缀函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Change</span><span class="params">(SqStack *S,Elemtype str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">Elemtype e;</span><br><span class="line">InitStack(S);  <span class="comment">//初始化运算符栈</span></span><br><span class="line"><span class="keyword">while</span>(str[i]!=<span class="string">&#x27;\0&#x27;</span>)  <span class="comment">//字符串未到末尾</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(str[i]))  </span><br><span class="line">&#123;<span class="comment">/*过滤数字字符，直接输出，直到下一位不是数字字符打印空格跳出循环 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,str[i++]);</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">isdigit</span>(str[i]))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*加减运算符优先级最低，如果栈顶元素为空则直接入栈，否则将栈中存储的运算符</span></span><br><span class="line"><span class="comment">全部弹栈，如果遇到左括号则停止，将弹出的左括号从新压栈，因为左括号要和右括号</span></span><br><span class="line"><span class="comment">匹配时弹出，这个后面单独讨论。弹出后将优先级低的运算符压入栈中*/</span></span><br><span class="line"><span class="keyword">if</span>(str[i]==<span class="string">&#x27;+&#x27;</span>||str[i]==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!StackLength(S))</span><br><span class="line">&#123;</span><br><span class="line">PushStack(S,str[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">PopStack(S,&amp;e);</span><br><span class="line"><span class="keyword">if</span>(e==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">PushStack(S,e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">while</span>( StackLength(S) &amp;&amp; e != <span class="string">&#x27;(&#x27;</span> );</span><br><span class="line"></span><br><span class="line">PushStack(S,str[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*当遇到右括号是，把括号里剩余的运算符弹出，直到匹配到左括号为止</span></span><br><span class="line"><span class="comment">左括号只弹出不打印（右括号也不压栈）*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(str[i]==<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">PopStack(S,&amp;e);</span><br><span class="line"><span class="keyword">while</span>(e!=<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,e);</span><br><span class="line">PopStack(S,&amp;e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*乘、除、左括号都是优先级高的，直接压栈*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(str[i]==<span class="string">&#x27;*&#x27;</span>||str[i]==<span class="string">&#x27;/&#x27;</span>||str[i]==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">PushStack(S,str[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(str[i]==<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n输入格式错误！\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*最后把栈中剩余的运算符依次弹栈打印*/</span></span><br><span class="line"><span class="keyword">while</span>(StackLength(S))</span><br><span class="line">&#123;</span><br><span class="line">PopStack(S,&amp;e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后缀表达式求值"><a href="#后缀表达式求值" class="headerlink" title="后缀表达式求值"></a>后缀表达式求值</h3><ol><li>从左往右扫描下一个元素，知道处理完所有元素</li><li>若扫描到操作数则压入栈</li><li>若扫描到运算符，则弹出两个栈顶元素，执行相应运算</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="keyword">char</span>* token)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strlen</span>(token) &gt; <span class="number">1</span> || (<span class="string">&#x27;0&#x27;</span> &lt;= token[<span class="number">0</span>] &amp;&amp; token[<span class="number">0</span>] &lt;= <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="keyword">char</span>** tokens, <span class="keyword">int</span> tokensSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tokensSize;</span><br><span class="line">    <span class="keyword">int</span> stk[n], top = <span class="number">0</span>;      <span class="comment">//操作数栈</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span>* token = tokens[i];</span><br><span class="line">        <span class="keyword">if</span> (isNumber(token)) &#123;</span><br><span class="line">            stk[top++] = atoi(token);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> num2 = stk[--top];</span><br><span class="line">            <span class="keyword">int</span> num1 = stk[--top];</span><br><span class="line">            <span class="keyword">switch</span> (token[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    stk[top++] = num1 + num2;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    stk[top++] = num1 - num2;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    stk[top++] = num1 * num2;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                    stk[top++] = num1 / num2;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stk[top - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="特殊矩阵的压缩"><a href="#特殊矩阵的压缩" class="headerlink" title="特殊矩阵的压缩"></a>特殊矩阵的压缩</h2><h3 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h3><p>若n阶方阵中任意一个元素都有$a<em>{i,j}=a</em>{j,i}$，则改矩阵为对称矩阵</p><p><img src="https://s2.loli.net/2022/05/07/ewEqHv6mnSDgL9o.png" alt="image-20220507193320066" style="zoom: 80%;" /></p><p>可以按行优先原则，只存储主对角线和下三角的元素，用一个大小为$\frac{n(n+1)}{2}$的数组来存储</p><p>$a_{i,j}$对应的就是数组中第$\frac{i(i-1)}{2}+j$个元素，下标在此基础上-1</p><p>（不需要背公式，主要是理解存储顺序以及下标需要-1）</p><hr><h3 id="三角矩阵"><a href="#三角矩阵" class="headerlink" title="三角矩阵"></a>三角矩阵</h3><p>除了主对角区和上(下)三角区，其余的元素都相同</p><p><img src="https://s2.loli.net/2022/05/07/b1LKMBiOZUYzn8F.png" alt="image-20220507194132179" style="zoom: 80%;" /></p><p>相比与对称矩阵，三角矩阵需要空间为$\frac{n(n+1)}{2}+1$，多一个空间用于最后存放c这个常量</p><hr><h3 id="三对角矩阵"><a href="#三对角矩阵" class="headerlink" title="三对角矩阵"></a>三对角矩阵</h3><p>当$|i-j|&gt;1$时，有$a_{i,j=0}$</p><p><img src="https://s2.loli.net/2022/05/07/BeydsbnLmYMNcxU.png" alt="image-20220507195404275" style="zoom: 80%;" /></p><p>需要大小为<code>3n-2</code>的数组，前<code>i-1</code>行共<code>3(i-1)-1</code>个元素，$a_{i,j}$是第<code>i</code>行第<code>j-i+2</code>个元素</p><p>所以$a_{i,j}$是第<code>2i+j-2</code>个元素</p><hr><h3 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h3><p>非零元素远远少于矩阵元素的个数</p><p><img src="https://s2.loli.net/2022/05/26/xQGXE1fTNWR49dr.png" alt="image-20220507200903464" style="zoom:67%;" /></p><p>使用三元组，即<code>i</code>行 <code>j</code>列 <code>v</code>值的方法存储</p><p><img src="https://s2.loli.net/2022/05/07/XUSYb7wNTfJpQvG.png" alt="image-20220507202249532"></p><p>也可以使用<strong>十字链表</strong>法</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.线性表</title>
      <link href="/post/42354.html"/>
      <url>/post/42354.html</url>
      
        <content type="html"><![CDATA[<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><p>线性表是具有相同数据类型的n个数据元素的<strong>有限</strong>序列，其中n为表长，当n=0时表是一个空表</p><p>除了第一个元素和最后一个元素外，每个元素有且仅有一个直接前驱和直接后继</p><h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><p><img src="https://s2.loli.net/2022/05/06/yN6gMPA7r3UlfYB.png" alt="image-20220506165445334"></p><hr><h2 id="基本运算和操作"><a href="#基本运算和操作" class="headerlink" title="基本运算和操作"></a>基本运算和操作</h2><p>包括初始化，销毁，插入，删除，查找，求表长等操作，针对不同的存储结构，其实现形式有所不同</p><hr><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><p>即是用顺序存储方式实现的线性表，把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现</p><p>可以通过静态分配或动态分配的方式实现顺序表</p><p>特点：</p><ul><li>随机访问，在O(1)时间内找到第<code>i</code>个元素</li><li>存储密度高，每个节点都只存储数据元素</li><li>拓展容量不方便（只能通过动态分配）</li><li>插入，删除不方便，要移动大量元素</li></ul><p>代码实现：</p><p>定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序表的结构体定义 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> *data;  <span class="comment">//存放顺序表元素的数组 </span></span><br><span class="line"><span class="keyword">int</span> length; <span class="comment">//存放顺序表的长度 </span></span><br><span class="line"> &#125;Sqlist;<span class="comment">//顺序表类型的定义 </span></span><br></pre></td></tr></table></figure><p>初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化顺序表 </span></span><br><span class="line"><span class="function">Sqlist <span class="title">initList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> Sqlist L;</span><br><span class="line"> L.data = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(maxSize*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));   <span class="comment">//动态分配数组空间</span></span><br><span class="line"> L.length = <span class="number">0</span>; </span><br><span class="line"> <span class="keyword">return</span> L;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>插入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在顺序表的第p个位置上插入新的元素e。如果p输入不正确，返回0，p输入正确，插入成功，返回1。 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insertElem</span><span class="params">(Sqlist &amp;L, <span class="keyword">int</span> p, <span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">if</span>(p&lt;<span class="number">0</span>||p&gt;L.length||L.length==maxSize)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=L.length<span class="number">-1</span>;i&gt;=p;--i)</span><br><span class="line">&#123;</span><br><span class="line">L.data[i+<span class="number">1</span>] = L.data[i];</span><br><span class="line">&#125;</span><br><span class="line">L.data[p] = e;</span><br><span class="line">++L.length;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> &#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>删除</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除表L中下标为p的元素，成功返回1，否则返回0，并将被删除元素的值赋给e。 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteElem</span><span class="params">(Sqlist &amp;L, <span class="keyword">int</span> p, <span class="keyword">int</span> &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">if</span> (p&lt;<span class="number">0</span>||p&gt;L.length<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">e = L.data[p];</span><br><span class="line"><span class="keyword">for</span>(i=p;i&lt;L.length<span class="number">-1</span>;++i)</span><br><span class="line">&#123;</span><br><span class="line">L.data[i] = L.data[i+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">--L.length;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><hr><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>每个结点除了存放数据元素外，还要存储指向下一个节点的指针</p><p><img src="https://s2.loli.net/2022/05/07/gOHYsF8VDxKUdTu.png" alt="image-20220507145406767"></p><p>定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;Node, *LinkList;  </span><br></pre></td></tr></table></figure><p>初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单链表的初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function">LinkList <span class="title">LinkedListInit</span><span class="params">()</span> </span>&#123;    <span class="comment">//　为什么用指针操纵结构体？因为比起直接传递结构体，指针的效率更高　　</span></span><br><span class="line">    Node* L;</span><br><span class="line">    L = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));   <span class="comment">//动态分配内存，申请结点空间，此语言的意思是开辟一个大小为一个Ｎｏｄｅ字节数的内存区域，而Ｌ指向的就是该区域 </span></span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>) &#123; <span class="comment">//判断是否有足够的内存空间 </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;申请内存空间失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;                  <span class="comment">//指针使用－＞运算符，表示直接操作结构体成员，将next设置为NULL,初始长度为0的单链表 </span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表的创建</span></span><br><span class="line"><span class="comment">//头插法，将新加入的元素都插到表头中</span></span><br><span class="line"><span class="function">LinkList <span class="title">LinkListCreatH</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node* L;</span><br><span class="line">    L = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));   <span class="comment">//申请头结点空间</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;                      <span class="comment">//初始化一个空链表</span></span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;您要创建长度为多少的链表：&quot;</span>);</span><br><span class="line">    scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>  x;                         <span class="comment">//x为链表数据域中的数据</span></span><br><span class="line">        scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"></span><br><span class="line">        Node* p;</span><br><span class="line">        p = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));   <span class="comment">//申请新的结点 </span></span><br><span class="line">        p-&gt;data = x;                     <span class="comment">//结点数据域赋值 </span></span><br><span class="line">        p-&gt;next = L-&gt;next;               <span class="comment">//将结点插入到表头L--&gt;|2|--&gt;|1|--&gt;NULL </span></span><br><span class="line">        L-&gt;next = p;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//尾插法，将新加入的元素都插入到表尾中</span></span><br><span class="line"><span class="function">LinkList <span class="title">LinkListCreatT</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        Node* L;</span><br><span class="line">    L = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;您要创建长度为多少的链表：&quot;</span>);</span><br><span class="line">    scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">        Node* s;</span><br><span class="line">        s = L;                            <span class="comment">// 设置一个和头结点相同起点的的尾巴指针</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>  x;                         <span class="comment">//x为链表数据域中的数据</span></span><br><span class="line">        scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"></span><br><span class="line">        Node* p;</span><br><span class="line">        p = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));   <span class="comment">//申请新的结点 </span></span><br><span class="line"></span><br><span class="line">            p-&gt;data = x;                     <span class="comment">//结点数据域赋值 </span></span><br><span class="line">            p-&gt;next = <span class="literal">NULL</span>;               <span class="comment">//将结点插入到表尾L--&gt;|1|--&gt;|2|--&gt;NULL </span></span><br><span class="line">            s-&gt;next = p;</span><br><span class="line">            s = p;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表的插入</span></span><br><span class="line"><span class="function">LinkList <span class="title">LinkedListInsert</span><span class="params">(LinkList L, <span class="keyword">int</span> i, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    Node* pre;                      <span class="comment">//pre为前驱结点 </span></span><br><span class="line">    pre = L;                       <span class="comment">// pre 首先指向头结点</span></span><br><span class="line">    <span class="keyword">int</span> tempi = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (tempi = <span class="number">1</span>; tempi &lt; i; tempi++) &#123;</span><br><span class="line">        pre = pre-&gt;next;                 <span class="comment">//查找第i个位置的前驱结点 </span></span><br><span class="line">    &#125;</span><br><span class="line">    Node* p;                                <span class="comment">//插入的结点为p</span></span><br><span class="line">    p = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));         <span class="comment">// 为插入的结点初始化内存</span></span><br><span class="line">    p-&gt;data = x;                            <span class="comment">// 为数据域赋值</span></span><br><span class="line">    p-&gt;next = pre-&gt;next;</span><br><span class="line">    pre-&gt;next = p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表的删除</span></span><br><span class="line"><span class="function">LinkList <span class="title">LinkedListDelete</span><span class="params">(LinkList L, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* p;</span><br><span class="line">    Node* pre;                   <span class="comment">//pre为前驱结点，p为查找的结点。</span></span><br><span class="line">    pre = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));         <span class="comment">// 为插入的结点初始化内存</span></span><br><span class="line">    p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;data != x) &#123;              <span class="comment">//查找值为x的元素 </span></span><br><span class="line">        pre = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    pre-&gt;next = p-&gt;next;          <span class="comment">//删除操作，将其前驱next指向其后继。 </span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><p>在单链表的基础上，增加了指向前驱结点的指针</p><p><img src="https://s2.loli.net/2022/05/07/cjniyXYzU4lgCLW.png" alt="image-20220507145324905"></p><p>定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DoubleNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DoubleNode</span>* <span class="title">prior</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DoubleNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;Dnode,*DnodeList;</span><br></pre></td></tr></table></figure><p>初始化和创建</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DnodeList <span class="title">CreatDnodeH</span><span class="params">()</span> </span>&#123;</span><br><span class="line">DnodeList L;</span><br><span class="line">L = (Dnode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Dnode));</span><br><span class="line">L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">L-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;number:&quot;</span>);</span><br><span class="line">scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x; i++) &#123;</span><br><span class="line">DnodeList P;</span><br><span class="line">P= (Dnode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Dnode));</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line">scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">P-&gt;data = m;</span><br><span class="line">        <span class="comment">//很明显是头插法</span></span><br><span class="line">P-&gt;next = L-&gt;next;</span><br><span class="line">L-&gt;next = P;</span><br><span class="line">P-&gt;prior = L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DnodeList <span class="title">InsertDnode</span><span class="params">(DnodeList L,<span class="keyword">int</span> i,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">DnodeList P;</span><br><span class="line">P = (Dnode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Dnode));</span><br><span class="line">P-&gt;data = x;</span><br><span class="line">DnodeList pre;</span><br><span class="line">pre = L;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">1</span>; m &lt; i; m++) &#123;</span><br><span class="line">pre = pre-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P-&gt;next=pre-&gt;next;</span><br><span class="line">    pre-&gt;next-&gt;prior=P;</span><br><span class="line">P-&gt;prior = pre;</span><br><span class="line">pre-&gt;next = P;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链表不具备随机存取特性，查找操作只能通过顺序遍历实现</p><hr><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>在单链表/双链表的基础上，尾结点不指向NULL，而是指向头结点，这种链表称作循环链表</p><p><img src="https://s2.loli.net/2022/05/07/ebgfBI4TDodRkwK.png" alt="image-20220507144839138"></p><hr><h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><p>分配一整片连续的内存空间，各个结点集中安置</p><p><img src="https://s2.loli.net/2022/05/07/DlEB7gu4FafIv1n.png" alt="image-20220507145636932" style="zoom:50%;" /></p><p>0号结点当作头结点，游标为-1表示已经到达表尾，其他的游标表示下一个结点的数组下标</p><p>本质上是用数组形式实现的链表，优点是增删不需要大量移动元素，缺点是不能随机存取，只能从头结点开始一次查找，容量固定不可变</p><p>适用于数据元素数量固定不变的场景（<strong>操作系统的文件分配表FAT</strong>）</p><hr><h3 id="顺序表和链表的比较"><a href="#顺序表和链表的比较" class="headerlink" title="顺序表和链表的比较"></a>顺序表和链表的比较</h3><p>顺序表</p><ul><li>优点：支持随机存取，存储密度高</li><li>缺点：大片连续空间分配不方便，改变容量不方便</li></ul><p>链表</p><ul><li>优点：离散的小空间分配方便，改变容量方便</li><li>缺点：不可随机存取，存储密度低</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.绪论</title>
      <link href="/post/10659.html"/>
      <url>/post/10659.html</url>
      
        <content type="html"><![CDATA[<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="数据结构的基本概念"><a href="#数据结构的基本概念" class="headerlink" title="数据结构的基本概念"></a>数据结构的基本概念</h2><p>数据：信息的载体，是描述客观事件属性的数，字符以及所有能输入到计算机中并被计算机程序识别和处理的符号的集合</p><p>数据元素：是数据的基本单位</p><p>数据项：一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位</p><p>数据对象：具有相同性质的数据元素的集合，是数据的一个子集</p><p><strong>数据结构：相互之间存在一种或多种特定关系的数据元素的集合</strong></p><hr><p>例子：</p><div class="table-container"><table><thead><tr><th>姓名</th><th>学号</th><th>年龄</th><th>成绩</th></tr></thead><tbody><tr><td>candle</td><td>2018114514</td><td>20</td><td>98</td></tr><tr><td>nightswatch</td><td>2018114515</td><td>22</td><td>99</td></tr></tbody></table></div><p>一个学生的数据可以视作一个数据元素，而姓名，学号等属性可以看做是数据项，多个学生组成了一个数据对象</p><hr><h2 id="数据结构三要素"><a href="#数据结构三要素" class="headerlink" title="数据结构三要素"></a>数据结构三要素</h2><h3 id="1-逻辑结构"><a href="#1-逻辑结构" class="headerlink" title="1.逻辑结构"></a>1.逻辑结构</h3><p>即是数据元素之间的逻辑关系，和实际在计算机中的存储形式没有关系</p><p>常见的逻辑结构有：集合结构，线性结构，树形结构，图状结构</p><h3 id="2-数据运算"><a href="#2-数据运算" class="headerlink" title="2.数据运算"></a>2.数据运算</h3><p>即是针对某种逻辑结构，定义基本运算，或者说是基本操作</p><p>比如查找，插入，删除等</p><p>通过逻辑结构和数据运算就可以定义一种数据结构了</p><h3 id="3-物理结构（存储结构）"><a href="#3-物理结构（存储结构）" class="headerlink" title="3.物理结构（存储结构）"></a>3.物理结构（存储结构）</h3><p>物理结构即是数据在计算机中的存储结构</p><p>常见的物理结构有：</p><ul><li>顺序存储：把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现</li><li>链式存储：逻辑上相邻的元素在物理位置上可以不相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系</li><li>索引存储：在存储元素信息的同时，还建立附加的索引表。索引表中每一项称为索引项，一般由关键字和地址组成</li><li>散列存储：根据元素的关键字直接计算出该元素的存储地址</li></ul><p>存储结构会影响存储空间分配的方便程度和数据运算的速度</p><hr><h2 id="算法的基本概念"><a href="#算法的基本概念" class="headerlink" title="算法的基本概念"></a>算法的基本概念</h2><p>算法：对特定问题求解步骤的一种描述，是指令的有限序列，其中每条指令表示一个或多个操作</p><p>特性：</p><ul><li>有穷性：一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成</li><li>确定性：算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出</li><li>可行性：算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现</li></ul><hr><h2 id="时间复杂度和空间复杂度"><a href="#时间复杂度和空间复杂度" class="headerlink" title="时间复杂度和空间复杂度"></a>时间复杂度和空间复杂度</h2><p>评估算法的时间开销以及空间（内存）开销的指标</p><p>一般是大O表示法 </p><p>（空间换时间）</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.指令系统</title>
      <link href="/post/790.html"/>
      <url>/post/790.html</url>
      
        <content type="html"><![CDATA[<h1 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h1><hr><h2 id="指令的概念和格式"><a href="#指令的概念和格式" class="headerlink" title="指令的概念和格式"></a>指令的概念和格式</h2><p>指令：指计算机执行某种操作的命令，是计算机运行的最小功能单位</p><p>计算机的所有指令的集合构成该机的指令系统，也称为指令集</p><p>一条指令是机器语言的一个语句，是一组有意义的二进制代码，由操作码字段和地址码字段两部分组成</p><p><img src="https://s2.loli.net/2022/03/16/To8UarBPJSFIQVW.png" alt="image-20220316185716163"></p><hr><p>按<strong>地址码长度</strong>分类：</p><p>而根据指令的不同，一条指令可能包含多个地址码，根据地址码数目的不同，可以将指令分为零地址指令，一地址指令……</p><ul><li>零地址指令</li></ul><ol><li>不需要操作数，如空操作，停机，关中断等指令，</li><li>堆栈计算机，两个操作数隐含存放在栈顶和次栈顶，计算结果压回栈顶</li></ol><ul><li>一地址指令</li></ul><ol><li>只需要单操作数，如加1，取反等操作  </li><li>需要两个操作数，但其中一个操作数隐含在某个寄存器中（比如ACC）</li></ol><ul><li>二，三地址指令</li></ul><p>​      常用于需要两个操作数的算数运算，逻辑运算等相关指令</p><ul><li><p>四地址指令</p><p>常是运算之后接跳转指令</p></li></ul><hr><p>按<strong>指令长度</strong>分类</p><p>指令子长：一条指令的总长度（可改变）</p><p>机器子长：CPU进行一次正数运算所能处理的二进制数据的位数（与ALU有关）</p><p>存储子长：一个存储单元中的二进制代码位数（通常和MDR位数相同）</p><p>指令的长度会影响到取指令所需时间，可以把指令分为定长指令字结构和变长指令字结构</p><hr><p>按<strong>操作码长度</strong>分类</p><p>可以分为定长操作码和可变长操作码</p><hr><p>按<strong>操作类型</strong>分类</p><ol><li><p><strong>数据传送</strong></p><p>LOAD  ：把存储器的数据放到寄存器中</p><p>STORE ： 把寄存器的数据放到存储器中</p></li><li><p><strong>运算</strong></p><p>算数运算：加减乘除，浮点运算</p><p>逻辑运算：与或非，异或，取反</p></li><li><p><strong>移位</strong></p><p>算数移位，逻辑移位，循环移位</p></li><li><p><strong>转移</strong></p><p>无条件转移 JMP  </p><p>条件转移  JZ  </p><p>调用和返回  CALL 和 RETURN</p><p>陷阱(Trap)</p></li><li><p><strong>输入输出</strong></p><p>CPU寄存器和IO端口之间的数据传送</p></li></ol><hr><h2 id="拓展操作码指令格式"><a href="#拓展操作码指令格式" class="headerlink" title="拓展操作码指令格式"></a>拓展操作码指令格式</h2><p>有<strong>定长指令字结构+可变长操作码</strong>  →拓展操作码的指令格式</p><p>即不同地址数使用不同长度的操作码</p><p>假设指令子长为16位，每个地址码占4位，前4位为基本操作码字段OP</p><p><img src="https://s2.loli.net/2022/03/16/C8KrRzsbaAqJmUu.png" alt="image-20220316195954835"></p><p>三地址指令地址码占据$A_1,A_2,A_3$，而OP表示操作码，则可以表示16条，但至少保留1111留作拓展操作码用，三地址指令为15条</p><p>二地址指令地址码占据$A_2,A_3$，1111 1111留作拓展操作码使用，共15条</p><p>一地址指令地址码占据$A_3$，1111 1111 1111 留作拓展操作码使用</p><p>零地址指令共16条</p><p>扩展码有两点特点：</p><ol><li><p>不允许短码是长码的前缀（哈夫曼树） </p></li><li><p>各指令的操作码不允许重复</p></li></ol><p>至于根据不同地址指令拓展出适应的地址码，可以参考计算机网络的子网划分问题。</p><hr><p>定长操作码的优点是可以简化计算机硬件设计，提高指令译码和识别速度很有利，缺点是指令数量增加会占用更多固定位，留给操作数地址的位数受限</p><p>拓展操作码可以在指令子长有限的情况下保留比较丰富的指令种类，但是增加了指令译码和分析的难度，使控制器的设计复杂化</p><hr><h2 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h2><p>寻找下一条将要执行的指令地址称为指令寻址</p><p>有两种方式</p><ol><li><p>顺序寻址</p><p>通过程序计数器PC+1，自动形成下一条指令的地址</p></li><li><p>跳跃寻址</p><p>通过转移类指令实现，跳跃就是指下条指令的地址不由程序计数器PC自动给出，而由本条指令给出下条指令地址的计算方式。跳跃指令之后会修改PC的值</p></li></ol><hr><h2 id="数据寻址"><a href="#数据寻址" class="headerlink" title="数据寻址"></a>数据寻址</h2><p>确定本条指令的地址码指明的真实地址</p><p>由于数据寻址的方式很多，为了区分各种方式，通常在指令字中设一个字段，来指明属于何种寻址方式</p><p><img src="https://s2.loli.net/2022/03/16/M3vphj2JRuok9eb.png" alt="image-20220316211519385"></p><p>数据寻址一共有10种方式</p><p><img src="https://s2.loli.net/2022/03/16/smYbjnycu6dF35V.png" alt="image-20220316211559572"></p><hr><h3 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h3><p>指令中的形式地址就是操作数的真实地址EA</p><p><img src="https://s2.loli.net/2022/03/17/uQ6ox39D1zUpifY.png" alt="image-20220317193218843"></p><p>优点：简单，指令执行阶段仅访问一次主存，不需专门计算操作数的地址</p><p>缺点：A的位数决定了该指令操作数的寻址范围，操作数的地址不易修改</p><hr><h3 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h3><p>指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数有效地址所在的存储单元的地址，也就是操作数地址的地址 EA=(A)</p><p><img src="https://s2.loli.net/2022/03/17/eOfVWCnp6zxuv5T.png" alt="image-20220317193609475"></p><p>优点：可扩大寻址范围，便于编址程序（跳转）</p><p>缺点：指令在执行过程中要多次访存</p><hr><h3 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h3><p>在指令字中直接给出寄存器的编号，$EA=R_i$，操作数存储在寄存器中</p><p><img src="https://s2.loli.net/2022/03/17/8gpCnMQfbq4XmE7.png" alt="image-20220317194055642"></p><p>优点：指令在执行阶段不访问主存，只访问寄存器，指令字短而且执行速度快</p><p>缺点：寄存器价格昂贵，寄存器个数有限</p><hr><h3 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h3><p>寄存器中给出的不是一个操作数，而是操作数所在主存单元的地址</p><p><img src="https://s2.loli.net/2022/03/17/APpWbYkLJm34qXn.png" alt="image-20220317194346370"></p><p>优点：相比于间接访存，速度更快</p><hr><h3 id="隐含寻址"><a href="#隐含寻址" class="headerlink" title="隐含寻址"></a>隐含寻址</h3><p>不是明显地给出操作数地址，而是在指令中隐含操作数的地址</p><p><img src="https://s2.loli.net/2022/03/17/EbP7YBVT6XUkrnp.png" alt="image-20220317194558522"></p><p>优点：有利于缩短指令子长</p><p>缺点：需增加存储操作数或隐含地址的硬件</p><hr><h3 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h3><p>形式地址A就是操作数本身，又称为立即数，一般采用补码形式，#表示立即寻址方式</p><p>优点：执行阶段不访问主存</p><p>缺点：A的位数限制了立即数的范围</p><hr><h3 id="基址寻址"><a href="#基址寻址" class="headerlink" title="基址寻址"></a>基址寻址</h3><p>将CPU中基址寄存器（BR）的内容加上指令格式中的形式地址A，而形成操作数的有效地址，即EA=(BR)+A</p><p><img src="https://s2.loli.net/2022/03/17/JnMoEXuARZct1H9.png" alt="image-20220317201400881"></p><p>也可以用其他寄存器作为基址寄存器</p><p>基址寄存器是面向操作系统的，其内容由操作系统或管理程序确定。在程序执行过程中，基址寄存器的内容不变，形式地址可变</p><p>优点：可扩大寻址范围，有利于多道程序设计，编址浮动程序</p><hr><h3 id="变址寻址"><a href="#变址寻址" class="headerlink" title="变址寻址"></a>变址寻址</h3><p>有效地址EA等于指令字中的形式地址A与变址寄存器IX的内容相加之和</p><p><img src="https://s2.loli.net/2022/03/17/DPfIzaMQZpAq6bt.png" alt="image-20220317202334313"></p><p>和基址寻址的区别是，变址寄存器中的地址可以被改变，而形式地址不变，即IX作为偏移量，而形式地址作为基址</p><p>在编制循环程序的时候，可以让数组的起始地址作为形式地址，IX不断增加，来处理数组</p><hr><h3 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h3><p>把程序计数器PC的内容加上指令格式中的形式地址A而形成操作数的有效地址，即EA=（PC）+A，其中A是相对于PC所指地址的偏移量，补码表示</p><p><img src="https://s2.loli.net/2022/03/17/PZEV9GNyl613Wvr.png" alt="image-20220317203643274"></p><p>取出当前指令后，PC会指向下一条指令，相对寻址是相对于下一条指令的偏移量</p><p>优点：操作数的地址不是固定的，随PC值的变化而变化，并且与指令地址之间总是相差一个固定值，因此便于程序浮动，广泛用于转移指令</p><hr><h3 id="堆栈寻址"><a href="#堆栈寻址" class="headerlink" title="堆栈寻址"></a>堆栈寻址</h3><p>操作数放在堆栈中，隐含使用堆栈指针SP作为操作数地址</p><p>硬堆栈使用专用的寄存器作为堆栈，而软堆栈是在主存中开辟一段地址作为堆栈使用</p><p>可用于函数调用时保存当前函数的相关信息</p><p><img src="https://s2.loli.net/2022/03/17/YbH9LxXsya2wj5B.png" alt="image-20220317215800055"></p><hr><h2 id="CISC和RISC"><a href="#CISC和RISC" class="headerlink" title="CISC和RISC"></a>CISC和RISC</h2><p>CISC：Complex Instruction Set Computer  复杂指令集</p><p>主要是X86架构，主要用于笔记本，台式机等</p><p>一条指令能完成一个复杂的基本功能</p><hr><p>RISC：Reduced Instruction Set Computer    精简指令集</p><p>主要是ARM架构，主要用于手机，平板</p><p>一条指令完成一个基本动作，多条指令组合完成一个复杂的基本功能</p><hr><p><img src="https://s2.loli.net/2022/03/19/XYOm2sdQJjvHL1n.png" alt="image-20220319143707720"></p>]]></content>
      
      
      <categories>
          
          <category> 组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.存储系统</title>
      <link href="/post/46984.html"/>
      <url>/post/46984.html</url>
      
        <content type="html"><![CDATA[<h1 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h1><hr><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="存储系统层次化结构"><a href="#存储系统层次化结构" class="headerlink" title="存储系统层次化结构"></a>存储系统层次化结构</h3><p><img src="https://s2.loli.net/2022/03/11/q1BjxAs6H2Ne9aW.png" alt="image-20220311211032882"></p><p><img src="https://s2.loli.net/2022/03/11/fFzOMgHruspdDmQ.png" alt="image-20220311210806966"></p><p>Cache指的是高速缓冲存储器</p><p>主存和辅存之间的交换涉及到了操作系统中的虚拟存储系统部分，解决了主存容量不够的问题</p><p>而Cache和主存之间的交换解决了主存与CPU速度不匹配的问题</p><hr><h3 id="存储器的分类"><a href="#存储器的分类" class="headerlink" title="存储器的分类"></a>存储器的分类</h3><p>按<strong>层级</strong>分：可以分为高速缓存（Cache），主存储器（内存），辅助存储器（外存，磁盘）</p><p>按<strong>存储介质</strong>分：半导体存储器（主存，Cache），磁表面存储器（磁盘，磁带，硬盘），光存储器（光盘）</p><p>按<strong>存储方式</strong>分：</p><ul><li>随机存取存储器 <strong>RAM</strong>（Random Access Memory）：即是读写任何一个存储单元所需时间都相同，与存储单元所在物理位置无关，比如内存条</li><li>顺序存取存储器（Sequential Access Memory，<strong>SAM</strong>）：读写一个存储单元所需时间取决于存储单元所在的物理位置，比如磁带</li><li>直接存取存储器（Direct Access Memory，<strong>DAM</strong>）：既有随机存取特性，也有顺序存取特性。先直接选取信息所在区域，然后按顺序方式存取，比如硬盘</li><li>相联存储器（Associative Memory），即可以按内容访问的存储器，（Content Addres Memory）<strong>CAM</strong>，比如快表</li></ul><p>按<strong>信息的可更改性</strong>：读写存储器（磁盘，内存）只读存储器（CD）</p><p>按<strong>信息的可保存性</strong>：</p><ul><li>断电后，存储信息消失（主存，Cache）</li><li>断电后，存储信息存在（磁盘，光盘）</li><li>信息读出后，原存储信息被破坏（DRAM芯片）</li><li>信息读出后，原存储信息不被破坏（SRAM芯片，磁盘）</li></ul><hr><h3 id="存储器的性能指标"><a href="#存储器的性能指标" class="headerlink" title="存储器的性能指标"></a>存储器的性能指标</h3><p><strong>存储容量</strong>：存储字数×子长</p><p><strong>单位成本</strong>：每位价格=总成本/总容量</p><p><strong>存储速度</strong>：数据传输率（主存带宽 ）=数据的宽度/存储周期</p><p>因为每次存储结束后，存储器需要一定的时间恢复，所以存储时间和存储周期之间是有差别的</p><p><img src="https://s2.loli.net/2022/03/11/9Yul2XPy4OivbzR.png" alt="image-20220311213337555"></p><hr><h2 id="主存储器的基本组成"><a href="#主存储器的基本组成" class="headerlink" title="主存储器的基本组成"></a>主存储器的基本组成</h2><h3 id="基本的半导体元件"><a href="#基本的半导体元件" class="headerlink" title="基本的半导体元件"></a>基本的半导体元件</h3><p>以下知识将大量涉及到数电，所以将简要描述知识点（数电里学过了）</p><p><img src="https://s2.loli.net/2022/03/14/qurMeSzD9NOmTAI.png" alt="image-20220314194737012"></p><p>MOS管和电容可以组成一个基本的<strong>存储元</strong>，来表示0和1</p><p><img src="https://s2.loli.net/2022/03/14/xzf6SOJg94NlQnT.png" alt="image-20220314194007948"></p><p>而多个存储元集中排列在一起，则形成了基本的存储单元，就是<strong>存储字</strong></p><p>而多个存储字会拼接会形成一个<strong>存储体</strong></p><p><img src="https://s2.loli.net/2022/03/14/3rilkX5sIbG4YHf.png" alt="image-20220314194316202"></p><p>而操纵这个存储体所需要的器件，就是<strong>译码器</strong></p><hr><h3 id="存储体芯片的基本原理"><a href="#存储体芯片的基本原理" class="headerlink" title="存储体芯片的基本原理"></a>存储体芯片的基本原理</h3><p><strong>译码器</strong>的作用是将MAR的中的地址信号，传达到具体的存储单元中去</p><p><img src="https://s2.loli.net/2022/03/14/UVWKD5cjg3HBfoi.png" alt="image-20220314195304494"></p><p>比如MAR中是3位地址，那么译码器会有$2^3=8$条线，连接到具体的存储单元中去，当某一条字选线接通的时候，存储字中的信息就会被存储在MDR中，通过数据总线传输到CPU</p><hr><p>需要一个<strong>控制电路</strong>来保持MAR和MDR中电信号稳定，同时还要有片选线，表示控制电路何时可用，同时还要有读控制线和写控制线，可以用两根线来读和写，也可以用一根线来读和写</p><p><img src="https://s2.loli.net/2022/03/14/L4Sv7q13PHaxUWe.png" alt="image-20220314195928191"></p><hr><p>总得来说，整体结构如下</p><p><img src="https://s2.loli.net/2022/03/14/QWoC7tkH59jP4mZ.png" alt="image-20220314200014262"></p><p>因为一个内存条里面有多块存储芯片，所以需要<strong>片选线</strong>来指定具体的存储芯片</p><p>而芯片上的金属引脚，就是用来连接地址线，片选线，数据线，读写控制线等的</p><hr><h2 id="SRAM和DRAM"><a href="#SRAM和DRAM" class="headerlink" title="SRAM和DRAM"></a>SRAM和DRAM</h2><p><strong>DRAM</strong>（Dynamic Random Access Memory）：动态RAM</p><p><strong>SRAM</strong>（Static Random Access Memory）：静态RAM</p><p>区别</p><ol><li>利用<strong>MOS管</strong>作为存储元的RAM就是DRAM，SRAM使用的是<strong>双稳态触发器</strong>作为存储元</li><li>DRAM在读出数据时会破坏性读出数据，读出后应有重写的操作，而SRAM在读取数据后不会被破坏，读写数据更快</li><li>DRAM每个存储元制造成本低，集成度高，功耗低 ，SRAM的成本高，功耗高</li></ol><p><img src="https://s2.loli.net/2022/03/14/PrjFtJq3QCvghG2.png" alt="image-20220314201356840"></p><p>SRAM常常用于Cache，而DRAM常用于主存</p><hr><p> <strong>DRAM的刷新</strong></p><p>刷新是指电容内的电荷只能维持2ms，所以DRAM需要不断的刷新，每次刷新一行存储单元，地址常常是二维的，译码器分为行译码器和列译码器</p><p>刷新操作有硬件支持，读书一行数据后重新输入，占用1个读写周期，不需要CPU控制</p><p>刷新方法有3种</p><ol><li><p>分散刷新 </p><p>每次读写完刷新一个行，将一个存取周期的前一半时间正常读取，后一半时间刷新某行</p><p><img src="https://s2.loli.net/2022/03/14/uxqE6FNHM9yPAkd.png" alt="image-20220314202218342"></p></li><li><p>集中刷新</p><p>在2ms内集中安排一个时间刷新，在此期间无法访问存储器，称为死区</p><p><img src="https://s2.loli.net/2022/03/14/AHcabRJBgL4l9SQ.png" alt="image-20220314202226554"></p></li><li><p>异步刷新</p><p>2ms内每行需要刷新一次，每隔固定的时间刷新一行，可以在译码阶段刷新</p><p><img src="https://s2.loli.net/2022/03/14/6uts5ZVGze2RFBx.png" alt="image-20220314202503063"></p></li></ol><hr><p>DRAM有地址线复用技术，可以将地址分两次传送，只需要n/2条地址线就能完成地址的传输</p><hr><h2 id="只读存取器ROM-Read-Only-Memory"><a href="#只读存取器ROM-Read-Only-Memory" class="headerlink" title="只读存取器ROM(Read-Only Memory)"></a>只读存取器ROM(Read-Only Memory)</h2><p>ROM芯片具有非易失性，断电后数据不会丢失</p><ol><li><p>MROM(Mask Read-Only Memory)——掩模式只读存储器</p><p>厂家在生产的时候直接写入，之后只能读出，任何人不能改写</p></li><li><p>PROM(Programmable) ——可编程只读存储器</p><p>可以用专门的写入器写人信息，写一次后不可更改</p></li><li><p>EPROM(Erasable Programmable)——可擦除可编程只读存储器</p><p>允许用户写入信息，之后用某种方法擦除数据，可进行多次重写 </p></li><li><p>Flash Memory ——闪存（u盘）</p><p>由EEPROM发展而来，断电后也能保存信息，可进行多次快速的擦除重写，由于闪存需要先擦除后写入，因此闪存的写比读更慢</p></li><li><p>SSD（Solid State Drives）——固态硬盘</p><p>有控制单元+存储单元（Flash芯片）构成，在闪存的区别在于控制单元不一样，存储介质一样，可以进行多次快速擦除重写，速度快，功耗低，价格高</p></li></ol><hr><p>BIOS芯片中存储了自举装入程序，负责引导装入操作系统</p><p><img src="https://s2.loli.net/2022/03/14/joYuP4HQU13LNmv.png" alt="image-20220314205925651"></p><p>尽管ROM的名字是“Read-Only”，但实际上，很多的ROM也可以 写（u盘）</p><p>很多ROM同样具有随机存取的特点</p><hr><h2 id="主存储器和CPU的连接"><a href="#主存储器和CPU的连接" class="headerlink" title="主存储器和CPU的连接"></a>主存储器和CPU的连接</h2><p>单块存储芯片和CPU的连接</p><p><img src="https://s2.loli.net/2022/03/14/38RvyHPSG7cDXIo.png" alt="image-20220314210901820"></p><p>如果想拓展存储体中的字数，需要用到<strong>字拓展法</strong></p><p>如果想拓展数据总线的宽度，需要用到<strong>位拓展法</strong></p><hr><h3 id="字拓展法"><a href="#字拓展法" class="headerlink" title="字拓展法"></a>字拓展法</h3><p>增加主存的<strong>存储字数</strong>，可以使用多个存储芯片，将多余的CPU的引脚来<strong>控制</strong>存储芯片的激活，即<strong>线选法</strong>，n条线输出n个选片信号</p><p><img src="https://s2.loli.net/2022/03/14/P6qCe1fsldEUxXV.png" alt="image-20220314212403971"></p><p>而在n条线之后添加译码器，可以输出$2^n$个选片信号，称为片选法</p><p><img src="https://s2.loli.net/2022/03/14/RTJu9PysmlFNCBx.png" alt="image-20220314212440866"></p><p>区别如下：</p><p><img src="https://s2.loli.net/2022/03/14/LY52rGvA1SEcKPh.png" alt="image-20220314212044687"></p><hr><h3 id="位拓展法"><a href="#位拓展法" class="headerlink" title="位拓展法"></a>位拓展法</h3><p>增加主存的<strong>存储子长</strong>，可以用多块存储芯片，将数据总线连接到不同芯片中，将1位芯片扩展到8位</p><p><img src="https://s2.loli.net/2022/03/14/AqyPcxNFm39KeTd.png" alt="image-20220314211354925"></p><hr><h3 id="字位同时拓展"><a href="#字位同时拓展" class="headerlink" title="字位同时拓展"></a>字位同时拓展</h3><p>使用多块存储芯片为1组，同时使用译码器来同时实现字位拓展</p><hr><h2 id="双端口RAM和多模块存储器"><a href="#双端口RAM和多模块存储器" class="headerlink" title="双端口RAM和多模块存储器"></a>双端口RAM和多模块存储器</h2><p>DRAM芯片的恢复时间很长，而现代计算机通常是多核CPU，多核CPU之间存在访存问题</p><h3 id="双端口RAM"><a href="#双端口RAM" class="headerlink" title="双端口RAM"></a>双端口RAM</h3><p><img src="https://s2.loli.net/2022/03/15/YpXvV47b8TkxfEB.png" alt="image-20220315101635030"></p><p>即指RAM提供2个端口，方便两个CPU同时访问，须有有两组完全独立的数据线，地址线，控制线，电路也更复杂</p><p>目的就是为了<strong>优化多核CPU访问一根内存条的速度</strong></p><p>两个端口可以同时对内存的不同地址单元进行读取，也可以对同一地址单元读出数据，但是不能同时对同一地址单元写入数据，也不能对同一地址单元同时读入和写入数据</p><p>解决办法：可以设置一个信号，由逻辑判断决定暂时关闭一个端口，被关闭的端口延后访问</p><hr><h3 id="多模块存储器"><a href="#多模块存储器" class="headerlink" title="多模块存储器"></a>多模块存储器</h3><p>为了提高存储器和CPU之间的速度，可以采用多体并行存储器</p><p>多体存储器分为高位交叉编址和低位高位编址，区别在于将内存条的某几位作为地址进行编址的位置的不同</p><p><img src="https://s2.loli.net/2022/03/15/HxcqZzh3LYutl1P.png" alt="image-20220315103114077"></p><p>可以看到，连续的地址由于低位交叉编址，被分配在了不同的内存条中，可以大大减少访问连续地址时的等待时间</p><p><img src="https://s2.loli.net/2022/03/15/owx2nE8phizGCM3.png" alt="image-20220315103819743"></p><p>假设每个存储体的存取周期是T，存取时间是r，那么连续存取n个字，耗时是<strong>T+(n-1)r</strong></p><p>为了保证存取的顺畅性，应保证模块数<strong>m=T/r</strong></p><p>双通道：即指的是两个内存条之间采用低位交叉方式进行编址</p><hr><p>单体多字存取器可以将存储器集合在一起，每次读取多个字，相当于位拓展</p><hr><h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><h3 id="基本概念和原理"><a href="#基本概念和原理" class="headerlink" title="基本概念和原理"></a>基本概念和原理</h3><p>Cache即是高速缓冲存储器，由SRAM组成，负责加快内存和CPU之间的数据传输</p><p>假设$t_c$为访问一次Cache所需时间，$t_m$为访问一次主存所需时间</p><p>命中率H：CPU访问的信息在Cache中的比率      </p><p>缺失率： M=1-H</p><p>如果先访问Cache，未命中再访问主存，那么平均访问时间是$t=Ht_c+(1-H)(t_c+t_m)$</p><p>如果同时访问Cache和主存，若Cache命中就立即停止访问主存，那么平均访问时间是$t=Ht_c+(1-H)(t_m)$</p><hr><p>（以下内容和操作系统的存储管理有极大联系）</p><p>为了实现将主存与Cache之间的数据交换，可以将主存的存储空间分块，主存与Cache之间以块为单位进行数据交换</p><p>假如主存的地址是4M，也就是$22$位，其中前12位标记为块号，后10位标记为块内的地址，整个主存被分为$2^{12}=4096$块，每一块包括有1K个地址</p><p>一块又称为一个页，或页面，而Cache中的块也被称为行，Cache的块的大小和主存中块的大小保持一致</p><p><img src="https://s2.loli.net/2022/03/15/95fgNAalhFyWOic.png" alt="image-20220315194805849"></p><hr><h3 id="Cache和主存之间的映射"><a href="#Cache和主存之间的映射" class="headerlink" title="Cache和主存之间的映射"></a>Cache和主存之间的映射</h3><ul><li>直接映射</li></ul><p>直接映射，即是<strong>主存块在Cache中的位置=主存块号%Cache总块数</strong></p><p>假设Cache的总块数是$2^3$，则相当于保留下主存块号的后3位，若Cache的总块数为$2^{n}$，则主存块的末尾n位直接反映了它在Cache中的位置，将主存块号的其他位置作为标记即可</p><p>标记的作用是指明Cache中块数对应的内存块数</p><p><img src="https://s2.loli.net/2022/03/15/3Aa9gFhVMPZTtGu.png" alt="image-20220315195733249"></p><p>CPU访问内存地址的步骤：</p><ol><li>根据主存块号的后三位确定Cache行</li><li>若主存块号的前19位和Cache标记匹配，且有效位为1，说明Cache命中，则访问块内地址为主存块内地址的单元</li><li>若未命中，则正常访问主存</li></ol><hr><ul><li>全相联映射</li></ul><p>也就是说，主存中的块可以随意放到Cache中去，放入后，将Cache块的标记改为主存地址即可</p><p>CPU访问内存地址步骤：</p><ol><li>主存地址的前22位对比Cache中所有块的标记</li><li>若标记匹配且有效位为1，则访问块内地址为主存块内地址的单元</li><li>若未命中，则正常访问主存</li></ol><hr><ul><li>组相联映射</li></ul><p>组相联映射，所属分组=主存块号%分组数</p><p>分组数为$2^{n}$，则主存块的末尾n位直接反映了它在Cache中分组的位置</p><p><img src="https://s2.loli.net/2022/03/15/F7BvcDIVap9QhCd.png" alt="image-20220315204721994"></p><p>CPU访问内存地址的步骤：</p><ol><li>根据主存块号的后2位确定所属分组号</li><li>若主存块号的前20位和Cache标记匹配，且有效位为1，说明Cache命中，则访问块内地址为主存块内地址的单元</li><li>若未命中，则正常访问主存</li></ol><hr><h3 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h3><p>对于全相联映射，当Cache满了之后，需要在全局中选择替换一块</p><p>对于直接映射，当Cache满了之后，可以直接替换掉</p><p>对于组相联映射，当Cache分组内满了之后，才需要在分组内选择替换哪一块</p><p>所以对于全相联映射和组相联映射，需要替换算法以判断替换的块数</p><hr><ul><li>随机算法（RAND）</li></ul><p>如果Cache满了，则随机选择一块进行替换，虽然实现简单，但Cache的命中率会很低</p><hr><ul><li>先进先出算法（FIFO）</li></ul><p>若Cache已满，则替换最先被调入的块，实现简单，但仍然没考虑到局部性原理</p><hr><ul><li>近期最少使用算法（LRU）</li></ul><p>为每一个Cache块设置一个计数器，用于记录每个Cache块已经有多久未被访问了，当Cache满后替换掉计数器最大的</p><p>计数规则如下：</p><ol><li>命中时，将所命中行计数器清零，比其低的计数器加1，其余不变</li><li>未命中且还有空闲行时，新装入的行计数器置0，其余非空闲行全加1</li><li>未命中且无空闲行时，计数器最大的信息块被淘汰，新装行的块计数器置0，其余全加1</li></ol><p>之所以命中时比命中行高的计数器不变，是因为加1了之后没有意义，而且可以用较少的比特位来表示计数器状态，假如Cache块的总数是$2^n$则计数器只用n位，而且Cache装满后，所有计数器的值一定不重复</p><p>这种算法的命中率高，算法性能优秀</p><hr><ul><li>最不经常使用算法（LFU）</li></ul><p>为每一个Cache块设置一个计数器，用于记录每个Cache块被访问过几次，当Cache块满后替换计数器最小的</p><p>新调入的块计数器为0，之后每被访问一次计数器+1，替换时，选择计数器最小的一行</p><p>若有多个计数器最小行，可以按其他策略来选择被替换的行，实际上性能不如LRU</p><hr><h3 id="Cache写策略"><a href="#Cache写策略" class="headerlink" title="Cache写策略"></a>Cache写策略</h3><p>CPU修改了Cache中的数据后，需要保证Cache和内存中的一致性</p><ul><li>写回法</li></ul><p>如果Cache对Cache写命中了，只修改Cache的内容，而不立刻写入主存，只有当此块被换出后才写入主存</p><p>需要设置一个标志位来表示该行是否被修改过</p><ul><li>全写法</li></ul><p>如果Cache对Cache写命中了，同时修改Cache和主存中的内容，可以保证数据的安全，一般使用写缓冲（write buffer）的方法</p><p>即用SRAM制造一个缓存器，实现FIFO的功能，如果要修改Cache，CPU将要修改的主存内容写入到缓存器中，然后由专门的控制电路控制写缓冲器写回到主存中去</p><p>使用写缓冲时，CPU写的速度很快，当写操作很频繁的时候，可以会发生阻塞</p><hr><ul><li>写分配法</li></ul><p>当CPU对Cache没有命中，则把主存中的块调入到Cache中进行修改，通常搭配写回法</p><ul><li>非写分配法</li></ul><p>当CPU对Cache没有命中，则对主存中的数据直接进行修改，通常搭配全写法</p><hr><p>现代计算机通常采用多级Cache，越接近CPU的Cache速度越快，容量越小</p><p><img src="https://s2.loli.net/2022/03/15/e9fIc1NTtxGKld5.png" alt="image-20220315212325199"></p><p>Cache和Cache之间常采用全写法和非写分配法，而Cache和主存之间使用写回法和写分配法</p><hr><h2 id="页式存储器"><a href="#页式存储器" class="headerlink" title="页式存储器"></a>页式存储器</h2><p>只介绍其和Cache的联系，具体看操作系统第三章</p><p><img src="https://s2.loli.net/2022/03/15/sylVQrROqGhibT7.png" alt="image-20220315212635889"></p>]]></content>
      
      
      <categories>
          
          <category> 组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.数据的表示和运算</title>
      <link href="/post/40849.html"/>
      <url>/post/40849.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据的表示和运算"><a href="#数据的表示和运算" class="headerlink" title="数据的表示和运算"></a>数据的表示和运算</h1><hr><h2 id="进位计数制"><a href="#进位计数制" class="headerlink" title="进位计数制"></a>进位计数制</h2><h3 id="任意进制转为十进制"><a href="#任意进制转为十进制" class="headerlink" title="任意进制转为十进制"></a>任意进制转为十进制</h3><p>根据权值进行运算即可</p><p><img src="https://s2.loli.net/2022/03/06/qSo1KkMa9jBZ63Q.png" alt="image-20220306150022009"></p><hr><h3 id="二进制和八进制，十六进制的相互转换"><a href="#二进制和八进制，十六进制的相互转换" class="headerlink" title="二进制和八进制，十六进制的相互转换"></a>二进制和八进制，十六进制的相互转换</h3><p>二进制转八进制，将二进制从低位到高位，3位一组，每组转换为对应的八进制符号即可</p><p>二进制转十六进制，将二进制从低位到高位，4位一组，每组转换为对应的十六进制符号即可</p><p>而反过来就是八进制，十六进制转换为二进制</p><hr><h3 id="十进制转为任意进制"><a href="#十进制转为任意进制" class="headerlink" title="十进制转为任意进制"></a>十进制转为任意进制</h3><p>通用方法是使用除基取余法，但实际上一般用拼凑法</p><p><img src="https://s2.loli.net/2022/03/06/RS7mL95cfi1Xwqr.png" alt="image-20220306150747121"></p><hr><h3 id="真值和机器数"><a href="#真值和机器数" class="headerlink" title="真值和机器数"></a>真值和机器数</h3><p>真值：实际带有正负号的数</p><p>机器数：把正负号数字化的数</p><hr><h2 id="字符与字符串"><a href="#字符与字符串" class="headerlink" title="字符与字符串"></a>字符与字符串</h2><h3 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h3><p>英文在计算机中通过ASCII码进行存储</p><p><img src="https://s2.loli.net/2022/03/06/14EeJrqAQXiN6on.png" alt="image-20220306151604128"></p><p>从32~126为可印刷字符，其余为控制，通信字符</p><hr><h3 id="汉字的存储"><a href="#汉字的存储" class="headerlink" title="汉字的存储"></a>汉字的存储</h3><p>汉字的存储有多种方式，简单介绍一种GB 2312-80</p><p>先通过94×94的的表格存储汉字得到<strong>区位码</strong></p><p>为了避免和ASCII码的前32位冲突，再将区位码+20H得到<strong>国标码</strong></p><p>再将国标码+80H，得到<strong>汉字内码</strong></p><hr><h3 id="字符串的存储"><a href="#字符串的存储" class="headerlink" title="字符串的存储"></a>字符串的存储</h3><p>计算机按字节编址，从地址为2的单元开始，存储字符串，很多语言中用 \0 作为字符串结尾</p><p>而汉字占据两个字节，有两种存储模式，分别是将最高位有效字节存储在低地址单元的大端模式，和将最高位有效位存储在高地址单元的小端模式</p><hr><h2 id="定点数的表示"><a href="#定点数的表示" class="headerlink" title="定点数的表示"></a>定点数的表示</h2><h3 id="无符号数"><a href="#无符号数" class="headerlink" title="无符号数"></a>无符号数</h3><p>无符号数：整个机器子长的全部二进制位均为数值位，没有符号位，相当于绝对值</p><p>8位二进制数可以表示$2^8$种不同状态</p><hr><h3 id="有符号数"><a href="#有符号数" class="headerlink" title="有符号数"></a>有符号数</h3><p>有符号数：用最高位表示数的正负，称为有符号数</p><p>定点数：约定机器数中的小数点位置是固定不变的，一种在符号位的后面，称作定点小数，一种是在最低位之后，称作定点整数</p><hr><ol><li><p><strong>原码</strong></p><p>将最高位作为符号位，剩下的位来表示真值的绝对值，最高位为0表示正数，1表示负数</p><p>如果机器字长为8位，原码整数可以表示的范围是：$-(2^7-1)$ ~ $(2^7-1)$</p><p>真值0有2种形式，+0 和 -0</p></li><li><p><strong>反码</strong></p><p>若符号位为0，则反码与原码相同，若符号位为1，则将原码的数值位全部取反得到反码<br>表示范围和原码一样</p></li><li><p><strong>补码</strong></p><p>正数的补码就是原码，负数的补码=反码末位+1（考虑进位）</p><p>补码的0仅有一种形式 把1 0000 000 规定为$-2^7$</p><p>补码整数表示范围是$-(2^7)$ ~ $(2^7-1)$</p><p>负数补码转换为原码：将除符号位取反，末位+1</p></li><li><p><strong>移码</strong></p><p>在补码的基础上将符号位取反，则是移码，移码相比于补码，可以更清晰的比较数的大小</p></li></ol><p><strong>补码的作用是将ALU中的减法操作转换为加法操作</strong>，就8位机器而言，其能表示的范围是-128~127，本质上可以看做是一个圆圈，从0开始到127,127接着是-128，然后又回到0，加法操作就是就是顺时针拨动，减法操作就是逆时针拨动</p><hr><h2 id="定点数的运算"><a href="#定点数的运算" class="headerlink" title="定点数的运算"></a>定点数的运算</h2><h3 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h3><p>移位：改变各个数码位和小数点的相对位置，从而改变各数码位的位权</p><hr><p><strong>算数移位</strong>：符号位保持不变，对数值位进行移位</p><ol><li><p><strong>原码</strong></p><p><strong>右移</strong>：高位补0，低位舍弃。若舍弃的位是0，相当于÷2，若舍弃的位≠0，那么被舍弃后会<strong>丢失精度</strong></p><p><strong>左移</strong>：低位补0，高位舍弃。若舍弃的位是0，相当于×2，若舍弃的位≠0，那么被舍弃后会出现<strong>严重误差</strong></p></li><li><p><strong>反码</strong></p><p>正数的反码和原码相同，因此对正数反码的移位运算也和原码相同 </p><p>负数的反码是对原码取反，所以对于负数反码来说，右移高位补1，左移低位补1</p></li><li><p><strong>补码</strong></p><p>正数的补码和原码相同，因此对正数反码的移位运算也和原码相同 </p><p>对于负数的补码而言：</p><p>右移：高位补1，低位舍弃</p><p>左移：低位补0，高位舍弃<br><img src="https://s2.loli.net/2022/03/08/ylvYVpSrfwF7hzB.png" alt="image-20220308154237389"></p><p>因为在负数补码中，以最右边的1为分界，右边同原码，左边同反码</p></li></ol><hr><p>总结：</p><p><img src="https://s2.loli.net/2022/03/08/l47CDRq8d9PBJGj.png" alt="image-20220308154607072"></p><hr><p><strong>逻辑移位</strong>：对所有位进行移位</p><p>右移：高位补0，低位舍弃</p><p>左移：低位补0，高位舍弃</p><hr><p><strong>循环移位</strong></p><p>左移：所有位向左边移动，最低位移到最高位</p><p>右移：所有位向右边移动，最高位移到最低位</p><hr><h3 id="加减运算和溢出"><a href="#加减运算和溢出" class="headerlink" title="加减运算和溢出"></a>加减运算和溢出</h3><p><strong>原码的加减法</strong></p><p>因为原码的符号位会影响运算，所以在涉及到正数和负数之间运算的时候需要用到绝对值和减法器</p><p>正+正    绝对值做加法</p><p>负+负    绝对值做加法，结果为负</p><p>正+负    绝对值大的减绝对值小的，符号同绝对值大的数</p><p>至于减法运算，把减数符号取反后，转变为加法就行</p><hr><p><strong>补码的加减法</strong></p><p>对于补码来说，无论是加法还是减法，都是可以转换成补码做加法操作，符号位也要参与运算</p><hr><p><strong>溢出</strong></p><p>正数+正数才有可能发生上溢（＞127）</p><p>负数+负数才有可能发生下溢  (&lt; -128）</p><hr><p><strong>溢出判断</strong></p><ol><li><p>一位符号位</p><p>$V=A_SB_S\bar{S}_S+\bar{A}_S\bar{B}_SS_S$</p><p>A的符号位是$A_S$,B的符号位是$B_S$，运算结果的符号位是$S_S$</p><p>V=0表示没有溢出，V=1表示有溢出</p><p>当减法操作时，$A_S$=1，$B_S$=1，且$S_S$=0，会判断出溢出</p><p>当加法操作时，$A_S$=0，$B_S$=0，且$S_S$=1，会判断出溢出</p></li></ol><ol><li><p>根据数据位进位情况判断</p><p><img src="https://s2.loli.net/2022/03/08/koUgjeWPEuA7vmH.png" alt="image-20220308165630903"></p><p>发生上溢的时候：$C_1$=1 $C_S$=0</p><p>发生下溢的时候：$C_1$=0 $C_S$=1</p><p>$C_S$和$C_1$不同有溢出，用异或操作可以判断溢出，不同为1，相同为0</p><p>$0\oplus 0=0$</p><p>$0\oplus 1=1$</p><p>异或结果为1，说明溢出</p></li></ol><ol><li><p>双符号位</p><p>多加一个符号位，正数的符号位00，负数符号为11</p><p>$S_1\oplus S_2=0$如果两个符号位相同则没有溢出，不同则溢出</p></li></ol><hr><h3 id="符号拓展"><a href="#符号拓展" class="headerlink" title="符号拓展"></a>符号拓展</h3><p>当8位数据拓展到16位数据时，正数都加0，负数反码,补码加1,</p><p>相当于左移嘛</p><hr><h3 id="原码和补码的乘除运算"><a href="#原码和补码的乘除运算" class="headerlink" title="原码和补码的乘除运算"></a>原码和补码的乘除运算</h3><p>略</p><hr><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>C语言中的定点正数都是用“补码”形式存储的</p><p>如果要使用无符号数，要在数据类型前加上 <code>unsigned</code></p><p>当有符号数转化成无符号数时，不会改变内容，而是改变解释方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> x=<span class="number">-4321</span>;                <span class="comment">//short一般占用2个字节</span></span><br><span class="line">unsighed <span class="keyword">short</span> y=(<span class="keyword">unsigned</span> <span class="keyword">short</span>)x;</span><br><span class="line">y=<span class="number">61213</span></span><br></pre></td></tr></table></figure><p>长整数变为短整数时，会将<strong>高位截断，保留低位</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">165537</span> ;<span class="comment">// a:0x 000286a1</span></span><br><span class="line"><span class="keyword">short</span> c=(<span class="keyword">short</span>) a;   <span class="comment">// c: 0x 96a1</span></span><br><span class="line">c=<span class="number">-31071</span></span><br></pre></td></tr></table></figure><p>短整数变长整数时：会经历符号扩展，按补码的规矩，往<strong>高位添1</strong></p><hr><h2 id="数据的存储和排列"><a href="#数据的存储和排列" class="headerlink" title="数据的存储和排列"></a>数据的存储和排列</h2><p>多字节数据在内存中一定是占据连续的几个字节，有最高有效字节MSB，最低有效字节LSB</p><p>对于机器而言，通过小端方式，即让最低位占据在低地址，更便于机器处理数据</p><p><img src="https://s2.loli.net/2022/03/08/b6FEL8oZRIGl37U.png" alt="image-20220308202030774"></p><hr><p>现代计算机通常使用按字节编址（8bit），即每个字节对应1个地址，但也支持按字，半字，字节寻址</p><p>假设存储子长为32位，则1个字=32bit，半字=16bit，每次访存只能读取1个字</p><p> 为了实现计算机内部的按字节，半字，字寻址，有两种数据排列方式</p><ol><li><strong>边界对齐方式</strong></li></ol><p><img src="https://s2.loli.net/2022/03/08/IvrsHuwQOV37UXk.png" alt="image-20220308204732745"></p><p>让边界对齐，按字的来排列数据，空出的部分进行填充</p><ol><li><strong>边界不对齐方式</strong></li></ol><p><img src="https://s2.loli.net/2022/03/08/N3qFDJw5Ipz1dk4.png" alt="image-20220308204958529"></p><p>对数据进行紧凑的排布，不进行填充</p><hr><p>边界对齐方式是一种用<strong>空间换时间</strong>的方式，因为每次访存只能读取一个字，边界对齐方式可以确保每次都能读取到完整数据</p><p>而边界不对齐方式是用时间换空间的方式，可以需要进行两次访存才能读取到完整数据</p><hr><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><h3 id="浮点数的表示"><a href="#浮点数的表示" class="headerlink" title="浮点数的表示"></a>浮点数的表示</h3><p>定点数可以表示的数字范围是有限的，所以需要<strong>浮点数</strong>  </p><p>浮点数由<strong>阶码</strong>和<strong>尾数</strong>构成，阶码反映数值大小，尾数反映精度</p><p>利用十进制的科学计数法举例，$+123456789=1.234×10^8$，可以记作+8 +1.234 前面的+8就是阶码，+1.234是尾数，而10是底</p><p><img src="https://s2.loli.net/2022/03/09/gdVZYXurwGMNU6m.png" alt="image-20220309200920548"></p><p>而在二进制中，阶码是常用补码或移码表示的<strong>定点整数</strong>，尾数是常用原码或补码表示的<strong>定点小数</strong></p><p>浮点数的真值：</p><p>​                                           $N=r^E×M$</p><p>式中的 r 表示阶码的底，通常是2 ，E表示阶码，M表示尾数</p><p>比如 0,10；0.01001    分号前表示的是阶码，分号后表示的是尾数，假设阶码，尾数都用补码表示</p><p>0,10  逗号前是阶码的符号位，阶码是正数，表示2</p><p>0.01001 小数点前是尾数的符号位，尾数是正数，表示$(2^{-2}+2^{-5})$</p><p>所以b=$2^2×(0.01001)$，左移两位，结果是+1.001</p><p>假设存储空间只有1B，那么存储时就会丢失精度</p><p><img src="https://s2.loli.net/2022/03/09/tSf3hHQViApNF5C.png" alt="image-20220309203941877"></p><hr><h3 id="浮点数的规格化"><a href="#浮点数的规格化" class="headerlink" title="浮点数的规格化"></a>浮点数的规格化</h3><p>在科学记数法中，规定用 $1≤|a|&lt;10$ 的数来乘10的幂，在浮点数的表示中，自然也对尾数的形式有要求，称为浮点数的规格化</p><p>所以上节的问题，可以将$2^2×(0.01001)$规格化为$2^1×(0.1001)$</p><p><img src="https://s2.loli.net/2022/03/09/B9fWbCMZnKtliHp.png" alt="image-20220309211202071"></p><p>左规：当浮点数运算的结果为非规格化时要进行规格化处理，将尾数算数左移移位，阶码减一</p><p>右规：当浮点数运算的结果尾数出现溢出（双符号位为01或10）时，将尾数右移一位，阶码加1</p><p>比如a=010；00.1100   b=010；00.1000</p><p>a+b的结果是$2^2×(00.1100+00.1000)=2^2×01.0100$，此时发生了溢出，可以右规，算数右移后，$2^3×00.1010$</p><hr><p>不过以上的例子都是正数，如果是尾数是负数的话，就要考虑到使用原码还是补码进行规格化</p><p>对于原码来说，其尾数的小数点后最高位必须是1，对于补码来说，尾数的小数点后最高位必须是0</p><hr><h3 id="IEEE754"><a href="#IEEE754" class="headerlink" title="IEEE754"></a>IEEE754</h3><p>对于浮点数的表示，国际上有个统一的标准，称为IEEE754</p><p>IEEE754使用移码来表示阶码，移码=真值+偏置值</p><p>在IEEE中，偏置值为127D，即0111 1111B，是$2^{n-1}-1$</p><p>真值为-128，-128加上127，即是顺时针偏移127，结果是补码-1，1000 0001，原码表示是 1111 1111</p><p>真值为-127 -127+127=0000 0000</p><hr><p>IEEE754中规定了浮点数的表示形式</p><p><img src="https://s2.loli.net/2022/03/10/bdo8R5MK3nhjwQG.png" alt="image-20220310205028832"></p><p><img src="https://s2.loli.net/2022/03/10/OE12DAC5b4dFpQw.png" alt="image-20220310205221185"></p><p>最高位是数符，表示的是整个浮点数的正负</p><p>尾数用原码表示，默认了原码的最高位是1，所以有23位</p><p>阶码为-128，-127时有特殊用途，只能取到-126~127之间</p><p>规格化的短浮点数的真值是：$(-1)^s×1.M×2^{E-127}$</p><hr><p>对于单精度浮点数来说，当尾数全为0，阶码真值最小为-126，移码为1，此时的<strong>最小绝对值为$(1.0)_2×2^{-126}$</strong></p><p>最大绝对值是，当尾数全为1，阶码真值最大为254,，移码为127，此时的<strong>最大绝对值为$(1.11..11)_2×2^{127}$</strong></p><hr><p>如果表示值比最小的绝对值还要小，就要使用特殊方法</p><p>当阶码全为0，即真值为-127，但尾数M不全为0时，规定阶码为-126，表示非规格化小数 $±(0.xxx)_2×2^{-126}$</p><p>当阶码和尾数都是0，那就是表示0</p><p>当阶码全为1，尾数全为0时，表示无穷大 $∞$</p><p>当阶码全为1，尾数不全为0时，表示非数值，即非法运算</p><hr><h3 id="浮点数的运算"><a href="#浮点数的运算" class="headerlink" title="浮点数的运算"></a>浮点数的运算</h3><p>运算步骤</p><ol><li>对阶，两个浮点数的阶不同时，让小阶向大阶对齐</li><li>尾数加减</li><li>规格化，保证尾数的最高位是有效位</li><li>舍入，舍入有很多规则，当要丢弃掉一些位时，可以四舍五入，或者全部丢弃</li><li>判断溢出 只有当阶码超过了两位情况下，才算发生了溢出，尾数溢出可以通过规格化来调整</li></ol><hr><h3 id="浮点数的类型转换"><a href="#浮点数的类型转换" class="headerlink" title="浮点数的类型转换"></a>浮点数的类型转换</h3><p>精度从小到大不会发生溢出  char→int→long→double   float→double</p><p>int和float同是32位，当时int表示整数，而float采用IEEE754标准表示整数及其小数，float能表示数的范围比int大得多</p><p>所以int→float：可能会损失精度，而float→int：既有可能发生溢出，也有可能损失精度</p><hr><h2 id="电路的基本原理"><a href="#电路的基本原理" class="headerlink" title="电路的基本原理"></a>电路的基本原理</h2><p>略</p>]]></content>
      
      
      <categories>
          
          <category> 组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.计算机概述</title>
      <link href="/post/6876.html"/>
      <url>/post/6876.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机概述"><a href="#计算机概述" class="headerlink" title="计算机概述"></a>计算机概述</h1><hr><h2 id="计算机硬件的基本组成"><a href="#计算机硬件的基本组成" class="headerlink" title="计算机硬件的基本组成"></a>计算机硬件的基本组成</h2><h3 id="早期的冯洛伊曼结构"><a href="#早期的冯洛伊曼结构" class="headerlink" title="早期的冯洛伊曼结构"></a><strong>早期的冯洛伊曼结构</strong></h3><p>冯洛伊曼提出了<strong>存储程序</strong>的思想，即在进行操作计算机计算的时候将指令二进制代码的形式提前直接输入到计算机的主储存器中，而计算机会按照存储的指令逐条执行</p><p><img src="https://s2.loli.net/2022/02/26/wilU1R9E2BYjmey.png" alt="image-20220226165739283"></p><p>在计算机系统中的软件和硬件在逻辑上是等效的</p><p>冯洛伊曼计算机的特点有：</p><ul><li>计算机由五大部件组成</li><li>指令和数据以同等地位存储在存储器中，可以按地址寻访</li><li>指令和数据用二进制表示</li><li>指令由操作码(具体运算类型)和地址码组成</li><li>存储程序（提前存储在存储器）</li><li>以<strong>运算器</strong>为中心</li></ul><hr><h3 id="现代计算机结构"><a href="#现代计算机结构" class="headerlink" title="现代计算机结构"></a><strong>现代计算机结构</strong></h3><p><img src="https://s2.loli.net/2022/02/26/WbSRpT1r3zAnB5o.png" alt="image-20220226170159297"></p><p>现代以存储器为中心，运算器和控制器直接和存储器连接，现代将运算器和控制器集合在一起，形成了<strong>CPU</strong></p><p><img src="https://s2.loli.net/2022/02/26/ed9WEmksOIl38ac.png" alt="image-20220226170515990"></p><hr><h2 id="硬件部件"><a href="#硬件部件" class="headerlink" title="硬件部件"></a>硬件部件</h2><h3 id="主存储器的基本组成"><a href="#主存储器的基本组成" class="headerlink" title="主存储器的基本组成"></a>主存储器的基本组成</h3><p><img src="https://s2.loli.net/2022/02/26/SytgaUJL9A1G4lB.png" alt="image-20220226171557536"></p><p>MAR（Memory Address Register）：存储地址寄存器</p><p>MDR   (Memory Data Register)：存储数据寄存器</p><p>MAR存放的是地址，存储体通过MAR的内容寻找需要的信息</p><p>MDR存放的是数据，存储体通过MAR找到数据后，将数据放到MDR中</p><hr><p><img src="https://s2.loli.net/2022/02/26/dlwLAOIP6hMgR1c.png" alt="image-20220226172036544"></p><p>数据在存储体中按地址进行存储</p><p><strong>存储字</strong>：存储单元中二进制代码的组合</p><p><strong>存储子长</strong>：存储单元中二进制的位数</p><p>MAR的位数可以反映存储单元的总个数，而MDR的位数可以反映存储子长</p><p><strong>MAR的位数×MDR的位数=存储器的总容量</strong></p><hr><h3 id="运算器的基本组成"><a href="#运算器的基本组成" class="headerlink" title="运算器的基本组成"></a>运算器的基本组成</h3><p><img src="https://s2.loli.net/2022/02/26/HAGpLb24DlzZUqh.png" alt="image-20220226172430521"></p><p>运算器用于实现算术运算和逻辑运算</p><p>由ACC  MQ  ALU  X组成，核心是ALU</p><p>ACC：累加器，用于存放操作数，或运算结果</p><p>MQ（Multiple-Quotient Register）：乘商寄存器，在乘除运算的时候，用于存放操作数或运算结果</p><p>ALU（Arithmetric and Logic Unit）：算术逻辑单元，通过内部复杂的电路实现算术运算，逻辑运算</p><p>X：通用的操作数寄存器，用于存放操作数</p><hr><h3 id="控制器的基本组成"><a href="#控制器的基本组成" class="headerlink" title="控制器的基本组成"></a>控制器的基本组成</h3><p><img src="https://s2.loli.net/2022/02/26/Rc4gHrSTFBaJYfz.png" alt="image-20220226184759208"></p><p>CU：控制单元，分析指令，给出控制信号</p><p>IR（Instruction Register）：指令寄存器，存放当前执行的指令</p><p>PC：程序计数器，存放下一条<strong>指令地址</strong>，有自动加一功能</p><p>完成一条指令需要先取指令，分析指令，再执行指令</p><hr><h3 id="计算机的工作过程"><a href="#计算机的工作过程" class="headerlink" title="计算机的工作过程"></a>计算机的工作过程</h3><p><img src="https://s2.loli.net/2022/03/04/4gDroFiAhXZtWSp.png" alt="image-20220304195213228"></p><p>从存储体中取一个数的过程：</p><ol><li>PC →MAR  将下一条指令在存储体中的地址传输到MAR中</li><li>MAR→存储体</li><li>MAR→MDR 存储体根据MAR中的地址找到该指令，并将该指令内容传到MDR中去</li><li>MDR→IR  IR存放当前指令</li><li>IR→CU  指令的操作码送到了CU中，分析当前指令的内容，得出这是取数指令</li><li>IR→MAR  指令的地址码送到MAR</li><li>MAR→存储体</li><li>MAR→MDR  MAR根据地址码，取出数放到MDR中</li><li>MDR→ACC  ACC存储了数</li></ol><p>主要是存储体会工作两次，第一次根据PC给出地址码，第二次根据地址码给出数</p><hr><p><img src="https://s2.loli.net/2022/03/04/VhXc84SiBYbs1Dz.png" alt="image-20220304202001740"></p><p>从存储体中存储一个数的过程：</p><ol><li>PC →MAR </li><li>MAR→存储体</li><li>MAR →MDR 存储体根据MAR的值，将指令放在MDR中</li><li>MDR →IR     将MDR的值放入IR中</li><li>IR →CU         将指令的操作码放入CU中，CU分析出这是存数指令</li><li>IR →MAR       指令的地址码放入MAR中</li><li>ACC →MDR    导致MDR等于操作数</li><li>MAR→存储体</li><li>MDR →存储体    MDR中的操作数会被存入到存储体中，地址为MAR中的地址</li></ol><p>对比存数和取数的操作，可以看出在1~4步取指令以及第5步分析指令阶段，执行的操作是一样的，区别只是在分析指令指令后的操作不同</p><p>CPU通过<strong>指令周期</strong>的不同阶段来区分指令和数据</p><hr><h2 id="计算机的层次结构"><a href="#计算机的层次结构" class="headerlink" title="计算机的层次结构"></a>计算机的层次结构</h2><p><img src="https://s2.loli.net/2022/03/04/uefaUcPrqO2JQ16.png" alt="image-20220304203734219"></p><p>实际上，有三种级别的语言，上图中只是比较传统的一种语言</p><ol><li>类似C，C++等语言，会先通过编译程序翻译成汇编语言，再由汇编语言翻译成机器语言</li><li>也可以直接用编译程序将高级语言翻译成机器语言</li><li>类似JAVAScript等语言，需要解释器，将源程序的一条语句翻译成机器语言后，立即执行，才会接着翻译下一句</li></ol><hr><h2 id="计算机性能指标"><a href="#计算机性能指标" class="headerlink" title="计算机性能指标"></a>计算机性能指标</h2><p><strong>存储器的性能指标</strong></p><p><strong>容量</strong>=存储单元个数×存储子长/8  =Byte</p><hr><p><strong>CPU的性能指标</strong></p><p>主频：CPU内数字脉冲信号振荡的频率，和时钟周期互为倒数，单位Hz，反映每秒有多少个时钟周期</p><p>CPI(Clock cycle Per Instruction)：执行一条指令所需的时钟周期数</p><p>执行一条指令的耗时为：CPI×CPU时钟周期</p><p>IPS（Instruction Per Second）：每秒执行多少条指令   =主频/平均CPI</p><p>FLOPS：每秒执行的浮点运算次数</p><p>（K=$10^3$，M=$10^6$，G=$10^9$，T=$10^{12}$）</p><hr><p>系统整体的指标</p><p>数据通路带宽：数据总线一次能并行的位数</p><p>吞吐量：系统在单位时间内处理请求的数量</p><p>响应时间：从用户向计算机发送一个请求，到系统对该请求做出响应并获得它所需要的结果的等待时间</p><hr>]]></content>
      
      
      <categories>
          
          <category> 组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>372.超级次方</title>
      <link href="/post/19997.html"/>
      <url>/post/19997.html</url>
      
        <content type="html"><![CDATA[<h1 id="372-超级次方"><a href="#372-超级次方" class="headerlink" title="372.超级次方"></a>372.超级次方</h1><p>你的任务是计算 a^b^<code>对</code>1337<code>取模，</code>a<code>是一个正整数，</code>b` 是一个非常大的正整数且会以数组形式给出。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：a = <span class="number">2</span>, b = [<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">8</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：a = <span class="number">1</span>, b = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>首先需要知道模运算满足交换律，再配合<code>50.Pow(x,n)</code>里面的快速降幂</p><p>   (<em>a</em>⋅<em>b</em>)mod<em>m</em>=[(<em>a</em>·mod<em>m</em>)⋅(<em>b</em>·mod<em>m</em>)]·mod<em>m</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOD = <span class="number">1337</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superPow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = b.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            ans = (<span class="keyword">int</span>) ((<span class="keyword">long</span>) ans * pow(a, b[i]) % MOD);</span><br><span class="line">            a = pow(a, <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                res = (<span class="keyword">int</span>) ((<span class="keyword">long</span>) res * x % MOD);</span><br><span class="line">            &#125;</span><br><span class="line">            x = (<span class="keyword">int</span>) ((<span class="keyword">long</span>) x * x % MOD);</span><br><span class="line">            n /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>50.Pow(x,n)</title>
      <link href="/post/65279.html"/>
      <url>/post/65279.html</url>
      
        <content type="html"><![CDATA[<h1 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50.Pow(x,n)"></a>50.Pow(x,n)</h1><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数，即，x^n^ </p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = <span class="number">2.00000</span>, n = <span class="number">10</span></span><br><span class="line">输出： <span class="number">1024.00000</span></span><br></pre></td></tr></table></figure><p><strong>Solution</strong>：递归</p><p>​                                                  x^77^=<em>x</em>→<em>x</em>^2^→<em>x</em>^4^→<em>x</em>^9^→<em>x</em>^19^→<em>x</em>^38^→<em>x</em>^77^</p><p>如果要计算一个数的N次幂，可以将其N/2，结果需要向下取整，如果N为奇数，就需要再乘一个x</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? quickMul(x, N) : <span class="number">1.0</span> / quickMul(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> y = quickMul(x, N / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> N % <span class="number">2</span> == <span class="number">0</span> ? y * y : y * y * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Solution1</strong>：迭代</p><p>由于递归需要使用额外的栈空间，我们试着将递归转写为迭代。在方法一中，我们也提到过，从左到右进行推导是不容易的，因为我们不知道是否需要额外乘 <em>x</em>。但我们不妨找一找规律，看看哪些地方额外乘了 <em>x</em>，并且它们对答案产生了什么影响。</p><p>​                                  x^77^=<em>x</em>→<em>x</em>^2^→<em>x</em>^4^→<em>x</em>^9^→<em>x</em>^19^→<em>x</em>^38^→<em>x</em>^77^</p><p>77的二进制表示是      77=1   0     0     1     1      0      1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> <span class="keyword">long</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1.0</span>;</span><br><span class="line">        <span class="comment">// 贡献的初始值为 x</span></span><br><span class="line">        <span class="keyword">double</span> x_contribute = x;</span><br><span class="line">        <span class="comment">// 在对 N 进行二进制拆分的同时计算答案</span></span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果 N 二进制表示的最低位为 1，那么需要计入贡献</span></span><br><span class="line">                ans *= x_contribute;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将贡献不断地平方</span></span><br><span class="line">            x_contribute *= x_contribute;</span><br><span class="line">            <span class="comment">// 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可</span></span><br><span class="line">            N /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? quickMul(x, N) : <span class="number">1.0</span> / quickMul(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.整数反转</title>
      <link href="/post/32892.html"/>
      <url>/post/32892.html</url>
      
        <content type="html"><![CDATA[<h1 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7.整数反转"></a>7.整数反转</h1><p>给你一个 32 位的有符号整数 <code>x</code> ，返回将 <code>x</code> 中的数字部分反转后的结果。</p><p>如果反转后整数超过 32 位的有符号整数的范围 <code>[−231, 231 − 1]</code> ，就返回 0。</p><p><strong>假设环境不允许存储 64 位整数（有符号或无符号）。</strong></p><p><strong>示例 1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = <span class="number">123</span></span><br><span class="line">输出：<span class="number">321</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rev &lt; Integer.MIN_VALUE / <span class="number">10</span> || rev &gt; Integer.MAX_VALUE / <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> digit = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            rev = rev * <span class="number">10</span> + digit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络重点题</title>
      <link href="/post/13956.html"/>
      <url>/post/13956.html</url>
      
        <content type="html"><![CDATA[<h1 id="408计算机网络"><a href="#408计算机网络" class="headerlink" title="408计算机网络"></a><strong>408计算机网络</strong></h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h2><p><img src="https://s2.loli.net/2021/12/29/Q6tAsoK3r1kn7Ly.png" alt="image-20210518114846042" style="zoom:67%;" /></p><p>解析：这个是基本概念问题，从下而上，第一个提供的是传输层</p><hr><p><img src="https://s2.loli.net/2021/12/29/FBRMkwIDnuaTKdG.png" alt="image-20210518145934778" style="zoom:67%;" /></p><p>解析：网络体系结构并没有描述协议的内部实现细节，所以选D</p><hr><p><img src="https://s2.loli.net/2021/12/29/sRiGIDf3Ynw2Mct.png" alt="image-20210518230116890" style="zoom:67%;" /></p><p>解析：在OSI参考模型中，应用层的相邻层是表示层，负责解决双方交换信息的表示问题，所以选B</p><hr><p><img src="https://s2.loli.net/2021/12/29/FaEqoigQLG4tHPu.png" alt="image-20210520145739421" style="zoom:67%;" /></p><p>解析：按照OSI参考模型的结构，直接为会话层提供服务的是会话层的下一层，传输层</p><hr><p><img src="https://s2.loli.net/2021/12/29/5iKbacjIhH1gwrp.png" alt="image-20210522011224206" style="zoom:67%;" /></p><p>解析：注意是OSI参考模型，一共有7层，除了物理层和应用层之外，其余还有5层，则一共的额外开销是100B，那么传输效率为400/500=80%</p><hr><p><img src="https://s2.loli.net/2021/12/29/XfSybj3FA5MCBLI.png" alt="image-20210522193943123"></p><p>解析：OSI参考模型的自下而上的第5层是会话层，作用是会话管理</p><hr><p><img src="https://s2.loli.net/2021/12/29/aiDQEsY5jrWKRc2.png" alt="image-20210522203306340" style="zoom:50%;" /></p><p>解析：语法：定义收发双方所交换信息的格式    语义：定义收发双方所有完成的操作   同步：定义收发双方的时序关系</p><hr><p><img src="https://s2.loli.net/2021/12/29/DFlSA7LuXgbdR2N.png" alt="image-20210520201927463" style="zoom:67%;" /></p><p>解析：R1是路由器，在网络层工作，属于第3层，Switch是交换机，在数据链路层工作，属于第二层，Hub是集线器，在物理层工作，属于第一层，所以选C</p><hr><p><img src="https://s2.loli.net/2021/12/29/FCkjmAUuN6gyQlS.png" alt="image-20210520202137801" style="zoom: 80%;" /></p><p><img src="https://s2.loli.net/2021/12/29/l9wf8ZoCHDVyEMF.png" alt="image-20210520202251041" style="zoom: 80%;" /></p><p>解析：明显考察的是香农公式的相关知识<img src="https://s2.loli.net/2021/12/29/he9GHM6JAI4iOfC.png" alt="image-20210520202446659"></p><p>理论最大传输速率约为80kbps，那么实际速率是40kbps</p><hr><p><img src="https://s2.loli.net/2021/12/29/VzIfN3vqrPMl2Fp.png" alt="image-20210520203224961" style="zoom:67%;" /></p><p>解析：本题考察交换机和集线器的区别，交换机会点对点的传播信息，而集线器只会将数据广播出去，所以能收到该数据帧的有H3和H2</p><hr><p><img src="https://s2.loli.net/2021/12/29/zK2EelsTYXgGh8N.png" alt="image-20210520203512911" style="zoom:67%;" /></p><p>解析：H3和H4之间是100Base-T以太网总线，传输速率是100Mbps，以太网规定争用期为512比特时间，所以本题中的以太网争用时间为$ 512/100Mb/s=5.12\mu s$，争用期包含信号端到端的传播时延和HUB双向再生比特流的时间，</p><p>该以太网端到端的单程信号传播时延为  $5.12\mu s/2-1.535\mu s=1.025\mu s$</p><p>因此H3到H4的最远距离为：200×1.025=205m</p><hr><p><img src="https://s2.loli.net/2021/12/29/mZCAIQEdpoPxkf3.png" alt="image-20210520205353069" style="zoom:67%;" /></p><p>解析：R3向R2通告的内容是，R3无法到达该网络，但R3并没有向R1更新信息，而R2收到R1更新后，会认为到达目的网络，可以从R1到R3再到目的网络，距离为3</p><hr><p><img src="https://s2.loli.net/2021/12/29/8bo5icTN7svgdUl.png" alt="image-20210520205628428" style="zoom:67%;" /></p><p><img src="https://s2.loli.net/2021/12/29/qT23a9S7ZmMe4Co.png" alt="image-20210520210319191" style="zoom:67%;" /></p><p>解析：因为点对点链路使用的是201.1.3.x/30地址，则可分配地址只有两个，分别是202.1.3.9和202.1.3.10，所以R2的L0接口地址为202.1.3.10，目的IP地址就是WEB服务器地址为130.18.10.1，所以答案选D</p><hr><p><img src="https://s2.loli.net/2021/12/29/8VpTZaW7loDGFM2.png" alt="image-20210520210529318" style="zoom:67%;" /></p><p>​                         <img src="https://s2.loli.net/2021/12/29/LRC9tyw5NVFpsGS.png" alt="image-20210520210548519" style="zoom:67%;" /></p><p>解析：可以知道H1和H2是在同一个网络的，H3和H4在同一个网络，所以A D都不可能发生，H2和H4的默认网关是192.168.3.254，是R2的网络路由器，所以可以访问到互联网，H1和H3的默认网关在图上没有显示，所以不能正常进行IP通信</p><hr><p><img src="https://s2.loli.net/2021/12/29/CgIEWomcPS4bkzd.png" alt="image-20210521121256546" style="zoom:67%;" /></p><p><img src="https://s2.loli.net/2021/12/29/yF2IsB81iWEopfc.png" alt="image-20210521121326368" style="zoom:67%;" /></p><p>解析：如果在本地域名服务器中就有缓存，就不需要发送DNS查询，最少为0次，如果没有缓存，使用迭代方式查询，先向根域名服务器查询，然后就向顶级域名服务器查询.com，然后向权限域名服务器查询xyz.com，然后向权限域名服务器查询abc.xyz.com，最多查询4次</p><hr><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a><strong>物理层</strong></h2><p><img src="https://s2.loli.net/2021/12/29/uxgGq3oHfLsRh4K.png" alt="image-20210518115012608" style="zoom:67%;" /></p><p>解析：这个主要考察的知识点是奈氏准则和调制的相关知识点，首先采用4个相位，每个相位有4种振幅，则一共有16种波形，那么可以调制的比特数量为$log_216=4$，再利用奈斯准则，传输速率为 $2<em>3</em>4=24kbps$,所以选B</p><hr><p><img src="https://s2.loli.net/2021/12/29/Un5DQBafEO3iI6o.png" alt="image-20210518155951861"></p><p>解析：采用4相位调制，那么码元数为$log_24=2$，波特率×码元数=比特率，波特率=2400/2=1200波特，选B</p><hr><p><img src="https://s2.loli.net/2021/12/29/IYEJtpyK9QZX8bF.png" alt="image-20210518193433805"></p><p>解析：</p><p>机械特性：指明接口所用接线器的形状和尺寸      </p><p>电气特性：指明在接口电缆的各条线上出现的电压的范围</p><p>功能特性：指明某条线上出现的某一电平表示各种意义</p><p>过程特性：指明对于不同功能的各种可能事件的出现顺序</p><hr><p><img src="https://s2.loli.net/2021/12/29/InJdVB6Q2LXmjvC.png" alt="image-20210518235712448"></p><p>解析： 10 BaseT网卡使用的是曼彻斯特编码，以中间时刻的跳变来表示数据，如果正跳变表示1，则该波形的数据是11001001，如正跳变表示0，则该波形的数据是0011 0110，所以此题选B</p><hr><p><img src="https://s2.loli.net/2021/12/29/IESUwqQn1oPy2he.png" alt="image-20210520150153454"></p><p>解析：根据香农公式和奈氏准则，A，B，C都会影响传输速率，所以选D</p><hr><p><img src="https://s2.loli.net/2021/12/29/kFcKVGZy4WMeYgt.png" alt="image-20210520172742345" style="zoom:67%;" /></p><p>解析：很明显，编码1是不归零编码，编码2是曼彻斯特编码</p><hr><p><img src="https://s2.loli.net/2021/12/29/4OsZSdLYDjt6peV.png" alt="image-20210522011449198"></p><p>解析：根据奈氏准则，在无噪声情况下的极限数据传输速率为：2W·Baud</p><p>​           根据香农定律，极限数据传输速率$W·log_2(S/N+1)=W·log_21001=9.8W$</p><p>​           2W·Baud&gt;9.8W,那么Baud&gt;4.9,则$log_2X&gt;4.9$，X至少是32</p><hr><p><img src="https://s2.loli.net/2021/12/29/XAUZwTVCWbisPeI.png" alt="image-20210522183111952"></p><p>解析：物理地址就是MAC地址，位于数据链路层，所以选C</p><hr><p><img src="https://s2.loli.net/2021/12/29/QEx638iVYmI5cKb.png" alt="image-20210522194144701"></p><p>解析：100BaseT中的T指的是Twisted pair (双绞线)</p><hr><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a><strong>数据链路层</strong></h2><p><img src="https://s2.loli.net/2021/12/29/QXeprG7DnqgYEZm.png" alt="image-20210518115342948" style="zoom:67%;" /></p><p>解析：考察的是回退N帧协议，协议特点是采用了累计确认的机制，如果收到了N帧的确认，那么N帧以及N帧之前的数据都可以确认接受了，即使N帧之前有些帧没有收到，那也可以确认收到</p><p>此题中，收到了0.2.3帧的确认，那么可以默认其收到了3帧以及3帧之前的确认，所以要重发的帧是4.5.6.7共4个帧</p><hr><p><img src="https://s2.loli.net/2021/12/29/C2xeh7nXvZdIH9Q.png" alt="image-20210518115751909" style="zoom:67%;" /></p><p>解析：以太网交换机工作在计算机网络的数据链路层，PDU(协议数据单元)对于数据链路层来说，就是帧，以太网交换机进行转发时，目的地址是目的物理地址，也称为MAC地址，所以选A</p><hr><p><img src="https://s2.loli.net/2021/12/29/DTscBdVoEyXR6PY.png" alt="image-20210518120126170" style="zoom:67%;" /></p><p>解析：此题考察CSMA/CD协议的相关概念，需要了解的是争用期，最小帧长等概念</p><p>争用期=信号在数据信道中往返的时间，最小帧长=争用期×传输速率</p><p>在此题中，假设减少的距离是X，$\frac{x}{2<em>10^8}</em>2*10^9=800$,x=80,所以是80m，选D</p><hr><p><img src="https://s2.loli.net/2021/12/29/vP5bxcQoUgN98Ft.png" alt="image-20210518150127586" style="zoom:67%;" /></p><p>解析：H1到H2的路径，至少包含两个路由器，也就是要经过两次转发</p><p><img src="https://s2.loli.net/2021/12/29/mKfaV2wo9tYBDxQ.png" alt="image-20210518150242675" style="zoom: 67%;" /></p><p>题目要求忽略传播时延，最终花费的时间为所有分组的发送时延+1个分组的发送时延×2</p><p>需要的时间=$(980<em>8)/(1</em>10^8)×980000/980+(1000<em>8)/(1</em>10^8)*2$=80.16ms</p><hr><p><img src="https://s2.loli.net/2021/12/29/bNWnaSv3iFdzRjx.png" alt="image-20210518151623430" style="zoom:67%;" /></p><p>解析：集线器可以扩展网络的广播域和碰撞域，网桥可以扩展网络的广播域，只有路由器可以隔绝网络风暴，所以选D</p><hr><p><img src="https://s2.loli.net/2021/12/29/JneOcN2ojqfv1lm.png" alt="image-20210518160154849" style="zoom:67%;" /></p><p>解析：采用选择重传协议，SR协议没有采用累计确认机制，所以超时的帧都会被重传，重传的帧数为0   2，选B</p><hr><p><img src="https://s2.loli.net/2021/12/29/sHdmgJwQyRcVO1K.png" alt="image-20210518161936781"></p><p>解析：只有CSMA/CA协议会对正确收到的数据帧进行确认，因为CSMA/CA是无线网采用的协议，误码率高，所以采用确认机制</p><hr><p><img src="https://s2.loli.net/2021/12/29/y98ZN2AmYL54DSH.png" alt="image-20210518194406240" style="zoom:67%;" /></p><p>解析：很明显,以太网的MAC协议就是CSMA/CD协议，而无线网的MAC协议是CSMA/CA,所以CSMA/CD提供的是无连接的不可靠服务，选A</p><hr><p><img src="https://s2.loli.net/2021/12/29/uW4zlRMAQrE76T1.png" alt="image-20210518200126699" style="zoom:67%;" /></p><p>解析：根据回退N帧协议的特点，从发送第一个数据帧开始，在未收到确认帧的情况下，可以一直连续不断的发送数据帧，为了信道利用率最高，所以应该是在发送数据帧到收到数据帧的总时间内，发送窗口的值至少应该比可以发送的帧的数目要大</p><p>假如数据帧的长度是128字节，发送一帧的时间是(128*8)/16000=64ms，发送一帧到收到确认为止的总时间为64+270×2+64=668ms，这段时间内，可以发送帧的数量为668/64=10.4375，所以至少要发送窗口至少大于11，$2^x&gt;11$，x至少应该是4</p><p>之所以选择128字节，因为如果选择更大的字节数，那么可以发送的帧的数量会变小，题目问的是要让信道利用率达到最高，所以比特数至少是4，</p><hr><p><img src="https://s2.loli.net/2021/12/29/f4LJRxDakMpPcGy.png" alt="image-20210518202619556" style="zoom:67%;" /></p><p>解析：基本概念，选A</p><hr><p><img src="https://s2.loli.net/2021/12/29/2tPoH1kwJlLizOc.png" alt="image-20210519150629063"></p><p>解析：主要考察报文交换和分组交换</p><p>采用报文交换，一次性发送8MB数据，忽略传播时延，那么需要的时间为发送时延×2=1600ms</p><p><img src="https://s2.loli.net/2021/12/29/Sc2EW6sxIXpNBmR.png" alt="image-20210520142459426" style="zoom: 50%;" /></p><p>采用分组交换，一次发送10KB大小的分组，忽略传播时延，那么需要的时间为所有分组的发送时延+最后一个分组的路由器发送时延=800+1ms=801ms</p><p><img src="https://s2.loli.net/2021/12/29/DgXsdJopSZRhe87.png" alt="image-20210520142537260" style="zoom:50%;" /></p><hr><p><img src="https://s2.loli.net/2021/12/29/va5sWtVr2cI7eu6.png" alt="image-20210520142606259"></p><p>解析：CDMA TDMA FDMA 都是静态划分信道的方法，不会产生冲突，CSMA是动态接入控制中的随机接入，会发生冲突，所以选B</p><hr><p><img src="https://s2.loli.net/2021/12/29/OFns42fwdPKla9g.png" alt="image-20210520142843498"></p><p>解析：考查数据链路层中的可靠传输，对于比特流，数据链路层采用的是每5个1之间插入1个0的方法来实现可靠传输，所以选A</p><hr><p><img src="https://s2.loli.net/2021/12/29/AFGH9URbpvnSWzk.png" alt="image-20210520143031298"></p><p>解析：以太网交换机有两种方式，一种是存储转发，一种是直通转发</p><p>直通转发就是在读取以太网帧的目的MAC后直接转发数据，目的MAC地址为6B，所以接受完目的MAC地址所耗费的时间=$(6×8)/(100×10^6)=0.48\mu s$,所以选B</p><hr><p><img src="https://s2.loli.net/2021/12/29/J2BNTeiCdhbkXDu.png" alt="image-20210520145924491"></p><p>解析：考察交换机自学习的过程</p><p>a向c发送信息，由于路由表中没有c的信息，所以会进行洪泛转发，转发端口为{2,3},并记录下a和端口1之间的关系</p><p>c向a发送信息，由于路由表中已经记录有a的消息，所以会进行单播转发，转发端口为{1}</p><p>所以选B</p><hr><p><img src="https://s2.loli.net/2021/12/29/EIBKstRvyuDnU71.png" alt="image-20210520150305095"></p><p>解析：甲乙之间的单向传播时延是50ms，则来回的总时间是100ms，在这个时间段内，主机甲发送一个分组所用的时间是 $(1000×8)/(100×10^6)=0.08ms$，0.08×1000=80ms&lt;100ms,所以主机甲在100ms内可以发送1000个分组，数据传输速率=数据传输量/数据传输时间，</p><p>$(1000<em>8</em>1000)/0.1=80Mbps$</p><hr><p><img src="https://s2.loli.net/2021/12/29/dfyontNiqYxBrzE.png" alt="image-20210520153036349"></p><p>解析：考察的是CDMA码分多址，将C的序列分为4个一组，与A的码片分组做内积，可以得到1，-1，1，说明发送的信息是101</p><hr><p><img src="https://s2.loli.net/2021/12/29/YcnJI3ysG91OtTK.png" alt="image-20210520173146460"></p><p>解析：<img src="https://s2.loli.net/2021/12/29/NMWkqV7TB42idZm.png" alt="image-20210520174502038"></p><p>为了使链路利用率不小于80%，总时间的(a+b+c)的80%都应处于连续发送数据帧的过程</p><p>总时间的80%=$((1000×8)/(128×10^3)+250ms+250ms)× 0.8 =450ms$</p><p>在450ms内发送的比特数量为57600b=7200B=7.2个数据帧</p><p>后退N帧协议的发送窗口尺寸$W_t≤2^n-1$</p><p>选择重传协议的发送窗口尺寸$W_t≤2^{n-1}$，所以帧的比特数量最少是4</p><hr><p><img src="https://s2.loli.net/2021/12/29/WoDRd2TQLsftaJ9.png" alt="image-20210520192957448" style="zoom: 80%;" /></p><p>解析：CSMA/CD是以太网的传输协议，并不使用于无线网络，所以选B</p><hr><p><img src="https://s2.loli.net/2021/12/29/DUBLTy1HeEYvscz.png" alt="image-20210520193120575"></p><p>解析：以太网本质上是一种多端口网桥，可以扩大网络的广播域，并不增加网络的冲突域，所以B，C错误，以太网交换机是工作数据链路层的协议，并不知道上层网络层协议，所以不能实现网络层协议，D也错误，答案是A</p><hr><p><img src="https://s2.loli.net/2021/12/29/4QtONyx7JzUGc2L.png" alt="image-20210522012112072"></p><p>解析：IEEE 802.11的数据帧有3个地址，格式如下</p><p><img src="https://s2.loli.net/2021/12/29/1j9hS8B6rqFTJgs.png" alt="image-20210521202246159"></p><p>则在该题中，数据帧是去往AP的，地址1为AP地址，地址2是源地址，地址3是目的地址，选B</p><hr><p><img src="https://s2.loli.net/2021/12/29/R3XPd7i9Naq8ecC.png" alt="image-20210522183219523"></p><p>解析：通过RTS与CTS帧的交换进行信道预约，所以选D</p><hr><p><img src="https://s2.loli.net/2021/12/29/YvyJoHnNqsOSD1a.png" alt="image-20210522183303294"></p><p>解析：假设数据帧的长度为X，信道利用率=发送时延/(发送时延+传输时延)</p><p>$(X/3×10^3)/(X/3×10^3+0.4)=0.4$，X=800</p><hr><p><img src="https://s2.loli.net/2021/12/29/QAf9KFdGYr4kcPe.png" alt="image-20210522183535656"></p><p>解析：数据包在发送过程中，MAC地址会改变，而IP地址不变，所以MAC地址分别是-51和-61</p><hr><p><img src="https://s2.loli.net/2021/12/29/tJQdeVuSWZyCviF.png" alt="image-20210522194434850"></p><p>解析：如果是接收窗口最大的话，那么一定是选择重传协议</p><p>发送窗口$W_T$和接收窗口$W_R$的取值范围 $W_R+W_T≤2^{n}$，所以接收窗口的最大值为3</p><hr><p><img src="https://s2.loli.net/2021/12/29/HB8xejrTJQYLgNt.png" alt="image-20210522195848422"></p><p>解析：最小帧长=争用期×发送速率</p><p>争用期=$128×8/10^5=10.24\mu s$，那么，单向传播时延是$10.24\mu s/2=5.12\mu s$</p><hr><p><img src="https://s2.loli.net/2021/12/29/7uHG8tZnFhg9Y1e.png" alt="image-20210522203637108"></p><p>解析：集线器拓展冲突域和广播域，交换机扩展广播域，隔绝冲突域，路由器隔绝冲突域和广播域，所以选C</p><hr><p><img src="https://s2.loli.net/2021/12/29/HjWRBMSbLrwVzt9.png" alt="image-20210522203811615"></p><p>解析：信道利用率=发送时延/(传输时延+发送时延+确认帧发送时延)</p><p>​          $0.8/(0.8×2+0.2×2)=40$%</p><hr><p><img src="https://s2.loli.net/2021/12/29/zZdpSkqLDjrHAVx.png" alt="image-20210522224753381"></p><p><img src="https://s2.loli.net/2021/12/29/mfcKeD4bsE97RBV.png" alt="image-20210522224801958" style="zoom: 50%;" /></p><p>解析：IFS2,IFS3,IFS4是短帧间间隔SIFS，而IFS1是DIFS，比SIFS长的多</p><hr><p><img src="https://s2.loli.net/2021/12/29/QRmDdH1cXFPVnke.png" alt="image-20210518152433911" style="zoom: 67%;" /></p><p>解析：此题考察了争用期的概念，以及以太网帧的相关知识</p><ol><li>最长时间就是争用期的时间=2/200000*2=$2×10^{-5}s$，而最短的时间则是，数据发送到刚好一半的位置被检测到了碰撞，为争用期的一半，是$10^{-5}s$</li><li>主机的有效数据传输速率=有效数据/总时间，总时间=最长数据帧发送时延+信号的传播时延+主机乙确认帧的发送实验+传输时延</li></ol><p>甲发送时延=$(1518<em>8)/(1</em>10^7)=1.2144ms$  传输时延=$2/200000$=0.01ms，乙发送时延=$(64*8)/(10^7)=0.0512ms$</p><p>总时间为：1.2144+0.01*2+0.0512=1.2856ms</p><p>因为MAC帧的数据帧格式为<img src="https://s2.loli.net/2021/12/29/3A1LXf8wbYznDIT.png" alt="image-20210506120334489" style="zoom:67%;" /></p><p>前导码有18个字节，有效数据传输速率为$(1500<em>8)/(1.2856</em>10^{-3})=9.33Mbps$</p><hr><p><img src="https://s2.loli.net/2021/12/29/PJtGNEh9cFyWZMD.png" alt="image-20210522162158606"></p><ol><li>t0到t1时刻期间，甲方收到了的数据帧是R0,1表示收到了第0帧，R1,3表示收到了第0,1,2帧，R3.3表示收到了第0,1,2帧，所以甲方断定乙方已正确接收的数据帧数是3帧，正确接收的是，S0,0   S1.0   S2.0</li><li>数据帧的发送序号和确认序号字段均为3比特，那么发送窗口大小为$2^3-1=7$，<img src="https://s2.loli.net/2021/12/29/XDZcYeqptHC8NV5.png" alt="image-20210522165228362" style="zoom:67%;" /></li></ol><p>此时最多还可以发送5个数据帧，因为主机甲没有收到主机乙的2号数据帧，所以会一直请求第2号数据帧，其中第一个帧是S5,2最后一个帧是S1,2</p><ol><li><p><img src="https://s2.loli.net/2021/12/29/8IJc1CQw5sr2BP9.png" alt="image-20210522170555815" style="zoom:67%;" /></p><p>此时要重传的数据帧是S2,3 S3,3 S4,3，一共3个</p></li></ol><ol><li><img src="https://s2.loli.net/2021/12/29/1gAUfOvWdxauotm.png" alt="image-20210522171003499" style="zoom:80%;" />甲可以达到的最大信道利用率是：发送数据的时间/从开始发送第0个数据帧到收到第0个确认帧的时间=7个数据帧的发送时间/(2a+2b)</li></ol><p>​       信道利用率为50%</p><hr><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a><strong>网络层</strong></h2><p><img src="https://s2.loli.net/2021/12/29/8WZpbVdz3DUTtYP.png" alt="image-20210518150937614" style="zoom:67%;" /></p><p>解析：在RIP协议中，距离16代表不可达，所以选择D</p><hr><p><img src="https://s2.loli.net/2021/12/29/6ndW1MjovQrtxJi.png" alt="image-20210518151057669" style="zoom:67%;" /></p><p>解析：拥塞丢弃分组是源点抑制</p><hr><p><img src="https://s2.loli.net/2021/12/29/psGOjKfoybqPc2I.png" alt="image-20210518151149727" style="zoom:67%;" /></p><p>解析：考察定长子网的概念</p><p>首先判断该IP地址为C类地址，然后子网掩码为255.255.255.248，换算成2进制，最后的字节        248=11111000，即借用了主机号的前5位作为网络号，所以网络中的最大子网个数为$2^5=32$ ,地址数量为$2^3=8$,每个子网需要一个网络地址和一个广播地址，所以最大可分配地址个数为6，选B</p><hr><p><img src="https://s2.loli.net/2021/12/29/pqP3iJF5lZ1tjR7.png" alt="image-20210518155846660" style="zoom:67%;" /></p><p>解析：基本概念，IP协议提供的是无连接不可靠的数据报服务</p><hr><p><img src="https://s2.loli.net/2021/12/29/jTVvtCPOZRn3dyI.png" alt="image-20210518170139628"></p><p>解析：考察的是路由器的跳转问题</p><p>让R1的IP分组正确地达到所有子网，首先可以确定的是下一跳的地址肯定是R2的接口192.168.1.2，然后将子网聚合，得到聚合地址块 </p><p>将192.168.2.0/25和192.168.2.128/25聚合得到192.168.2.0/24，网络地址为192.168.2.0，子网掩码为255.255.255.0，所以选D</p><hr><p><img src="https://s2.loli.net/2021/12/29/OVqQtmB38veiMPR.png" alt="image-20210518170754509"></p><p>解析：考察划分子网的知识，192.168.4.0是C地址，/30说明将主句号的前6位都用作了网络号，主机号只有两位，而能够作为子网地址的只有192.168.4.2和192.168.4.1</p><p>如果192.168.4.3是单播地址，那么能接收的IP分组最大主机数为1，如果为广播地址，则接收该目的地址的IP分组的最大主机数为该地址块中可分配的地址数，最大为2，选C</p><hr><p><img src="https://s2.loli.net/2021/12/29/d1bQktA3X7gEsy6.png" alt="image-20210518193241992" style="zoom:67%;" /></p><p>解析：ICMP(Internet Control Message Protocol)是网际控制报文协议，由IP数据报封装，所以选B</p><hr><p><img src="https://s2.loli.net/2021/12/29/9scKOIXpQVEouUz.png" alt="image-20210518202502679" style="zoom:50%;" /></p><p>解析：IP路由器确实能对收到的IP分组头进行差错校验，但是并不能保证传输的IP分组不丢失，所以选C</p><hr><p><img src="https://s2.loli.net/2021/12/29/vwPbaTO2mkXzAFy.png" alt="image-20210518202708247" style="zoom: 67%;" /></p><p>解析：该主机的是B类地址，子网掩码是255.255.252.0,252转化为2进制是 1111 1100，主机号的前6位被占用为网络号，主机的IP地址的广播地址为</p><div class="table-container"><table><thead><tr><th>网络号</th><th>主机号</th></tr></thead><tbody><tr><td>180.80.010011</td><td>11.11111111</td></tr></tbody></table></div><p>是180.80.79.255 选D</p><hr><p><img src="https://s2.loli.net/2021/12/29/3TvIEXBAzODV5CP.png" alt="image-20210520193410429"></p><p>解析：当目的地址的网络可以和多个目的网络匹配上时，选择后缀最长的网络，所以选C</p><hr><p><img src="https://s2.loli.net/2021/12/29/t1eAQqh4SjKBI8D.png" alt="image-20210522012838576"></p><p>解析：0.0.0.0表示主机地址，可以作为源地址，但是不能作为目的IP地址</p><p>​          127.0.0.1表示环回测试地址，既可以作为源地址，又可以作为目的地址</p><p>​           20.10.10.3是普通的A类地址，既可以作为源地址，又可以作为目的地址</p><p>​          255.255.255.255是广播地址，不可以作为源地址，可以作为目的IP地址</p><hr><p><img src="https://s2.loli.net/2021/12/29/kY8alpCWg17XMqP.png" alt="image-20210522013143558" style="zoom:67%;" /></p><p>解析：基本概念问题，分别是UDP,IP,TCP</p><hr><p><img src="https://s2.loli.net/2021/12/29/IMVPZSuX9p3qnmg.png" alt="image-20210522013239411"></p><p>解析：划分为128个规模的子网，则$log_2X=128,X=7$，需要借用7位主机号来分配网，剩下的主机号为16-7=9，最大IP地址个数为$2^9=512$，而可以分配的IP地址数为512-2=510</p><hr><p><img src="https://s2.loli.net/2021/12/29/6E3SmqjK7eAwUTB.png" alt="image-20210522183705668"></p><p>解析：路由聚合的方法：找待聚合的各网络的共同前缀</p><p>聚合之后的网络地址为：35.230.32.0/19</p><hr><p><img src="https://s2.loli.net/2021/12/29/wklpfSt9isaVX2B.png" alt="image-20210522200316020"></p><p>解析：划分为5个子网，1个是可能的最小子网，那么另外4个子网要尽可能的大</p><p>101.200.16.0/20 的主机号段是 101.200.0001 |0000   0001 0100</p><p>第21位为0 也是就/21地址块是最大的地址块，然后就第21位为1的地址块再进行细分，第22位为0的地址块是第二大地址块，就第22为1的地址块细分，第23为0的地址块是第3大地址块，就第23为1的地址块进行细分，第24位为0和为1的地址块是第4，第5大地址块，也就是尽可能小的地址块，地址数量为：$2^8=256$</p><hr><p><img src="https://s2.loli.net/2021/12/29/hd46TCB28U3PjxN.png" alt="image-20210522203441818"></p><p>解析：建立虚电路的时候需要进行路由选择，虚电路网络不需要为每条虚电路预分配带宽</p><hr><p><img src="https://s2.loli.net/2021/12/29/k6KNy89nXTl4wtP.png" alt="image-20210518123946639"  /></p><p><img src="https://s2.loli.net/2021/12/29/pIrWaYVONo3QByR.png" alt="image-20210518123957521"></p><p>解析：此题考察网络中IP地址，路由跳转等知识点</p><ol><li><p>首先判断该网络为C类地址，在划分子网的时候，题目要求是每个局域网不少于120个地址，所以$2^x&gt;120+2$，x至少为7，所以只有借用第一位主机号作为网络号，局域网1的地址为202.118.1.0到202.118.1.127，局域网1的地址块为 <strong>202.118.1.0/25</strong>，局域网2的地址为202.118.1.128到202.118.1.256，局域网2的地址块为  <strong>202.118.1.128/25</strong></p></li><li><p>给出R1的路由表 </p><p>| 目的IP地址    | 子网掩码        | 下一跳IP地址 | 接口 |<br>| :—————— | ———————- | —————— | —— |<br>| 202.118.1.0   | 255.255.255.128 | 无           | E1   |<br>| 202.118.1.128 | 255.255.255.128 | 无           | E2   |<br>| 0.0.0.0       | 0.0.0.0         | 202.118.2.2  | L0   |<br>| 202.118.3.2   | 255.255.255.255 | 202.118.2.2  | L0   |</p><p>需要注意的是，因为没有指明是到互联网中的那一条路由，所以是采用默认路由的方式进行配置，而到域名服务器是到一个特定主机的路由，所以采用对特定主机的方式进行配置</p></li><li><p>要路由聚合技术，则需要找到局域网1和局域网2的共同前缀，为202.118.1，则聚合了之后，其聚合路由地址为<strong>202.118.1.0/24</strong></p></li></ol><hr><p><img src="https://s2.loli.net/2021/12/29/QiXTtv7yqcAP1RM.png" alt="image-20210518172036987"></p><p><img src="https://s2.loli.net/2021/12/29/dVunIrAKo5fLM3c.png" alt="image-20210518172129028"></p><p><img src="https://s2.loli.net/2021/12/29/nGUJZ248QcCmqNH.png" alt="image-20210518172045742"></p><p><img src="https://s2.loli.net/2021/12/29/4ySLZvurXjCiKxD.png" alt="image-20210518172052740"></p><p>本题是对以太网帧格式，IP分组格式，IP地址，MAC地址，ARP协议，HTTP/1.1持续的非流水线方式的综合考查</p><ol><li>根据层层封装的原理，IP数据报会被封装在以太网帧中进行发送，则以太网帧中的第1个到第6个字节是目的MAC地址，主机的默认网关地址为 00 21 27  21 51 ee         第31个字节到第34个字节是源IP地址，40 aa 62 20 十进制表示是 64.170.98.32</li><li>使用ARP协议确定目的MAC地址，封装该协议的请求报文采用广播形式，目的MAC地址为FF FF FF FF FF FF</li><li>需要注意的是，在题目的图中，是进行了有效数据传输的，所以发出Web请求是在第三次握手的时候</li></ol><p><img src="https://s2.loli.net/2021/12/29/RBUqtguZHlXcfLb.png" alt="image-20210518192758534" style="zoom:50%;" /></p><p>一共经过了6个RTT</p><ol><li>在经过路由器转发时，需要修改IP分组中的源IP地址，生存时间，首部校验和，</li></ol><p>因为IP地址是私有地址，所以在经过路由器转发的时候会改变其源IP地址</p><hr><p><img src="https://s2.loli.net/2021/12/29/ONsM1ePQfhptqak.png" alt="image-20210520144551905" style="zoom: 80%;" /></p><p><img src="https://s2.loli.net/2021/12/29/VZpaKlgImGy83QH.png" alt="image-20210520144557289" style="zoom:67%;" /></p><p>解析：本题考察路由表转发，路由聚合等知识点</p><ol><li><p>| 目的网络         | 下一跳      | 接口 |<br>| ———————— | —————- | —— |<br>| 194.17.20.128/25 | 直连        | E0   |<br>| 153.14.5.0/24    | 153.14.3.2  | S0   |<br>| 194.17.20.0/23   | 194.17.24.2 | S1   |</p></li><li><p>通过E0来转发该IP分组，因为目的网络的前缀更长</p></li><li>BGP，通过TCP建立连接</li></ol><hr><p><img src="https://s2.loli.net/2021/12/29/DB5XcrRh6AOyUxn.png" alt="image-20210520171435267" style="zoom: 80%;" /></p><p><img src="https://s2.loli.net/2021/12/29/IdQp74HJVKjvO3w.png" alt="image-20210520171442954" style="zoom: 80%;" /></p><ol><li><p>因为图中标注了权值，所以采用的是OSPF协议，则要将192.1.7.0和192.1.6.0聚合起来</p><p>| 目的网络     | 下一跳    | 接口 |<br>| —————— | ————- | —— |<br>| 192.1.1.0/24 | 直连      | E0   |<br>| 192.1.5.0/24 | 10.1.1.10 | L1   |<br>| 192.1.6.0/23 | 10.1.1.2  | L0   |</p></li><li><p>通过L0转发分组，收到的IP分组TTL为64-3=61</p></li><li><img src="https://s2.loli.net/2021/12/29/qWhPgElI3NCY4fV.png" alt="image-20210520172427620" style="zoom: 80%;" /></li></ol><p>需要增加一条特殊的直连网络，网络前缀Prefix为0.0.0.0/0，度量Metric为10</p><hr><p><img src="https://s2.loli.net/2021/12/29/rTjhNbVlyIg1OnD.png" alt="image-20210522184131547"></p><ol><li>将192.168.1.0均分给两个子网，按图中格式，说明子网掩码为255.255.255.128，销售部的广播地址是192.168.1.127，技术部的子网地址是192.168.1.128，还有254-208=46个子网可以分配</li><li>需要注意的是，IP数据报里面的偏移量一定要是8的整数倍，1500B的IP分组，数据载荷部分为1480B，分为两部分，每段能最多封装780B的数据载荷，至少分为2片，则第1段分776B，而第2段分704B，第1的片偏移量为0，第2段的片偏移量为776/8=97</li></ol><hr><p><img src="https://s2.loli.net/2021/12/29/1CwEZYdA6LNcH5x.png" alt="image-20210522202310386"></p><ol><li><p>路由器，交换机，交换机</p></li><li><p>设备1的所有接口需要配置IP地址，</p><p>IF1 192.168.1.254/30    IF2    192.168.1.1     IF3 192.168.1.65</p></li><li><p>NAT服务</p></li><li><p>H4</p></li></ol><hr><h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a><strong>运输层</strong></h2><p><img src="https://s2.loli.net/2021/12/29/1lJZXBq3gGQH5kf.png" alt="image-20210518122513494" style="zoom:67%;" /></p><p>解析：此题考察的是TCP协议的确认机制，在TCP报文中，当正确收到了报文X，那么回传的确认的报文序号是X+1,</p><p>在此题中，第一个段的序号为200，则第二个段的序号为200+300=500，正确收到第二个段后，应该发送第三个段的序号，则为500+500=1000，选D</p><hr><p><img src="https://s2.loli.net/2021/12/29/AoJGRFExdUqj3pB.png" alt="image-20210518122754848" style="zoom:67%;" /></p><p>解析：此题考察的是TCP协议的拥塞控制，当发生堵塞的时候，慢开始门限会变为原来的一半，而发送窗口会重置为1,</p><p>此题中，拥塞窗口为16KB时发生了堵塞，则发送窗口变为1，慢开始门限变为8，经过4个RTT，则发送窗口从，1变为2,2变为4,4变为8，到8的时候启动拥塞避免算法，从8到9，所以选C</p><hr><p><img src="https://s2.loli.net/2021/12/29/e2fAoHLEaUzJiZl.png" alt="image-20210518151923330" style="zoom:67%;" /></p><p>解析：此题考察TCP连接的流量控制原理</p><p>当主机乙收到了第一个段的确认段时，滑动窗口向前移动，接收窗口同时变为2000字节，此时，接收窗口内有待确认的第2段，以及还未发送的第3段，所以还可以发送的最大字节数为1000字节，所以此题选A</p><p><img src="https://s2.loli.net/2021/12/29/pRWfjhZsqOumGX9.png" alt="image-20210518152214261"></p><hr><p><img src="https://s2.loli.net/2021/12/29/OMiN3VUcJHlhPqW.png" alt="image-20210518171315692" style="zoom:67%;" /></p><p>解析：考察的知识点是TCP连接的建立过程，当主机甲发送SYN=1,seq=x时，主机乙如果要建立连接，应该要回复SYN=1,ACK=1,seq=y,ack=x+1,综上选C</p><hr><p><img src="https://s2.loli.net/2021/12/29/q6uydviKbIkgLnc.png" alt="image-20210518171754133" style="zoom:67%;" /></p><p>解析：考察TCP协议中的确认机制</p><p>TCP协议并没有累计确认机制，所以主机乙正确接受到第1和第3段后，会向主机甲发送的确认序号应该是第2段的序号，也就是900-400=500  选B</p><hr><p><img src="https://s2.loli.net/2021/12/29/YiUXL2BqMCHe9GE.png" alt="image-20210520143945241"></p><p>解析：收到乙的确认序号为2046，则要发送的需要就是2046，收到了乙的数据段序号为1913，载荷为100字节，则发送的确认序号就是1913+100=2013，所以选B</p><hr><p><img src="https://s2.loli.net/2021/12/29/pZgy4YsDcFPoG7B.png" alt="image-20210520153314038"></p><p>解析：考察TCP的拥塞控制</p><p>当发生超时的时候拥塞窗口为8kb，则会将慢开始门限变为4KB，发送窗口为1KB，进行慢开始算法</p><p><img src="https://s2.loli.net/2021/12/29/XNQuFqHrgtkaP6I.png" alt="image-20210520153953116"></p><p>10个RTT后拥塞窗口变为12KB，但是乙每次都会发送接收窗口为10KB的确认段，甲的发送窗口取决于接收窗口和拥塞窗口的最小值，所以甲的发送窗口为10KB</p><hr><p><img src="https://s2.loli.net/2021/12/29/8duDeLT1JI2fRWU.png" alt="image-20210520170943143"></p><p>解析：UDP协议提供是无连接服务，TCP和UDP都可以提供复用/分用服务，而UDP协议并不提供可靠数据传输服务，所以选择B</p><hr><p><img src="https://s2.loli.net/2021/12/29/CMoJylqLNDtuAab.png" alt="image-20210520193616428"></p><p>解析：乙收到的数据全部存入缓存，不被取走，以为着每次接收过后，接收窗口的值都会降低，在不发生阻塞的情况下，阻塞窗口会一直提高，发送窗口的取值是阻塞窗口和接收窗口的最小值，在4个RTT后，接收窗口的值是16-1-2-4-8=1，阻塞窗口的值是1-2-4-8-16，取最小值，发送窗口是1KB</p><hr><p><img src="https://s2.loli.net/2021/12/29/tyvaHVonEpOJ48N.png" alt="image-20210522013619849" style="zoom:67%;" /></p><p>解析：拥塞窗口的增长是1-2-4-8-16-32，接收窗口的减少是64-63-61-57-49-33-1，至少需要5个RTT，时间为5×5ms=25ms</p><hr><p><img src="https://s2.loli.net/2021/12/29/DSa71VlTkHA4NIJ.png" alt="image-20210522183840681"></p><p>解析：分用是指在目的主机收到了报文后，按照目的端口号将数据交付给上面的进程</p><hr><p><img src="https://s2.loli.net/2021/12/29/bLiURE5N6GQ8cqI.png" alt="image-20210522201852567" style="zoom:67%;" /></p><p>解析：若TCP支持快重传，那么会在收到连续的3次相同的确认报文后立即开始重传，时间点在t3</p><hr><p><img src="https://s2.loli.net/2021/12/29/4QWSYHJ1pofwKq7.png" alt="image-20210522202017259"></p><p>解析：第三次握手的TCP段的ACK=y+1,y是第二次握手时乙发送的初始序列号，则为2046+1=2047</p><hr><p><img src="https://s2.loli.net/2021/12/29/pxO3l7JZv8LgNMz.png" alt="image-20210522224946606"></p><p>解析：最长时间是在达到了慢开始门限值后，再开始增加的拥塞窗口，8到20需要经过12个RTT，就是24ms</p><hr><p><img src="https://s2.loli.net/2021/12/29/fOvdXNgMqJsxLcD.png" alt="image-20210522225200566"></p><p>解析：字节数为5000-1001+1=4000</p><hr><p><img src="https://s2.loli.net/2021/12/29/OS4AtzjDxlwp7Qm.png" alt="image-20210518205638100" style="zoom: 80%;" /></p><p><img src="https://s2.loli.net/2021/12/29/mlxL2jsotknuq1H.png" alt="image-20210518205653004" style="zoom:80%;" /></p><p>已知，题目给出IP数据报格式以及TCP报文格式</p><p><img src="https://s2.loli.net/2021/12/29/2sOpQZd1J5Nn8mw.png" alt="image-20210510201659621" style="zoom:67%;" /></p><p><img src="https://s2.loli.net/2021/12/29/KVcvw214d6xSZa7.png" alt="image-20210512223248172" style="zoom:50%;" /></p><ol><li><p>题目已经给出了主机H的IP地址，对比IP数据报的首部格式，第13到16字节是其源IP地址，192.168.0.8化为16进制形式为 c0 a8 00 08，对比可知，编号为1.3.4的分组是H发送的   </p><p>建立TCP连接需要经过3报文握手，前两次握手的SYN标志位是1，第三次握手SYN=0，ACK=1，可以根据以上取值来寻找分组，可以看到5个分组的首部字段长度都为5，所以在可变部分都没有进行添加，则分组的前20字节为IP数据报部分，后20字节为TCP报文段，可以得出1分组的SYN位是1,ACK=0,第2个分组的SYN位是1,ACK=1，第3个分组的SYN=0,ACK=1,所以在1.2.3完成了TCP连接建立</p><p>以太网的最小帧长为64字节，除去首部和尾部共16字节外，数据载荷的最小长度为46字节<img src="https://s2.loli.net/2021/12/29/542KOlh3TEAbuns.png" alt="image-20210518211555026"></p><p>本题中，数据载荷部分就是IP分组，若IP分组的长度小于46字节，就需要填充，根据IP数据报中的总长度字段，可以得出，第3，5号需要填充</p></li><li><p>在TCP报文段中找到序号的值，从第4号分组中开始，应用层的初始序号为84 6b 41 c6 ，在第5号分组中，确认序号为84 6b 41 d6，因此收到的数据量=确认序号-初始序号，结果为16字节</p></li><li><p>需要找到生存时间，可以找到其发出前的生存时间为40H，而2号和5号收到的分组，生存时间都为31H，可以算出生存时间减少了15，所以经过了15个路由器</p></li></ol><hr><p><img src="https://s2.loli.net/2021/12/29/3TV985FsyAiGPoE.png" alt="image-20210520200540939"></p><p><img src="https://s2.loli.net/2021/12/29/PBeKA7jixg6nzVC.png" alt="image-20210520200549881"></p><ol><li>最大范围是从111.123.15.5到111.123.15.254，目的地址是255.255.255.255，源地址是0.0.0.0</li><li>会广播发送，MAC的目的地址为FF-FF-FF-FF-FF-FF，是00-a1-a1-a1-a1-a1</li><li>子网掩码为255.255.255.0和WWW服务器的子网掩码相同，能访问到WWW服务器，默认网关是111.123.15.2，属于配置错误，无法连接到Internet</li></ol><hr><p><img src="https://s2.loli.net/2021/12/29/BRJzme8Y2aog1Sh.png" alt="image-20210522004408908" style="zoom:67%;" /></p><ol><li><p>第二次握手TCP段的SYN位是1，ACK位是1，确认号是1+100=101</p></li><li><p>H3在收到了第8个确认段后，拥塞窗口应该是1+8=9，第8个确认段发送回来的接收窗口应该是20-8=12，H3的发送窗口会取拥塞窗口和接收窗口的最小值，也就是9</p></li><li><p>发送窗口等于0的时候，就是接收窗口全部被填满了，一共接收了20个数据段，那么下一个待发送的数据段序号为101+1024×20=20581                                                                            </p><p>在经过1个RTT后，接收窗口为1，第2个RTT后，接收窗口为3，第3个RTT后，接收窗口为7，第4个RTT后，接收窗口为15，第5个RTT后，接收窗口被填满，用时200ms×5=1s</p><p>在此期间，传输了1024×20×8b的数据，所以传输速率为20.48kb/s</p></li><li><p>在4报文挥手中，S释放连接的最快速度是1.5个RTT，也就是1.5×200ms=300ms</p></li></ol><hr><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a><strong>应用层</strong></h2><p><img src="https://s2.loli.net/2021/12/29/DjWxgaIdPiwSAVU.png" alt="image-20210518123414257" style="zoom:67%;" /></p><p>解析：此题考察应用层的FTP协议，在建立FTP连接时，先建立FTP控制连接用来传递FTP命令，然后再建立FTP数据连接传输数据，FTP控制连接一直建立，而FTP数据连接是有数据连接时才建立，所以此题选A</p><hr><p><img src="https://s2.loli.net/2021/12/29/cVi4lo5qXB7Yedb.png" alt="image-20210518152248551" style="zoom:67%;" /></p><p>解析：在递归查询中，用户主机和本地域名服务器发送的消息都是一条，消息由服务器层层递进</p><hr><p><img src="https://s2.loli.net/2021/12/29/Nu1W6gvlxAesSMB.png" alt="image-20210518203353153" style="zoom:67%;" /></p><p>解析：用户于邮件服务器，邮件服务器之间都采用的是STMP协议，而用户从邮件服务器中取出数据采用的是POP3协议，所以选D</p><hr><p><img src="https://s2.loli.net/2021/12/29/X1fa9vtigxKNbcS.png" alt="image-20210520144447533"></p><p>解析：从邮件服务器向用户代理发送邮件使用的是POP3协议，所以选A</p><hr><p><img src="https://s2.loli.net/2021/12/29/pzY3n9FtRQ6VKfU.png" alt="image-20210520171145886"></p><p>解析：如果家庭局域网与ISP之间通过PPP协议，而主机使用ARP协议来获取MAC地址，查询DNS地址会用到UDP协议，所以选D</p><hr><p><img src="https://s2.loli.net/2021/12/29/86s7HRFc3dCKqGL.png" alt="image-20210520172617313" style="zoom:67%;" /></p><p>解析：POP协议的传输层协议是TCP协议，所以是有链接可靠的数据传输服务，选D</p><hr><p><img src="https://s2.loli.net/2021/12/29/xlrtMHvF3cXjA94.png" alt="image-20210520194448098" style="zoom:80%;" /></p><p>解析：因为有Cookie，所以该浏览器曾经浏览过该网址，GET报文请求浏览index.html。确实存放在该网址上，Connection方式是Close，代表不是持续连接，所以选C</p><hr><p><img src="https://s2.loli.net/2021/12/29/Hbr73KgU6VuGJt5.png" alt="image-20210522014253809"></p><p>解析：服务器与服务器的TCP21端口建立控制连接，但是数据连接的建立端口取决于是被动连接还是主动连接，所以连接端口不一定是20，选C</p><hr><p><img src="https://s2.loli.net/2021/12/29/Qdroyf1ntFOAiM4.png" alt="image-20210522183020071"></p><p>解析：DNS使用的是UDP协议，所以是无连接服务，选B</p><hr><p><img src="https://s2.loli.net/2021/12/29/IR9w8X4NmYByga7.png" alt="image-20210522184003448"></p><p>解析：SMTP传输的数据都是ASCII文本，如果不是ASCII文本，就会通过MIME来转换</p><hr><p><img src="https://s2.loli.net/2021/12/29/9JYkutZfoTrUXq8.png" alt="image-20210522202122259"></p><p>解析：很明显在C/S模型中，客户和客户之间不可以直接通信，所以选B</p><hr><p><img src="https://s2.loli.net/2021/12/29/yCiek52OLFp7dR6.png" alt="image-20210522225412986"></p><p>解析：主机与WEB服务器建立连接需要三报文握手，要经过2个RTT时间，也就是20ms，题目没有给出主机和本地域名服务器之间的交互时间，所以忽略不计，那么最短时间就是20ms，最长时间是，经过根域名服务器，com顶级域名服务器，abc.com权限域名服务器，经过3次查询，最长时间是20+30ms=50ms</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.应用层</title>
      <link href="/post/60874.html"/>
      <url>/post/60874.html</url>
      
        <content type="html"><![CDATA[<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>应用层解决应用进程的交互来实现特定网络应用的问题，是计算机网络体系结构的最顶层，是设计和建立计算机网络的最终目的</p><p><img src="https://s2.loli.net/2021/12/29/OSyt5AorhqlB46X.png" alt="image-20210513222908382"></p><h2 id="客户服务器方式和对等方式"><a href="#客户服务器方式和对等方式" class="headerlink" title="客户服务器方式和对等方式"></a>客户服务器方式和对等方式</h2><p>网络应用程序运行在处于网络边缘的不同的端系统，通过彼此间的通信来共同完成某项任务</p><p>开发一种新的网络应用首先要考虑的问题就是网络应用程序在各种端系统上的组织方式和他们之间的关系</p><p>目前主要流行的是以下两种：</p><ul><li>客户/服务器(Client/Server,C/S)方式</li><li>对等(Peer-to-Peer,P2P)方式</li></ul><p>客户/服务器就是指通信中所涉及的两个应用进程</p><p><img src="https://s2.loli.net/2021/12/29/EjC9Fg7wWLGUlNr.png" alt="image-20210513223841461"></p><p>客户是服务请求方，服务器是服务提供方</p><p>服务器总是处于运行状态，并等待客户的服务请求，服务器具有固定端口号(例如HTTP服务器的默认端口号为80)，而运行服务器的主机也具有固定的IP地址</p><p>C/S方式是因特网上传统的，同时也是最成熟的方式，很多网络应用采用的就是C/S方式</p><p>基于C/S方式的应用程序通常是<strong>服务集中型</strong>的，即应用服务集中在网络中比客户计算机少得多的服务器计算机上</p><ul><li>由于一台服务器计算机要为多个客户机提供服务，在C/S应用中，常会出现服务器计算机跟不上众多客户机请求的情况</li><li>为此，在C/S应用中，常用计算机集群来构建一个强大的虚拟服务器</li></ul><p>对等方(Peer-to-Peer)方式</p><p>在P2P方式中，没有固定的服务请求者和服务提供者，分布在网络边缘各端系统中的应用进程是对等的，被称为对等方。对等方相互之间直接通信，每个对等方既是服务的请求者，又是服务的提供者</p><p><img src="https://s2.loli.net/2021/12/29/5sZOb8uQ1XEVGNw.png" alt="image-20210513234930891"></p><p>基于P2P的应用是<strong>服务分散型</strong>的，因为服务不是集中在少数几个服务器中，而是分散在大量对等计算机中</p><p>P2P最突出的特性之一就是它的<strong>可拓展性</strong>，因为系统每增加一个对等方，不仅增加的是服务的请求者，同时也增加恶劣服务的提供者，系统性能不会因为规模的增大而降低</p><p>P2P<strong>具有成本上的优势</strong>，因为它通常不需要庞大的服务器设置和服务器带宽</p><hr><h2 id="动态主机配置协议DHCP"><a href="#动态主机配置协议DHCP" class="headerlink" title="动态主机配置协议DHCP"></a>动态主机配置协议DHCP</h2><p>动态主机配置协议DHCP(Dynamic Host Configuration Protocol)提供了一种机制，称为即插即用。这种机制允许一台计算机加入新网络时可<strong>自动获取</strong>IP地址等网络配置信息</p><p>在网络中配置DHCP服务器，让接入网络中的主机开机启动DHCP，就可以通过DHCP自动获取网络配置信息</p><p>DHCP的工作过程</p><p>DHCP采用C/S方式，是应用层协议，<strong>使用UDP所提供的服务</strong>，也就是说DHCP在运输层会被封装成UDP用户数据报，服务器使用的UDP端口是67，客户使用的UDP端口是68</p><p><img src="https://s2.loli.net/2021/12/29/5KdCRkAHO3czbQY.png" alt="image-20210514222041851"></p><p>DHCP广播发送DHCP发现报文，源IP地址为0.0.0.0，因为主机目前还未分配到IP地址，因此使用该地址代替，目的地址为255.255.255.255，因为主机不知道有几个DHCP服务器，也不知道它们的主机地址是多少，所以采用广播地址</p><p>在DHCP发现报文中，封装有事物ID和DHCP客户端的MAC地址，DHCP服务器收到了发现报文后，根据其中封装的DHCP客户端的MAC地址来查找自己的数据库，看是否有相关的配置信息，如果有，就使用这些配置信息来构建并发送DHCP提供报文，如果没有，则采用默认配置信息构建并发送DHCP提供报文</p><p><img src="https://s2.loli.net/2021/12/29/jQCpqar54WNIcOl.png" alt="image-20210514223448736">因为DHCP客户还没有IP地址，所以采用广播地址，DHCP客户会根据报文中的事物ID来判断是否是自己所请求的报文</p><p>如果DHCP客户接受到多个DHCP服务器报文，则会从中选择一个，并会向所选择的DHCP服务器发送DHCP请求报文</p><p><img src="https://s2.loli.net/2021/12/29/ehaqlTdIUF2x7kS.png" alt="image-20210514224637960"></p><p>源IP地址为0.0.0.0，因为DHCP客户才选择了一个服务器作为自己的DHCP服务器，首先需要征得服务器的同意才能正式使用租用的IP地址</p><p>目的IP地址仍为广播地址，这样不用向网络中的每一个DHCP服务器发送DHCP请求报文，来告知他们是否被选择成为服务器</p><p><img src="https://s2.loli.net/2021/12/29/miT97GJ1fLeh82R.png" alt="image-20210514225517190"></p><p> 如果服务器接收该请求，则会给DHCP客户发送DHCP确认报文，DHCP收到该确认报文后，则会正式使用该IP地址</p><p>当租用期过了一半时，DHCP客户会向DHCP服务器发送DHCP请求报文，来请求更新租用期</p><p>如果DHCP服务器同意延长，则会更新租用期，若不同意，则立即停止使用租用的IP地址，并重新发送发现报文，如果服务器不响应，则在0.875倍租用期的时候重新发送请求报文。</p><p><img src="https://s2.loli.net/2021/12/29/3ROsaMbYg1jHnrA.png" alt="image-20210514230445756"></p><p>DHCP客户可以随时提前终止DHCP服务器所提供的租用期，只需要向DHCP服务器发送DHCP释放报文段即可</p><hr><p>DHCP中继代理</p><p>在实际应用情况下，如果主机网络和DHCP服务器中有路由器的话，则主机无法通过DHCP服务器来配置网络信息，因为路由器不会转发客户的DHCP发现报文</p><p>解决办法是给该路由器配置DHCP服务器的IP地址，并使之成为DHCP中继代理，这样就可以通过DHCP来自动获取网络配置信息了，当路由器获取到广播DHCP发现报文后，会单播转发给DHCP服务器</p><hr><h2 id="域名系统DNS"><a href="#域名系统DNS" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h2><p>域名系统DNS(Domain Name System)是因特网使用的命名系统，用来把便于人们记忆的具有特定含义的主机名，转为方便于机器处理的IP地址</p><p>当我们在浏览器地址栏中输入某个Web服务器的域名时，用户主机会首先在自己的DNS高速缓存中查找该域名所对应的IP地址，如果没有找到，则会向网络中某台DNS服务器查询，DNS服务器中有域名和IP地址的映射数据库</p><p>因特网采用<strong>层次树状结构</strong>的域名结构</p><p>域名的结构由若干个分量组成，各分量之间用点隔开，分别代表不同级别的域名</p><p><img src="https://s2.loli.net/2021/12/29/KYqXzifdwscmZ9r.png" alt="image-20210515120908885"></p><ul><li>每一级的域名都由英文字母和数字组成，不超过63个字符，不区分大小写</li><li>级别最低的域名写在最左边，而级别最高的顶级域名写在最右边</li><li>完整的域名不超过255个字符</li></ul><p>域名系统既不规定一个域名需要包含多少个下级域名，也不规定每一级的域名代表了什么意思</p><p>各级域名由其上一级的域名管理结构管理，而最高的顶级域名则由因特网名称与数字地址分配机构ICANN进行管理</p><p>顶级域名TLD(Top Level Domain)分为以下三类：</p><ul><li>国际顶级域名nTLD   采用ISO 3166的规定，如cn表示中国，us表示美国等</li><li><p>通用顶级域名gTLC   最常用的通用顶级域名有7个，即：com(公司企业)，net(网络服务机构)，org(非营业性组织)，int(国际组织)，edu(美国教育结构)，gov(美国政府部门)，mil(美国军事机构)</p></li><li><p>反向域arpa  用于反向域名解析，即IP地址反向解析为域名</p></li></ul><p>在国家顶级域名下注册的二级域名均由该国家自行确定</p><p>我国将二级域名划分为以下两类：</p><ul><li>类别域名    共7个 ：ac(科研机构)，com(工，商，金融等企业)，edu(教育机构)，gov(政府部门)，net(提供网络服务的机构)，mil(军事机构)和org(非盈利性组织)</li><li>行政区域名：共34个，适用于我国的各省，自治区，直辖市等等</li></ul><p><img src="https://s2.loli.net/2021/12/29/iqCzNKnUvcPTsMS.png" alt="image-20210515134747409"></p><p>域名和IP地址的映射关系必须保存在域名服务器中，供其他应用查询，DNS使用分布在各地的域名服务器来实现域名到IP地址的转换</p><p>域名服务器可以划分为以下四种不同的类型：</p><ul><li>根域名服务器</li></ul><p>根域名服务器是最高层次的域名服务器，每个根服务器都知道所有的顶级域名服务器的域名及其IP地址，因特网共有13个不同IP地址的根域名服务器，根域名服务器通常不直接对域名进行解析，而是返回该域名所属顶级域名的顶级域名服务器的IP地址</p><ul><li>顶级域名服务器</li></ul><p>这些域名服务器负责管理该顶级域名服务器注册的所有二级域名</p><ul><li>权限域名服务器</li></ul><p>这些域名服务器负责管理某个区的域名，每个主机的域名都必须在某个权限域名服务器处注册登记，因此权限域名服务器知道其管辖的域名与IP地址的映射关系，另外，权限域名服务器还知道其下级域名服务器的地址</p><ul><li>本地域名服务器</li></ul><p>本地域名服务器不属于上述的域名服务器的等级结构，当一个主机发出DNS请求报文时，这个报文首先被送往该主机的本地域名服务器，本地域名服务器起着代理的作用，会将该报文转发到上述的域名服务器的等级结构中，有时被称为默认域名服务器</p><hr><p>域名解析的过程</p><ul><li>递归查询</li></ul><p><img src="https://s2.loli.net/2021/12/29/TEr7sRIaFfUeZxm.png" alt="image-20210515135549482"></p><p>本地域名服务器直接询问根域名服务器，然后根域名服务器再层层向下询问，得到信息后，原路返回</p><ul><li>迭代查询</li></ul><p><img src="https://s2.loli.net/2021/12/29/c7uXIAfeao3QKzD.png" alt="image-20210515135633703"></p><p>通过本地域名服务器向直接向根域名服务器查询，然后根域名服务器告诉本地域名服务器下级的域名服务器的地址</p><p>由于递归查询对于被查询的域名服务器负担太大，通常采用以下模式，从请求主机到本地域名服务器的查询是递归查询，而其余的查询是迭代查询</p><hr><p>为了提高DNS的查询效率，并减轻根域名服务器的负荷和减少因特网上的DNS查询报文数量，在域名服务器广泛使用了告诉缓存。高速缓存用来存放查询过的域名以及从何处获得域名映射消息的记录</p><p>由于域名到IP地址的映射关系并不是永久不变，为保持高速缓存中的内容，域名服务器应为每项内容设计计时器并删除超过合理时间的项</p><hr><h2 id="文件传送协议FTP"><a href="#文件传送协议FTP" class="headerlink" title="文件传送协议FTP"></a>文件传送协议FTP</h2><p>将某台计算机中的文件通过网络传送到可能相距很远的另一台计算机中，是一项基本的网络应用，就是文件传送</p><p>文件传送协议(File Transfer Protocol)是因特网上使用得最广泛的文件传送协议</p><ul><li>FTP提供交互式的访问，允许客户指明文件的类型和格式，并允许文件具有存储权限</li><li>FTP屏蔽了各个计算机的细节，因而适合在异构网络中任意计算机之间传送文件</li></ul><p>FTP的常见用途是在计算机之间传输文件，尤其是用于批量传输文件</p><p>FTP的另一个常见用途是让网站设计者将构成网络内容的大量文件批量上传到他们的Web服务器</p><hr><p>FTP的基本工作原理</p><p>主动模式</p><p><img src="https://s2.loli.net/2021/12/29/SHev7QzY3asxqfp.png" alt="image-20210515194212745"></p><p>FTP随机选择一个临时端口号，与FTP服务器的熟知端口号建立TCP连接，用来传送控制命令，当有数据要传输的时候，FTP客户通过FTP服务器来与自己的另一个临时端口号建立TCP连接，建立数据通道，这种模式称为主动模式，建立数据通道时，FTP服务器主动连接FTP客户</p><p>控制连接在整个会话过程中一直保持打开，用于传送FTP相关控制命令</p><p>数据连接用于文件传输，在每次文件传输时才建立，传输结束就关闭</p><p>被动模式</p><p><img src="https://s2.loli.net/2021/12/29/gILweWfCOoKGUDF.png" alt="image-20210515194728197"></p><p>当有数据要传输时，FTP客户通过命令通道告知FTP服务器开启某个临时端口被动等待TCP连接，建立数据通道，这种模式称为被动模式，建立数据通道时，ftp被动等待FTP客户的连接</p><hr><h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><p>电子邮件系统采用客户/服务器方式</p><p>电子邮件系统的三个主要组成构件：用户代理，邮件服务器，以及电子邮件所需的协议</p><ul><li>用户代理是用户与电子邮件系统的接口，又称为电子邮件客户端软件</li><li>邮件服务器是电子邮件系统的基础设施，因特网上所有的ISP都有邮件服务器，其功能是发送和接收邮件，同时还要负责维护用户的邮箱</li><li>协议包括邮件发送协议(例如STMP)和邮件读取协议(例如POP3，IMAP)</li></ul><p><img src="https://s2.loli.net/2021/12/29/tMcGLlQy4wFsiSv.png" alt="image-20210515195419673"></p><p><img src="C:\Users\烛\AppData\Roaming\Typora\typora-user-images\image-20210515195428356.png" alt="image-20210515195428356"></p><p>简单邮件传送协议SMTP(Simple Mail Transfer Protocol)的基本工作原理</p><p>发送方会周期性地对邮件进行缓存扫描，如果发现有邮件，则会和SMTP服务器进行TCP连接，端口号为25，之后SMTP客户就可以通过该连接对SMTP服务器发送相关的控制命令，SMTP也会给SMTP客户发送相应的应答，共21种</p><p><img src="https://s2.loli.net/2021/12/29/omgxbZTyQkCinLS.png" alt="image-20210515200349045"></p><p>电子邮件的信息格式并不是由SMTP定义的，而是在RFC 822中单独定义，一个电子邮件有信封和内容两部分，而内容又由首部和主体两部分构成</p><hr><p>SMTP协议只能传送ASCII码文本数据，不能传送可执行文件或其他的二进制对象</p><p>SMTP不能满足多媒体邮件的需要，并且许多其他国家的文字也无法用SMTP传送</p><p>为了解决SMTP传送非ASCII码文本的问题，提出了<strong>多用途因特网拓展MIME</strong>(Multipurpose Internet Mail Extensions)，可以将非ASCII码的内容转换为ASCII码的形式</p><ul><li>增加了5个新的邮件首部字段，这些字段提供了有关邮件主体的信息</li><li>定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化</li><li>定义了传送编码，可对任何内容格式进行转换，而不会被邮件系统改变</li></ul><p><img src="https://s2.loli.net/2021/12/29/theAIg9qYT7pUGW.png" alt="image-20210515210516453"></p><hr><p>常见的邮件读取协议</p><p>邮局协议POP(Post Office Protocol)：非常简单功能有限的邮件读取协议，用户只能以下载并删除方式或下载并保留方式从邮件服务器下载邮件到用户方计算机，不允许客户在邮件服务器上管理自己的邮件</p><p>因特网邮件访问协议IMAP(Internet Message Access Protocol)：功能比POP3强大的邮件读取协议，用户在自己计算机上就可以操控邮件服务器中的邮箱，就像在本地操控一样，因此IMAP是一个联机协议</p><p>POP3和IMAP4都采用<strong>基于TCP连接的客户/服务器方式</strong>，POP3使用熟知端口110，IMAP使用熟知端口143</p><hr><p>现在越来越多的人使用万维网的电子邮件，通过浏览器登录邮件服务器万维网网站就可以撰写，收发，阅读邮件</p><p>用户可以通过用一个邮箱服务器，之间通过HTTP超文本链接协议发送信息</p><p><img src="https://s2.loli.net/2021/12/29/n7blLXS6uUzmHp3.png" alt="image-20210515211343604"></p><p>不同的邮件服务器之间也可以通过SMTP进行传送</p><p><img src="https://s2.loli.net/2021/12/29/FgwPX8l1CBpbxHv.png" alt="image-20210515211416771"></p><hr><h2 id="万维网WWW"><a href="#万维网WWW" class="headerlink" title="万维网WWW"></a>万维网WWW</h2><p>万维网WWW(World Wide Web)并非某种特殊的计算机网络，它是一个大规模，联机式的信息储存所，是运行在因特网上的一个分布式应用</p><p>利用网页之间的超链接将不同网站的网页链接成一张逻辑上的信息网</p><p>浏览器最重要的部分是<strong>渲染引擎</strong>，也就是浏览器内核，负责对网页内容进行解析和显示</p><hr><p>为了方便地访问在世界范围的文档，万维网使用统一资源定位符URL来指明因特网上任何种类资源的位置</p><p>URL由以下4个部分组成：</p><p>&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</p><p>万维网的文档由超文本标记语言HTML,层叠样式表CSS，脚本语言JavaScript</p><hr><p>超文本传输协议HTTP(HyperText Transfer Protocol)</p><p>定义了浏览器怎样向万维网服务器请求万维网文档，以及万维网服务器怎样把万维网文档传送给浏览器</p><p><img src="https://s2.loli.net/2021/12/29/BIcYUuFVzpCxsrZ.png" alt="image-20210515215654346"></p><p>HTTP/1.0采用非持续连接方式，在该方式下，每次浏览器请求一个文件都要与服务器建立TCP连接，收到响应后立即关闭连接</p><ul><li>每请求一个文档就要有两倍的RTT的开销</li><li>为了减少时延，浏览器通常会建立多个并行的TCP连接同时请求多个对象，但是这样会大量占用万维网服务器的资源</li></ul><p>HTTP/1.1采用持续连接方式，在该方式下，万维网服务器在发送响应后仍然保持这条连接，使同一个客户和该服务器可以继续在这条连接上传送HTTP请求报文和响应报文</p><hr><p>HTTP的报文格式</p><p>HTTP是面向文本的，其报文的每一个字段都是一些ASCII码串，并且每个字段的长度都是不确定的</p><p><img src="https://s2.loli.net/2021/12/29/fMioPSTwae4WEAH.png" alt="image-20210515224748271"></p><p>万维网使用Cookie在服务器上记录用户信息</p><ul><li>早期的万维网应用非常简单，仅仅是用户查看存放在不同服务器上的各种静态文档，因此HTTP被设计为一种无状态的协议，这样可以简化服务器的设计</li><li>Cookie提供了一种机制使得万维网服务器能够记住用户，而无需用户主动提供用户标识信息，也就是说，Cookie是一种对无状态的HTTP进行状态化的技术</li></ul><p><img src="https://s2.loli.net/2021/12/29/RkDqZ2bK7Xg6f4r.png" alt="image-20210515225045453"></p><p><img src="https://s2.loli.net/2021/12/29/9ilfFxUJ1wnYXrj.png" alt="image-20210515225139099"></p><hr><p>万维网缓存和代理服务器</p><ul><li>在万维网中还可以使用缓存机制来提高万维网的效率</li><li>万维网缓存又称为Web缓存(Web Cache)，位于中间系统上的Web缓存又称为代理服务器</li><li>Web缓存把最近一些请求和响应暂存在本地磁盘中，当新请求到达时，若发现这个请求与展示存放的记录相同，就返回暂存的响应，而不需要按URL的地址再次去因特网访问该资源</li></ul><hr><p>HTTP连接分为<strong>持续连接和非持续连接</strong></p><p>持续连接又分为非流水的持续连接和流水的持续连接</p><p>如果用户向服务器请求数据，比如说3个图片和1个网页</p><ul><li>非流水的持续连接</li></ul><p><img src="https://s2.loli.net/2021/12/29/lU4m6BxYavrzq7A.png" alt="image-20210526125834400" style="zoom:67%;" /></p><p>需要5个RTT时间+4个对象的传输时间</p><ul><li>流水的持续连接</li></ul><p><img src="https://s2.loli.net/2021/12/29/6tjlfNcrbiuF1ev.png" alt="image-20210526125946863" style="zoom:67%;" /></p><p>需要3个RTT时间+4个对象的传输时间</p><p>非持续连接</p><p><img src="https://s2.loli.net/2021/12/29/RFNlfI5KaYT8JCO.png" alt="image-20210526130048609" style="zoom:67%;" /></p><p>需要8个RTT+4对象传输时间</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.运输层</title>
      <link href="/post/9992.html"/>
      <url>/post/9992.html</url>
      
        <content type="html"><![CDATA[<h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>物理层</strong>，<strong>数据链路层</strong>以及<strong>网络层</strong>共同解决了将主机通过异构网络互联起来所面临的问题，实现了主机到主机之间的通信</p><p>实际上在计算机网络中进行通信的实际是位于通信两段主机中的<strong>进程</strong></p><p><img src="https://s2.loli.net/2021/12/29/g5DYbqGCWcL3KfA.png" alt="image-20210512160739809"></p><p>运输层直接为应用进程间的逻辑通信提供服务</p><p>运输层向高层用户屏蔽了下面网络核心的细节，它使应用进程看见的就好像是在两个运输层实体之间有一条端到端的逻辑通信信道</p><p>根据应用需求不同，因特网的运输层为应用层提供了两种不同的运输协议，即<strong>面向连接的TCP和无连接的UDP</strong>，这两种协议是重点内容</p><hr><h2 id="端口号和复用和分用"><a href="#端口号和复用和分用" class="headerlink" title="端口号和复用和分用"></a>端口号和复用和分用</h2><p>为了使运行在不同操作系统的计算机进程之间能够进行网络通信，就必须使用统一的方法对TCP/IP体系的应用进程进行标识</p><p>TCP/IP体系的运输层采用<strong>端口号</strong>来区分应用层的不同应用进程</p><p>端口号使用<strong>16比特</strong>表示，取值范围0~65535</p><ul><li>熟知端口号：0~1023，IANA把这些端口号指派给了TCP/IP体系中最重要的一些应用协议，例如FTP使用21/20，HTTP使用80</li><li>登记端口号：1024~49151，为没有熟知端口号的应用程序使用，使用这类端口号必须在IANA按照规定登记，防止重复</li><li>短暂端口号：49152~65535，为客户进程选择暂时使用，当服务器进程收到客户进程的报文时，就知道客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用</li></ul><p><strong>端口号只具有本地意义</strong>，即端口号只是为了标识本计算机应用层中各进程，在因特网中，不同计算机中的相同端口号没有联系</p><hr><p>发送方的某些应用报文在运输层使用UDP协议进行封装，这叫做UDP复用，而另一些应用报文，使用TCP协议封装，叫做TCP复用，运输层使用端口号来区分进程</p><p>无论是UDP的用户数据保，还是TCP的报文，在网络层要通过IP协议封装，这叫做IP复用</p><p><img src="https://s2.loli.net/2021/12/29/WnaL4MjiHroCpqX.png" alt="image-20210512162319927"></p><p>接收方的网络层收到了IP数据报后进行IP分用，根据协议字段的取值来上交给运输层的UDP和TCP协议，然后TCP和UDP协议通过解析端口号将数据上交给不同的应用</p><hr><p>TCP/IP体系的应用层常用协议所使用的运输层熟知端口号</p><p><img src="https://s2.loli.net/2021/12/29/tZMEAXgQHKjaYNf.png" alt="image-20210512162610354"></p><hr><h2 id="TCP和UDP的对比"><a href="#TCP和UDP的对比" class="headerlink" title="TCP和UDP的对比"></a>TCP和UDP的对比</h2><p>用户数据报协议UDP(User Datagram Protocol)</p><p>传输控制协议TCP(Transmission Control Protocol)</p><ul><li>连接方式</li></ul><p>UDP是无连接的，使用通信协议的双方可以随时发送数据</p><p>TCP是有连接的，在进行数据传输之前必须建立连接，传输结束后必须释放连接</p><ul><li>传输方式</li></ul><p>UDP支持单播，多播以及广播</p><p>TCP只支持单播</p><ul><li>面向的对象</li></ul><p>UDP是面向应用报文的</p><p>TCP是面向字节流的</p><ul><li>服务类型</li></ul><p>UDP向上层提供无连接不可靠传输服务</p><p>TCP向上层提供面向连接的可靠传输服务</p><ul><li>首部类型</li></ul><p>UDP首部开销小，仅8字节</p><p>TCP首部最小4字节，最大60字节</p><p><img src="https://s2.loli.net/2021/12/29/sbaecJrmFzoDBT7.png" alt="image-20210512163645535"></p><hr><h2 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h2><p>流量控制(flow control)就是让发送方的发送速率不要太快，让接收方来得及接收</p><p>TCP采用<strong>滑动窗口</strong>机制来很方便的在TCP连接上实现对发送方的流量控制</p><ul><li><p>TCP接收方利用自己的接收窗口的大小来限制发送方发送窗口的大小</p><p><img src="https://s2.loli.net/2021/12/29/89mfxFCRv5XGVIY.png" alt="image-20210512164457098"></p></li></ul><p>接收方可以在确认报文的时候调整接收窗口的大小，从而限制发送方发送窗口的大小，其他的协议细节，与选择重传协议类似</p><p>考虑这样一种情况</p><p><img src="https://s2.loli.net/2021/12/29/t9MmQ6YPxj1IVTi.png" alt="image-20210512164820161"></p><p>此时A会一直等待B发送的非0窗口的通知，B也一直等待A发送的数据，若不采取措施，这种互相等待而形成的死锁局面会一直持续下去</p><p>为了解决这种情况，当发送方的发送窗口被调控到0的时候，就会启动一个<strong>持续计时器</strong>，若持续计时器超时，就发送一个<strong>零窗口探测报文</strong>，仅携带一个字节的数据，而对方在确认这个探测报文段时，给出自己的接收窗口值，如果接受窗口值仍然是0，那么收到这个报文段的一段就会重新启动持续计时器。</p><hr><h2 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h2><p>在某些阶段，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏，这种情况就叫做<strong>拥塞(congestion)</strong></p><p>若出现拥塞而不进行控制，整个网络的吞吐量将随输入负荷的增大而下降</p><p>TCP有4种拥塞控制算法</p><ul><li>慢开始</li><li>拥塞避免</li><li>快重传</li><li>快恢复</li></ul><p>发送方要维护一个叫做<strong>拥塞窗口cwnd</strong>的状态变量，其值取决于网络的拥塞程度，并且动态变化</p><ul><li>拥塞窗口cwnd的维护原则：只要网络没有出现拥塞，拥塞窗口就在增大一些，但只要网络出现拥塞，拥塞窗口就减少一些</li><li>判断出现网络拥塞的依据：没有按时收到应当到达的确认报文(发生超时重传)</li></ul><p>发送方将拥塞窗口作为<strong>发送窗口swnd</strong>，即<strong>swnd=cwnd</strong></p><p>维护一个慢开始门限<strong>ssthresh(slow start threshold)状态变量</strong>：</p><ul><li>当cwnd&lt;ssthresh时，使用慢开始算法</li><li>当cwnd&gt;ssthresh时，停止使用慢开始算法而改用拥塞避免算法</li><li>当cwnd=ssthresh时，既可以使用慢开始算法，也可以使用拥塞避免算法</li></ul><p><strong>慢开始算法</strong></p><p><img src="https://s2.loli.net/2021/12/29/KpTjQfmAnRoW9ew.png" alt="image-20210512190921019"></p><p>开始设定cwnd=1，ssthresh=16</p><p>当cwnd没有到ssthresh时，cwnd呈指数增长，这就是慢开始算法</p><p><strong>拥塞避免</strong></p><p><img src="https://s2.loli.net/2021/12/29/7C5HRNjYqvlSU3E.png" alt="image-20210512191125121"></p><p>当cwnd超过了ssthresh时，开始使用拥塞避免算法，此时cwnd不再指数增长，而是每次加1，直到出现拥塞情况</p><p> 当重传计时器超时，则判断网络很可能出现了拥塞，进行以下工作：</p><ul><li>将ssthresh值更新为发生拥塞cwnd值的<strong>一半</strong></li><li>将cwnd<strong>减少为1</strong>，并重新开始执行慢开始算法</li></ul><p><img src="https://s2.loli.net/2021/12/29/xFCKuhfEmgVMapT.png" alt="image-20210512191519560"></p><ul><li>慢开始是指一开始向网络注入的报文段少，并不是指拥塞窗口cwnd增长速度慢</li><li>拥塞避免并非完全能够避免拥塞，而是指在拥塞避免阶段将拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞</li></ul><p><strong>快重传</strong></p><p>有时候个别报文段会在网络中丢失，但实际上网络并未发生拥塞，这会导致发送方的超时重传，并误认为网络发送了拥塞，这样会启动慢开始算法，降低效率</p><p>采用快重传算法可以让发送方尽早知道发生了个别报文段的丢失</p><p>所谓快重传，就是使发送方<strong>尽快进行重传</strong>，而不是等超时重传计时器超时在重传</p><ul><li>要求接收方不要等待自己发送数据时才进行捎带确认，而是立即发送确认</li><li>即使收到了失序的报文段也要立即发出对已收到报文段的重复确认</li><li>发送方一旦收到了<strong>3个连续的重复确认</strong>，就将相应的报文段立即重传，而不是等待超时重传计时器</li></ul><p><img src="https://s2.loli.net/2021/12/29/r4baEuUdniJSGZK.png" alt="image-20210512192324785"></p><p>发送方一旦收到了3个重复确认，就是现在只是丢失了个别的报文段，于是不启动慢开始算法，而执行<strong>快恢复算法</strong></p><ul><li>发送方将慢开始门限ssthresh值和拥塞窗口cwnd值调整为<strong>当前窗口的一半</strong>，开始执行拥塞避免算法</li></ul><p><img src="https://s2.loli.net/2021/12/29/hvmARyI1MbaCgD8.png" alt="image-20210512194138350" style="zoom:67%;" /></p><hr><h2 id="TCP超时重传时间的选择"><a href="#TCP超时重传时间的选择" class="headerlink" title="TCP超时重传时间的选择"></a>TCP超时重传时间的选择</h2><p>TCP超时重传的时间的选择是一个很复杂的问题</p><p> <img src="https://s2.loli.net/2021/12/29/4b7qsftCFizpUVO.png" alt="image-20210512194423673"></p><p>如果将重传时间RTO的值设置的比RTT0小，那么会导致不必要的重传，使网络负荷增大</p><p>如果将重传时间RTO的值设置的比RTT0大，那么会导致网络的空闲时间增大，降低传输效率</p><p>所以超时重传时间<strong>RTO</strong>的值应<strong>略大于</strong>往返时间<strong>RTT</strong></p><hr><p>问题在于RTT会随着不同网络环境而<strong>发生变化</strong>，所以不能使用某次测量得到的RTT样本来计算超时重传时间RTO</p><p>利用每次测量得到的RTT样本，计算<strong>加权平均往返时间$RTT_s$(</strong>又称为平滑的往返时间)</p><p>$RTT_{S1}=RTT_1$</p><p>新的$RTT_S=(1-α)×旧的RTT_S+α×新的RTT样本$</p><p>在上式中，$0≤α&lt;1$</p><ul><li><p>若α接近0，则新RTT样本对$RTT_s$的影响不大</p></li><li><p>若α接近1，则新RTT样本对$RTT_s$的影响较大</p></li></ul><p>RFC6298推荐的α值为1/8，即<strong>0.125</strong></p><hr><p>RFC6298建议用下式计算超时<strong>重传时间RTO</strong></p><p><strong>$RTO=RTT_S+4×RTT_D$</strong></p><p>$RTT_S$是加权平均往返时间</p><p>$RTT<em>D$是RTT偏差的加权平均，$RTT</em>{D1}=RTT_1/2$</p><p>$RTT_D=(1-β)×旧的RTT_D+β×|RTT_S-新的RTT样本|$</p><p>β的建议值为<strong>0.25</strong></p><p><img src="https://s2.loli.net/2021/12/29/yQj9EDkwAcHTLRX.png" alt="image-20210512201043445" style="zoom:50%;" /></p><hr><p>但是出现超时重传时无法测准往返时间RTT的问题，Karn提出了一个算法：在计算$RTT_S$时，只要报文段重传了，就<strong>不采用</strong>其往返时间RTT样本，进而RTO也不会重新计算</p><p>这样又有新的问题，如果报文段的时延突然增大了很多，并且很长一段时间都会保持这种时延，因此在原来得出的重传时间内，不会收到确认报文段，于是重传报文段，但是根据Karn算法，不考虑重传的往返时间样本，RTO无法更新，这会导致<strong>报文段反复重传</strong></p><p>所以要对Karn算法进行修正，方法是：报文段每重传一次，就把超时重传时间RTO增大一些，典型的做法是将新RTO的值取为旧RTO值的2倍</p><hr><h2 id="TCP可靠传输的实现"><a href="#TCP可靠传输的实现" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h2><p>TCP基于以字节为单位的滑动窗口来实现可靠传输</p><p><img src="https://s2.loli.net/2021/12/29/9vDiRKLBI2fc8jh.png" alt="image-20210512201955142"></p><p>接收方会发送自己的接受窗口尺寸以及希望收到下一个字节的序号</p><p><img src="https://s2.loli.net/2021/12/29/5QMlwet7fZb4GXO.png" alt="image-20210512202102075"></p><p>如果要描述发送窗口的状态，可以使用3个指针P1,P2,P3分别指向相应的字节序号</p><p><img src="https://s2.loli.net/2021/12/29/lPJtgTCwxRuI51f.png" alt="image-20210512202702306"></p><p>虽然发送方的发送窗口是根据接收窗口设置的，但在同一时刻，发送方的发送窗口并不总是和接收方的接收窗口一样大</p><ul><li>网络传送窗口需要经历一定的时间滞后，并且时间不确定</li><li>发送方还可能根据网络当时的拥塞情况适当减少自己的发送窗口尺寸</li></ul><p>对于不按序到达的数据应如何处理，TCP并无明确规定</p><ul><li>如果接收方把不按序到达的数据一律丢弃，那么接收窗口管理比较简单，但是会浪费网络资源</li><li>TCP通常对不按序到达的数据临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程</li></ul><p>TCP要求接收方必须有<strong>累计确认和捎带确认机制</strong>，这样可以减少传输开销</p><ul><li>接收方不应过分推迟发送确认，否则会导致不必要的超时重传</li><li>捎带确认实际上不会经常发生，因为大多数应用程序很少同时在两个方向上发送数据</li></ul><p><strong>TCP的通信是全双工通信</strong>，通信中的每一行都在发送和接受报文段，因此，每一行都有自己的发送窗口和接收窗口</p><hr><h2 id="TCP的连接建立"><a href="#TCP的连接建立" class="headerlink" title="TCP的连接建立"></a>TCP的连接建立</h2><p> TCP是面向连接的协议，基于运输连接来传送TCP报文段</p><p>TCP运输连接有以下3个阶段</p><ul><li>建立TCP连接</li><li>数据传送</li><li>释放TCP连接</li></ul><p><img src="https://s2.loli.net/2021/12/29/UPaKZB9EMILOdCl.png" alt="image-20210512203914881"></p><hr><p>TCP使用“三报文握手”建立连接</p><p>一开始，两端TCP进程都属于关闭状态</p><p><img src="https://s2.loli.net/2021/12/29/gf7ZFMVlGCpyuD3.png" alt="image-20210512204038983"></p><p>TCP服务器进程首先开始建立传输控制块，用来存储一些重要信息</p><p><img src="https://s2.loli.net/2021/12/29/RvLBPJy4YsMntSF.png" alt="image-20210512204211022"></p><p>之后TCP服务器开始进入监听状态，等待TCP客户发起连接，由于TCP服务器是等待客户建立连接，所以是<strong>被动打开</strong></p><p>然后TCP客户同样建立传输控制块，然后向TCP服务器发送TCP连接请求报文段，并进入同步已发送状态，报文段首部中同部位<strong>SYN被设置为1</strong>，序号字段seq设置为x<img src="https://s2.loli.net/2021/12/29/x4hRL23NcopS6wH.png" alt="image-20210512204454452"></p><p>当TCP服务器接收到报文后，则向TCP客户进程发送TCP连接请求确认报文段，并进入同步已接收状态</p><p>报文中的SYN和ACK都设置为1，表示这是一个TCP连接请求确认报文段，序号字段seq被设置了一个初始值y，作为TCP服务器进程所选择的初始序号，ack=x+1，这是对TCP客户进程所选择的初始序号的确认</p><p><img src="https://s2.loli.net/2021/12/29/7YLctdHjPTC8h1I.png" alt="image-20210512204850732"></p><p>TCP客户进程在收到TCP连接请求确认报文段后，还要向TCP服务器发送一个普通的TCP确认报文段，并进入连接已建立状态，ACK=1，表示这是普通的确认报文段，seq=x+1，因为第一个报文段的序号为x，ack=y+1，是对TCP服务器进程所选择的初始序号的确认</p><p><img src="https://s2.loli.net/2021/12/29/dQwnclMTEVbgfrt.png" alt="image-20210512205406891"></p><p>TCP采取三握手连接是为了防止已失效的连接请求报文段突然又传送到了TCP服务器，因而导致错误</p><p><img src="https://s2.loli.net/2021/12/29/fEYqJ6iDn5o3Uh9.png" alt="image-20210512205704419"></p><hr><h2 id="TCP的连接释放"><a href="#TCP的连接释放" class="headerlink" title="TCP的连接释放"></a>TCP的连接释放</h2><p>TCP通过“四报文挥手”来释放报文段</p><p><img src="https://s2.loli.net/2021/12/29/sd3rkPJYITE6pS4.png" alt="image-20210512210014482"></p><p>如果是TCP客户想要发送释放TCP连接，则会发送TCP连接释放报文段，并进入终止等待1状态，该报文段中的<strong>FIN和ACK都会设置为1</strong>，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认，序号seq报文段的值设置为u，等<strong>于TCP客户进程之前已传送过的数据的最后一个字节序号加1</strong>，ack=v，等于TCP客户之前收到的数据的最后一个字节加1</p><p><img src="https://s2.loli.net/2021/12/29/xARhSiy2LPbXdVk.png" alt="image-20210512210354884"></p><p>TCP服务器在收到TCP连接释放报文段后，会发送一个普通的TCP确认报文段并进入关闭等待状态，ACK=1表示这是一个普通的TCP确认报文，seq=v，等于TCP服务器进程之前已传送过的数据的最后一个字节，ack=u+1，是对TCP连接释放报文段的确认</p><p>TCP服务进程此时会通知高层进程，TCP客户进程要断开与自己的TCP连接，此时，从TCP客户进程到TCP服务器进程这个方向上的连接就释放了，此时TCP连接属于<strong>半关闭状态</strong>，因为<strong>TCP客户已经没有数据要发送了，但TCP服务器进程如果还有数据要发送</strong>，TCP客户进程<strong>仍要</strong>接收</p><p>这个状态可能要持续一段时间，当TCP客户收到了TCP确认报文段后，会进入终止等待2状态</p><p><img src="https://s2.loli.net/2021/12/29/ERvewlp1BnOMNV4.png" alt="image-20210512211114614"></p><p>当TCP服务器没有数据要发送了，应用就会通知服务器释放连接</p><p>TCP服务器进程发送TCP连接释放报文段并进入<strong>最后确认状态</strong>，报文段中的FIN和ACK设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认，假定seq=w，这是在半关闭状态下，TCP服务器进程可能又发送了一些数据，确认号ack的值为u+1，这是对之前收到的TCP连接释放报文段的<strong>重复确认</strong></p><p><img src="https://s2.loli.net/2021/12/29/vzlYWLgTb1a75m6.png" alt="image-20210512211502771"></p><p>TCP客户进程收到了TCP连接释放报文段后，必须针对该报文段发送普通的TCP确认报文段，之后进入时间等待状态，ACK=1，表示这是不同的TCP确认报文段，seq的值为u+1，确认号ack的值设置为w+1，是对收到的TCP连接释放报文段的确认</p><p>TCP服务器进程在收到后就进入关闭状态，而TCP客户进程还要经过2MSL后才能进入关闭状态</p><p>MSL(Maximum Segment Lifetime)意思是最长报文段寿命</p><p><img src="https://s2.loli.net/2021/12/29/enjvk1QtZKyFp7c.png" alt="image-20210512211902948"></p><p>设置2MSL的意义在于，加入最后TCP客户发送的普通的TCP确认报文段丢失了，TCP服务器发送的TCP连接释放报文段会超时重传，如果不设置2MSL，那么TCP客户关闭后，就无法接受到超时重传的消息，就会导致TCP服务器一直在最后确认阶段</p><p><img src="https://s2.loli.net/2021/12/29/Bubr2iHIVqnUpCE.png" alt="image-20210512212138764"></p><hr><p>如果TCP双方在建立连接后，TCP客户方突然出现了故障，显然，TCP服务器就不会再收到TCP客户的数据，应该有措施让TCP服务器进程不要再白白等待下去</p><p><img src="https://s2.loli.net/2021/12/29/dLJcQeHtIjPGlkx.png" alt="image-20210512212609291"></p><p>为了避免这种情况，TCP服务器每收到一次TCP客户进程的数据，就重新设置并启动保活计时器</p><p>若保活计时器定时周期内未收到TCP客户进程发来的数据，则当保活计时器到时候，TCP服务器进程就向TCP客户进程发送一个探测报文段，以后每隔75秒发送一次探测报文段，若一连发送10个探测报文段仍无TCP客户进程的响应，TCP服务器进程就会认为TCP客户端进程故障，则会关闭这个连接</p><hr><h2 id="TCP报文段的首部格式"><a href="#TCP报文段的首部格式" class="headerlink" title="TCP报文段的首部格式"></a>TCP报文段的首部格式</h2><p>为了实现可靠运输，TCP采用了面向字节流的方式</p><p>但TCP在发送数据时，是从发送缓存取出一部分或全部字节并给其添加一个首部使之成为TCP报文段进行发送</p><ul><li>一个TCP报文段由首部和数据载荷两部分构成</li><li>TCP的全部功能都体现在它首部中各字段的作用</li></ul><p><img src="https://s2.loli.net/2021/12/29/iDSjosP6Z5nvOQ8.png" alt="image-20210512223248172"></p><ul><li>源端口：占16比特，写入源端口号，用来标识发送该TCP报文段的应用进程</li><li>目的端口：占16比特，写入目的端口号，用来表示接收该TCP报文段的应用进程</li></ul><ul><li>序号：占32个比特，取值范围$[0,2^{32}-1]$，序号增加到最后一个后，下一个序号就又回到0</li></ul><p>序号指出本TCP报文段数据载荷第一个字节的序号</p><ul><li>确认号：占32比特，取值范围$[0,2^{32}-1]$,确认号增加到最后一个后，下一个确认号就又回到0</li></ul><p>指出期望收到对方下一个TCP报文段的数据载荷的第一个字节的序号，<strong>同时也是对之前收到的所有数据的确认</strong></p><p>若确认好=n，则表明到序号n-1为止的所有数据都已正确接收，期望接收序号为n的数据</p><ul><li>确认标志位ACK：取值为1时，确认号字段才有效，取值为0时，确认号字段无效</li></ul><p>TCP规定，在连接建立后所有传送的TCP报文段都必须把ACK置1</p><p><img src="https://s2.loli.net/2021/12/29/BDkqPgZE2H5d1Yc.png" alt="image-20210512225242924"></p><ul><li>数据偏移：占4比特，并以4字节为单位</li></ul><p>用来指出TCP报文段的数据载荷部分的起始处距离TCP报文段的起始处有多远，这个字段实际上是指出了TCP报文段的<strong>首部长度</strong></p><p>首部的固定长度为20字节，最大长度为60字节，若不是4的倍数，则填充到4的倍数</p><ul><li>窗口：占16比特，以字节为单位，指出发送本报文段的一方的接收窗口</li></ul><p>窗口值作为接收方让发送方设置其发送窗口的依据，以<strong>接收方的接受能力来控制发送能力，称为流量控制</strong></p><ul><li>校验和：占16比特，检查范围包括TCP报文段的首部和数据载荷两部分</li></ul><p>在计算校验和时，要在TCP报文段的前面加上12字节的伪首部</p><p><img src="https://s2.loli.net/2021/12/29/2iQU8dvORr4YTIu.png" alt="image-20210512235922525"></p><ul><li>同步标志位SYN：在TCP连接建立时用来同步序号</li><li>终止标志位FIN：用来释放TCP连接</li><li>复位标志位RST：用来复位TCP连接，当RST=1时，表明TCP连接出现了异常，必须释放连接，然后重新连接</li><li>推动标志位PSH：接收方的TCP收到该标志位为1的报文段会<strong>尽快上交应用进程</strong>，而不必等到接收缓存都填满后再向上交付</li><li><p>紧急标志位URG：取值为1时紧急指针字段有效，取值为0时紧急指针字段无效</p></li><li><p>紧急指针：占16比特，以字节为单位，用来指明紧急数据的长度</p></li></ul><p>当发送方有紧急数据时，可将紧急数据插队到发送缓存的最前面，并立刻封装到一个TCP报文段中发送、紧急指针会指出本报文数据载荷部分包含了多长的紧急数据</p><p>扩展部分扩展了TCP报文的功能</p><ul><li>最大报文段MSS选项：TCP报文段数据载荷的最大长度</li><li>窗口扩大选项：为了扩大窗口</li><li>时间戳选项：用来计算往返时间RTT，用来处理序号超范围的情况，又称为防止序号绕回PAWS</li></ul><p>填充：由于选项的长度可变，因此使用填充来确保报文段首部能被4整除</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.网络层</title>
      <link href="/post/9495.html"/>
      <url>/post/9495.html</url>
      
        <content type="html"><![CDATA[<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>网络层的主要任务是实现网络互连，进而实现数据包在各网络之间的传输</p><p>主要要解决以下主要问题：</p><ul><li>网络层向运输层提供的是可靠传输还是不可靠传输</li><li>网络层寻址问题</li><li>路由选择问题</li></ul><hr><h2 id="网络层提供的服务"><a href="#网络层提供的服务" class="headerlink" title="网络层提供的服务"></a>网络层提供的服务</h2><p>面向连接的虚电路服务</p><ul><li><p>核心思想是可靠通信由网络来保证</p></li><li><p>必须建立网络层的连接—–虚电路VC</p></li><li><p>目的主机的地址仅在连接建立阶段使用，之后每个分组的首部只需携带一条虚电路的编号</p></li></ul><p><img src="https://s2.loli.net/2021/12/29/EpZB6nkU71dWc3m.png" alt="image-20210507104138583"></p><p>这种通信方式如果再使用可靠传输的网络协议，就可使所发送的分组最终正确到达接收方</p><p>通信结束后，需要释放之前所建立的虚电路</p><p>然而因特网并没有采用这种方法</p><hr><p>无连接的数据报服务</p><ul><li><p>可靠通信应当由用户主机来保证</p></li><li><p>不需要建立网络层连接</p></li><li><p>每个分组可走不同的路径</p></li><li><p>每个分组的首部必须携带目的分组的完整地址</p></li></ul><p><img src="https://s2.loli.net/2021/12/29/ZocIlWz1MdHXBAF.png" alt="image-20210507104439633"></p><p>这种通信方式所传送的分组可能误码，丢失，重复和失序</p><p>由于网络本身不采用端到端的可靠传输服务，所以网络中的路由器就可以做的比较简单，而且价格低廉，因特网采用了这种设计思想，将复杂的网络处理功能置于因特网的边缘，而将相对简单的尽最大努力的分组交付功能置于因特网核心</p><p><img src="https://s2.loli.net/2021/12/29/6OoxKNLTFqAJGcy.png" alt="image-20210507104654352"></p><hr><h2 id="IPv4地址"><a href="#IPv4地址" class="headerlink" title="IPv4地址"></a>IPv4地址</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>IPv4就是给因特网上每一台主机（或路由器）的每一个接口分配一个在全世界范围内是唯一的32比特的标识符</p><p>IP地址由因特网名字和数据分配机构ICANN进行分配</p><p>IPv4地址的编址方法经历了3个阶段：分类编址    划分子网    无分类编址</p><p>IPv4地址由32个比特组成，采用点分十进制表示方法以方便用户使用</p><p><img src="https://s2.loli.net/2021/12/29/arx6pTyMLq25eSW.png" alt="image-20210507110644819"></p><hr><h3 id="分类编址的IPv4地址"><a href="#分类编址的IPv4地址" class="headerlink" title="分类编址的IPv4地址"></a>分类编址的IPv4地址</h3><p>分为A类地址 B类地址 C类地址 D类地址 E类地址</p><p><img src="https://s2.loli.net/2021/12/29/H3y5uzR6B8WbeAd.png" alt="image-20210507110823896"></p><ul><li><p>只有A类，B类，C类地址可以分配给网络各接口</p></li><li><p><strong>主机号为全0的地址是网络地址</strong>，不能分配给主机或路由器接口</p></li><li><strong>主机号为全1的地址是广播地址</strong>，不能分配给主机或路由器接口</li></ul><p>A类</p><p><img src="https://s2.loli.net/2021/12/29/8vwSdIczJZ1rqnG.png" alt="image-20210507115249485"></p><p><strong>最小网络号0，保留不指派</strong></p><p>第一个可指派的网络号为1，网络地址为1.0.0.0</p><p><strong>最大网络号127，作为本地环回测试地址，不指派</strong></p><hr><p>B类</p><p> <img src="https://s2.loli.net/2021/12/29/kclJBEPbLNXvhGC.png" alt="image-20210507115314323"></p><p>最小网络号也是第一个可指派的网络号128.0 网络地址为128.0.0.0</p><p>最大网络号也是最后一个可指派的网络号191.255 网络地址为191.255.0.0</p><hr><p>C类</p><p><img src="https://s2.loli.net/2021/12/29/dDobkj2M3NSRZcU.png" alt="image-20210507115441232"></p><p>最小主机号也是第一个可指派的网络号192.0..0，网络地址为192.0.0.0</p><p>最大主机号也是最后一个可指派的网络号223.255.255，网络地址为223.255.255.0</p><hr><p><img src="https://s2.loli.net/2021/12/29/49KQEdYx5sp1omi.png" alt="image-20210507120510325"></p><hr><h3 id="划分子网的IPv4地址"><a href="#划分子网的IPv4地址" class="headerlink" title="划分子网的IPv4地址"></a>划分子网的IPv4地址</h3><p>如果需要的IP地址个数在在变化，如果每次都要申请，会很浪费IP地址</p><p>可以从主机号部分借用一部分比特作为子网号，计算机需要知道主机号中有多少位作为了子网号，所以需要<strong>子网掩码</strong></p><p>32bit的子网掩码可以表明分类IP地址的主机号部分被借用了几个比特作为子网号</p><ul><li>子网掩码使用连续的比特1来对应网络号和子网号</li><li>子网掩码使用连续的比特0来对应主机号</li><li>将划分子网的IPv4地址与其相应的子网掩码进行逻辑与运算就可以得到IPv4所在子网的网络地址</li></ul><p><img src="https://s2.loli.net/2021/12/29/mAunLsaNr4EW5Ze.png" alt="image-20210507121200065"></p><p>子网号占据了多少个1说明就借用了几个比特，1个子网号可以划分2个子网</p><hr><p>默认的子网掩码是指未划分子网的情况下使用的子网掩码</p><p><img src="https://s2.loli.net/2021/12/29/MvdG3ln7IazycmV.png" alt="image-20210507123011637"></p><p><img src="https://s2.loli.net/2021/12/29/cGUu9TQtpS2Mjhd.png" alt="image-20210507123018503"></p><p><img src="https://s2.loli.net/2021/12/29/5HdtK3YoPLcOqIV.png" alt="image-20210507123047394"></p><hr><h3 id="无分类编址的IPv4地址"><a href="#无分类编址的IPv4地址" class="headerlink" title="无分类编址的IPv4地址"></a>无分类编址的IPv4地址</h3><p>数量巨大的C类网因为地址空间太小并没有得到充分的运用，而因特网的IP地址在加速消耗，整个IPv4地址空间面临全面耗尽的威胁</p><p>为此，因特网工程任务组IETF又提出了采用无分类编址的方法</p><p>无分类域间路由选择CIDR(Classless Inter-Domain Routing)</p><ul><li>CIDR消除了传统A类，B类和C类地址，以及划分子网的概念</li><li>CIDR可以更加有效地分配IPv4的地址空间</li></ul><p>CIDR采用斜线记法，在IPv4地址后面加上斜线，在斜线后面写上<strong>网络前缀所占的比特数量</strong></p><p><img src="https://s2.loli.net/2021/12/29/Ed2gyKjrLZVzwN9.png" alt="image-20210507123900406"></p><p>CIDR实际上是将网络前缀都相同的连续的IP地址组成一个CIDR地址块</p><p>只要知道CIDR地址块中的任何一个地址，就可以知道该地址块的全部细节</p><ul><li>地址块的最小地址，最大地址</li><li>地址块的地址数量</li><li>地址块聚合某类网络的数量</li><li>地址掩码</li></ul><p>路由聚合（构造超网）</p><p>将有很多共同前缀的路由信息通过CIDR的方式打包发送给另一个路由</p><p><img src="https://s2.loli.net/2021/12/29/aSsx9bHvjKTApgm.png" alt="image-20210507124504885"></p><p>聚合地址块：172.1.4.0/22</p><ul><li><p>网络前缀越长，地址块越小，路由越具体</p></li><li><p>如果路由器查表转发分组的时候发现有多条路由可选，则选择网络前缀最长的那条，称为最长前缀匹配，因为这样的路由更具体</p></li></ul><hr><h3 id="IPv4地址的应用规划"><a href="#IPv4地址的应用规划" class="headerlink" title="IPv4地址的应用规划"></a>IPv4地址的应用规划</h3><p>根据网络中主机和路由器的数目可以进行IPv4地址的划分，有两种方式</p><p>定长的子网掩码FLSM(Fixed Length Subnet Mask)</p><ul><li>使用同一个子网掩码来划分子网，每个子网分配的IP地址相同</li></ul><p>如果网络中子网数目是n个，那么最少需要借用$log_2n$个比特充当子网掩码</p><p>如果网络中子网的最大主机数是x个，那么根据网络类型，要确保主机地址被借用后，也可以有足够的地址满足要求</p><hr><p>变长的子网掩码VLSM(Variable Length Subnet Mask)</p><ul><li>使用不同的子网掩码来划分子网，每个子网分配的IP地址不同</li></ul><p>在分配地址的时候，每个子块的起点位置不能随意选取，只能选取块大小整数倍的地址作为起点</p><hr><h2 id="IP数据报发送和转发的过程"><a href="#IP数据报发送和转发的过程" class="headerlink" title="IP数据报发送和转发的过程"></a>IP数据报发送和转发的过程</h2><p><img src="https://s2.loli.net/2021/12/29/63fKrSG5hpJZl49.png" alt="image-20210507155405472"></p><p>每个网络中都有其网络地址和子网掩码</p><p>同一个网络中的自己可以直接通信，而不同网络中的主机则需要路由器进行中转</p><p>问题是源主机如何判断目的主机是否需要是同一个网络中的？</p><p>可以将目的主机与源主机的子网掩码相与来得到目的网络地址，该地址与源主机的网络地址不相等，就可以知道目的主机与源主机不在同一个网络</p><p>这样就要通过路由器来转发数据，又有一个问题，主机怎么知道路由器的存在？</p><p>实际上，每一个主机都必须指定一个路由器，称为<strong>默认网关</strong>，如果主机要通过路由器传输信息，则会把数据传输给默认网关</p><p><img src="https://s2.loli.net/2021/12/29/AsLZF7miplrxhKW.png" alt="image-20210507160139055"></p><p>如果路由器收到了IP数据报，该如何转发</p><ol><li>首先检查IP数据报，若出错，则直接丢弃该IP数据报，若没有出错，则直接进行转发</li><li>根据IP数据报的目的地址在路由表中查找匹配的条目：若找到匹配的条目，则转发给条目中指示的下一跳，若找不到，则丢弃数据报，并通告源主机</li></ol><p>路由器在配置的时候就知道了各个接口所连接的网络和地址掩码</p><p><img src="https://s2.loli.net/2021/12/29/Mt7DNdAY2TeRV1h.png" alt="image-20210507160639084"></p><p>将目的地址与地址掩码相与，得到目的网络地址，如果相同则转发，不同则查找下一个条目</p><hr><p>如果在网络中发送广播，即目的地址是广播地址，则广播只会在本网络中传播，而路由器会判断出是广播，不会进行转发，所以路由器可以隔离广播风暴</p><hr><h2 id="静态路由配置和路由环路"><a href="#静态路由配置和路由环路" class="headerlink" title="静态路由配置和路由环路"></a>静态路由配置和路由环路</h2><p>静态路由配置是指用户或网络管理员使用路由器的相关命令给路由器人工配置路由表</p><p>这样配置不能及时适应网络状态，可以出现以下导致路由环路的错误</p><ul><li>配置错误</li><li>聚合了不存在的网络</li><li>网络故障</li></ul><p><img src="https://s2.loli.net/2021/12/29/iVE4WbDHCRlKwha.png" alt="image-20210510142840511"></p><p>如果此时R1的收到的IP数据报要转发给目的主机，但是在R1中并没有相关路由配置</p><p>此时就需要给R1的路由表配置相关信息，使R1下一跳在R2</p><p><img src="https://s2.loli.net/2021/12/29/SZdKtCwg4kyjFXn.png" alt="image-20210510143204263"></p><p>如何R2接入了因特网，那么众多IP数据报需要通过R1转发到达R2，如果是一条一条配置的话工作量太大了，此时我们可以使用<strong>默认路由</strong>的概念</p><p><img src="https://s2.loli.net/2021/12/29/aVceqfF6WiMhQl2.png" alt="image-20210510143337978"></p><p>将目的网络设置成0.0.0.0/0，此时其他的IP数据报都会默认跳转到R2</p><p>有时候我们可以给路由器添加针对某个主机的<strong>特定主机路由条目</strong></p><p><img src="https://s2.loli.net/2021/12/29/bMV3DuOFcYHl89S.png" alt="image-20210510143718110"></p><p>如果要给192.168.2.1的主机添加特定主机路由配置，就在路由器中设置成192.168.2.1/32</p><p>这样网络的前缀最长，路由最具体，当路由器具有多种转发路径可以选择的时候，会采取最长前缀匹配原则，转发的时候会有最高的优先级</p><hr><p>路由配置错误导致的路由环路问题</p><p>假如R1收到数据要转发给R2，而R2的路由错误配置。导致R2的数据要转发回R1，那么就出现了路由环路的问题</p><p><img src="https://s2.loli.net/2021/12/29/Fhp7AtekyVGzgQW.png" alt="image-20210510144229295"></p><p>为了防止IP数据报在路由环路中永久的兜圈，在IP数据报首部设有生存时间TTL字段</p><p>当IP数据报进入路由器后，TTL字段的值就减1，若TTL的值不等于0，则被路由器转发，否则被丢弃</p><hr><p>聚合了不存在的网络导致的路由环路问题</p><p>如果在路由器中聚合了不存在的网络地址，当R2收到后会转发给R1，而R1收到后转发给R2，那么就形成了路由环路</p><p><img src="https://s2.loli.net/2021/12/29/qa7doPVQYunMWNy.png" alt="image-20210510145250091"></p><p>针对这种情况，可以在R2中添加针对不存在的聚合网络的黑洞路由，一旦IP数据报进入到黑洞路由后就会被丢弃</p><p><img src="https://s2.loli.net/2021/12/29/5jxPcpa2L6KwoSI.png" alt="image-20210510145407140"></p><p>因为黑洞路由更具体，所以会优先转发黑洞路由</p><hr><p>网络故障导致的路由环路</p><p>假设路由器自动检测到其中的一条直连网络出现了故障而不可达，就会在路由表中删除该条目，如果R2转发数据给地址，会通过R1转发，R1查找不到该地址，又通过默认路由到R2中，形成了路由环路</p><p><img src="https://s2.loli.net/2021/12/29/cQ4rKRTMhGlUZWb.png" alt="image-20210510145726319"></p><p>针对这种情况，可以在R1中添加针对被删除网络的黑洞路由，这样就不会形成环路了</p><hr><h2 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>路由协议分为静态路由选择和动态路由选择</p><p>静态路由选择方式相对简单，但不能及时适应网络变化，所以一般在小规模网络中采用</p><p>动态路由选择方式比较复杂，能较好地适应网络状态的变化，所以适用于大规模网络</p><p>因特网所采用的路由选择协议的主要特点：</p><ul><li>自适应：动态路由选择，能较好适应网络状态</li><li>分布式：路由器之间交换路由信息</li><li>分层次：将整个因特网分为许多较小的自治系统AS</li></ul><p>在自治系统内部使用的协议是内部网络协议IGP，在两个自治系统之间使用的协议是外部网关协议EGP</p><p><img src="https://s2.loli.net/2021/12/29/BYQa8eXrswFIhyG.png" alt="image-20210510150638806"></p><p>RIP和IGRP基于距离向量，OSPF和IS-IS基于链路状态</p><hr><h3 id="路由器的基本结构"><a href="#路由器的基本结构" class="headerlink" title="路由器的基本结构"></a>路由器的基本结构</h3><p>路由器是一种具有多个输入端口和输出端口的专用计算机，任务是转发分组</p><p>路由器可以划分为路由选择部分和分组转发部分</p><p><img src="https://s2.loli.net/2021/12/29/RHPzq4sQo63StN9.png" alt="image-20210510152558418"></p><p>路由表如果收到了路由报文就会更新自己的路由表</p><ul><li>路由表一般仅包含从目的网络下一跳的映射</li><li>路由表需要对网络拓扑变化的计算最优化</li><li>转发表是从路由表得出的</li><li>转发表的结构应当使查找过程最优化</li></ul><hr><h3 id="路由信息协议RIP"><a href="#路由信息协议RIP" class="headerlink" title="路由信息协议RIP"></a>路由信息协议RIP</h3><p>路由信息协议RIP(Routing Information Protocol)是内部网关协议IGP中最先得到广泛使用的协议之一</p><p>RIP要求自治系统AS内的每一个路由器都要维护从它自己到AS内其它每一个网络的距离记录。这是一组距离，称为“距离向量D-V(Distance-Vector”</p><p>RIP使用跳数作为度量来衡量到达目的网络的距离</p><ul><li>路由器到直连网络的距离定义为1</li><li>路由器到非直连网络的距离定义为经过的路由器数加1</li><li>允许一条路径最多只能包含15个路由器。<strong>距离等于16相当于不可达</strong>，所以RIP只适用于小型互联网</li><li>RIP被封装在UDP协议中</li></ul><p>RIP协议认为“距离短”的路由就是最优选择的路由，也就是所通过路由器数量最少的路由</p><p><img src="https://s2.loli.net/2021/12/29/jetkNZxXP1vmW7g.png" alt="image-20210510180046128"></p><p>尽管R1到R2的带宽，但是RIP会认为R1到R4的更好</p><p>到到达同一网络由多条距离相等的路由时，可以进行<strong>等价负载均衡</strong>，也就是将通信量均衡地分布到多条等价的路由上</p><p><img src="https://s2.loli.net/2021/12/29/t1J3IjNDwMaTeAQ.png" alt="image-20210510180254683"></p><p>RIP包含有以下三个要点</p><ul><li>和谁交换信息    仅和相邻路由器交换信息</li><li>交换什么信息    自己的路由表</li><li>合适交换信息    周期性交换</li></ul><p><img src="https://s2.loli.net/2021/12/29/gMuyKjoIRkP5flY.png" alt="image-20210510180407506"></p><hr><p>RIP的基本工作过程</p><ol><li>当路由器刚开始工作的时，只知道自己到直连网络的距离为1，并不知道和自己相邻路由器的信息</li><li>每个路由器仅和相邻路由器周期性地交换并更新路由信息</li><li>若干次交换和更新后，每个路由器都知道到达本AS内各网络的最短距离和下一跳地址，称为<strong>收敛</strong></li></ol><p><img src="https://s2.loli.net/2021/12/29/Tx6i5XuY4WBKPFn.png" alt="image-20210510181014661"></p><hr><p>RIP更新报文</p><p><img src="https://s2.loli.net/2021/12/29/iOctXFuBf3dQ2P1.png" alt="image-20210510181150740"></p><p>这是C的路由表，而C的相邻路由器接收到该路由表时，会对其进行改造，成如下形式</p><p><img src="https://s2.loli.net/2021/12/29/hQfDsGw4CBWAkLH.png" alt="image-20210510181341506"></p><p>所有的距离加1，并且下一跳都变为C</p><p><img src="https://s2.loli.net/2021/12/29/wUAmhykHxJFpnlT.png" alt="image-20210510181433801"></p><p>然后对比C的路由表和自己的路由表</p><ul><li>如果目的网络和下一跳一样，则要更新信息</li><li>发现了新的网络，进行添加</li><li>如果目的网络一样，距离一样，下一跳不一样，就进行等价负载均衡</li><li>如果目的网络一样，距离不一样，下一跳不一样，如果新路由的距离短，则更新信息，如果距离更长，则不更新</li></ul><hr><p>RIP存在有坏消息传播得慢这一问题</p><p><img src="https://s2.loli.net/2021/12/29/2CgVGtcKAukY4va.png" alt="image-20210510181845024"></p><p>如果N1故障了，R1会将其距离设置为16，并把信息传输给R2，R2之前的路由表信息是，到达N1的距离为2，因为路由表在周期性的更新信息</p><p>那么，如果R2的路由器信息更早的到达的R1，R1则不再会认为到N1的距离为16，而是会更新为3，同时将此路由表信息传输给R2,R2接受到后，就会认为到达N1的距离为4</p><p><img src="https://s2.loli.net/2021/12/29/QrmzCp6uxqcGRPV.png" alt="image-20210510182217999"></p><p>直到R1和R2都认为到N1的距离为16才会终止</p><p>”坏消息传的慢“，又称为路由环路或距离无穷计数问题，这是距离向量算法的一个固有问题，可以采取多种措施减少出现该问题的概率或减少该问题带来的危害</p><ul><li>设置最大路径距离为15</li><li>当路由表发生变化的时候立即发送更新报文(触发更新)，而不是周期性发送</li><li>让路由器记录收到某特定路由信息的接口，而不让同一路由信息再通过此接口向反方向传送(即水平分割)</li></ul><hr><h3 id="开放最短路径优先OSPF"><a href="#开放最短路径优先OSPF" class="headerlink" title="开放最短路径优先OSPF"></a>开放最短路径优先OSPF</h3><p>开放最短路径优先OSPF(Open Shortest Path First)是为了克服RIP的缺点而开发出来的</p><ul><li>“开放”表明OSPF不是受某一家厂商控制，而是公开发表的</li><li>“最短路径优先”是因为使用了迪杰斯特拉提出的最短路径算法SPF</li></ul><p>OSPF采用SPF算法计算路由，从算法上保证了不会产生路由环路</p><p>OSPF基于<strong>链路状态</strong>，而不像RIP那样是基于距离向量的</p><p>OSPF采用SPF算法计算路由，从算法上保证了<strong>不会产生路由环路</strong></p><p>OSPF<strong>不限制网络规模</strong>，更新效率高，收敛速度快</p><p>链路状态是指本路由器都和哪些路由器相邻，以及相应链路的“代价”(cost)</p><ul><li>代价可以是很多指标，比如距离，时延，带宽等由网络管理人员决定</li></ul><hr><p>OSPF报文</p><p>OSPF相邻路由器之间通过交互问候(Hello)分组，建立和维护邻居关系</p><ul><li><p>Hello分组封装在IP数据报中，发往组播地址224.0.0.5(所有的OSPF路由器)</p></li><li><p><img src="https://s2.loli.net/2021/12/29/jh4Q9NSZiBwUu7H.png" alt="image-20210510191725479"></p></li><li><p>发送周期为10秒</p></li><li><p>如果40秒未收到来自邻居路由器的Hello分组，则认为该邻居路由器不可达</p></li></ul><p>使用OSPF的每个路由器都会产生链路状态通告LSA(Link State Advertisement)，LSA包含以下信息：</p><ul><li>直连网络的链路状态信息</li><li>邻居路由器的链路状态信息</li></ul><p>LSA被封装在链路状态更新分组LSU中，采用洪泛法发送</p><p>使用OSPF的每个路由器都有一个<strong>链路状态数据库LSDB</strong>，用于存储LSA</p><p>通过各路由器洪范发送封装有自己LSA的LSU分组，各路由器的LSDB最终<strong>达成一致</strong></p><p>使用OSPF的各路由器基于LSDB进行最短路径优先SPF计算，构建出各自到达其他路由器的最短路径，即构建各自的路由表</p><p><img src="https://s2.loli.net/2021/12/29/cfeYLoaObS9Z3WQ.png" alt="image-20210510194954434"></p><hr><p>OSPF的工作原理</p><p>OSPF有以下5种分组</p><ul><li>问候分组 用来发现和维护邻居路由器的可达性</li><li>数据库描述 向邻居路由器给出自己的链路状态数据库中的所有链路状态项目的摘要信息</li><li>链路状态请求 向邻居路由器请求发送某些链路状态项目的详细信息</li><li>链路状态更新(LSU) 路由器使用这种分组进行洪泛转发</li><li>链路状态确认 对LSU的确认分组</li></ul><p><img src="https://s2.loli.net/2021/12/29/bhkCQRda3Yx2wo6.png" alt="image-20210510193341006"></p><p>每30分钟或者链路状态发生变化，都会通过洪泛法来发送LSU，并给该路由器发送确认分组</p><hr><p>OSPF在多点接入网络中，很容易产生多个多播分组</p><p><img src="https://s2.loli.net/2021/12/29/wZnhLPzDITUm4jg.png" alt="image-20210510193626726"></p><p>为了减少多播分组的发送，OSPF采用选举指定路由器DR(Designated Router)和备用的指定路由器BDR的方法</p><p><strong>所有的非DR/BDR只与DR/BDR建立邻居关系，通过其交换网络</strong></p><p><img src="https://s2.loli.net/2021/12/29/ik1L5XhGtIJBrqV.png" alt="image-20210510193841039"></p><hr><p>为了让OSPF能够用于规模更大的网络，OSPF把一个自治系统再划分为若干个更小的区域(Area)</p><p><img src="https://s2.loli.net/2021/12/29/b1xQRpkevwFZHJl.png" alt="image-20210510194014162"></p><p>可以降低洪泛法交换信息的范围局限在每个区域内</p><p>区域内路由器IR(Inter Router)：接口都完全在一个区域内的路由器</p><p>区域边界路由器ABR(Area Border Router)：一个接口用于连接自身区域，另一个用于连接主干</p><p>主干路由器BR(Backbone Router)：主干区域内的路由器</p><p>自治系统边界路由器ASBR(AS Border Router)：专门用于和其他自治系统交换信息</p><hr><h3 id="边界网关协议-BGP"><a href="#边界网关协议-BGP" class="headerlink" title="边界网关协议(BGP)"></a>边界网关协议(BGP)</h3><p>在配置BGP时，每个自治系统的管理员要选择一个路由器作为该自治系统的“BGP发言人”</p><p>不同自治系统的BGP发言人要交换路由信息，<strong>首先必须建立TCP连接</strong>，端口号为179</p><ul><li>在此TCP连接上交换BGP报文以建立BGP会话</li><li>利用BGP会话交换路由信息</li><li>使用TCP连接交换路由信息的两个BGP发言人，彼此称为对方的邻站或对等站</li></ul><p>BGP发言人除了运行BGP外，还必须运行自己所在自治系统的内部网关协议IGP</p><p><img src="https://s2.loli.net/2021/12/29/mbYzl7Rw9rq5OtV.png" alt="image-20210510200357288"></p><p>BGP发言人交换网络可达性的信息</p><p>当BGP发现人交换了网络可达性信息之后，各BGP发言人就根据所采用的策略从收到的信息中找出到达各自治系统的较好的路由，也就是构造出树形结构，不存在环路的连通图</p><p>BGP-4有以下4种报文</p><p>OPEN 打开报文 ：用来与相邻的另一个BGP发言人建立关系，让通信初始化</p><p>UPDATE 更新报文 ：用来通告某一路由信息，以及列出要撤销的路由</p><p>KEEPLIVE 保活报文：用来周期性地证实邻站的连通性</p><p>NOTIFICATION 通知报文：用来发送检测到的差错</p><hr><h2 id="IPv4数据报的首部格式"><a href="#IPv4数据报的首部格式" class="headerlink" title="IPv4数据报的首部格式"></a>IPv4数据报的首部格式</h2><p><img src="https://s2.loli.net/2021/12/29/BpcMX15ytDbiVGm.png" alt="image-20210510201659621"></p><p>固定部分是每个IP数据报都要包含的内容，可变字段是可以根据需求添加的内容</p><ul><li><strong>版本</strong></li></ul><p>占4个比特，表示IP协议的版本，通信协议的IP协议版本必须一致，目前广泛使用的是IPv4</p><ul><li><strong>首部长度</strong></li></ul><p>占4比特，用来表示IP数据报首部的长度，该字段的取值以4字节为单位</p><p>最小10进制取值为5，表示只有20字节固定部分，最大10进制取值为15，表示20字节固定部分和最大400字节可变部分</p><ul><li><strong>可选字段</strong></li></ul><p>长度从1个字节到40个字节不等，用来支持排错，测量以及安全等措施，实际上很多被使用</p><ul><li><strong>填充字段</strong></li></ul><p>用来确保首部长度为4字节的整数倍，使用全0进行填充</p><ul><li><strong>区分服务</strong></li></ul><p>占8个比特，利用该字段的不同数值可提供不同等级的服务质量，一般情况下不使用</p><ul><li><strong>总长度</strong></li></ul><p>站16比特，表示IP数据报的总长度(首部+数据载荷)</p><p>最大取值为十进制的65535，以字节为单位</p><p><img src="https://s2.loli.net/2021/12/29/sYpZA9k1ouI3mra.png" alt="image-20210510203030287"></p><p><strong>标识，标志，片偏移</strong>三个字段共同用于IP数据报分片</p><p>以太网的数据链路层鬼听MTU的值为1500字节，如果IP数据报的大小超过了这么多，就需要进行分片</p><p><img src="https://s2.loli.net/2021/12/29/ISBAp8NTQqnUdig.png" alt="image-20210510203710260"></p><ul><li><strong>标识</strong></li></ul><p>占16比特，属于同一个数据报的各分片数据报应该具有相同的标识</p><ul><li><strong>标志</strong></li></ul><p>占3个比特，各比特含义如下</p><p>DF位：1表示不允许分片 0表示允许分片</p><p>MF位：1表示后面还有分片 0表示这是最后一个分片</p><p>保留位：必须为0</p><ul><li><strong>片偏移</strong></li></ul><p>占13个比特，指出分片数据报的数据载荷部分偏移其原数据报的位置有多少个单位</p><p>以8个字节为单位</p><p>因为片偏移量<strong>以8个字节为单位</strong>，<strong>所以除了第一个分片外，其余分片的数据载荷必须是8的整数倍</strong>，在分片的时候需要注意</p><ul><li><strong>生存时间</strong></li></ul><p>占8个比特，以条数为单位，转发IP数据报时，将IP数据报首部中的该字段的值减1，若不为0则转发</p><ul><li><strong>协议</strong></li></ul><p>占8个比特，指明IPv4数据报的数据部分是何种协议数据单元</p><p><img src="https://s2.loli.net/2021/12/29/pI47QveCkDzjMUJ.png" alt="image-20210510205506569"></p><ul><li><strong>首部检验和</strong></li></ul><p>占16个比特，用来检测首部在传输工程中是否出现差错，比CRC检验码简单，称为因特网检验和</p><p>IP数据报没经过一个路由器，路由器都要重新计算首部检验和，因为某些字段可能会发生变化，在IPv6中不再计算检验和</p><ul><li><strong>源IP地址和目的IP地址</strong></li></ul><p>各占32比特，用来填写发送该IP数据报的源主机的IP地址和接收该IP数据报的目的主机的IP地址</p><hr><h2 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h2><p>主机或路由器通过ICMP(Internet Control Message Protocol)来发送差错报告报文和询问报文</p><p>被封装在IP数据报中发送</p><p>报文一共有一下5种</p><ul><li>终点不可达</li></ul><p>当路由器或主机无法交付数据报时，就向源点发送终点不可达报文</p><ul><li>源点抑制</li></ul><p>当路由器或主机由于拥塞而丢弃数据时，就向源点发送源点抑制报文</p><ul><li>时间超过</li></ul><p>若转发的数据报的生存时间为0，除了丢弃该数据报，还要向源点发送时间超过报文</p><ul><li>参数问题</li></ul><p>如果路由器或目的主机收到IP数据报后，根据其首部的检验和字段发现了误码，就丢弃该数据报，并且向源点发送参数问题报文</p><ul><li>改变路由</li></ul><p>路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的主机</p><p>以下情况不该发送ICMP差错报告报文</p><ul><li>对ICMP差错报文不应发送ICMP差错报文</li><li>对第一个分片的数据报文的所有后序报文都不发送ICMP差错报告报文</li><li>对具有多播地址的数据报不发送</li><li>对具有特殊地址的数据报(127.0.0.0或0.0.0.0)不发送</li></ul><hr><p>ICMP询问报文主要有两种</p><ul><li>回送请求和回答</li></ul><p>ICMP回送请求是由主机或路由器向一个特定的目的主机发出的询问，收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文，用来测试目的站是否可达</p><ul><li>时间戳请求和回答</li></ul><p>ICMP时间戳请求报文是请某个主机或路由器回答当前的时间和日期，用来进行时钟同步和测量时间</p><hr><h2 id="虚拟专用网VPN"><a href="#虚拟专用网VPN" class="headerlink" title="虚拟专用网VPN"></a>虚拟专用网VPN</h2><p>虚拟专用网VPN(Virtual Private Network)：利用公网的因特网作为本机构各专用网之间的通信载体</p><p>由于IPv4地址的紧缺，一个机构所申请到的地址数量很少，因此，虚拟专用网中各主机所分配的地址应该是本机构可只有分配的专用地址，而不是需要申请的，在因特网上使用的公有地址</p><p>有10.0.0.0~10.255.255.255(10/8地址块) 172.16.0.0~172.31.255.255(172.16/12地址块)</p><p>   192.168.0.0~192.168.255.255(192.168/16地址块)</p><p>私有地址只能用于内部通信，不能在因特网上传输，路由器对目的地址是私有地址的IP数据报一律不进行转发</p><p>很显然，两个私有地址之间要实现远程通信，需要两个有公网IP的路由器</p><p>假设需要远程通信，在主机1把数据包传送给路由器1，路由器1吧IP数据报加密，然后用IP数据报的形式通过因特网传输到路由器2，路由器2解析加密的IP数据报，然后把数据发送给主机2</p><p><img src="https://s2.loli.net/2021/12/29/IFujaoiqhW9sNmd.png" alt="image-20210510224501522"></p><p>从逻辑上看来R1和R2好像是点对点链路，所以也把这种技术称为IP隧道技术</p><p>同一机构内不同部分的内部网络所构成的虚拟专用网VPN又称为内联网VPN</p><p>有时一个结构的VPN需要有某些外部机构参与进来，这样的VPN称为外联网VPN</p><p>在外地工作的员工需要访问公司内部的专用网络时，只要在任何地点接入到因特网，运行PC中的VPN软件，在员工的PC和公司的主机之间建立VPN隧道，即可以访问专用网络中的资源，这种VPN称为远程接入VPN</p><hr><h2 id="网络地址转换NAT"><a href="#网络地址转换NAT" class="headerlink" title="网络地址转换NAT"></a>网络地址转换NAT</h2><p>NAT(Network Address Translation)：能使大量使用内部专用地址的专用网络用户共享少量外部全球地址来访问因特网上的主机和资源</p><p>使用私有地址的主机想要与因特网的主机上进行通信，需要一个NAT路由器，至少有一个有效地外部全球IP地址，所有的使用私有地址的主机在和外界通信的时候都要在NAT路由器上将IP地址转换成全球IP地址</p><p><img src="https://s2.loli.net/2021/12/29/c9Dv1RWkzLEfew5.png" alt="image-20210510225648917"></p><p>NAT路由器会建立一个转换表来记录私有地址和全球IP地址之间的转换关系</p><p>该转换方法存在一个问题：如果NAT路由器具有N个全球IP地址，那么至多有N个内网主机能够同时和因特网上的主机通信</p><p>所以推出了网络地址与端口转换技术NAPT，将运输层的端口号和IP地址一起转换，这样用一个全球IP地址就可以使多个拥有本地地址的主机同时和因特网上的主机进行通信</p><p><img src="https://s2.loli.net/2021/12/29/jiBPgp34nEWvFot.png" alt="image-20210510235817887"></p><p>对于一些P2P网络应用，需要外网主机主动与内网主机进行通信，在通过NAT时会遇到问题，需要网络应用自己使用一些特殊的NAT穿越技术来解决问题</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.数据链路层</title>
      <link href="/post/17624.html"/>
      <url>/post/17624.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>链路：就是从一个结点到相邻结点的一段物理线路，而中间没有任何其他的交换线路</p><p>数据链路：是指把实现通信协议的硬件和软件加到链路上，就构成了数据链路</p><p>数据链路层以帧为单位传输和处理数据</p><p>数据链路层在传输数据的时候主要考虑三个问题</p><ul><li><strong>封装成帧</strong></li><li><strong>差错检测</strong></li><li><strong>可靠传输</strong></li></ul><p>封装成帧：</p><p>数据链路层给网络层交付的协议数据单元添加帧头和帧尾的操作，称为封装成帧</p><p><img src="https://s2.loli.net/2021/12/28/jhVMolX7akAy6dS.png" alt="image-20210429161619830"></p><p>目的是在链路上以帧为单位传输数据</p><hr><p>差错检测：</p><p>帧在传输过程中可能出现误码，根据帧尾中的检错码就可以检测帧中是否有误码</p><hr><p>可靠传输：</p><p>接收方主机收到有误码的帧后，不会接收该帧，将其丢弃，如果数据链路层提供的是不可靠服务，那么该帧就被永久丢弃了</p><p>如果链路层提供的是可靠服务，就需要其他措施来确保接收方主机还可以重新收到被丢弃的这个帧的正确副本。尽管误码是不能完全避免的，但如果能够实现发送方发送什么，接收方就能收到什么，就称为可靠传输</p><hr><p>对于使用广播信道的数据链路层，还需要考虑<strong>数据的编制问题，和数据在信道传输的碰撞问题</strong></p><hr><h2 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h2><p>封装成帧是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之成为帧</p><ul><li>帧头和帧尾包含有重要的控制信息</li></ul><p>数据链路层会把上层交付下来的协议数据单元封装成帧后，要通过物理层，把各个比特转换成电信号发送到传输媒体，那么接收方的数据链路层从比特流中识别帧呢？</p><ul><li>帧头和帧尾的作用之一就是帧定界</li></ul><p><img src="https://s2.loli.net/2021/12/28/YlNw7qMpheJvusa.png" alt="image-20210429185457517"></p><p>在帧头和帧尾的中有一个字节的标识字段，用来标识帧</p><p>并不是每一种帧都包含了帧定界格式</p><p><img src="https://s2.loli.net/2021/12/28/VNvFh31WwLtEo9u.png" alt="image-20210429185723929"></p><p>MAC帧交付到物理层后，物理层会给MAC帧添加前导码，然后在转换为电信号发送</p><p><img src="https://s2.loli.net/2021/12/28/VH1RZzP8kgsb6Sj.png" alt="image-20210429185816427"></p><p>前导码中的前七个字节为前同步码，作用是使接收方的时钟同步，后一个字节为定界符，用来表示之后的帧是MAC帧</p><p>以太网还规定了帧间间隔时间为96bit。所以不需要帧结束定界符</p><hr><p><strong>透明传输：是指数据链路层对上层交付的传输数据没有任何限制，就好像数据链路层不存在一样</strong></p><p>但是，如果上层交付的协议数据单元中，包含了帧定界标志，如果不做任何处理的话，接收方就不能正确接收该帧 </p><p><img src="https://s2.loli.net/2021/12/28/24ogtASXLR3fnUd.png" alt="image-20210429192413380"></p><p>如果要求上层的协议数据单元不能包含帧定界标志的话，就不能称为透明传输</p><p>实际上为了透明传输，所有的数据链路层协议都会解决这个问题</p><ul><li>面向字节的物理链路使用<strong>字节填充</strong>的方法实现透明传输</li></ul><p>比如，在传输之前，对帧的数据部分进行扫描，如果发现了帧定界符，则在其中加入转义字符，如果其中有转义字符，也需要插入转义字符</p><p><img src="https://s2.loli.net/2021/12/28/z98Ps2KSFBdOWuk.png" alt="image-20210429193002873"></p><hr><ul><li>面向比特的物理链路使用比特填充的方法实现透明传输</li></ul><p>如果在帧的数据部分出现了帧定界标志，在发送前，可使用<strong>0比特传输法</strong>，每5个连续数据的比特1后面添加一个比特0，接收的时候将其剔除即可</p><p><img src="https://s2.loli.net/2021/12/28/3UNFSwfYXP4QbnR.png" alt="image-20210429193544931"></p><hr><p>为了提高帧的传输效率，应该使帧的数据部分的长度尽可能大些</p><p>考虑到差错控制等多种因素，每一种数据链路层协议都规定了帧的数据部分的长度上限，即<strong>最大传送单元MTU</strong>(Maximum Transfer Unit)</p><hr><h2 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h2><p>比特差错：实际的通信链路都不是理想的，比特在传输构成中可能会产生差错：1可能会变成0，而0也可能变成1，这称为比特差错</p><p>在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率BER</p><p><img src="https://s2.loli.net/2021/12/28/uNyDjzZE3OCweRb.png" alt="image-20210429194932945"></p><p>使用 差错检测码来检测数据在传输过程中是否产生了比特差错，是数据链路层要解决的问题</p><hr><p>奇偶校验：在待发送的数据后面添加1位奇偶校验码，使整个数据中“1”的个数为奇数或者偶数</p><p>但是如果传输过程中产生2位误码，那么就无法检出错误了</p><hr><p>循环冗余校验CRC(Cyclic Redundancy Check)</p><ul><li>收发双方约定好一个生成多项式G(x)</li><li>发送方基于待发送的数据和生成多项式计算出差错检测码(冗余码),将其添加到待传输数据的后面一起传输</li><li>接收方通过生成多项式来计算收到的数据是否产生了误码</li></ul><p><img src="https://s2.loli.net/2021/12/28/HmiqSKWrAvjPz5g.png" alt="image-20210429204755515"></p><p><img src="https://s2.loli.net/2021/12/28/yS29dBVCInLG3Fe.png" alt="image-20210429204823494"></p><p>检错码只能检查出帧在传输过程中出现了差错，但并不能定位错误，因此无法纠正错误码</p><p>循环冗余校验CRC有很好的检错能力，虽然计算复杂，但是容易使用硬件实现，因此广泛用于数据链路层</p><hr><h2 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>使用差错检测技术可以检测到帧在传输过程中是否产生了误码</p><p>不可靠传输服务：仅仅丢弃有误码的帧，其他什么都不做</p><p>可靠传输服务：想办法实现发送端发送什么，接收端就收到什么</p><p>一般情况下，有线链路的误码率比较低，所以为了减小开销，并不要求数据链路层向上提供可靠服务，即使出现误码，问题可由上层处理</p><p><img src="https://s2.loli.net/2021/12/28/w7T2AGZU1ldLv3H.png" alt="image-20210429205549920"></p><p>但是对于无线链路，误码率较高，则必须要采用可靠传输服务</p><p><img src="https://s2.loli.net/2021/12/28/c9ZeGgQkytWF5C8.png" alt="image-20210429205625927"></p><p>比特差错只是传输差错的一种</p><p>从整个计算机网络体系结构来看，传输差错还包括分组丢失，分组失序以及分组重复</p><p> 可靠传输服务并不仅局限于数据链路层，其他各层均可选择实现可靠传输</p><hr><h3 id="停止等待协议SW-Stop-and-Wait"><a href="#停止等待协议SW-Stop-and-Wait" class="headerlink" title="停止等待协议SW(Stop-and-Wait)"></a>停止等待协议SW(Stop-and-Wait)</h3><p><img src="https://s2.loli.net/2021/12/28/3A95JjmrUoObZCB.png" alt="image-20210429213051724"></p><p>当发送方发送了一个数据包之后，就开始等待，当接收方收到了数据之后，会发送一个确认数据给发送方，当发送方收到了确认数据后，才会继续发送数据，当接收方收到误码后，会把数据包丢弃，然后会发送一个错误信息给发送方，发送方收到后会重传。这样就实现了可靠传输</p><hr><p>但是这样会有一个问题，如何DATA在传输过程<strong>丢失</strong>了，那么接收方就不会发送确认消息，此时该怎么办？</p><p>为了解决这个问题，可以在发送方发送完一个数据分组时，启动一个<strong>超时计时器</strong>。如果到了超时计时器所设置的<strong>重传时间</strong>，而发送方仍收不到接收方的任何消息，则重传原来的数据分组，这就叫做超时重传</p><p>一般可将重传时间选为略大于从发送方到接收方的平均往返时间</p><p><img src="https://s2.loli.net/2021/12/28/nZ2SgTvuCXBe5w1.png" alt="image-20210429214929826"></p><hr><p>这样解决了DATA的丢失问题，但是ACK同样也有可能丢失，当ACK丢失的时候，发送方启动超时重传器，重传了DATA数据包，此时接收方无法判断这个数据包是否是刚才的数据包？此时就导致了<strong>分组重复</strong></p><p><img src="https://s2.loli.net/2021/12/28/iEPcApBoK5xbtTZ.png" alt="image-20210429215833717"></p><p>为了避免分组重复这种传输错误，必须给每个分组带上序号</p><p>对于停止-等待协议，由于每发送一个数据分组就停止等待，只要保证每发送一个新的数据分组，其发送序号与上次发送的数据分组的序号不同就可以了，因此用一个比特来编号就可以了</p><p><img src="https://s2.loli.net/2021/12/28/ApeP9glTVcQdDn4.png" alt="image-20210429221644470"></p><hr><p>给数据编号，这样就解决了确认信号的丢失问题，那么需要给确认信号也编号吗？</p><p>假如在收到数据后，接收方发出的确认信号经过了一些延迟，发出去的时候，发送方已经启动重传协议发送了数据0，此时收到了确认数据，发送数据1，发送方收到了重复的数据0，发送ACK表示丢弃，问题是发送方如何判断这个ACK的意思呢？</p><p>确认分组编号就可以解决这种问题</p><p><img src="https://s2.loli.net/2021/12/28/NkCOYEpU2W7HAva.png" alt="image-20210429223042978"></p><p>注意事项：</p><ul><li>接收端检测到数据分组有误码时，将其丢弃并等待发送方的超时重传，但对误码率较高的点对点链路，为使发送方尽早重传，也可以给发送方发送NAK分组</li><li>给数据分组编号的时候，需要要1个比特编号就行了，即0和1</li><li>给ACK分组编号，所用的比特和给数据分组编号时候一样，但是数据链路层一般不会出现ACK分组迟到的情况，所以在数据链路层实现SW协议时，可以不用给ACK分组编号</li></ul><p>信道利用率</p><p>发送一个数据分组开始，到收到确认消息，有三段时间</p><p>数据分组的发送时延 $T_D$</p><p>数据在信道中的往返时间RTT</p><p>收到确认分组的处理时延$T_A$</p><p><img src="https://s2.loli.net/2021/12/28/2fteDsa6QpIBCg7.png" alt="image-20210503121418032"></p><p>只有在发送数据的时候才算在利用信道</p><p><strong>信道利用率$U=T_D/(T_D+RTT+T_A)$</strong></p><hr><p>当往返时延RTT远大于数据帧发送时延$T_D$的时，信道利用率非常低，为了克服停止等待协议信道利用率低的缺点，就产生了另外两种协议，即<strong>后退N帧协议</strong>和<strong>选择重传协议</strong></p><hr><h3 id="回退N帧协议GBN-G0-Back-N"><a href="#回退N帧协议GBN-G0-Back-N" class="headerlink" title="回退N帧协议GBN(G0-Back-N)"></a>回退N帧协议GBN(G0-Back-N)</h3><p>因为停止等待协议的信道利用率很低，所以如果能流水线式传输数据分组的话，信道利用率会高很多</p><p><img src="https://s2.loli.net/2021/12/28/z2qPviOxgRAsC8J.png" alt="image-20210503122151575"></p><p>主要是通过发送窗口的方式来实现多个数据包的发送</p><p>1.采用3个比特给分组编序号，即0~7</p><p>2.发送窗口的尺寸<strong>不能超过**</strong>$2^n-1$**，如果发送窗口尺寸为1，则是SW协议</p><p>3.接收窗口的尺寸为1</p><p><img src="https://s2.loli.net/2021/12/28/gjBTixKmFDudHc7.png" alt="image-20210503123646724"></p><p><strong>累计确认</strong></p><p>接收方不一定要对收到的数据分组逐个发送确认，而是可以在收到几个数据分组后，对按序到达的最后一个数据分组发送确认，</p><p>比如在接收到3个数据包后，只需要发送一个ACK2就可以了，说明在ACKn之前的数据包都成功接收了</p><p>即使确认分组丢失，发送方也不必重传，只要只要后面的确认分组到了就行，使用累计确认也有缺点，当发送方发送的第一个数据包出现误码的时候，接收方只有全部丢弃数据包</p><p><img src="https://s2.loli.net/2021/12/28/4VH8vjt1msC7Blc.png" alt="image-20210503124400005"></p><p>当出现差错的时候，接收窗口每丢弃一次，就会发送一次之前的ACK序号，当发送窗口接收到重复的ACK时，可以不等超时计时器超时就立刻重传</p><p>尽管之后的数据分组都正确的到达了接收方，但是由于第一个数据分组没有被接收，它们同样也不能被接收，发送方还要重传这些数据分组，这就是所谓的Go-back-N(回退N帧)</p><p><img src="https://s2.loli.net/2021/12/28/vYNgMOEJymkDVZj.png" alt="image-20210503124832603"></p><p><img src="https://s2.loli.net/2021/12/28/5YFodSXRHk238by.png" alt="image-20210503124838991"></p><hr><h3 id="选择重传协议SR-Selective-Request"><a href="#选择重传协议SR-Selective-Request" class="headerlink" title="选择重传协议SR(Selective Request)"></a>选择重传协议SR(Selective Request)</h3><p>回退N帧协议的接收窗口尺寸为1，因此接收方只能按序接收正确到达的分组，一个数据的误码导致在其之后的数据不能被接收，这是对通信资源的浪费</p><p>为了提高性能，只重传出现误码的数据分组，因此，接收窗口的尺寸应该大于1，以便接收方先收下失序到达但无误码并且序号落在接收窗口的数据分组，等到所缺分组收齐后再一并送交上层。这就是选择重传协议</p><p><strong>选择重传协议不采用累计确认，而是逐一确认</strong></p><p><img src="https://s2.loli.net/2021/12/28/hcEDnk87T9qPs3Q.png" alt="image-20210503144635659"></p><p>发送窗口的尺寸不能超过$1&lt;W_T≤2^{n-1}$,n为编码的比特数</p><p>如果尺寸超过了，则会导致重复分组的问题</p><p><img src="https://s2.loli.net/2021/12/28/Pa6VmFe5T3KhEnt.png" alt="image-20210503144850644"></p><p><img src="https://s2.loli.net/2021/12/28/xs1tRwFaMPdKJGN.png" alt="image-20210503144855854"></p><hr><h2 id="点对点协议PPP"><a href="#点对点协议PPP" class="headerlink" title="点对点协议PPP"></a>点对点协议PPP</h2><p>PPP(Point-to-Point Protocol)是目前使用最广泛的点对点链路层协议</p><p>PPP协议为在点对点链路传输各种协议数据报提供了一个标准方法，主要由以下三部分构成</p><ul><li>对各种协议数据报的封装方法</li><li>链路控制协议LCP  用于建立，配置以及测试数据链路的连接</li><li>一套网络控制协议NCPs  其中每一个协议支持不同的网络层协议</li></ul><p><img src="https://s2.loli.net/2021/12/28/qZAsWRLvT56QMEy.png" alt="image-20210506093520648"></p><p>帧的格式</p><p><img src="https://s2.loli.net/2021/12/28/qiHJt6DyoQaeNnx.png" alt="image-20210506093558036"></p><p>标志F(Flag)字段：PPP帧的定界符，取值为0x7E</p><p>地址(Address)字段：没什么用</p><p>控制(Control)字段：没什么用</p><p>协议(Protocol)字段：指明帧的数据部分送交那个协议处理</p><p>帧检验序列(Frame Check Sequence)字段：CRC计算出的校验位</p><hr><p>透明传输</p><p>如果是字节的异步链路，则采用字节填充法</p><p><img src="https://s2.loli.net/2021/12/28/pmb2s8AekfO3PRq.png" alt="image-20210506093916444"></p><ul><li>将出现的每一个7E字节转变成(7D,5E)</li><li>出现的每一个7D字节转变成(7D,5D)</li><li>出现的每一个ASCII控制字符，则在前插入一个7D，同时将该字符编码加上0x20</li></ul><p>接收方进行反变换就可以恢复原来帧的数据部分</p><p>如果是比特的同步链路则采用比特填充法</p><p><img src="https://s2.loli.net/2021/12/28/m1WPFqokbEz3enR.png" alt="image-20210506094216846"></p><p>发送方对帧的数据部分进行扫描，只要发现5个连续的比特1，就立即填充一个比特0</p><hr><p>接收方每收到一个PPP帧，就进行CRC校验，若CRC检验正确，就收下这个帧，反之，就丢弃这个帧，使用PPP的数据链路层向上不提供可靠传输服务</p><hr><h2 id="媒体接入控制-Media-Access-Control"><a href="#媒体接入控制-Media-Access-Control" class="headerlink" title="媒体接入控制(Media Access Control)"></a>媒体接入控制(Media Access Control)</h2><p>总线性网络在各主机同时发送数据时会发生信号的碰撞，使信息发送失败，共享信道要着重考虑的一个问题就是如何协调多个发送和接收站点对一个共享传输媒体的占用，即<strong>媒体接入控制MAC(Medium Access Control)</strong></p><p><img src="https://s2.loli.net/2021/12/28/lsaptYBDTiyVmU3.png" alt="image-20210506094848034"></p><hr><h3 id="静态划分信道"><a href="#静态划分信道" class="headerlink" title="静态划分信道"></a>静态划分信道</h3><p>信道复用</p><p>复用(Multiplexing)是通信技术中的一个重要概念，复用就是通过一个物理线路同时传输多路用户的信号</p><p>当网络中传输媒体的传输容量大于多条单一信道的总通信量时，可利用复用技术在一条物理线路上建立多条通信信道来充分利用传输媒体的带宽</p><p><strong>频分复用(FDM)</strong></p><p><img src="https://s2.loli.net/2021/12/28/ONfq3RCaJkhyUmQ.png" alt="image-20210506101102625"></p><p>将传输线路的资源划分成多个子频带，形成多个子信道</p><p>频分复用的所有用户同时占用不同的频带资源并行通信</p><p><strong>时分复用(TDM)</strong></p><p><img src="https://s2.loli.net/2021/12/29/GTukjH6Qnoe9bNy.png" alt="image-20210506101436703"></p><p>将时间划分为一个个小的时隙，每对用户只在被划分的时间中传递信息</p><p>时分复用的所有用户在不同的时间占用同样的频带宽度</p><hr><p><strong>波分复用(WDM)</strong></p><p>波分复用其实就是光的频分复用</p><p><img src="https://s2.loli.net/2021/12/29/bLmzERWgZ3T7PYu.png" alt="image-20210506101654141"></p><p>变换光的波长，来利用波长的不同来传递不同的信息</p><hr><p><strong>码分复用(CDM)</strong></p><p>实际上由于该技术主要用于多址接入，人们更常用的名词是码分多址CDMA(Code Divison Multiple Access)</p><p>复用和多址的概念：</p><ul><li>复用是将单一媒体的频带资源划分成很多子信道，这些子信道之间相互独立，互不干扰，从媒体的整体频带资源上来看，每个子信道只占用该媒体频带资源的一部分</li><li>多址处理的是动态分配信道给用户，这在用户仅仅暂时占用信道的应用是必须的</li><li>某种程度上，多址是复用的应用</li></ul><p>与FDM和TDM不同，CDM的每一个用户可以在同样的时间使用同样的频带进行通信，由于各用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰</p><p>在CDMA中，每一个比特时间再划分为m个短的间隔，称为码片(Chip)</p><p>在使用CDMA的每一个站被指派一个唯一的m bit码片序列</p><ul><li>一个站如果要发送比特1，则发送它自己的m bit码片序列</li><li>一个站如果要发送比特0，则发送它自己的m bit码片序列的二进制反码</li></ul><p>码片序列的挑选原则如下：</p><ul><li><p>分配给每个站的码片序列必须各不相同，实际常采用伪随机码序列</p></li><li><p>分配给每个站的码片序列必须正交(规格化內积为0)</p></li></ul><p>$S·T=1/m\sum_{i=1}^mS_iT_i=0$</p><p>用收到的码片序列分别与各站的码片序列进行求内积运算，若计算结果为1，则被判断的站发送了比特1，若计算结果为-1，则被判断的站发送了比特0，若计算结果为0，则被判断的站没有发送数据</p><hr><h3 id="CSMA-CD协议"><a href="#CSMA-CD协议" class="headerlink" title="CSMA/CD协议"></a>CSMA/CD协议</h3><p><strong>载波监听多址接入/碰撞检测 CSMA/CD(Carrier Sense Multiple Access/Collision Detection)</strong></p><p>适用于总线型网络</p><p>多址接入MA：多个站连接在一条总线上，竞争使用总线</p><p>载波监听CS：每一个站在发送帧之前先要检测一下总线上是否有其他站点在发送帧</p><ul><li>若检测到总线空闲96比特时间，则发送这个帧</li><li>若检测到总线忙，则继续检测并等待总线转为空闲96比特时间</li><li>96比特时间被成为帧间最小间隔，作用是使接收方可以检测出一个帧的结束</li></ul><p>碰撞检测CD：每一个正在发送帧的站边发送边检测碰撞</p><ul><li>一旦发现总线上出现碰撞，则立即停止发送，退避一段随机时间后再次发送</li></ul><p>以太网还采取一种叫做强化碰撞的措施，这就是当发送帧的站点一旦检测到碰撞，除了立即停止发送帧外，还要再继续发送32或48比特的人为干扰信号，以便有足够多的碰撞信号使所有站点都能检测出碰撞</p><hr><p><strong>争用期(碰撞窗口)</strong></p><p><img src="https://s2.loli.net/2021/12/29/8fiTbqPOtQJcFV3.png" alt="image-20210506110901740"></p><ul><li>主机最多经过<strong>$2\tau$</strong>的时长就可检测到本次发送是否遭受了碰撞</li><li>因此，以太网的端到端往返传播时延$2\tau$称为<strong>争用期或碰撞窗口</strong></li><li>经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞</li></ul><p>显然，在以太网中发送帧的主机越多，端到端往返传播时延越大，发生碰撞的概率就越大，因此，共享式以太网不能连接太多主机，使用的总线也不能太长</p><p>10Mb/s以太网把<strong>争用期定为512比特发送时间</strong>，因此其总线长度不能超过5120m，但考虑到其他因素，总线长度不能超过2500m</p><hr><p>最小帧长</p><p>以太网规定最小帧长为64字节，即512比特，如果发送的数据非常少，那么必须加入一些填充字节，使帧长不小于64字节</p><p>以太网的最小帧长确保了主机可在帧发送完成之前就检测到该帧的发送过程中是否遭遇了碰撞</p><p>如果在争用期内检测到碰撞，就立即中止发送，这时发送出的数据一定小于64字节，因此但凡长度小于64字节的帧都是由于碰撞而异常中止的无效帧</p><p><strong>最小帧长=争用期×数据传输速率</strong></p><hr><p>最大帧长</p><p>为了避免主机一直发送信息，则帧长应该有上限，以太网MAC帧的最大帧长为1518字节</p><p><img src="https://s2.loli.net/2021/12/29/xLO72BuywohQMIf.png" alt="image-20210506120334489"></p><p><img src="https://s2.loli.net/2021/12/29/AoMGOI9EY8ytHSj.png" alt="image-20210506120358536"></p><hr><p>退避时间—截断二进制指数退避算法</p><p><img src="https://s2.loli.net/2021/12/29/vFNxjfzK2oOB8gk.png" alt="image-20210506120431417"></p><p><img src="https://s2.loli.net/2021/12/29/qNiFwmjUM5yxJIr.png" alt="image-20210506120504474"></p><p>若连续多次发生碰撞，就表明可能有较多的主机参与竞争信道，但使用上述退避算法可使重传需要推迟的平均时间随重传次数而增大，因而减少发生碰撞的概率</p><p>当重传的次数达到16次仍不成功时，则表明同时打算发送帧的主机太多，以至于连续发生碰撞，则丢弃该帧</p><hr><p>信道利用率</p><p><img src="https://s2.loli.net/2021/12/29/5YQ9PFOZdGmw3XS.png" alt="image-20210506120858254"></p><p>如果各个主机发送帧都不会产生碰撞，那么在极限情况下，发送一帧占用总线的时间为$T_0+\tau$，而帧的本身的发送时间是$T_0$</p><p>所以<strong>极限信道利用率</strong>$S_{max}=\frac{T_0}{T_0+\tau}$</p><p>以太网的端距离应该短一些，帧应该长一些</p><hr><p>帧发送流程</p><p><img src="https://s2.loli.net/2021/12/29/qzU8upI49TbLjra.png" alt="image-20210506121849770"></p><p>帧接收流程</p><p><img src="https://s2.loli.net/2021/12/29/CMbPFcqB3fdXY78.png" alt="image-20210506121927621"></p><hr><h3 id="CSMA-CA协议"><a href="#CSMA-CA协议" class="headerlink" title="CSMA/CA协议"></a>CSMA/CA协议</h3><p><strong>载波监听多址接入/碰撞避免(Carrier Sense Multiple Access/Collision Avoidance)</strong></p><p>适用于无限局域网使用的协议</p><p>在无线局域网中依然可以使用载波监听多址接入，但是不能使用碰撞检测CD</p><ul><li>因为无线信道的传输条件特殊，信号强度的动态范围非常大，无线网卡上接收到的信号强度往往会远远小于发送信号的强度，如果要在无线网卡上实现碰撞检测CD，对硬件的要求非常高</li><li>即使能够在硬件上实现无线局域网的碰撞检测功能，但由于无线电波传播的特殊性，进行碰撞检测的意义也不大</li></ul><p>802.11无线局域网使用CSMA/CA协议，在CSMA的基础上增加了一个CA功能</p><p>由于不可能避免所有的碰撞，并且无线信道误码率较高，所以还使用了数据链路层确认机制(停止等待协议)来保证数据被正确接收</p><p>802.11的MAC层标准定义了两种不同的媒体接入控制方式:</p><ul><li>分布式协调功能DCF(Distributed Coordination Function) 在DCF方式下，没有中心控制站点，每个站点使用CSMA/CA协议通过争用信道来获取发送权</li><li>点协调PCF(Point Coordination Function) PCF方式，使用集中控制的接入算法，在实际中较少使用</li></ul><hr><p>帧间间隔IFS(InterFrame Space)</p><p>所有的站点必须在持续检测到信道空闲一段指定时间后才能继续发送帧，这段时间被称为帧间间隔IFS</p><p>帧间间隔的长短取决于该站点要发送的帧的类型</p><ul><li>高优先级帧等待时间短，低优先级帧等待时间长</li></ul><p><strong>短帧间间隔SIFS(28us)</strong>，是最短的帧间间隔，用来分隔开属于一次对话的各帧，一个站点应当能够在这段时间内从发送方式切换到接收方式。使用SIFS的帧类型有ACK帧，CTS帧，由过长的MAC帧分片后的数据帧，以及所有回答AP探询的帧和在PCF方式中接入点AP发送出的任何帧</p><p><strong>DCF帧间间隔DIFS(128us)</strong>，在DCF方式中用来发送数据帧和管理帧</p><hr><p>CSMA/CA协议的工作原理</p><p><img src="https://s2.loli.net/2021/12/29/5Rf6DGNXU92V1QK.png" alt="image-20210506144704769"></p><p>检测到信道空闲还要等DIFS再发送的原因是：让高优先级的帧先发送</p><p>发送第1帧后，等待SIFS后再发送的原因是：SIFS用来分隔帧和帧之间的间隔</p><p>经过DIFS，还要退避一段时间是因为：避免很多站点同时发送数据</p><p>当站点检测到信道是空闲的，并且所发送的数据帧不是成功发送完上一个数据帧之后立即发送的数据帧，则不使用退避算法</p><p>以下情况必须使用退避算法：</p><ul><li>在发送数据帧之前检测到信道处于忙状态</li><li>在每一次重传一个数据帧时</li><li>在每一次成功发送后要连续发送下一个帧时</li></ul><hr><p>退避算法</p><p>在执行退避算法时，站点为退避计时器设置一个随机的退避时间</p><ul><li>当退避计时器的时间减小到0，就可以开始发送数据</li><li>当退避计时器的时间还未减小到0，信道又转到忙状态时，就冻结退避计时器，重新等待信道变为空闲，再经过DIFS，继续启动退避计时器</li></ul><p>进行第i次退避时，退避时间在时隙编号{0,1…$2^{2+i}-1$}中随机选择一个，然后乘以基本退避时间，就可以得到随机的退避时间，当时隙编号达到255，也就是第6次退避时就不再增加</p><p><img src="https://s2.loli.net/2021/12/29/sI6Jt8frpBVbqSo.png" alt="image-20210506145615797"></p><hr><p>信道预约和虚拟载波监听</p><p>为了尽可能减少碰撞的概率和降低碰撞的影响，802.11标准允许发送数据的站点对信道进行预约</p><ol><li><p>源站在发送数据帧之前先发送一个短的控制帧，称为RTS(Request To Send)，包括源地址，目的地址以及这次通信所需的持续时间</p></li><li><p>若目的站正确收到了源站的RTS帧，且媒体空闲，就发送一个响应控制帧，称为允许发送CTS(Clear To Send )，它也包括这次通信所需的持续时间</p></li><li>源站收到了CTS帧后，在等待一段时间SIFS后，就可以发送数据帧</li><li>若目的站正确收到了源站发来的数据帧，在等待时间SIFS后，就向源站发送确认帧ACK</li></ol><p>除源站和目的站以外的其他各站，在收到CTS帧后就推迟接入无限局域网中，这样就保证了源站和目的站之间的通信不会收到其他站的干扰</p><p>如果RTS帧发生碰撞，源站就收不到CTS帧，需执行退避算法重传RTS帧</p><p><img src="https://s2.loli.net/2021/12/29/n7iSqGXpCZQVOyW.png" alt="image-20210506150303279"></p><p>由于RTS帧和CTS帧很短，发生碰撞和碰撞产生的开销很小，所以用很小的代价对信道进行预约是值得的</p><p>除了RTS和CTS会携带通信需要持续的时间，数据帧也能携带通信所需要的时间，这称为802.11的虚拟载波监听机制</p><p>利用虚拟载波监听机制，站点只要监听到RTS帧，CTS帧或数据帧中的任何一个，就能知道信道被占用的持续时间，而不需要真正监听到信道上的信号，因此虚拟载波监听可以减少隐蔽站的问题</p><p><img src="https://s2.loli.net/2021/12/29/j3FhRGpOmNLvtSw.png" alt="image-20210506150644858"></p><hr><h2 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h2><p>使用点对点的信道的数据链路层不需要地址</p><p>当多个主机连接在同一个广播信道上，要实现两个主机之间的通信，则每个主机必须有一个唯一的标识，即一个数据链路层地址</p><p>当每个主机发送的帧中必须携带标识发送主机和接收主机的地址，这类主机是用于媒体接入控制MAC的，因此这类地址被称为<strong>MAC地址</strong></p><p>MAC地址一般被固化在网卡的EEPROM中，因此也被称为硬件地址，有时也被称为物理地址，但并不意味在MAC地址属于物理层</p><p>一般情况下，用户主机会用有线网卡和无线网卡两个网络适配器，每个适配器有一个全球唯一的MAC地址，而交换机和路由器往往有更多的MAC地址，严格来说，MAC地址是对网络上各<strong>接口</strong>的唯一标识，而不是各设备的唯一标识</p><hr><p>MAC地址格式</p><p><img src="https://s2.loli.net/2021/12/29/feb57NmRES9aiod.png" alt="image-20210506151527641"></p><p><img src="https://s2.loli.net/2021/12/29/ArQCqty54JngopK.png" alt="image-20210506151613766"></p><p>字节发送顺序是从第一字节到第六字节</p><p>字节内的比特发送顺序是 $b_0$到$b_7$</p><hr><p>IEEE 802.11帧的地址字段常用格式</p><p><img src="https://s2.loli.net/2021/12/29/lC5SnzYowGgu6bM.png" alt="image-20210521202418866"></p><p><img src="https://s2.loli.net/2021/12/29/lj2Bgn4R8UDAS5i.png" alt="image-20210521202246159"></p><p>有三个地址字段，AP是无线访问接入点</p><hr><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>IP地址属于网络层</p><p>IP地址是因特网上的主机和路由器所使用的地址，用于标识两部分信息：</p><ul><li>网络编号：标识因特网上数以百计的网络</li><li>主机编号：标识同一网络上不同主机</li></ul><p>数据包转发过程中IP地址与MAC地址的变化情况</p><p><img src="https://s2.loli.net/2021/12/29/ikT94CHX7W1ALnw.png" alt="image-20210506162942242"></p><p><img src="https://s2.loli.net/2021/12/29/wK5v3F2sTOuzoGB.png" alt="image-20210506163046761"></p><p><strong>数据包转发过程中源IP地址和目的IP地址保持不变</strong></p><p><strong>数据包转发过程中源MAC地址和目的MAC地址逐个链路改变</strong></p><p>主机和路由器在转发过程中知道对方的IP地址，却不知道对方的MAC地址</p><hr><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><p>地址解析协议ARP(Address Resolution Protocol)，是根据主机IP地址获取其MAC地址的一种协议</p><p>每个主机都有自己的ARP高速缓存表，源主机在自己的ARP高速缓存表中查找目的主机的IP地址所对应的MAC地址，若找到了，则可以封装MAC帧进行发送，若找不到则发送ARP请求(封装在广播MAC帧中)</p><p><img src="https://s2.loli.net/2021/12/29/uG5wzVXpNZ3tY6g.png" alt="image-20210506164039820"></p><p><img src="https://s2.loli.net/2021/12/29/udMKqHnTvB6QIsw.png" alt="image-20210506164054208"></p><p>目的主机收到了ARP请求后，将源主机的IP地址与MAC地址记录到自己的ARP高速缓存表中，然后给源主机发送ARP响应(封装在单播MAC帧中)，ARP响应中包含有目的主机的IP地址和MAC地址</p><p><img src="https://s2.loli.net/2021/12/29/ObJFtKQg9S3X4wy.png" alt="image-20210506164323603"></p><p>源主机收到了ARP响应后，将目的主机的IP地址与MAC地址记录到自己的ARP高速缓存表中，然后就可以封装之前想发送的MAC帧并发送给目的主机</p><p><img src="https://s2.loli.net/2021/12/29/dqzKoxPVAIv6DcB.png" alt="image-20210506164333188"></p><p>ARP的作用范围：逐段链路或逐个网络使用</p><p>ARP高速缓存表中的类型分为静态和动态</p><p>静态是手工设置的，不同操作系统下的生命周期不同，动态的是自动获取的，生命周期默许为两分钟</p><p><img src="https://s2.loli.net/2021/12/29/NKb2gZ9TDV7sFSm.png" alt="image-20210506164517772"></p><p>除了ARP请求和响应外，ARP还有其他类型的报文</p><p>ARP没有安全验证机制，存在ARP欺骗问题</p><hr><h2 id="集线器和交换机"><a href="#集线器和交换机" class="headerlink" title="集线器和交换机"></a>集线器和交换机</h2><p>集线器</p><p><img src="https://s2.loli.net/2021/12/29/SmikXrgJtsa26QF.png" alt="image-20210506171827531"></p><ul><li><p>使用集线器的以太网在逻辑上仍是一个总线网，各站共享总线资源，使用的还是CSMA/CD协议</p></li><li><p><strong>集线器只工作在物理层</strong>，它的每个接口仅简单地转发比特，不进行碰撞检测</p></li><li><p>集线器一般有少量的容错能力和网络管理能力</p></li></ul><p>使用集线器HUB可以在物理层扩展以太网</p><p><img src="https://s2.loli.net/2021/12/29/n7gOZqNXyPld5j9.png" alt="image-20210506172111174"></p><p>如果某台主机想要给另一台主机发送信息，那么在域中的各个主机都会收到帧</p><hr><p>以太网交换机</p><p>在交换机中，某台主机想要给另一台主机发送信息，其他的主机不会收到信息</p><p><img src="https://s2.loli.net/2021/12/29/iOhnPEYskyGMURA.png" alt="image-20210506172451709"></p><ul><li><p>以太网一般有多种接口，每个接口都可以与直接一台主机或另一个以太网交换机相连，一般工作在全双工方式</p></li><li><p>而使用集线器的以太网在逻辑上是共享总线的，要使用CSMA/CD协议，工作在半双工方式</p></li><li><p>以太网交换机具有并行性，能同时连通多对接口，使多对主机能同时通信，无碰撞 </p></li><li>以太网交换机工作在数据链路层(也包括物理层)，它收到帧后，在帧交换表中查找帧的目的MAC地址所对应的接口号，然后通过该接口转发帧</li><li>以太网交换机是一种即插即用设备，其内部的帧交换表是通过自学习算法自动逐渐建立起来的</li><li>帧有两种转发方式：存储转发，直通交换</li></ul><p><img src="https://s2.loli.net/2021/12/29/chaJdX7ToYDmNPl.png" alt="image-20210506173122785"></p><p><img src="https://s2.loli.net/2021/12/29/d43DzCnmvlXNpih.png" alt="image-20210506173203078"></p><hr><h2 id="交换机自学习和转发帧"><a href="#交换机自学习和转发帧" class="headerlink" title="交换机自学习和转发帧"></a>交换机自学习和转发帧</h2><p>以太网交换机自学习和转发帧的流程：</p><p>1.收到帧后登记。登记的内容为帧的源MAC地址及进入交换机的接口号</p><p><img src="https://s2.loli.net/2021/12/29/vDa7MSbGOQdNpIE.png" alt="image-20210506182814674"></p><p>2.根据帧的目的MAC地址和交换机的帧交换表对帧进行转发，有以下3种情况</p><ul><li>明确转发：交换机知道从哪个接口转发该帧</li></ul><p><img src="https://s2.loli.net/2021/12/29/myzKd8sUTYrq1Ca.png" alt="image-20210506182948250"></p><ul><li>盲目转发：交换机不知道应当从哪个端口转发帧，只能将其通过除进入交换机的接口外的其他所有接口转发（也称为泛洪）</li></ul><p><img src="https://s2.loli.net/2021/12/29/C2aWrMvx4TtupNJ.png" alt="image-20210506183112004"></p><ul><li>明确丢弃：交换机知道不应该转发该帧，将其丢弃</li></ul><p><img src="https://s2.loli.net/2021/12/29/VCXqkh26mrsRKPc.png" alt="image-20210506183245013"></p><p>帧交换机中每条记录都有自己的有效时间，到期删除，原因如下</p><ul><li>交换机的接口改接了另一台主机</li><li>主机更换了网卡</li></ul><hr><h2 id="以太网交换机的生成树协议STP"><a href="#以太网交换机的生成树协议STP" class="headerlink" title="以太网交换机的生成树协议STP"></a>以太网交换机的生成树协议STP</h2><p>为了提高以太网的可靠性，可以添加冗余链路来提高以太网的容错率</p><p><img src="https://s2.loli.net/2021/12/29/KNwJosM5pB2fPch.png" alt="image-20210506183936821"></p><p>但是冗余链路会形成网络环路，导致很多问题</p><ul><li>广播风暴 大量消耗网络资源，使网络无法正常转发其他数据帧</li><li>主机会收到重复的广播帧</li><li>交换机的帧交换表震荡</li></ul><p>为了可以在增加网络可靠性的同时，有避免网络环路带来的问题，我们可以使用生成树协议STP(Spanning Tree Protocol)</p><ul><li>STP可以自动计算并构建一个在逻辑上没有环路的网络，其逻辑拓扑结构必须是树型</li><li>最终生成的树型逻辑拓扑要确保连通整个网络</li><li>当首先连接交换机或网络物理拓扑发生变化时，交换机都将进行生成树的重新计算</li></ul><p><img src="https://s2.loli.net/2021/12/29/UrleYB7P8jEdhDm.png" alt="image-20210506184809995"></p><hr><h2 id="虚拟局域网VLAN"><a href="#虚拟局域网VLAN" class="headerlink" title="虚拟局域网VLAN"></a>虚拟局域网VLAN</h2><p>使用一个或多个以太网交换机互连起来的交换式以太网，其所有站点都属于同一个广播域</p><p>巨大的广播域会带来很多弊端，因为在网络会频繁的出现广播信息</p><p>所以需要分割广播域</p><ul><li>使用路由器可以隔离广播域</li></ul><p><img src="https://s2.loli.net/2021/12/29/5MDCYIJQF67cpyk.png" alt="image-20210506185804509"></p><p>但是路由器的成本较好</p><ul><li>使用VLAN来分隔广播域</li></ul><p>虚拟局域网VLAN(Virtual Local Area Network)是一种将局域网内的设备划分成与物理位置无关的逻辑组的技术，这些逻辑组具有某些共同的需求</p><p><img src="https://s2.loli.net/2021/12/29/csFQB4bOE9Mmrae.png" alt="image-20210506190027134"></p><hr><p>实现机制</p><p>IEEE 802.1帧对以太网的MAC帧格式进行了扩展，插入了4字节的VLAN标记</p><p><img src="https://s2.loli.net/2021/12/29/452xEhRAklHbCs6.png" alt="image-20210506190137136"></p><p>VLAN标记的最后12比特称为VLAN标识符VID，唯一地标识了以太网帧属于哪一个VLAN</p><p>VID的有效取值为1~4094，802.1Q帧是由交换机来处理的，而不是用户主机来处理的，当交换机收到普通的以太网帧时，会插入4字节的VLAN标记，称为打标签</p><p>当交换机转发802.1Q帧，<strong>可能</strong>会删除4字节的VLAN标记转变为普通的以太网帧</p><hr><p>交换机的端口类型有以下3种：</p><ul><li>Access</li><li>Trunk</li><li>Hybrid</li></ul><p>交换机各端口的默认VLAN ID</p><p>在华为交换机上称为Port VLAN ID，即端口VLAN ID，简记为PVID</p><p><img src="https://s2.loli.net/2021/12/29/cPloE2pKvCSGxbN.png" alt="image-20210506190827177"></p><p>Access端口</p><ul><li><p>Access端口一般用于连接用户计算机</p></li><li><p>Access端口只能属于一个VLAN</p></li><li><p>Access端口的PVID值与端口所属VLAN的ID相同</p></li><li><p>Access端口接收处理方法：一般只接收未打标签的普通以太网帧，根据接收帧的端口PVID给帧打标签，字段中的VID取值与端口的PVID取值相等</p></li><li><p>Access端口发送处理方法：若帧中的VID与端口的PVID相等，则去标签并且转发该帧，否则不转发</p></li></ul><p><img src="https://s2.loli.net/2021/12/29/DAWpPH6BlhSGtga.png" alt="image-20210506191156814"></p><p>Trunk端口</p><ul><li><p>Trunk端口一般用于交换机之间或交换机与路由器之间的互连</p></li><li><p>Trunk端口可以属于多个VLAN</p></li><li><p>用户可以设置Trunk端口的PVID值，默认情况下，Trunk端口的PVID值为1</p></li></ul><p><img src="https://s2.loli.net/2021/12/29/iWNoAMZ69ItVrbk.png" alt="image-20210506191803866"></p><ul><li>Trunk端口发送处理方法：对VID等于PVID的帧，去标签转发</li><li>Trunk端口接收处理方法：接收未打标签的帧，根据接收帧的端口的PVID给帧打标签，字段中的VID取值与端口中的PVID取值相等</li></ul><hr><p>华为的Hybrid端口</p><p>用户可以设置Hybrid端口中的PVID值</p><p>Hybrid端口发送处理方法</p><p>查看帧的VID是否在端口的去标签列表中：</p><p>若存在，则去标签后转发，若不存在，则直接转发</p><p><img src="https://s2.loli.net/2021/12/29/OVG8PNxL4nWfe7a.png" alt="image-20210506193153467"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.物理层</title>
      <link href="/post/38801.html"/>
      <url>/post/38801.html</url>
      
        <content type="html"><![CDATA[<h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><img src="https://s2.loli.net/2021/12/28/Qni2LAWXguIrHfS.png" alt="image-20210427211044376"></p><p>物理层的作用是解决在各种传输媒体上传输比特0和1的问题</p><p>物理层的接口主要有以下4个特性：</p><p>机械特性：指明接口所用接线器的形状和尺寸，引脚数目和排列，固定和锁定装置</p><p>电气特性：指明在接口电缆的各条线上出现的电压的范围</p><p>功能特性：指明某条线上出现的某一电平表示何种意义</p><p>过程特性：指明对于不同功能的各种可能事件的出现顺序</p><p>物理层的协议比较多，都包含了以上4种特性，需要掌握特性，而不是具体协议</p><hr><h2 id="传输媒体"><a href="#传输媒体" class="headerlink" title="传输媒体"></a>传输媒体</h2><p>传输媒体并不属于互联网的体系结构，处于物理层之下</p><p>导引型传输媒体</p><p><img src="https://s2.loli.net/2021/12/28/Y32oDNV4FSAsUWT.png" alt="image-20210427211851913"></p><p>非导引型传输媒体</p><p><img src="https://s2.loli.net/2021/12/28/e9oZ1RIKHjLOxf5.png" alt="image-20210427211908326"></p><hr><h2 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h2><h3 id="串行传输与并行传输"><a href="#串行传输与并行传输" class="headerlink" title="串行传输与并行传输"></a>串行传输与并行传输</h3><p>串行传输是指数据是一个比特一个比特依次发送，在发送和接收端直接，只需要1条传输线路</p><p><img src="https://s2.loli.net/2021/12/28/8MlFadYIwzUsRD7.png" alt="image-20210427212050037"></p><p>并行传输是指数据是一次发送n个比特，在发送和接收端之间需要n条传输线路</p><p><img src="https://s2.loli.net/2021/12/28/6Fjy7Rvpw8Efoeq.png" alt="image-20210427212142899"></p><p>一般电脑之间的远距离传输是串行传输，而电脑内部之间，CPU和内存之间通过总线进行并行传输</p><hr><h3 id="同步传输与异步传输"><a href="#同步传输与异步传输" class="headerlink" title="同步传输与异步传输"></a>同步传输与异步传输</h3><p>同步传输是指数据块以稳定的比特流的形式进行传输，字节之间没有间隔</p><p><img src="https://s2.loli.net/2021/12/28/CUrw4J7Xzg2aZ5Q.png" alt="image-20210427212341718"></p><p>接收端在比特信号的中间时刻进行检测，来判断是比特0还是比特1</p><p>由于不同设备的时钟不同，累计误差会导致判别错位</p><p><img src="https://s2.loli.net/2021/12/28/YdyXljM7wkmPzZ8.png" alt="image-20210427212513348"></p><p>所以需要采用方法使收发双方同步</p><p>外同步：在收发双方之间添加一条单独的时钟信号线</p><p>内同步：发送端将时钟同步信号编码到发送数据中一起传输(例如曼彻斯特编码)</p><p>异步传输：让字节作为独立的传输单位，字节之间的时间间隔不是固定的</p><p><img src="https://s2.loli.net/2021/12/28/AsqM68vzcLKPeUV.png" alt="image-20210427212802907"></p><p>接收端仅在每个字节的起始处对字节内的比特实现同步，为此通常在每个字节前后加上起始位和结束位</p><p><img src="https://s2.loli.net/2021/12/28/JA2xmi5MrTBFP1s.png" alt="image-20210427212900846"></p><p>异步是指字节之间异步(间隔不是固定的)</p><hr><h3 id="单工，半双工，全双工通信"><a href="#单工，半双工，全双工通信" class="headerlink" title="单工，半双工，全双工通信"></a>单工，半双工，全双工通信</h3><p>单工通信：又称为单向通信</p><p><img src="https://s2.loli.net/2021/12/28/D4d6cPrvSICfUEb.png" alt="image-20210427213158360"></p><p>半双工通信：又称为双向交替通信，双方设备可以交换信息，但不能同时进行</p><p><img src="https://s2.loli.net/2021/12/28/I69ofsPFG1axByU.png" alt="image-20210427213134387"></p><p>全双工：又称为双向同时通信，双方设备可以同时通信</p><p><img src="https://s2.loli.net/2021/12/28/1hMaTFxNdverYC5.png" alt="image-20210427213247983"></p><hr><h2 id="编码和调制"><a href="#编码和调制" class="headerlink" title="编码和调制"></a>编码和调制</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>消息（message)：计算机要处理的文字，图片等</p><p>数据（data）：是运送消息的实体</p><p>信号（signal）：是数据的电磁表现</p><p>基带信号：是信源发出的原始电信号</p><p><img src="https://s2.loli.net/2021/12/28/whJLsHBgID4zbjk.png" alt="image-20210427224355044"></p><p>基带信号又分数字基带信号和模拟基带信号，都能够进行编码和调制</p><p>将基带信号变成数据信号的过程叫做编码</p><p>将基带信号变成模拟信号的过程叫做调制</p><p><img src="https://s2.loli.net/2021/12/28/Qfn3MOX9YrKkhNe.png" alt="image-20210427225310553"></p><p><strong>码元</strong>：在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形</p><p><img src="https://s2.loli.net/2021/12/28/G9VAxtjfTZrLzQe.png" alt="image-20210427225542783"></p><hr><h3 id="常用编码"><a href="#常用编码" class="headerlink" title="常用编码"></a>常用编码</h3><p>1.不归零编码NRZ：用正电平和负电平来表示</p><p><img src="https://s2.loli.net/2021/12/28/B3ITsUpHZw8b2Xk.png" alt="image-20210427225904493"></p><p>当接受到连续信号的时候，系统需要判断码元的个数，这需要额外的一根传输线来传输时钟信号，使发送方和接受方同步</p><p>然而对于计算机网络，这根线用来传输数字信号也不会来传输时钟信号，所以不用</p><hr><p>2.归零编码RZ：用正电平，负电平，零电平表示</p><p><img src="https://s2.loli.net/2021/12/28/SwZAUavTNfkuhjm.png" alt="image-20210427230347670"></p><p>每个码元传输结束后信号都要归零，所以接收放只要在信号归零后进行采样即可，不需要时钟信号，实际上，这相当于将时钟信号用归零方式编码在了数据之内，这称为<strong>自同步</strong>信号</p><p>但是，归零编码中的大部分数据带宽都用来归零了，编码效率低</p><hr><p>3.<strong>曼彻斯特编码</strong>：在每个码元的中间时刻信号都会发生跳变，根据跳变的方向来判断比特</p><p><img src="https://s2.loli.net/2021/12/28/1ijDMuf8WovU2Ge.png" alt="image-20210427231357417"></p><p>码元中间时刻的跳变既可以表示时钟，又可以表示数据</p><p>是传统以太网的编码方式</p><hr><p>4.差分曼彻斯特编码：每个码元的中间时刻信号会跳变，但是只表示时钟信号，根据码元开始处电平是否变化表示数据</p><p><img src="https://s2.loli.net/2021/12/28/BojK4kYe9b6VqAh.png" alt="image-20210427231909998"></p><p>比曼彻斯特编码变化少，更适合较高的传输速率</p><hr><h3 id="基本调制方法"><a href="#基本调制方法" class="headerlink" title="基本调制方法"></a>基本调制方法</h3><p>可以调幅，调频，调相</p><p><img src="https://s2.loli.net/2021/12/28/Pp8SDcoOLe7gnhH.png" alt="image-20210428000528585"></p><p>使用基本调制方法，1个码元只能包含1个比特信息</p><p>如果要让一个码元包括更多的比特，可以使用混合调制</p><p>因为频率和相位是相关的，即频率是相位随时间的变化率，所以不能一起混合调制</p><p>混合调制可以让相位和振幅一起调制，称为<strong>正交振幅调制QAM</strong> </p><hr><p>举例 QAM16</p><p>可以有12种相位，每种相位有1或2种振幅可选</p><p><img src="https://s2.loli.net/2021/12/28/KghFbVqRElCiwdT.png" alt="image-20210428001140955"></p><p>QAM可以调制出16种码元，每种码元可以表示$log_216=4$种比特</p><p><img src="https://s2.loli.net/2021/12/28/OBPNrndpRlyuEI3.png" alt="image-20210428001350815"></p><p>码元与4个比特的对应关系采用格雷码，任意两个相邻码元只有1个比特不同</p><hr><h2 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h2><p>信号在信道中传输的一般都会失真，当失真严重的时候就无法判断信号</p><p>造成信号的失真因素主要有：</p><ul><li>码元传输</li><li>信号传输距离</li><li>噪声干扰</li><li>传输媒体质量</li></ul><hr><p><strong>奈氏准则：在假定的理想条件下，为了避免码间串扰，码元传输速率是有上限的</strong></p><p>理想低通信道的最高码元传输速率=2W Baud=2W码元 /秒</p><p>理想带通信道的最高码元传输速率=W Baud=W码元/秒</p><p>W：信号带宽 </p><p>Baud：波特，即码元/秒</p><p>低通信道和带通信道的区别是：低通信道只有上限，而带通信道有上下限</p><p>码元的传输速率又称波特率，与比特率之间有一定关系</p><p>当1个码元携带n比特的信息量时，则波特率换成比特率时，数值要乘以n</p><p>要提高信息传输速率，就必须设法让每一个码元携带更多个比特的信息，这需要多元调制</p><hr><p>信道的极限信息传输速率还要受限于实际的信号在信道中传输时的信噪比</p><p><strong>香农公式</strong>：<strong>带宽受限且有高斯白噪声干扰的信道的极限信息传输速率</strong></p><p><strong>$c=W×log_2(1+S/N)$</strong></p><p>C：信道的极限信息传输速率</p><p>W：信号带宽</p><p>S：信道内所传信号的平均功率</p><p>N：信道内的高斯噪声功率</p><p>S/N：信噪比，使用分贝(dB)作为度量单位 =$10×log_{10}(S/N)$</p><p>信道带宽或信道中信噪比越大，信号的极限传输速率越高</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.计算机网络—概述</title>
      <link href="/post/21933.html"/>
      <url>/post/21933.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络—概述"><a href="#计算机网络—概述" class="headerlink" title="计算机网络—概述"></a>计算机网络—概述</h1><h2 id="因特网"><a href="#因特网" class="headerlink" title="因特网"></a>因特网</h2><p>网络：由若干结点(Node)和连接这些结点的链路(Link)组成</p><p>互联网：多个网络可以通过<strong>路由器</strong>互连起来，这样就构成了一个覆盖范围更大的网络，即互联网，所以互联网是网络的网络</p><p>因特网：是世界上最大的互联网络</p><p>internet：是一个通用名词，泛指由多个计算机连接的网络，这些网络之间的协议可以是任意的</p><p>Internet：是一个专有名词，指当前全球最大，开放的，由众多网络相互连接成的特定计算机网络，采用TCP/IP协议族作为基本规则</p><hr><p>ISP(Internet Service Provider)：<strong>因特网服务提供者</strong></p><p>因特网协会ISOC是一个国际性组织，负责对因特网进行全面管理，以及在世界范围内促进其发展和使用</p><hr><p>因特网由边缘部分和核心部分组成</p><p>边缘部分：由所有连接在因特网上的主机组成。这部分是用户直接使用的，用来进行通信</p><p>核心部分：有大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的</p><p><img src="https://s2.loli.net/2021/12/28/WO5IqkdV269eKYi.png" alt="image-20210426193841099"></p><hr><h2 id="信息交换方式"><a href="#信息交换方式" class="headerlink" title="信息交换方式"></a>信息交换方式</h2><p>电路交换(Circuit Switching)</p><p>电话交换机接通电话线的方式称为电路交换</p><p><img src="https://s2.loli.net/2021/12/28/qsZg7Ul9v6ezMK2.png" alt="image-20210426194030792"></p><p>当使用电路交换来传送计算机数据的时候，线路的传输效率很低</p><p><img src="https://s2.loli.net/2021/12/28/CmKzcyW9j5A21QJ.png" alt="image-20210426194551234"></p><hr><p>分组交换(Packet Switching)</p><p><img src="https://s2.loli.net/2021/12/28/7tPchzVH3Ose5RB.png" alt="image-20210426194357711"></p><p>由发送方 中转方 接收方组成</p><p><img src="https://s2.loli.net/2021/12/28/chOA1R9Pvf7JGmI.png" alt="image-20210426194430256"></p><p><img src="https://s2.loli.net/2021/12/28/qijTFte94YaphCR.png" alt="image-20210426194625967"></p><hr><p>报文交换不多介绍，用与早期通信网络的交换方式</p><p><img src="https://s2.loli.net/2021/12/28/cHpI9xwVaz8ouMK.png" alt="image-20210426194608172"></p><hr><h2 id="计算机网络的定义和分类"><a href="#计算机网络的定义和分类" class="headerlink" title="计算机网络的定义和分类"></a>计算机网络的定义和分类</h2><p>计算机网络并没有一个准确的定义</p><p>简单定义：一个互相连接的，自治的计算机的集合</p><p>较好定义：计算机网络主要是由一些通用的，可编程的硬件互联而成的，而这些硬件并非专门用来实现某一特定目的的。这些可编程硬件能够用来传送多种不同类型的数据,并能支持广泛和日益增长的应用</p><hr><p>计算机网络的分类</p><p>按交换技术分类:电路交换网络 报文交换网络 分组交换网络</p><p>按使用者分类：公用网 专用网</p><p>按传输介质分类：有线网络 无线网络</p><p>按覆盖范围分类：广域网（WAN） 城域网（MAN）局域网（LAN）个域网（PAN）</p><p>按拓扑结构分类：</p><p>总线型网络</p><p><img src="https://s2.loli.net/2021/12/28/BmqzGrhKVHDlNMi.png" alt="image-20210426195243863"></p><p>星型网络</p><p><img src="https://s2.loli.net/2021/12/28/BH1IMoFSkLAi6Rf.png" alt="image-20210426195255906"></p><p>环形网络</p><p><img src="https://s2.loli.net/2021/12/28/7YAZJnjK8eDqk2E.png" alt="image-20210426195312257"></p><p>网状型网络</p><p><img src="https://s2.loli.net/2021/12/28/ovNhu8Z7AqVXjGB.png" alt="image-20210426195357462"></p><hr><h2 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h2><p>包含有8个指标：速率 带宽 吞吐量 时延 时延带宽积 往返时间 利用率 丢包率</p><h3 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h3><p>比特是计算机中数据量的单位 </p><p><img src="https://s2.loli.net/2021/12/28/JA65US1bxjXBueE.png" alt="image-20210426200048122"></p><p>速率：连接在计算机网络主机在数字信道传送比特的速率，也称比特率</p><p>​                                <img src="https://s2.loli.net/2021/12/28/ZAWO8gYXhn5GqVR.png" alt="image-20210426200224343"></p><p>特别要注意的是，<strong>速率中的k和数据量中的K含义是不同的</strong></p><p>数据量中的K表示$2^{10}$,而在数据率中表示$10^3$</p><p>所以如果100MB的数据，网卡的发送速率为100Mbps，那么需要几秒传输成功呢？</p><p>首先需要把100MB换算成bit，那么就是$2^{10}<em>2^{10}</em>100=2^{20}<em>100B=2^{20}</em>8*100bit$</p><p>而100Mbps代表每秒传输$100<em>10^{3}</em>10^{3}=1*10^{8}bit$</p><p>所以需要$(8<em>2^{20}</em>100)/(1*10^8)s\approx8.388s$</p><p>有时候可以估算，将1M估算为$10^{6}$</p><hr><h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><p>用来表示网络的通信线路所能传送数据的能力，因此网络带宽表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据率”</p><p>单位：b/s(kb/s,Mb/s)</p><hr><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p>表示在单位时间内通过某个网络的数据量</p><hr><h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><p>时延即是指：分组从源主机传送到目的主机的过程中，花费的时间</p><p>时延一般有3种</p><p>主机将分组发送到传播线路的时间叫做发送时延，发送时延=分组长度(b)/发送速率(kb/s)</p><p>分组在传输线路中传送的时间叫传播时延，传播速率=传播距离/传播速度</p><p>分组被中间的路由器处理的时间叫做处理时延，一般不计算</p><p>而主要的时延有可能是发送时延，也有可能是传播时延，依据具体情况而定</p><hr><h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><p>时延带宽积=传播时延×带宽</p><p><img src="https://s2.loli.net/2021/12/28/xACMBco7zlqPJgT.png" alt="image-20210426203253222"></p><p>又称为以比特为单位的链路长度</p><hr><h3 id="往返时间"><a href="#往返时间" class="headerlink" title="往返时间"></a>往返时间</h3><p>RTT(Round-Trip-Time)：指源主机发送分组开始，直到源主机又确认到来自目的的主机确认分组为止</p><hr><h3 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h3><p>信道利用率：表示某信道有百分之几的时间是被利用的</p><p>网络利用率：全网络的信道利用率的加权平均</p><p>当某信道的利用率增大的时，信道引起的时延也会增加，所以利用率不是越高越好</p><p>如果用$D_0$表示网络空闲时的时延，D表示网络当前的时延，那么在适当的假定条件下，<img src="https://s2.loli.net/2021/12/28/FVvSY1LBialNeUX.png" alt="image-20210426203841917"></p><p>当网络的利用达到50%的时候，时延就要加倍</p><p><img src="https://s2.loli.net/2021/12/28/zJP9hgYfdKSuZ7k.png" alt="image-20210426203914101"></p><hr><h3 id="丢包率"><a href="#丢包率" class="headerlink" title="丢包率"></a>丢包率</h3><p>丢包率是指分组丢失率，在一定的时间范围内，传输过程中丢失的分组数量与总分组数量的比率</p><hr><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><p>OSI体系结构</p><p><img src="https://s2.loli.net/2021/12/28/Zp8AhTvDr2COW1E.png" alt="image-20210426204242730"></p><p>是法律上的国际标准</p><hr><p>TCP/IP体系结构</p><p><img src="https://s2.loli.net/2021/12/28/pP9j1RDwsmdvLSz.png" alt="image-20210426204319691"></p><p>是事实上的国际标准</p><hr><p>原理体系结构</p><p><img src="https://s2.loli.net/2021/12/28/ArsxIQqzBkHbcVN.png" alt="image-20210426205055288"></p><p>用于教学</p><hr><h3 id="分层的必要性"><a href="#分层的必要性" class="headerlink" title="分层的必要性"></a>分层的必要性</h3><p>考虑一个问题，电脑之间如何实现通信？</p><p>1.肯定是先考虑采用什么物理介质来连接电脑，比如，光纤，双绞线网线</p><p>以及采用什么样的物理接口，用什么样的信号来表示bit</p><p>这些问题都属于<strong>物理层</strong></p><p><img src="https://s2.loli.net/2021/12/28/UgYIGa62MbLurNX.png" alt="image-20210426205402002"></p><hr><p>2.一般来说，计算机网络是由多台电脑组成的，直接通过总线联络，假设已经解决了物理层的问题了，那么在总线中传输的时候，主机如何知道数据是否是发给自己的呢？</p><p>这就涉及到如何标识网络中各个主机的问题了，主机如何从一连串比特中区分地址和数据。</p><p>这些问题属于<strong>数据链路层</strong></p><p><img src="C:/Users/烛/AppData/Roaming/Typora/typora-user-images/image-20210426205700188.png" alt="image-20210426205700188"></p><hr><p>当解决了物理层和数据链路层之后，我们就可以在一个网络中通信了，然后当今互联网被称为网络的网络，由很多个网络组成，所以在互联网中通信的时候，我们还需要考虑如何标识网络的问题</p><p>如何标识各网络以及网络中的各主机（IP地址）</p><p>路由器如何转发分组，如何进行路由选择的问题</p><p>这些问题属于<strong>网络层</strong></p><p><img src="https://s2.loli.net/2021/12/28/fWY4ljbX9Va3LZB.png" alt="image-20210426210448356"></p><hr><p>解决了以上3层，就可以实现分组在网络之间传输了</p><p>然后这还不够，如果电脑中运行有多个进程，电脑收到了分组后，如何判断分组是那个进程所需要的呢？</p><p>如何解决进程之间的网络通信问题？</p><p>以及加入路由器在丢包，那么该如何处理</p><p>这些问题都属于<strong>运输层</strong></p><p><img src="https://s2.loli.net/2021/12/28/i7XIlbYdZURt59G.png" alt="image-20210426210648645"></p><hr><p>解决了以上4层，就可以实现进程之间基于网络的通信了</p><p>在此基础上，只需要制定各种应用层协议 ，并根据应用进程之间的交互来编写特定的网络应用程序，就可以来完成特定的网络应用</p><p>比如有支持万维网应用的HTTP协议</p><p>支持电子邮件的SMTP协议</p><p>支持文件传输的FTP协议等</p><p>这些问题全部属于<strong>应用层</strong></p><p><img src="https://s2.loli.net/2021/12/28/lpdNzaSQ9u8wbeR.png" alt="image-20210426210942288"></p><hr><p>总的概况</p><p><img src="https://s2.loli.net/2021/12/28/x8dn21au5PKXUh6.png" alt="image-20210426211033451"></p><hr><h3 id="专用术语"><a href="#专用术语" class="headerlink" title="专用术语"></a>专用术语</h3><p>实体：指任何发送或接受信息的硬件或软件进程</p><p>对等实体：收发双方相同层次中的实体</p><p><img src="https://s2.loli.net/2021/12/28/HSk6elzEKx2Qvwr.png" alt="image-20210426211817282"></p><hr><p>协议：控制两个对等实体进行逻辑通信的规则的集合·</p><p>协议包括三要素 语法 语义 同步</p><p>语法 定义所交换信息的格式</p><p>语义  定义收发双方所要完成的操作</p><p>同步 定义收发双方的时序关系</p><hr><p>在协议的控制下，两个对等实体间的逻辑通信使得本层能够向上一层提供服务，很明显，协议是水平的，服务是垂直的</p><p><img src="https://s2.loli.net/2021/12/28/iFgaMKxwtI7QuT9.png" alt="image-20210426213108478"></p><p>服务访问点：在统一系统中相邻两层的实体交换信息的逻辑接口</p><p>服务原语：上层使用下层所提供的服务必须通过与下层交换一些指令，这些命令称为服务原语</p><p><strong>协议数据单元PDU：对等层次之间的数据包称为该层的协议数据单元</strong></p><p>服务数据单元SDU：同一系统内，层与层之间交换的数据包称为服务数据单元</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>408操作系统大题解析</title>
      <link href="/post/24355.html"/>
      <url>/post/24355.html</url>
      
        <content type="html"><![CDATA[<h1 id="408操作系统大题解析"><a href="#408操作系统大题解析" class="headerlink" title="408操作系统大题解析"></a>408操作系统大题解析</h1><h2 id="进程同步问题"><a href="#进程同步问题" class="headerlink" title="进程同步问题"></a>进程同步问题</h2><p>首先需要知道的是，进程同步问题大多都是从信号量机制出发，考查对一段程序进行PV操作</p><p>在阅读题目时，一定要想信号量机制的应用,找出并标记出来</p><ul><li>互斥问题</li><li>同步问题</li><li>前驱关系</li></ul><p><img src="https://s2.loli.net/2021/12/28/T594luQEyhnJgfc.png" alt=""></p><p>此题很明显的看可以初看，很像是生产者–消费者的变形，区别只是在于生产者生成的东西，只能给部分消费者使用</p><p>所以根据生成的数字，通知相应的进程即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 互斥关系 ：对缓冲区的使用 mutex=1</span></span><br><span class="line"><span class="comment">// 前驱关系：缓冲内有数字，才能取出  odd,even=0</span></span><br><span class="line"><span class="comment">//          缓冲区未满才能往里面放置   empty=N</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">semaphore mutex=<span class="number">1</span>;</span><br><span class="line">semaphore odd=<span class="number">0</span>,even=<span class="number">0</span>;</span><br><span class="line">sempahore empty=N</span><br><span class="line">    cobegin&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        x=produce();</span><br><span class="line">        P(empty);</span><br><span class="line">        P(mutex);</span><br><span class="line">        Put();</span><br><span class="line">        V(mutex);</span><br><span class="line">        <span class="keyword">if</span>(x%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">            V(even);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            V(odd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Process <span class="title">P2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span><span class="params">(True)</span></span>&#123;</span><br><span class="line">        P(odd);</span><br><span class="line">        P(mutex);</span><br><span class="line">        getodd();</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(empty);</span><br><span class="line">        countodd();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Process <span class="title">P3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span><span class="params">(True)</span></span>&#123;</span><br><span class="line">        P(even);</span><br><span class="line">        P(mutex);</span><br><span class="line">        geteven();</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(empty);</span><br><span class="line">        countodd();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p><img src="https://s2.loli.net/2021/12/28/hJyaWC9K5FVXj8s.png" alt="image-20210813162810061"></p><p>仅有一个进程，自然就没有进程之间的同步问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 互斥关系：对门的使用 mutex=1</span></span><br><span class="line"><span class="comment">// 前驱关系：只有博物馆人数未满才能进门  x=500</span></span><br><span class="line"></span><br><span class="line">cobegin</span><br><span class="line">    参观者进程i&#123;</span><br><span class="line">    P(x); </span><br><span class="line">    P(mutex);</span><br><span class="line">    进门</span><br><span class="line">    V(mutex);</span><br><span class="line">    参观</span><br><span class="line">    P(mutex);</span><br><span class="line">    出门</span><br><span class="line">    V(mutex);</span><br><span class="line">    V(x);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p><img src="https://s2.loli.net/2021/12/28/AgXWN1jFMSObaUf.png" alt="image-20210813163352677"></p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//互斥关系：对取号机的使用   mutex=1</span></span><br><span class="line"><span class="comment">//前驱关系：必须有位置，顾客才能坐下  x=10</span></span><br><span class="line"><span class="comment">//         必须有顾客，营业员才能服务  y=0</span></span><br><span class="line"><span class="comment">//同步关系：顾客被叫到服务和营业员叫顾客服务之间的同步 service=0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cobegin()&#123;</span><br><span class="line">    Process 顾客</span><br><span class="line">    &#123;</span><br><span class="line">        P(x);</span><br><span class="line">        P(mutex);</span><br><span class="line">        取号</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(y);</span><br><span class="line">        P(servive);</span><br><span class="line">        接受服务</span><br><span class="line">    &#125;</span><br><span class="line">    Process 营业员</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(True)&#123;</span><br><span class="line">            P(y);</span><br><span class="line">            V(service);</span><br><span class="line">            V(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;coend</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p><img src="https://s2.loli.net/2021/12/28/Ek6pm3DJOGatjWZ.png" alt="image-20210813164949915"></p><p>在原来的消费者生产者问题上，新加了一个限制条件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//互斥问题：对缓冲区的使用 mutex1=1</span></span><br><span class="line"><span class="comment">//         消费者之间的互斥 mutex2=1</span></span><br><span class="line"><span class="comment">//前驱关系：缓冲区必须有空，才能往里面放东西 x=1000</span></span><br><span class="line"><span class="comment">//         缓冲区必须有产品，才能从里面拿东西 y=0</span></span><br><span class="line">producer()[</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        produce();</span><br><span class="line">        P(x);</span><br><span class="line">        P(mutex2);</span><br><span class="line">        input;</span><br><span class="line">        V(mutex2);</span><br><span class="line">        V(y);</span><br><span class="line">    &#125;</span><br><span class="line">    comsumer()&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    P(mutex1)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            P(y);</span><br><span class="line">            P(mutex2);</span><br><span class="line">            output;</span><br><span class="line">            V(mutex2);</span><br><span class="line">            V(x);</span><br><span class="line">            consumer;</span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex1);        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p><img src="https://s2.loli.net/2021/12/28/mNBflvC7X5ysZWb.png" alt="image-20210813165921622"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相当于是两个生产者和消费者进程</span></span><br><span class="line"><span class="comment">/*互斥关系：对邮箱A和邮箱B的使用 mutex1=1,mutex2=1</span></span><br><span class="line"><span class="comment">  前驱关系:只有邮箱A有邮件才能从里面取出来 fullA=x</span></span><br><span class="line"><span class="comment">          只有邮件A未满才能往里面放邮件   emptyA=M-x</span></span><br><span class="line"><span class="comment">          只有邮箱B有邮件才能从里面取出来 fullB=y</span></span><br><span class="line"><span class="comment">          只有邮件B未满才能往里面放邮件   emptyB=N-y</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">A&#123;</span><br><span class="line">    <span class="keyword">while</span>(True)&#123;</span><br><span class="line">        P(fullA);</span><br><span class="line">        p(mutex1);</span><br><span class="line">        从A的信箱中取出一个邮件</span><br><span class="line">        V(mutex1);</span><br><span class="line">        V(emptyA);</span><br><span class="line">        回答问题并提出一个新问题</span><br><span class="line">        P(emptyB);</span><br><span class="line">        p(mutex2);</span><br><span class="line">        将新邮件放入B的信箱</span><br><span class="line">        V(mutex2);</span><br><span class="line">        V(fullB);</span><br><span class="line">           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">B&#123;</span><br><span class="line">    <span class="keyword">while</span>(True)&#123;</span><br><span class="line">        P(fullB);</span><br><span class="line">        p(mutex2);</span><br><span class="line">        从B的信箱中取出一个邮件</span><br><span class="line">        V(mutex2);</span><br><span class="line">        V(emptyB);</span><br><span class="line">        回答问题并提出一个新问题</span><br><span class="line">        P(emptyA);</span><br><span class="line">        p(mutex1);</span><br><span class="line">        将新邮件放入B的信箱</span><br><span class="line">        V(mutex1);</span><br><span class="line">        V(fullA);</span><br><span class="line">           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p><img src="https://s2.loli.net/2021/12/28/3ZaRLC7ibtxnKXz.png" alt="image-20210813180656033"></p><p>这种程序题首先要搞清楚的就是，修改变量的互斥关系</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只有线程3在修改变量，所以要关注线程12与3的</span></span><br><span class="line"><span class="comment">// 线程1和线程3关于y互斥 mutex1=1</span></span><br><span class="line"><span class="comment">// 线程2和线程3关于y，z互斥 mutex2=1 mutex3=1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">thread1&#123;</span><br><span class="line">    cnum w;</span><br><span class="line">    P(mutex1);</span><br><span class="line">    w=add(x,y);</span><br><span class="line">    V(mutex1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">thread2&#123;</span><br><span class="line">    cnum w;</span><br><span class="line">    P(mutex2);</span><br><span class="line">    P(mutex3);</span><br><span class="line">    w=add(y,z);</span><br><span class="line">    V(mutex3);</span><br><span class="line">    V(mutex2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">thread3&#123;</span><br><span class="line">    cnum w;</span><br><span class="line">    w.a=<span class="number">1</span>;</span><br><span class="line">    w.b=<span class="number">1</span>;</span><br><span class="line">    P(mutex3);</span><br><span class="line">    z=add(z,w);</span><br><span class="line">    V(mutex3);</span><br><span class="line">    P(mutex1);</span><br><span class="line">    P(mutex2);</span><br><span class="line">    y=add(y,w);</span><br><span class="line">    V(mutex1);</span><br><span class="line">    V(mutex2);</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><img src="https://s2.loli.net/2021/12/28/9HQFDgvl6Zu5SPI.png" alt="image-20210813184313765"></p><p>哲学家问题的变种，解决问题的思路之一就是限制进餐的哲学家人数，从n人变为n-1人</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以碗为核心，让碗的数量不超过n-1</span></span><br><span class="line"><span class="comment">//前驱关系，必须有碗才能吃饭，bowl=min(n-1,m)</span></span><br><span class="line"><span class="comment">//同步关系，必有同时有两只筷子 chopsticks[n]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    chopsticks[i]=<span class="number">1</span>;</span><br><span class="line">bowl=min(n<span class="number">-1</span>,m);</span><br><span class="line"></span><br><span class="line"><span class="function">CoBegin</span></span><br><span class="line"><span class="function"><span class="title">while</span><span class="params">(<span class="literal">true</span>)</span></span>&#123;</span><br><span class="line">    think;</span><br><span class="line">    P(bowl);</span><br><span class="line">    P(chopsticks[i]);</span><br><span class="line">    P(chopsticks[(i+<span class="number">1</span>)%n]);</span><br><span class="line">    就餐;</span><br><span class="line">    V(chopsticks[i]);</span><br><span class="line">    V(chopsticks[(i+<span class="number">1</span>)%n]);</span><br><span class="line">    V(bowl);</span><br><span class="line">&#125;</span><br><span class="line">CoEnd</span><br></pre></td></tr></table></figure><h2 id="进程调度问题"><a href="#进程调度问题" class="headerlink" title="进程调度问题"></a>进程调度问题</h2><p><img src="https://s2.loli.net/2021/12/28/nhI7KeOji5CAFZQ.png" alt="`"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">解析：</span><br><span class="line">    <span class="number">1.</span>由于采用了静态优先数，当就绪队列中总有优先数较小的进程时，优先数较大的进程一</span><br><span class="line">直没有机会运行，因而会出现饥饿现象</span><br><span class="line">    <span class="number">2.</span>优先数priority的计算公式为：</span><br><span class="line"> priority=nice+k1×cpuTime-k2×waitTime，其中k1&gt;<span class="number">0</span>，k2&gt;<span class="number">0</span>，用来分别调整cpuTime和waitTime在priority中所占的比例。waitTime可使长时间等待的进程优先数减小，从而避免出现饥饿现象。</span><br></pre></td></tr></table></figure><hr><h2 id="页面转换问题"><a href="#页面转换问题" class="headerlink" title="页面转换问题"></a>页面转换问题</h2><p><img src="https://s2.loli.net/2021/12/28/q92AmunVWJxSYXb.png" alt="image-20210815105101897"></p><p><strong>页框：将内存划分成一块块的格式，每个物理叫做页框</strong></p><p><strong>页面：按照内存中划分形式，将进程划分成一个个块，每个块叫页面</strong></p><ol><li><p>页内偏移量为12位，则页的大小是$2^{12}B$,即4KB，页表占用的页表项的个数为$2^{32}/2^{12}=2^{20}$，即1MB，占用的字节为1×4=4MB</p></li><li><p>页目录号就是逻辑地址的前10位，页表索引就是逻辑地址的中间10位</p></li></ol><p>​       页目录号可以表示为(LA&gt;&gt;22)，页表索引可以表示为(LA&gt;&gt;12)&amp;0x3FF(0x3FF会自动补足0)</p><ol><li><p>已知代码段的起始逻辑地址为0000 8000H，可知他们的页号是8，计算得到物理地址1为</p><p>0020 0000H+8×4=0020 0020H，物理地址2为0020 0024H</p><p>页框号是物理块号，即是00900H和00901H</p><p>物理地址3为00901000H</p><hr><p><img src="https://s2.loli.net/2021/12/28/kfnRToyjeMc9PGY.png" alt="image-20210815135349120"></p></li></ol><ol><li>页的大小等于页框的大小，都为$2^{12}=4KB$，虚拟空间的大小为$2^{32}/2^{12}=2^{20}$页</li><li>页目录占$(2^{10}×4)/2^{12}=1$页，页表项占$(2^{20}×4)/2^{12}=1024$页，共占1024+1=1025页</li><li>访问的是同一个二级页表  页目录号010=0000 0001 00和 011=0000 0001 0001，前10位都相同</li></ol><hr><p><img src="https://s2.loli.net/2021/12/28/WhX2HTUVPI4acf3.png" alt="image-20210815141055934"></p><ol><li><p>根据页式管理的工作原理，应先考虑页面大小，以便将页面和页内位移分解出来，页面大小为4KB，即是$2^{12}$，占据了虚地址的低12位，虚地址剩余的位置即是页号</p><p> 2362的页号是2，快表中没有，两次访存，访问快表10ns+两次访问存时间为10+100+100=210ns</p><p>1565的页号是1，会产生缺页中断，时间为访问快表，访问内存，产生缺页中断并处理，访问快表，访问内存  总时间为10+100+$10^{8}$+10+100=100 000 220ns</p><p>25A5的页号是2，快表中已经记录有了，一次访存，时间为10+100=110ns</p></li></ol><ol><li>根据LRU的置换算法，会把0号页面淘汰，那么分配给1号页面的页框号为101H，则虚地址的1565H的565表示页内偏移量，物理地址为101565H</li></ol><hr><p><img src="https://s2.loli.net/2021/12/28/MEULmrShucQVwn2.png" alt="image-20210815143944662"></p><ol><li>页框号为21 起始驻留集为空，而0页对应的页表为空闲链表中的第三个空闲页框，对应的页框号是21</li><li>页框号为32，在第三轮扫描中，第二轮被换下的32页框被重新放入，所以是32</li><li>页框号为41，第2页从来没有被访问过，从空闲页框链表中取出链表头的页框41</li><li>适合，如果程序的时间局部性越好，从空闲页框链中重新取回的机会越大，该策略优势也就越明显</li></ol><hr><p><img src="https://s2.loli.net/2021/12/28/8zscKUfLq6RhrSC.png" alt="image-20210815150245641"></p><ol><li><p>逻辑地址空间占64KB，即是$2^{16}$，页的大小为1KB，则页偏移量占据后10位，17CAH=0001 0111 1100 1010 的前6位表示页号，页号为5</p></li><li><p>FIFO会将第0号页面淘汰，页框号为7，物理地址为0001 1111 1100 1010 即是1FCAH</p><p>Clock会将第2号页面淘汰，页框号为2，物理地址为0000 1011 1100 1010即是 0BCAH</p></li></ol><hr><p><img src="https://s2.loli.net/2021/12/28/8bthO1AgQSc92k6.png" alt="image-20210815152510912" style="zoom:80%;" /></p><p><img src="https://s2.loli.net/2021/12/28/i5rUlQVxpLs4qzm.png" alt="image-20210815152526794"></p><ol><li><p>前10位是页目录的号数，中间10是页表号，最后12位是页内偏移量</p><p>0000 0001 1000 0000 0110  0000 0000 1000        0180 6008H</p></li><li><p>物理，会，不会</p></li><li><p>访问，修改</p></li></ol><hr><h2 id="文件存储问题"><a href="#文件存储问题" class="headerlink" title="文件存储问题"></a>文件存储问题</h2><p><img src="https://s2.loli.net/2021/12/28/TJbgc85xSKn1BeG.png" alt="image-20210815161434970"></p><p>1.dir目录文件</p><div class="table-container"><table><thead><tr><th>文件名</th><th>簇号</th></tr></thead><tbody><tr><td>dir1</td><td>48</td></tr></tbody></table></div><p>dir1目录文件</p><div class="table-container"><table><thead><tr><th>文件名</th><th>簇号</th></tr></thead><tbody><tr><td>file1</td><td>100</td></tr><tr><td>file2</td><td>200</td></tr></tbody></table></div><p>2.2B也就是16位，FAT最多有$2^{16}$个表项，系统也最多有$2^{16}$个块，FAT的最大长度是$2^{16}×2B=128KB$，文件的最大长度是$2^{16}×4KB=256MB$</p><p>3.根据FAT的存放标准，每一个块指示下一个块的位置，file1的簇号106存放在FAT的100号表项中，簇号108存放在FAT的106号表项中</p><p>4.第5000个字节明显是在第106簇中，已经读入了dir了，所以需要读入dir1的目录文件48号簇和file1的106号簇</p><hr><p><img src="https://s2.loli.net/2021/12/28/Uw4vjp6cIE1Lmqr.png" alt="image-20210815162546899"></p><ol><li>采用直接索引结构，4TB/1KB=$2^{32}$，32位最少需要4B来表示，那么512B的索引表区最多存储128个表项，128×1KB=128KB，最大长度是128KB</li><li>块数占了2B，即是16位，$2^{16}$，可以表示$2^{16}$×1KB=$2^{16}$KB，剩下的504B采取直接索引的方式，可储存504/6=84个磁盘，即是84KB，一共是$2^{16}$KB+84KB</li></ol><p>​      扩展单个文件的长度，就是让块数所占的字节尽可能贴近最大块数，调整为4B，即占据32位，和文件里面的物理块数一样，达到文件系统空间上限</p><hr><p><img src="https://s2.loli.net/2021/12/28/T3aGU4goO1rKSRv.png" alt="image-20210815165649844"></p><ol><li><p>系统采用顺序分配方式时，插入记录需要移动其他的记录块，整个文件共有 200 条记录，要插入新记录作为第 30 条，而存储区前后均有足够的磁盘空间，且要求最少的访问存储块数，则要把文件前 29 条记录前移，若算访盘次数移动一条记录读出和存回磁盘各是一次访盘，29 条记录共访盘 58 次，存回第 30 条记录访盘 1 次，共访盘 59 次。F 的文件控制区的起始块号和文件长度的内容会因此改变。</p></li><li><p>文件系统采用链接分配方式时，插入记录并不用移动其他记录，只需找到相应的记录，修改指针即可。插入的记录为其第 30 条记录，那么需要找到文件系统的第 29 块，一共需要访盘 29 次，然后把第 29 块的下块地址部分赋给新块，把新块存回内存会访盘 1 次，然后修改内存中第 29 块的下块地址字段，再存回磁盘，一共访盘 31 次。 4 个字节共 32 位，可以寻址 $2^{32}$=4G 块存储块，每块的大小为 1KB，即 1024B，其中下块地址部分占 4B，数据部分占 1020B，那么该系统的文件最大长度是 4G×1020B=4080GB。</p></li></ol><hr><p><img src="https://s2.loli.net/2021/12/28/71DM3VI9RSymduk.png" alt="image-20210815203424396"></p><ol><li><p>关键在于一个簇内能放多少个地址项，4KB/4B=$2^{10}$，最大文件长度为8×4KB+$2^{10}$×10KB+</p><p>$2^{20}$×10KB+$2^{30}$×10KB</p></li><li><p>一个图像文件大小为5600B&gt;4KB，所以会占据两个簇，1个簇里面最多存放4096/64=64个索引节点，则最多有$2^{26}=64M$个索引结点，最大支持64M个图像文件</p></li><li><p>不相同，因为6KB<32KB,在直接索引结点内，而40KB>32KB，在一级索引结点内</p></li></ol><hr><h2 id="磁盘调度问题"><a href="#磁盘调度问题" class="headerlink" title="磁盘调度问题"></a>磁盘调度问题</h2><p><img src="https://s2.loli.net/2021/12/28/EKQDBorR8FhjgGZ.png" alt="image-20210815205503146"></p><p><img src="https://s2.loli.net/2021/12/28/Edrvh7YQjWmMZnp.png" alt="image-20210815205511199"></p><ol><li>16384是$2^{14}$，而2KB的内存空间转为位，也是$2^{14}$位，所以正好可以用位示图法</li><li>移动磁道的时间为20+90+20+40=170ms，转速为100r/s，旋转延迟为5ms，总的旋转延迟为20ms，读100个扇区的时间为1/(100*100)=0.1ms,总读取时间为0.4ms，总时间为170+20+0.4=190.4ms</li><li>FCFS算法，因为Flash储存器不需要考虑寻道时间和旋转延迟，可以按I/O请求的先后顺序服务</li></ol><hr><p><img src="https://s2.loli.net/2021/12/28/kQbG2t7v5LjdBrF.png" alt="image-20210815231148159"></p><ol><li><p>300×10×200×512=300000MB</p></li><li><p>在85号柱面上，通过计算，85号柱面对应的簇号是85000~85999所以先到100260再到101660，然后访问110560，最后访问60005</p></li><li><p>物理地址由柱面号，磁头号，扇区号组成</p><p>柱面号=100530/1000=100</p><p>磁头号=530/100=60</p><p>扇区号=（530*2）%200=60</p><p>由磁盘驱动程序完成</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.磁盘存储器的管理</title>
      <link href="/post/53689.html"/>
      <url>/post/53689.html</url>
      
        <content type="html"><![CDATA[<h1 id="磁盘存储器的管理"><a href="#磁盘存储器的管理" class="headerlink" title="磁盘存储器的管理"></a>磁盘存储器的管理</h1><h2 id="磁盘的结构"><a href="#磁盘的结构" class="headerlink" title="磁盘的结构"></a>磁盘的结构</h2><p>磁盘：表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据</p><p>磁道：磁盘的盘面被划分成一个个磁道，这样的一个圈就是一个磁道</p><p>扇区：一个磁道又被划分为一个个扇区，每个扇区就是一个磁盘块，每个磁盘块存放的数据量相同</p><p><img src="https://s2.loli.net/2021/12/28/oYBVzZWxgnprhc5.png" alt="image-20210809162010308"></p><p>最内侧磁道上的扇区面积最小，所以数据密度最大</p><p>将磁头移动到想要读写的扇区所在的磁道，磁盘会转起来，让目标扇区在磁头下面划过，完成对扇区的读写</p><p>盘面：一个盘片可以有两个盘面，所有的磁头都连在同一个磁臂上，因此所有磁头只能共进退</p><p>柱面：所有盘面中相对位置相同的磁道组成柱面</p><p>磁盘的物理地址：可以使用(柱面号，盘面号，扇区号)来定位任意一个磁盘块。</p><p>磁盘的分类：磁头可以移动的称为活动头磁盘，磁头不能移动的称为固定头磁盘，这种磁盘中每个磁道有一个磁头</p><hr><h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2><h3 id="一次磁盘读写需要的时间"><a href="#一次磁盘读写需要的时间" class="headerlink" title="一次磁盘读写需要的时间"></a>一次磁盘读写需要的时间</h3><p>寻找时间$T_S$：在读写数据前，将磁头移动到指定磁道所花的时间</p><ul><li>启动磁头臂需要的时间，假设为s</li><li>移动磁头需要的时间，假设磁头匀速移动，每跨越一个磁道耗时为m,总共需要跨越n条磁道</li></ul><p><strong>寻找时间</strong>$T_S$=s+m×n</p><p><strong>延迟时间</strong>$T_R$：通过旋转磁盘，使磁头定位转到目标扇区所需要的时间</p><p>假设磁盘转速为r，则平均延迟时间为1/2r</p><p>传输时间：从磁盘读出或向磁盘写入数据所经历的时间，假设磁盘转速为r，读写的字节数为b，每个磁道上的字节数为N</p><p><strong>传输时间</strong>$T_t=b/(rN)$</p><p>可以得知延迟时间和传输时间都和磁盘的转速线性相关，操作系统无法进行优化，所以磁盘调度算法的操作主要是影响<strong>寻找时间</strong></p><hr><h3 id="先来先服务算法-FCFS"><a href="#先来先服务算法-FCFS" class="headerlink" title="先来先服务算法(FCFS)"></a><strong>先来先服务算法(FCFS)</strong></h3><p>根据进程请求访问磁盘的先后顺序进行调度</p><p><img src="https://s2.loli.net/2021/12/28/E3Hs6PjkQoqVyYe.png" alt="image-20210809170455778"></p><p>优点：公平，如果请求访问的磁道比较集中的话，性能还算好</p><p>缺点：如果有大量进程竞争使用磁道，请求访问的磁道很分散，则FCFS在性能上很差，寻到时间长</p><hr><h3 id="最短寻找时间优先算法-SSTF"><a href="#最短寻找时间优先算法-SSTF" class="headerlink" title="最短寻找时间优先算法(SSTF)"></a>最短寻找时间优先算法(SSTF)</h3><p>SSTF算法会优先处理与当前磁头最近的磁道，可以保证每次的寻道时间最短，但是并不能保证总的寻道时间最短</p><p><img src="https://s2.loli.net/2021/12/28/UL16ixdVJjhCRnl.png" alt="image-20210809170443913"></p><p>优点：性能较好，平均寻道时间短</p><p>缺点：可能会饥饿</p><hr><h3 id="扫描算法-SCAN"><a href="#扫描算法-SCAN" class="headerlink" title="扫描算法(SCAN)"></a>扫描算法(SCAN)</h3><p>只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动，也叫电梯算法</p><p><img src="https://s2.loli.net/2021/12/28/oDgx76j5mCpl42U.png" alt="image-20210809170515784"></p><p>优点：性能较好，平均寻道时间较短，不会产生饥饿</p><p>缺点：只有到达最边上磁道才会改变移动方向，对于各个位置磁道的相应频率不平均</p><hr><h3 id="LOOK调度算法"><a href="#LOOK调度算法" class="headerlink" title="LOOK调度算法"></a>LOOK调度算法</h3><p>在SCAN的基础上，增加了一个特性，如果磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向</p><p><img src="https://s2.loli.net/2021/12/28/pAkN14gChjFcOKV.png" alt="image-20210809170529250"></p><hr><h3 id="循环移动算法-C-SCAN"><a href="#循环移动算法-C-SCAN" class="headerlink" title="循环移动算法(C-SCAN)"></a>循环移动算法(C-SCAN)</h3><p>SCAN算法对于各个位置磁道的响应频率不平均，而C-SCAN算法就是为了解决这个问题，规定只有磁头朝向某个特定方向移动时才处理磁道访问请求，而返回时直接快速移动至起始端而不处理任何请求</p><p><img src="https://s2.loli.net/2021/12/28/NmX9cGaukrwn2Wo.png" alt="image-20210809170551266"></p><hr><h3 id="C-LOOK调度算法"><a href="#C-LOOK调度算法" class="headerlink" title="C-LOOK调度算法"></a>C-LOOK调度算法</h3><p>结合LOOK和循环移动，如果磁头移动方向上没有磁道访问请求了，就立刻让磁头返回，并且磁头只需要返回到有磁道访问请求的位置</p><p>如果题目未具体说明，则SCAN就是LOOK，C-SCAN就是C-LOOK</p><hr><h2 id="减少磁盘延迟时间的方法"><a href="#减少磁盘延迟时间的方法" class="headerlink" title="减少磁盘延迟时间的方法"></a>减少磁盘延迟时间的方法</h2><p>交替编号，让逻辑上相邻的扇区在物理上有一定的间隔，可以让读取连续的逻辑扇区所需要的延迟时间更小</p><p>读取地址连续的磁盘块时，采用(柱面号，盘面号，扇区号)的地址结构可以减少磁头移动消耗的时间</p><hr><h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><p><strong>磁盘初始化</strong></p><ol><li><p>进行物理格式化，将磁盘的各个磁道划分为扇区</p></li><li><p>将磁盘分区，每个分区由若干个柱面组成</p></li><li>进行逻辑格式化，创建文件系统。包括创建文件系统的根目录，初始化存储空间管理所用的数据结构</li></ol><p><strong>引导块</strong></p><p>计算机开机时需要进行一系列初始化工作，这么工作是通过执行初始化程序完成的</p><p>在ROM中存放很小的自举装入程序，完整的自举程序放在磁盘的启动块上，启动块位于磁盘的固定位置</p><p><strong>坏块的管理</strong></p><p>无法正常使用的扇区就是坏块，属于硬件故障，操作系统无法修复，应该标记出来，避免使用</p><p>对于简单磁盘，可以在逻辑格式化的时候进行检查，表明哪些是坏扇区</p><p>对于复杂磁盘，可以保留一些备用扇区用于替换坏块</p><hr><h2 id="提高磁盘I-O速度的方法"><a href="#提高磁盘I-O速度的方法" class="headerlink" title="提高磁盘I/O速度的方法"></a>提高磁盘I/O速度的方法</h2><ol><li><p>采用磁盘高速缓存</p></li><li><p>提前读</p><p>如果采用顺序访问方式，可以预知下一次要读的盘块，在读当前块的时候，同时将下一个盘块中的数据也读入缓冲区</p></li><li><p>延迟写</p><p>指缓冲区A中的数据本应立即写回磁盘，但是考虑到缓冲区中的数据可能会在不久之后再被访问，所以并不立即将缓冲区A中的数据写入磁盘，而是将它挂到空闲缓冲队列的末尾</p></li><li><p>优化物理块的分布</p></li><li>虚拟盘</li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.文件管理</title>
      <link href="/post/14694.html"/>
      <url>/post/14694.html</url>
      
        <content type="html"><![CDATA[<h1 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>文件是指创建者所定义的，具有文件名的一组数据的集合，可分为有结构文件和无结构文件两种</p><p>在有结构的文件中，文件由若干个相关记录组成，而无结构文件则被看成一个字符流</p><p>文件属性包括：</p><ul><li>文件类型，可以从不同的角度来对规定文件的类型</li><li>文件长度，文件长度指文件的当前长度</li><li>文件的物理位置，通常用于指示文件所在的设备以及设备中地址的指针</li><li>文件的建立时间，指最后一次修改时间等</li></ul><hr><h2 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h2><p>流式文件：无结构的文件，数据不再组成记录，只是一串顺序的信息集合</p><p>有结构文件：由一组相似的记录组成，又称纪录式文件，每条记录由若干个数据项组成，一般来说，每条记录有一个数据项作为关键字，根据各条记录的长度是否相等，又可分为定长记录和可变长记录</p><hr><h3 id="顺序文件"><a href="#顺序文件" class="headerlink" title="顺序文件"></a>顺序文件</h3><p>文件的记录按一个接一个顺序排列，记录可以是定长的或可变长的，各个记录在物理上可以<strong>顺序存储</strong>或<strong>链式存储</strong></p><p>顺序存储：逻辑上相邻的记录物理上也相邻</p><p>链式存储：逻辑上相邻的记录物理上不一定相邻</p><p><img src="https://s2.loli.net/2021/12/28/dE1cFBYKiyCjQ5e.png" alt="image-20210805204921561"></p><p>定长记录可以随机存取，可变长记录不可以随机存取</p><hr><h3 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h3><p>对于可变长记录文件，要找到第i个记录，必须先顺序查找到前i-1个记录，很不方便</p><p>如果建立一张索引表加快文件的检索速度，每条记录对应一个索引项</p><p><img src="https://s2.loli.net/2021/12/28/n9NqAu7MEswIjeB.png" alt="image-20210805205319391"></p><p><strong>索引表本身就是定长记录的顺序文件</strong>，因此可以迅速找到第i个记录对应的索引项</p><p>由于索引文件有很快的检索速度，因此主要用于对信息处理的及时性要求比较高的场所</p><p>缺点：每个记录对应一个索引表项，因此索引表可能会很大</p><hr><h3 id="索引顺序文件"><a href="#索引顺序文件" class="headerlink" title="索引顺序文件"></a>索引顺序文件</h3><p>索引顺序文件是索引文件和顺序文件思想的结合，在索引顺序文件中，同样会为文件建立一张索引表，但是，并不是每个记录都对应一个索引表项，而是一组记录对应一个索引表项</p><p><img src="https://s2.loli.net/2021/12/28/WNpAbtHyZsri1df.png" alt="image-20210805210155962" style="zoom:67%;" /></p><p> 为了进一步提高检索效率，可以为顺序文件建立多级索引表</p><hr><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><h3 id="文件控制块"><a href="#文件控制块" class="headerlink" title="文件控制块"></a>文件控制块</h3><p>目录本身就是一种有结构文件，由一条条记录组成，每条记录对应一个放在该目录下的文件</p><p>为了能对一个文件进行正确的存取，必须为文件设置用于描述和控制文件的数据结构，称之为文件控制块(FCB)</p><p><strong>FCB中包含了文件的基本信息(文件名，文件大小，物理地址，逻辑结构等)，存储控制信息，使用信息</strong></p><p>每当创建一个文件时，先建立一个FCB，用来记录文件属性，每当存取文件时，先找到FCB，再找到文件信息盘块号或索引表就能存取文件</p><hr><p>为了加快文件查找速度，将FCB汇集和组织在一起形成文件目录</p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p><strong>单级目录结构</strong></p><p>早期操作系统并不支持多级目录，整个系统中只建立一张目录表，每个文件占一个目录项</p><p>单级目录实现了按名存取，但是不允许文件重名，显然单级目录结构不适用于多用户操作系统</p><hr><p><strong>两级目录结构</strong></p><p>早起的多用户操作系统，采用两级目录机构，分为主文件目录和用户文件目录</p><p>主文件目录记录用户名及相应的用户文件目录的存放位置</p><p>用户文件目录由该用户的文件FCB组成</p><p>两级目录结构允许不同用户的文件重名，也可以在目录上实现访问限制，但是两级目录结构依然缺乏灵活性，也不能对自己的文件进行分类</p><hr><p><strong>多级目录结构</strong></p><p>用户要访问某个文件时要用文件路径名标识文件，文件路径是个字符串，各级目录之间用 / 隔开，从根目录出发的路径称为绝对路径</p><p>系统根据绝对路径一层一层地找到下一级目录。从外存读入根目录的目录表</p><p>每次从根目录找很低效，可以设置相对目录，减少磁盘I/O次数</p><p>树形目录可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护。但是，树形结构不便于实现文件的共享。为此，提出了无环图目录结构</p><p><img src="https://s2.loli.net/2021/12/28/lshZct3Jfyu4oI2.png" alt="image-20210809153155151"></p><hr><p><strong>无环图目录结构</strong></p><p>在树形目录结构的基础上，增加一些指向同一节点的有向边，使整个目录成为一个有向无环图，可以更方便地实现多个用户间的文件共享</p><p>需要为每个共享结点设置一个共享计数器，用于记录此时有多少个地方在共享这个结点，用户提出删除结点的请求时，只是删除该用户的FCB，并共享计数器减1，并不会删除共享结点，只有共享计数器为0时才被删除</p><p><img src="https://s2.loli.net/2021/12/28/oWu4aTLDxIAymEw.png" alt="image-20210809153136401"></p><hr><p><strong>索引结点</strong></p><p>在查找各级目录的过程只需要文件名这个信息，只有文件名匹配的时候，才需要读出文件的其他信息</p><p>可以将除了文件之外的描述信息都放到索引结点</p><p><img src="https://s2.loli.net/2021/12/28/RIEVXlBZd5Uv2iM.png" alt="image-20210806183119195" style="zoom:50%;" /></p><hr><h2 id="文件的物理结构"><a href="#文件的物理结构" class="headerlink" title="文件的物理结构"></a>文件的物理结构</h2><p>类似内存分页，磁盘中的储存单元也会被分为一个个块，很多操作系统中，磁盘块的大小与内存块，页面的大小相同</p><p>在外存管理中，为了方便对文件数据的管理，文件的逻辑地址空间也被分为了一个一个的文件块，于是文件的逻辑地址也可以表示为(逻辑块号，块内地址)的形式</p><p>用户通过逻辑地址操作自己的文件，操作系统负责实现<strong>从逻辑地址到物理地址的映射</strong></p><hr><h3 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h3><p>连续分配方式要求每个文件在磁盘上占有一组连续的块</p><p><img src="https://s2.loli.net/2021/12/28/jmoOZGz9htBSyxa.png" alt="image-20210807124526272"></p><p>文件目录中记录存放的起始块号和长度</p><p><img src="https://s2.loli.net/2021/12/28/A1nMouSi8QxaDwc.png" alt="image-20210807124607286"></p><p>用户给出了要访问的逻辑块号，操作系统找到该文件对应的目录项(FCB)</p><p>物理块号=起始块号+逻辑块号</p><p>优点：</p><ul><li><p>连续分配支持顺序访问和<strong>随机访问</strong></p></li><li><p>在读取某个磁盘块时，需要移动磁头，访问的两个磁盘块相隔越远，移动磁头所需时间就越长，<strong>所以，连续分配的文件在顺序读写时速度最快</strong></p></li></ul><p>缺点：</p><ul><li>连续分配方式的文件不方便扩展</li><li>物理上采用连续分配，存储空间利用率低，会产生难以利用的磁盘碎片</li></ul><hr><h3 id="链接分配"><a href="#链接分配" class="headerlink" title="链接分配"></a>链接分配</h3><p><strong>隐式链接</strong></p><p>除了文件的最后一个磁盘块，每个磁盘块都会保存指向下一个盘块的指针，这些指针对用户是透明的</p><p><img src="https://s2.loli.net/2021/12/28/8xasMShYgFpNDtW.png" alt="image-20210807125455265"></p><p>在目录中记录了文件的起始块号和结束块号</p><p><img src="https://s2.loli.net/2021/12/28/GwOxVhFrSsfaTKI.png" alt="image-20210807125632597"></p><p>从目录项中找到起始块号，将0号逻辑块读入内存，由此知道1号逻辑块存放的物理块号，再找到2号逻辑块存放位置，以此类推</p><p>因此，读入i号逻辑块，总共需要i+1次磁盘I/O</p><p>优点：很方便文件拓展，不会有碎片问题，外存利用率高</p><p>缺点：采用链式分配方式的文件，只支持顺序访问，不支持随机访问，查找效率低</p><p>为了提高检索速度和减小指针所占用的存储空间，可以将几个盘块组成一个簇（cluster）。比如，一个簇可包含 4个盘块，在进行盘块分配时，是以簇为单位进行的。在链接文件中的每个元素也是以簇为单位的。这样将会成倍地减小查找指定块的时间，而且也可减小指针所占用的存储空间，但却增大了内部碎片，而且这种改进也是非常有限的。</p><hr><p><strong>显式链接</strong></p><p>把用于链接文件各物理块的指针显示地存放在一张表中，即文件分配表(FAT，File Allocation Table)</p><p><img src="https://s2.loli.net/2021/12/28/U2SqhWrXsyFCK1u.png" alt="image-20210807130533901"></p><p>在目录中只需记录文件的起始块号</p><p>在FAT中，记录每个物理块号对应的下一块，如果物理块号是文件的末尾，可以记为-1</p><p><img src="https://s2.loli.net/2021/12/28/85zbaL72gkHvclm.png" alt="image-20210807130925006"></p><p>一个磁盘仅设置一张FAT，开机时，将FAT读入内存，并常驻内存，FAT的各个表项在物理上连续存储，且每一个表项长度相同，因此，物理块号字段可以是隐含的</p><p>逻辑块号转换成物理块号的过程不需要读磁盘操作</p><p>优点：采用显式链式分配的文件，支持顺序访问，也支持随机访问，由于块号转换不需要访问磁盘，因此相比于隐式链接来说，访问速度要快，也不会产生外部碎片，方便扩展</p><p>缺点：文件分配表需要占据一定空间</p><hr><h3 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h3><p>索引分配允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表，索引表中记录了文件的各个逻辑块对应的物理块，索引块存放的磁盘块称为索引块，文件数据存放的磁盘块称为物理块</p><p><img src="https://s2.loli.net/2021/12/28/X7YN3uz96DWol8e.png" alt="image-20210807132630534"></p><p>在索引块中存放的是索引表</p><p><img src="https://s2.loli.net/2021/12/28/5UGVNI3AlERbBm2.png" alt="image-20210807132650573"></p><p>在显式链接中，文件分配表FAT是一张磁盘对应一张，而索引分配方式中，索引表是一个文件对应一张</p><p>可以用固定长度表示物理块号，因此，索引表中的逻辑块号可以是隐含的</p><p>将索引表从外存读入内存，并查找索引表即可知道i号逻辑块在外存中的存放位置，可见，索引分配方式支持随机访问，也支持文件拓展</p><hr><p>如果整张索引表的大小超过了一个磁盘块，该如何解决？</p><p><strong>链接方案</strong></p><p>如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放</p><p><img src="https://s2.loli.net/2021/12/28/PW4TVcHGAENtqQl.png" alt="image-20210807133320820" style="zoom:67%;" /></p><p>但是，如果索引表过大，那么所要链接的索引块也就很多，如果要找最后一个索引块，那么必须先顺序地读入前面所有索引块，很低效</p><hr><p><strong>多层索引</strong></p><p>建立多层索引，事第一层索引块指向第二层索引块，还可根据文件的大小要求再建立第三层，第四层索引块</p><p> <img src="https://s2.loli.net/2021/12/28/XvmyuHoiAQwnG13.png" alt="image-20210809135600928" style="zoom:80%;" /></p><p>如果使用两层索引，则文件的最大长度可以达到256*256=64MB</p><p>缺点是，即使是小文件，访问一个数据块依然需要k+1次读磁盘</p><hr><p><strong>混合索引</strong></p><p>多种索引分配方式的结合，例如，一个文件的顶级索引表中，既包含直接地址索引，又包含一级间接索引，还包含两级间接索引</p><p><img src="https://s2.loli.net/2021/12/28/6lCV8msJwry49gf.png" alt="image-20210809140129781"></p><hr><p>总结</p><p><img src="https://s2.loli.net/2021/12/28/9JBSHFQRqnobrVI.png" alt="image-20210809140115622"></p><hr><h2 id="文件存储空间管理"><a href="#文件存储空间管理" class="headerlink" title="文件存储空间管理"></a>文件存储空间管理</h2><p>存储空间的划分：将物理磁盘划分为一个个文件卷</p><p>存储空间的初始化：将各个文件卷划分为目录区，文件区</p><p>目录区主要存放文件目录信息，用于磁盘存储空间管理的信息</p><p>文件区用于存放文件数据</p><hr><h3 id="空闲表法"><a href="#空闲表法" class="headerlink" title="空闲表法"></a>空闲表法</h3><p>适用于连续分配方式</p><p><img src="https://s2.loli.net/2021/12/28/M1m4xfyFOg9jNRz.png" alt="image-20210809141501833" style="zoom:67%;" /></p><p><img src="https://s2.loli.net/2021/12/28/OJczBFxiAK5XGUs.png" alt="image-20210809141511435" style="zoom:50%;" /></p><p>分配磁盘：与内存管理中的动态分区分配类似，为一个分配连续的存储空间，同样可采用首次适应，最佳适应，最坏适应等算法决定为文件分配哪个区间</p><p>回收磁盘：和动态分区分配一样，需要考虑到不同情况</p><hr><h3 id="空闲链表法"><a href="#空闲链表法" class="headerlink" title="空闲链表法"></a>空闲链表法</h3><p>空闲盘块链</p><p><img src="https://s2.loli.net/2021/12/28/R7Tp3AUCzq8ZiLW.png" alt="image-20210809143156559"></p><p>空闲盘块中存储着下一个空闲盘块的指针</p><p>操作系统保存着链头和链尾指针</p><p>分配：若某文件申请K个盘块，则从链头开始一次摘下K个盘块分配，并修改空闲链的链头指针</p><p>回收：回收的盘快挂到链尾，并修改空闲链的链尾指针</p><p>适用于离散分配的物理结构</p><hr><p>空闲盘区链</p><p><img src="https://s2.loli.net/2021/12/28/woiSBfl15kTVCX9.png" alt="image-20210809143233807"></p><p>连续的空闲盘块组成一个空闲盘区</p><p>空闲盘区中第一个盘块记录了盘区的长度，下一个盘块的指针</p><p>分配：若某个文件申请K个盘块，则可以开始采用适应算法，从链头开始检索，找到一个大小符合要求的空闲盘区，如果没有合适的连续空闲块，也可以将不同盘区的盘块同时分配给一个文件</p><p>回收：如果回收区没有和任何空闲区相邻，将回收区作为单独的一个空闲盘区挂到链尾</p><p>离散分配，连续分配都使用，为一个文件分配多个磁盘块时效率高</p><hr><h3 id="位示图法"><a href="#位示图法" class="headerlink" title="位示图法"></a>位示图法</h3><p>每个二进制对应一个盘块，比如0代表盘块空闲，1代表盘块已分配，位移图一般用连续的字来表示</p><p><img src="https://s2.loli.net/2021/12/28/1qUtFgswGamXrfM.png" alt="image-20210809145411487"></p><p><img src="https://s2.loli.net/2021/12/28/AU5b2HilKZInJhB.png" alt="image-20210809145133667"></p><p>分配：若文件需要K个块，先顺序扫描位示图，找到K个相邻或不相邻的0，根据字号，位号算出对应的盘块号，将相应盘块分配给文件，将相应位设置为1</p><p>回收：根据回收的盘块号计算出相应的字号，位号，将相应二进制设为0</p><hr><p>此外，在文件的显式分配中所使用的FAT表，由于标记了磁盘中各块的被使用情况，一样可以用在空闲空间的管理中</p><hr><h2 id="文件的基本操作"><a href="#文件的基本操作" class="headerlink" title="文件的基本操作"></a>文件的基本操作</h2><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><p>创建文件需要进行Create系统调用，需要提供的几个主要参数</p><ol><li>所需的外存大小</li><li>文件存放路径</li><li>文件名</li></ol><p>在处理系统调用时，主要有两步</p><ol><li>在外存中找到文件所需的空间</li><li>根据文件存放路径的信息找到该目录对应的目录文件，在目录文件创建该文件对应的目录项</li></ol><hr><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>通过Delete系统调用</p><p>处理系统调用时，主要有三步</p><ol><li>根据文件存放路径，找到文件名对应的目录项</li><li>根据目录项记录的文件位置，回收文件占用的磁盘块</li><li>从目录项中删除文件对应的目录项</li></ol><hr><h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p>通过open系统调用</p><p>需要提供的主要参数</p><ol><li>文件存放路径</li><li>文件名</li><li>要对文件的操作类型</li></ol><p>操作系统在处理open系统调用时，主要做了：</p><ol><li>根据文件存放路径找到文件名对应的目录项，并检查该文件是否有指定的操作权限</li><li>将目录项复制到内存中的打开文件表，并将对应的目的编号返回给用户，之后用户使用打开文件表的编号来指明要操作的文件</li></ol><p>之后用户进程A再操作文件就不需要每次都重新检查目录了，这样可以加快文件访问速度</p><p><img src="https://s2.loli.net/2021/12/28/tzKvfUM4Qw29IOT.png" alt="image-20210809151725333"></p><p>进程的打开文件表中，读写指针记录了该进程对文件读写所进行到的位置</p><p>访问权限标明了进程能对文件所进行的操作</p><p>系统表索引号指向了系统的打开文件表</p><p><img src="https://s2.loli.net/2021/12/28/viXnhdF6qG5s3mT.png" alt="image-20210809151916877" style="zoom: 80%;" /></p><p>打开文件时并不会把文件数据直接读入内存，索引号也称文件描述符</p><hr><h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><p>系统在处理close系统调用时</p><ol><li>将进程的打开文件表相应表项删除</li><li>回收分配给该文件的内存空间等资源</li><li>系统打开文件表的打开计数器count减1</li></ol><hr><h3 id="读文件与写文件"><a href="#读文件与写文件" class="headerlink" title="读文件与写文件"></a>读文件与写文件</h3><p>进程在使用read系统调用时，需要的主要参数是</p><ol><li>指明是哪个文件</li><li>还需要指明要读入多少数据</li><li>读入的数据要放在内存中的什么位置</li></ol><p>在写文件时，需要的主要参数是</p><ol><li>指明是哪个文件</li><li>还需要指明要写出多少数据</li><li>写出的数据要放在内存中的什么位置</li></ol><hr><h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><p><strong>基于索引结点的共享方式(硬链接)</strong></p><p>在索引结点中设置一个链接计数变量count，用于表示链接本索引结点上的用户目录项数</p><p><img src="https://s2.loli.net/2021/12/28/DLKy286tFET3ues.png" alt="image-20210809153408702"></p><hr><p><strong>基于符号链的共享方式</strong>(<strong>软链接</strong>)</p><p>创建Link类型的文件，记录文件的存放路径</p><hr><h2 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h2><p><strong>口令保护</strong></p><p>口令一般存放在文件对应的FCB或索引结点中，用户访问文件需要先输入口令，操作系统会将用户提供的口令与FCB中存储的口令进行对比，如果正确就允许访问</p><p>优点：保存口令的空间开销不多，验证口令的时间开销也很小</p><p>缺点：存放在系统内部不安全</p><hr><p><strong>加密保护</strong></p><p>使用某个密码对文件进行加密，在访问文件时需要提供正确的密码才能对文件进行正确的解密</p><p>优点：保密性强，不需要在系统中存储密码</p><p>缺点：加密和解密要花费一定时间</p><hr><p><strong>访问控制表</strong></p><p>在每个文件的FCB中增加一个访问控制列表，该表中记录了各个用户可以对该文件执行哪些操作</p><hr><h2 id="文件的层次结构"><a href="#文件的层次结构" class="headerlink" title="文件的层次结构"></a>文件的层次结构</h2><p><img src="https://s2.loli.net/2021/12/28/7jGsp2LAuoUPkEH.png" alt="image-20210809160601183"></p><p>用户接口：向上层提供一些功能接口，用于处理用户发出的系统调用</p><p>文件目录系统：根据用户给出的文件路径找到相应的FCB或索引结点，所有的目录，目录项相关的管理工作都在本层完成</p><p>存取控制模块：为了保证文件数据的安全，主要完成文件保护的功能</p><p>逻辑文件系统和信息缓冲区：用户指明想要文件记录号，将记录号转换为对应的逻辑地址</p><p>物理文件系统：将上一层提供的逻辑地址转换为实际的物理地址</p><p>辅助分配模块：负责文件存储空间的清理，即负责分配和回收存储空间</p><p>设备管理模块：直接与硬件交互，负责和硬件直接相关的一些管理工作</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.输入输出系统</title>
      <link href="/post/32110.html"/>
      <url>/post/32110.html</url>
      
        <content type="html"><![CDATA[<h1 id="输入输出系统"><a href="#输入输出系统" class="headerlink" title="输入输出系统"></a>输入输出系统</h1><h2 id="I-O设备的概念和分类"><a href="#I-O设备的概念和分类" class="headerlink" title="I/O设备的概念和分类"></a>I/O设备的概念和分类</h2><p>I/O设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件</p><p>按使用特性分类：人机交互类，存储设备，网络通信设备</p><p>按信息交换的单位分类：块设备(可寻址)，字符设备(不可寻址，中断驱动)</p><hr><h2 id="I-O控制器"><a href="#I-O控制器" class="headerlink" title="I/O控制器"></a>I/O控制器</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>控制器分为机械部件和电子部件，机械部件主要用来执行具体的I/O操作，电子部件通常是一块插入主板扩充槽的印刷电路板</p><p><strong>I/O控制器</strong>：CPU无法直接控制I/O设备的机械部件，因此I/O设备还要有一个电子部件作为CPU和I/O设备机械部件之间的中介，用于实现CPU对设备的控制，这个电子部件就是I/O控制器，又称设备控制器</p><hr><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p><strong>接受和识别CPU发出的命令</strong></p><p>如CPU发来的read/wirte命令，I/O控制器中会有相应的控制寄存器来存放命令和参数</p><p><strong>向CPU报告设备的状态</strong></p><p>I/O控制器中会有相应的状态寄存器，用于记录I/O设备的当前状态</p><p><strong>数据交换</strong></p><p>I/O控制器中会设置相应的数据寄存器，输出时，数据寄存器用于暂存CPU发来的数据，之后再由控制器传送设备，输入时，数据寄存器用于暂存设备发来的数据，之后CPU从数据寄存器中取走数据</p><p><strong>地址识别</strong></p><p>类似于内存的地址，为了区分设备控制器中的各个寄存器，也需要给各个寄存器设置一个特定的地址，I/O控制器通过CPU提供的地址来判断CPU要读写的是哪个寄存器</p><hr><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>由CPU与控制器的接口，I/O逻辑，控制器与设备的接口</p><p>I/O逻辑负责接收和识别CPU的各种命令，并负责对设备发出命令</p><p>CPU与控制器的接口用于实现CPU与控制器之间的通信，CPU通过控制线发出命令，通过地址线指明要操作的设备，通过数据线来取出数据或放入数据</p><p>控制器与设备的接口，用于实现控制器与设备之间的通信</p><p><img src="https://s2.loli.net/2021/12/28/ujrAO7NEY2vZPph.png" alt="image-20210804162140721"></p><p>注意：一个I/O控制器可能会对应多个设备</p><p>既然I/O控制器可以对应多个设备，那么自然也会有多个寄存器，且这些寄存器都要有相应的地址，才能方便CPU操作，有的计算机会让这些寄存器占用内存地址的一部分，称为<strong>内存映像I/O</strong>；另一些计算机则采用I/O专用地址，即<strong>寄存器独立编址</strong></p><p>如果采用内存映像I/O，优点是简化了指令，可以采用对内存进行操作的指令来对控制器进行操作</p><p>采用寄存器独立编址，缺点是需要专门的指令来实现对寄存器的操作，不仅要指明寄存器的地址，还要指明控制器的编号</p><hr><h2 id="I-O控制方式"><a href="#I-O控制方式" class="headerlink" title="I/O控制方式"></a>I/O控制方式</h2><h3 id="程序直接控制方式"><a href="#程序直接控制方式" class="headerlink" title="程序直接控制方式"></a>程序直接控制方式</h3><p>完成一次读写操作的流程</p><ol><li>CPU向控制器发出读指令，并且将状态寄存器设为1(未就绪)</li><li><strong>轮询</strong>检查控制器状态</li><li>输入设备准备好数据后将数据传给控制器，并报告自身状态</li><li>控制器将输入的数据放到数据寄存器中，并将状态改为0</li><li>CPU从数据寄存器中读出数据</li></ol><p>CPU干预的频率：很频繁，I/O操作开始之前，完成之后需要CPU介入，并且在等待I/O完成的过程中CPU需要不断轮询检查</p><p>数据传输的单位：每次读写一个字</p><p>数据的流向：读操作：从I/O设备到CPU到内存，每个字的读写都需要CPU的帮助</p><p>优点：实现简单，在读写指令之后，加上实现循环检查的一系列指令即可</p><p>缺点：CPU和I/O设备只能串行工作，CPU需要一直轮询检查，长期处于忙等状态，CPU利用率低</p><hr><h3 id="中断驱动方式"><a href="#中断驱动方式" class="headerlink" title="中断驱动方式"></a>中断驱动方式</h3><p>引入中断机制，由于I/O设备速度很慢，因此在CPU发出读写命令后，可将等待I/O的进程阻塞，先切换到别的进程执行。</p><p>当I/O完成后，控制器会向CPU发出一个中断信号，CPU检测到中断信号后，会保存当前进程的运行环境信息，转去执行中断处理程序处理该中断。</p><p>处理中断的过程中，CPU从I/O控制器读一个字的数据到CPU寄存器，再写入主存。接着，CPU恢复等待I/O的进程的运行环境，然后继续执行</p><p><img src="https://s2.loli.net/2021/12/28/Vr1xmjSJXqvcfDp.png" alt="image-20210804165230989" style="zoom: 67%;" /></p><p>CPU会在每个指令周期的末尾检查中断</p><p>中断处理过程中需要保存，恢复进程的运行环境，这个过程需要一定的时间开销，如果中断发生的频率过高，也会降低系统性能</p><p><strong>CPU干预的频率</strong>：I/O操作开始之前，完成之后需要CPU介入，在等待I/O完成的过程中CPU可以切换到别的进程执行</p><p><strong>数据传输的单位</strong>：每次读写一个字</p><p><strong>数据的流向</strong>：读操作：从I/O设备到CPU到内存，每个字的读写都需要CPU的帮助</p><p><strong>优点</strong>：CPU和I/O设备可以并行工作，CPU利用率得到提升</p><p><strong>缺点</strong>：每个字在I/O设备与内存之间的运输，都要经过CPU，而频繁的中断处理会消耗较多的CPU时间</p><hr><h3 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h3><p>DMA方式(Direct Memory Access ,直接存储器存取)，主要用于块设备的I/O控制</p><ul><li>数据的传送单位是 块 不再是字传送</li><li>数据的流向是从设备直接放入内存，或者是内存直接到设备，不再需要CPU中转</li><li>仅在传送一个或多个数据块开始和结束时，才需要CPU干预</li></ul><p>在DMA控制器中，有4个寄存器：</p><p>DR(Data Reigster,数据寄存器)：暂存从设备到内存，或从内存到设备的数据</p><p>MAR(Memory Address Register,内存地址寄存器)：在输入时，MAR表示数据应放到内存中的什么位置</p><p>DC(Date Counter 数据计数器)：表示剩余要读/写的字节数</p><p>CR(Command Register,命令状态寄存器)：用于存放CPU发来的I/O命令，或设备状态</p><p><img src="https://s2.loli.net/2021/12/28/3O98DB2UKuhNIy6.png" alt="image-20210804171914731"></p><p><strong>CPU干预的频率</strong>：仅在传送一个或多个数据块的开始和结束时才需要CPU干预</p><p><strong>数据传输的单位</strong>：每次读写一个或多个块(每次读写只能是连续多个块，且这些读入内存中也必须连续的)</p><p><strong>数据的流向</strong>：读操作：从I/O设备直接到内存，</p><p><strong>优点</strong>：数据传输以块为单位，CPU介入频率进一步降低，传输效率进一步增加</p><p><strong>缺点</strong>：CPU每发出一条I/O指令，只能读写一个或多个数据块，如果要读写多个离散存储的数据块，或者要讲数据块写到不同的内存区域时，CPU要分别发出多条I/O指令，进行多次中断处理才能完成</p><hr><h3 id="通道控制方式"><a href="#通道控制方式" class="headerlink" title="通道控制方式"></a>通道控制方式</h3><p>通道：一种硬件，通道可以识别并执行一系列通道指令</p><p>执行过程：</p><ol><li>CPU向通道发出I/O指令，指明通道程序在内存中的位置，并指明要操作的是哪个I/O设备，之后CPU就切换到其他进程执行了</li><li>通道执行内存中的通道程序(其中指明了要读写多少数据，读写的数据应放在内存中的什么位置)</li><li>通道执行完规定任务后，向CPU发出中断信号，之后CPU对中断进行处理</li></ol><p>通道可以识别一系列通道指令，但是可以执行的指令很单一，并且通道程序是放在主机内存中的，也就是说通道和CPU共享内存</p><p><img src="https://s2.loli.net/2021/12/28/b1a2UqQTf8dvoAW.png" alt="image-20210804185035565"></p><p><strong>CPU干预的频率</strong>：极低，通道会根据CPU的指示执行相应的通道程序，只有完成一组数据块的读写后才需要发出中断信号</p><p><strong>数据传输的单位</strong>：每次读写一组数据块</p><p><strong>数据的流向</strong>：读操作：从I/O设备直接到内存</p><p><strong>优点</strong>：CPU，通道，I/O设备可以并行工作，资源利用率很高</p><p><strong>缺点</strong>：实现复杂，需要专门的通道硬件支持</p><p><img src="https://s2.loli.net/2021/12/28/ankYK5oAB1tURrx.png" alt="image-20210804185536944"></p><hr><h2 id="I-O软件的层次结构"><a href="#I-O软件的层次结构" class="headerlink" title="I/O软件的层次结构"></a>I/O软件的层次结构</h2><p><img src="https://s2.loli.net/2021/12/28/mkABsrK84nqahju.png" alt="image-20210804185922289" style="zoom:67%;" /></p><p>中间的三层属于操作系统内核部分</p><hr><p><strong>用户层软件</strong></p><p>实现了与用户交互的接口，用户可直接使用该层提供的，与I/O操作相关的库函数对设备进行操作</p><p>用户层软件将用户请求翻译成格式化的I/O请求，并通过系统调用请求操作系统内核的服务</p><hr><p><strong>设备独立性软件</strong></p><p>又称设备无关性软件，与设备的硬件特性无关的功能都在这一层实现</p><p>主要功能是</p><ul><li>向上层提供统一的调用接口</li><li>同时实现对设备的保护</li><li>设备独立性软件要对一些设备的错误进行处理</li><li>设备的分配和回收</li><li>数据缓冲区管理</li><li>建立逻辑设备名到物理设备名的映射关系，根据设备类型选择调用相应的驱动程序，需要通过逻辑设备表(LUT)来确定物理设备名</li></ul><hr><p><strong>设备驱动程序</strong></p><p>主要负责对硬件设备的具体控制，将上层发出的一系列命令转化为特定设备能听得懂的一系列操作，包括设置设备寄存器，检测设备状态等</p><p>一般以一个独立进程方式存在</p><hr><p><strong>中断处理程序</strong></p><p>当I/O任务完成时，I/O控制器会发送一个中断信号，系统会根据中断信号类型找到相应的中断处理程序并执行。中断处理程序的处理流程如下：</p><p><img src="https://s2.loli.net/2021/12/28/K4uANVTIUFQ6af2.png" alt="image-20210804195840756"></p><hr><p>总体结构示意图</p><p><img src="https://s2.loli.net/2021/12/28/ObV7KkNoSHcfq3r.png" alt="image-20210804225326944"></p><hr><p>功能实现示意图</p><p><img src="https://s2.loli.net/2021/12/28/T2VFDLGRwkxHrs3.png" alt="image-20210804225757931"></p><hr><h2 id="假脱机技术"><a href="#假脱机技术" class="headerlink" title="假脱机技术"></a>假脱机技术</h2><p>用软件的方式模拟脱机技术</p><p> <img src="https://s2.loli.net/2021/12/28/3nl6jzcDLfvBP47.png" alt="image-20210805151445612"></p><p>输入井用于收容I/O设备输入的数据</p><p>输出井用于收容I/O设备输出的数据</p><p>在输入进程的控制下，输入缓冲区用于暂存从输入设备输入的数据，之后再转存到输入井中</p><p>在输出进程的控制下，输出缓冲区用于暂存从输出设备输出的数据，之后再转存到输出井中</p><hr><p>假如有一台打印机，当多个用户进程提出输出打印的请求时，系统都会答应他们的要求，但是并不是真正把打印机分配给他们，而是又假脱机管理进程为每个进程做两件事：</p><ol><li>在磁盘输出井中为进程申请一个空闲缓冲区，并将要打印的数据送入其中</li><li>为用户进程申请一张空白的打印请求表，并将用户的打印请求填入表中，在将该表挂到假脱机文件队列上</li></ol><p>当打印机空闲时，输出进程会从文件队列的队头取出一张打印请求表，并根据表中的要求将要打印的数据从输出井传送到输出缓冲区，再输出到打印机进行打印</p><p><img src="https://s2.loli.net/2021/12/28/CpMRbELimzaUc4l.png" alt="image-20210805152358564"></p><hr><h2 id="设备的分配和回收"><a href="#设备的分配和回收" class="headerlink" title="设备的分配和回收"></a>设备的分配和回收</h2><p><strong>设备的固有属性</strong></p><p>可以分为三种：独占设备，共享设备，虚拟设备</p><p>独占设备：一个时段只能分配给一个进程</p><p>共享设备：可同时分配给多个进程使用，各进程往往是宏观上同时使用设备，而微观上交替使用</p><p>虚拟设备：采用SPOOLing技术将独占设备改造成虚拟的共享设备，可以给多个设备</p><hr><p><strong>设备分配算法</strong></p><p>安全分配：为进程分配一个设备后就将进程阻塞，本次I/O完成后才将进程唤醒，不会死锁，但是CPU和I/O设备只能串行工作</p><p>不安全分配方式：进程发出I/O请求后，系统为其分配I/O设备，进程可继续执行</p><p>静态分配：进程运行前就分配全部所需资源，运行结束后归还资源</p><p>动态分配：进程运行过程中动态申请设备资源</p><hr><p><strong>设备分配管理中的数据结构</strong></p><p><img src="https://s2.loli.net/2021/12/28/FGoLmrgTAylfIaZ.png" alt="image-20210805153131127"></p><p><strong>设备控制表(DCT)</strong>：系统为每个设备配置一张DCT，用于记录设备情况</p><p><img src="https://s2.loli.net/2021/12/28/Gtq4LPYZmVvxnMy.png" alt="image-20210805153225584"></p><p><strong>控制器控制表(COCT)</strong>：每个设备控制器对应一张DCT，操作系统根据COCT信息对通道进行操作和管理</p><p><img src="https://s2.loli.net/2021/12/28/Am2tFp8BLT1qnMa.png" alt="image-20210805153827293"></p><p><strong>通道控制表(CHCT)</strong>：每个通道都会对应一张CHCT，操作系统根据CHCT的信息对通道进行操作和管理</p><p><img src="https://s2.loli.net/2021/12/28/IH4N2s6P17MSTvr.png" alt="image-20210805153411068"></p><p><strong>系统设备表(SDT)</strong>：记录了系统中全部设备的情况，每个设备对应一个表目</p><p><img src="https://s2.loli.net/2021/12/28/J2mTGrRfPjsxt9O.png" alt="image-20210805153535963"></p><hr><p><strong>设备分配的步骤</strong></p><ol><li>根据进程请求的物理设备名查找SDT</li><li>根据SDT找到DCT，若设备忙碌则将PCB挂到设备等待队列中，不忙碌则将设备分配给进程</li><li>根据DCT找COCT，若控制器忙碌则将PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程</li><li>根据COCT找CHCT，若通道忙碌则将PCB挂到通道等待队列中，不忙碌则将通道分配给进程</li></ol><p>缺点：用户编程必须使用物理设备名，不方便编程，若进程请求的物理设备正在忙碌，则即使系统中还有同类型的设备，进程也必须阻塞等待</p><p>改进方法：建立逻辑设备名与物理设备名的映射机制，用户编程时只需要提供逻辑设备名</p><p> 即在第2步的时候，查找SDT，找到用户进程指定类型的，并且空闲的设备，将其分配给该进程，操作系统在逻辑设备表中新增一个表项</p><p>如果之后用户进程再次通过相同的逻辑设备名请求设备，通过LUT表就可以知道对应的是什么物理设备，并且也知道该设备的驱动程序入口地址</p><hr><h2 id="缓冲区管理"><a href="#缓冲区管理" class="headerlink" title="缓冲区管理"></a>缓冲区管理</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>缓冲区是一个存储区域，可以用专门的硬件寄存器组成，也可利用内存作为缓冲区</p><p>使用硬件作为缓冲区的成本较高，容量也较小，一般仅用于对速度要求非常高的场合</p><p>一般用内存作为缓冲区，设备独立性软件的缓冲区管理就是要组织好这些缓冲区</p><hr><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li><p>缓和CPU和I/O设备之间速度不匹配的矛盾</p></li><li><p>减少对CPU中断频率，放宽对CPU中断响应时间的限制</p></li><li><p>解决数据粒度不匹配的问题</p></li><li><p>提高CPU与I/O设备的并行性</p></li></ul><hr><h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><p>单缓冲：当用户进程请求某种块设备读入若干块的数据，若采用单缓冲的策略，操作系统会在主存中为其分配一个缓冲区</p><p>当缓冲区数据非空时，不能往缓冲区加入数据，只能传出；当缓冲区为空时，可以往其中加入数据，但必须充满后，才能从缓冲区把数据传出</p><p>假定一个初始状态，分析下次到达相同状态需要多少时间，这就是处理一块数据平均所需时间</p><p><img src="https://s2.loli.net/2021/12/28/qgoEGIAc6NTkZH5.png" alt="image-20210805160744435"></p><p>采用单缓冲策略，处理一块数据平均耗时Max(C,T)+M</p><hr><p><strong>双缓冲</strong></p><p>采用双缓冲策略，进程会在主存中为其配置两个缓冲区</p><p><img src="https://s2.loli.net/2021/12/28/X13OYeiMBfrQwod.png" alt="image-20210805161243582"></p><p>采用双缓冲策略，处理一个数据块的平均耗时是Max(T,C+M)</p><hr><p><strong>使用单/双缓冲在通信时的区别</strong></p><p>如果两台通信的机器只设置单缓冲区的话，在任一时刻只能实现数据的单向传输</p><p>管道通信中的管道其实就是缓冲区，要实现数据的双向通信，必须设置两个管道</p><hr><h3 id="循环缓冲区"><a href="#循环缓冲区" class="headerlink" title="循环缓冲区"></a>循环缓冲区</h3><p>将多个大小相等的缓冲区链接成一个循环队列</p><p><img src="https://s2.loli.net/2021/12/28/G9uZg3ClASEhp5T.png" alt="image-20210805162619374"></p><hr><h3 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h3><p>缓冲池由系统中共用的缓冲区组成，缓冲区可以分为空缓冲队列，输入队列，输出队列</p><p>根据一个缓冲区在实际运算中扮演的功能不同，又设置了4种工作缓冲区，用于收容输入数据的工作缓冲区，用于提取输入数据的工作缓存区，用于收容输出数据的工作缓存区，用于提取输出数据的工作缓存区</p><p><img src="https://s2.loli.net/2021/12/28/XQ32rmEAgaGLNRb.png" alt="image-20210805163024368"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.虚拟存储器</title>
      <link href="/post/56594.html"/>
      <url>/post/56594.html</url>
      
        <content type="html"><![CDATA[<h1 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>传统存储管理方式存在一些问题，比如作业必须一次全部装入内存后才能开始运行，一旦作业被装入内存，就会一直驻留在内存中，直到作业结束，这会浪费很多内存资源</p><p>根据局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行，在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序</p><p>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存</p><p>在操作系统的作用下，在用户开始似乎有一个比实际内存大得多的内存，这就是<strong>虚拟内存</strong></p><p>虚拟内存技术，允许一个作业分多次调入内存，实现需要建立在离散分配的内存管理方式上</p><hr><h2 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h2><p>请求分页存储管理和基本分页存储管理的主要区别是：</p><p>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序，操作系统需要提供请求调页功能</p><p>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存，操作系统需要提供页面置换的功能</p><p><img src="https://s2.loli.net/2021/12/28/bCoa7GMtIJerE65.png" alt="image-20210803101510437"></p><p>请求分页存储管理的页表</p><p><strong>状态位</strong>：表示是否已调入内存</p><p><strong>访问字段</strong>：可记录最近被访问过几次，或记录上次被访问的时间，供置换算法参考</p><p><strong>修改位</strong>：表示页面调入内存后是否被修改过</p><p><strong>外存位置</strong>：页面在外存中的存放位置</p><hr><p>每当要访问的页面不在内存时，便产生一个缺页中断，然后由操作系统的缺页中断处理程序处理中断，此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放入就绪队列</p><p>如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中相应的页表项</p><p>如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰，若该页面在内存期间被修改过，则要将其写回外存，未修改过的页面不用写回外存</p><p>缺页中断属于内中断，一条指令在实行期间，可能产生多次缺页中断</p><p><img src="https://s2.loli.net/2021/12/28/yeXovTDz1fq3KiS.png" alt="image-20210803102256507"></p><hr><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><p>页面的换入换出需要磁盘I/O，会有较大的开销，因此好的页面置换算法应该追求更少的缺页率</p><h3 id="最佳置换算法-OPT-Optimal"><a href="#最佳置换算法-OPT-Optimal" class="headerlink" title="最佳置换算法(OPT,Optimal)"></a><strong>最佳置换算法(OPT,Optimal)</strong></h3><p>：每次选择淘汰的页面将是以后永不使用，或者最长时间内不再被访问的页面，这样可以保证最低的缺页率</p><p>最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面，操作系统无法提前预判页面访问序列，因此，最佳置换算法是无法实现的</p><hr><h3 id="先进先出算法（First-In-First-Out"><a href="#先进先出算法（First-In-First-Out" class="headerlink" title="先进先出算法（First In First Out)"></a><strong>先进先出算法（First In First Out)</strong></h3><p>：每次选择淘汰的页面是最早进入内存的页面</p><p>Belady异常：当为进程分配的物理块数增大时，缺页次数不减反增的异常现象</p><p>只有FIFO算法会产生Belady异常，FIFO算法虽然实现简单，暗示该算法与进程实际运行时的规律不适应，因此算法性能差</p><hr><h3 id="最近最久未使用置换算法-LRU-Least-Recently-Used"><a href="#最近最久未使用置换算法-LRU-Least-Recently-Used" class="headerlink" title="最近最久未使用置换算法(LRU,Least Recently Used)"></a><strong>最近最久未使用置换算法(LRU,Least Recently Used)</strong></h3><p>：每次淘汰的页面是最近最久未使用的页面</p><p>实现方法：赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间t，当要淘汰一个页面时，选择t值最大的</p><p>该算法实现需要专门的硬件，虽然算法性能好，但是实现困难，开销大</p><hr><h3 id="时钟置换算法-CLOCK"><a href="#时钟置换算法-CLOCK" class="headerlink" title="时钟置换算法(CLOCK)"></a><strong>时钟置换算法(CLOCK)</strong></h3><p>又称最近未用算法(NRU,Not Recently Used)</p><p>实现方法：为每个页面设置一个访问位，再将内存中的页面都通过指针链接成一个循环队列。当某页被访问时，其访问位置为1。当要淘汰一个页面时，只需检查页的访问位。如果是0，就将其换出，如果是1，就将它置为0，继续检查下一个页面</p><p>若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0，再进行第二轮扫描</p><hr><h3 id="改进型时钟置换算法"><a href="#改进型时钟置换算法" class="headerlink" title="改进型时钟置换算法"></a><strong>改进型时钟置换算法</strong></h3><p>简单的时钟置换算法仅考虑到一个页面最近是否被访问过，事实上，如果被淘汰的页面没有被修改过，就不需要执行I/O操作写回外存，只有被淘汰的页面修改过，才需要写回外存</p><p>因此，操作系统还应考虑页面有没有被修改过，在其他条件都相同时，应优先淘汰没有修改过的页面，避免I/O操作，这就是改进型的时钟置换算法思想</p><p>修改位=0，表示未修改过，修改位为1，表示页面修改过，用(访问位,修改位)表示页面</p><p>第一轮：从当前位置开始扫描到第一个(0,0)替换</p><p>第二轮：若第一轮失败，则查找第一个(0,1)替换，本轮将所有扫描过的帧访问为设为0</p><p>第三轮：若第二轮失败，则重新扫描，查找到第一个(0,0)替换</p><p>第四轮：若第三轮扫描失败，则重新扫描，查找到第一个(0,1)替换</p><p><img src="https://s2.loli.net/2021/12/28/O4vuJlhzNQ1Xe3D.png" alt="image-20210803133816478"></p><hr><h2 id="页面分配策略，抖动，工作集"><a href="#页面分配策略，抖动，工作集" class="headerlink" title="页面分配策略，抖动，工作集"></a>页面分配策略，抖动，工作集</h2><p>驻留集：指请求分页存储管理中给进程分配的物理块的集合</p><p>在使用虚拟存储技术的系统中，驻留集大小一般小于进程总大小</p><p>固定分配：操作系统为每个进程分配一个固定数目的物理快</p><p>可变分配：先为每个进程分配一定的数目，在运行期间，可根据情况做适当的增加或减少</p><hr><p>局部置换：发生缺页的时候只能选进程自己的物理块进行置换</p><p>全部置换：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程有的物理快置换到外存，在分配给缺页进程</p><p>全部置换肯定是可变分配</p><hr><h3 id="分配策略"><a href="#分配策略" class="headerlink" title="分配策略"></a><strong>分配策略</strong></h3><p><strong>固定分配局部置换</strong></p><p>系统为每个进程分配一定数量的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。</p><p>这种策略的缺点是：很难在刚开始就确定应为每个进程分配多少个物理块才算合理。（采用这种策略的系统可 以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的内存块数）</p><hr><p><strong>可变分配全部置换</strong></p><p>刚开始会为每个进程分配一定数量的物理块。操作系统会保持一个空闲物理块队列。当某进程发生缺页时，从空闲物理块中取出一块分配给该进程；若已无空闲物理块，则可选择一个未锁定的页面换出外存，再将该物理块分配给缺页的进程。</p><p>采用这种策略时，只要某进程发生缺页， 都将获得新的物理块，仅当空闲物理块用完时，系统才选择一个未锁定的页面调出。被选择调出的页可能是系统中任何一个进程中的页，因此这个被选中的进程拥有的物理块会减少，缺页率会增加。</p><hr><p><strong>可变分配局部置换</strong></p><p>刚开始会为每个进程分配一定数量的物理块，若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。若进程在运行中频繁缺页，系统会为该进程多分配几个物理块，直至该进程缺页率趋势适当程度</p><hr><h3 id="调入页面策略"><a href="#调入页面策略" class="headerlink" title="调入页面策略"></a><strong>调入页面策略</strong></h3><p><strong>预调页策略</strong>：根据局部性原理，一次调入若干个相邻的页面可能比一次调入一个页面更高效，但如果提前调入的页面中大多数都没被访问过，则又是低效的。因此可以预测不久之后可能访问到的页面，将它们预先调入内存，但目前预测成功率只有50%左右。故这种策略主要用于进程的<strong>首次调入</strong>， 由程序员指出应该先调入哪些部分。</p><hr><p><strong>请求调入策略</strong>：进程在<strong>运行期间</strong>发现缺页时才将所缺页面调入内存。由这种策略调入的页面一定会被访问到，但由于每次只能调入一页，而每次调页都要磁盘I/O操作，因此I/O开销较大。</p><hr><h3 id="调入页面的位置"><a href="#调入页面的位置" class="headerlink" title="调入页面的位置"></a><strong>调入页面的位置</strong></h3><p><strong>系统拥有足够的对换区空间</strong>：页面的调入、调出都是在内存与对换区之间进行，这样可以保证页面的调入、调出速度很快。在进程运行前，需将进程相关的数据从文件区复制到对换区。</p><p><strong>系统缺少足够的对换区空间</strong>：凡是不会被修改的数据都直接从文件区调入，由于这些页面不会被修改，因此换出时不必写回磁盘，下次需 要时再从文件区调入即可。对于可能被修改的部分，换出时需写回磁盘对换区，下次需要时再从对换区调入。</p><p><strong>UNIX 方式</strong>：运行之前进程有关的数据全部放在文件区，故未使用过的页面，都可从文件区调入。若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入。</p><p><img src="https://s2.loli.net/2021/12/28/KJhQi7u4gpwnex5.png" alt="image-20210803165725723" style="zoom:80%;" /></p><hr><p><strong>抖动现象</strong>：刚刚换出的页面马上就要换入内存，刚刚换入的页面马上又换出外存，这种频繁的页面行为称为抖动现象</p><p>产生抖动现象的主要原因是<strong>进程频繁访问的页面数目高于可用的物理块数</strong></p><p>工作集：指在某段时间间隔里，进程实际访问页面的集合</p><p>操作系统会根据窗口尺寸来算出工作集，工作集大小可能小于窗口尺寸，在实际应用中，操作系统可以统计进程的工作集大小来考虑分配的驻留集</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.存储器管理</title>
      <link href="/post/37793.html"/>
      <url>/post/37793.html</url>
      
        <content type="html"><![CDATA[<h1 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h1><h2 id="为什么需要内存管理"><a href="#为什么需要内存管理" class="headerlink" title="为什么需要内存管理"></a>为什么需要内存管理</h2><p>内存的基础知识在计算机执行时，处理器处理的几乎每一条指令都涉及到对存储器的访问，因此要求存储器的访问速度能跟上处理机的运行速度。此外还要求存储器有非常大的容量</p><p>因为主存储器的速度是跟不上处理器的，所以为了缓和这一矛盾，引入寄存器和高速缓存</p><p><strong>寄存器</strong>：有和处理器一样的速度，所以寄存器的访问速度最快，但是价格昂贵，主要用于存放处理器运行时的数据</p><p><strong>高速缓存</strong>：介于寄存器和储存器之间的存储器，主要用于备份主存中较常用的数据，一减少主存储器的访问次数，可以大幅提高程序执行速度</p><p><strong>磁盘缓存</strong>：磁盘的I/O速度也远低于对主存的访问速度，为了缓和矛盾，而设置了磁盘缓存，主要用于暂时存放频繁使用的一部分磁盘数据与信息，减少访问磁盘的次数，磁盘缓存雨高速缓存不同，并不实际存在，而是将主存中部分存储空间暂时存放从磁盘中读出的信息，主存当然也可以看做是硬盘的高速缓存</p><p>由于任何程序和数据都<strong>必须占用内存空间</strong>才能执行和处理，因此有效地存储管理也是多道程序设计技术的关键支撑</p><hr><h2 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h2><p>内存可以存放数据，程序执行前需要先放到内存中才能被CPU处理，最后将其再转变为一个可以执行的程序，通常要经过以下几个步骤</p><ol><li>编译：由编译程序对用户源程序进行编译，形成若干个目标模块</li><li>链接：由链接程序将编译后形成的一组目标模块和它们所需要的库函数链接在一起，形成一个完整的转入模块</li><li>装入：由装入程序将装入模块装入内存</li></ol><p><img src="https://s2.loli.net/2021/12/28/zWMPFZitN59jOYo.png" alt="image-20210801151654153"></p><p><strong>程序的装入</strong></p><p>为了解释方便，假设一个无需链接的单个目标模块的装入过程，该目标模块也就是装入模块，可以有如下<strong>三种装入方式</strong></p><ul><li>绝对装入方式</li></ul><p>在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码，装入程序按照装入模块中的地址，将程序和数据装入内存</p><ul><li>静态重定位</li></ul><p>静态重定位：又称可重定位装入，编译，链接后的装入模块的地址都是从0开始的，指令中使用的地址，数据存放的地址都是相对于起始地址而言的逻辑地址。可以根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行重定位，将逻辑地址变换为物理地址</p><p>静态重定位的特点是在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业，作业一旦进入内存后，在运行期间不能移动</p><ul><li>动态重定位</li></ul><p>动态重定位：又称动态运行时装入，编译，链接后的装入模块的地址都是从0开始的，装入程序把装入模块装入内存后，并不会立即将逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行时才进行，因此装入内存后所有的地址依然是逻辑地址，这种方式需要一个重定位寄存器的支持</p><hr><p><strong>程序的链接</strong></p><p>源程序经过编译后，可得到一组目标模块，<strong>链接</strong>程序的功能是将这组模块以及它们所需要的库函数装配成一个完整的装入模块</p><ul><li>静态链接方式</li></ul><p>在程序运行前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件，之后不再才开</p><ul><li>装入时动态链接</li></ul><p>将各目标模块装入内存时，边装入边链接的链接方式</p><ul><li>运行时动态链接</li></ul><p>在程序执行过程中需要该目标模块时，才对它进行链接，其优点是便于修改和更新，便于实现对目标模块的共享</p><hr><h2 id="内存管理的概念"><a href="#内存管理的概念" class="headerlink" title="内存管理的概念"></a><strong>内存管理的概念</strong></h2><ul><li><strong>内存分配</strong></li></ul><p>要为每道程序分配内存空间，提高存储器的利用率，尽量减少碎片，允许正在运行的程序增加内存空间，</p><ul><li><strong>内存保护</strong></li></ul><p>确保每道用户程序都仅在自己的内存空间中运行，绝不允许用户程序访问操作系统的程序和数据</p><ul><li><strong>地址映射</strong></li></ul><p>每道程序经过编译和链接后形成的地址都是从0开始的，但是不可能将它们真的从0开始的物理地址装入内存，为了保证程序运行，存储器必须提供地址映射功能，即将地址空间中的逻辑地址转换为内存空间中的物理地址，在硬件支持下完成</p><ul><li><strong>内存扩充</strong></li></ul><p>借助虚拟存储功能，在逻辑上扩充内存容量</p><p>​    </p><hr><h2 id="覆盖与交换技术"><a href="#覆盖与交换技术" class="headerlink" title="覆盖与交换技术"></a>覆盖与交换技术</h2><p><strong>覆盖技术</strong></p><p>覆盖技术用来解决程序大小超过物理内存总和的问题</p><p>覆盖技术的思想：将程序分为多个段，常用的段常驻内存，不常用的段在需要时调入内存</p><p>在内存中分一个固定区和若干个覆盖区，需要常驻内存的段放在固定区中，调入后就不再调出，不常用的段放在覆盖区，需要用到时调入内存，用不到时调出内存</p><p>必须由程序员声明覆盖结构，操作系统自动完成覆盖，缺点：对用户不透明，增加了用户编程负担，现在已经成为历史</p><hr><p><strong>交换技术</strong></p><p>设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存(进程在内存与磁盘间动态调度)</p><p>通常把磁盘分为文件区和对换区两部分，文件区主要用于存放文件，主要追求存储空间的利用率，因此采用的是<strong>离散分配方式</strong></p><p>对换区空间只占磁盘空间的小部分，因此对换区空间的管理主要追求换入换出速度，因此对换区采用<strong>连续分配方式</strong></p><hr><h2 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h2><p>连续分配：为用户分配的必须是一个连续的内存空间</p><h3 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h3><p>内存被分为系统区和用户区，系统区通常位于内存的低地址部分，用户存放操作系统的相关数据，用户区用于存放用户进程相关数据</p><p>内存中只能有一道用户程序，用户程序独占整个用户区空间</p><p>优点：实现简单，无外部碎片，可以采用覆盖技术扩充内存，不一定需要采用内存保护(早期的PC操作系统MS-DOS)</p><hr><h3 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h3><p>将整个用户空间分配为若干个固定大小的分区，在每个分区中只装入一道作业，这样就形成了最早的，最简单的一种可执行多道程序的内存管理方式</p><p>分区大小相等：缺乏灵活性，但是很适合用于用一台计算机控制多个相同对象的场合</p><p>分区大小不同：增加了灵活性，可以满足不同大小的进程需求</p><p>操作系统需要建立一个分区说明表，来实现各个分区的分配与回收，每个表项对应一个分区，通常按分区大小排列，每个表项包括对应分区的大小，起始地址，状态</p><p><img src="https://s2.loli.net/2021/12/28/gIUqhR3fL2Q7i1a.png" alt="image-20210809141346845"></p><p><img src="https://s2.loli.net/2021/12/28/qnuWJP5LBlNzjAF.png" alt="image-20210809141333066" style="zoom:67%;" /></p><p><strong>地址转换</strong>：对于固定分区的方式采用静态地址重定位的方式</p><p><strong>内存保护</strong>：可由加载程序进行地址越界检查</p><p>优点：实现简单，无外部碎片</p><p>缺点：会产生内部碎片，内存利用率低，当用户程序太大，不得不采取覆盖技术</p><hr><h3 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a><strong>动态分区分配</strong></h3><p>在进程装入内存的时候，根据进程的大小<strong>动态</strong>地建立分区，并使分区的大小正好适合进程的需要，因此系统分区的大小数目是可变的</p><p>系统可以采用空闲分区表或者空闲分区链来记录内存的使用情况</p><ul><li>空闲分区表：每个空闲分区对应一个表项，表项中包含分区号，分区大小，分区起始地址等信息</li><li>空闲分区链：每个分区的起始部分和末尾部分分别设置前向指针和后向指针，起始部分处还可记录分区大小等信息</li></ul><p><img src="https://s2.loli.net/2021/12/28/fowURdezKrCsina.png" alt="image-20210809141433554"></p><p><strong>分配算法</strong>：当一个新作业装入内存时，须按照一定的动态分区分配算法，从空闲分区表中选出一个分区分配给该作业。由于分配算法对系统性能有很大影响，因此很重要</p><p><strong>分配内存</strong>：如果请求的分区比空闲分区小，只需要在空闲分区表中修改分区大小和起始位置，如果请求的分区和空闲分区一样，那么可以直接删除空闲分区的那个表项</p><p><strong>回收内存</strong>：有3种情况</p><p>如果回收区的前后有一个相邻的空闲分区，则将其合并</p><p>如果回收区的前后各有一个相邻的空闲分区，则全部合并</p><p>如果回收区的前后都没有相邻的空闲分区，则新增一个表项</p><hr><p><strong>地址转换</strong>：采用动态地址重定位</p><p><strong>内存保护</strong>：设置两个专用控制寄存器，分别存放分区的起始地址和进程占有的连续存储空间的长度，在执行指令或访问数据时，由寄存器对比知道绝对地址以达到保护的目的</p><p>动态分区分配没有内部碎片，但是有外部碎片</p><p>内部碎片：分配给某进程的内存区域，如果有些部分没有用上</p><p>外部碎片：是指内存中某些空闲分区由于太小而难以利用</p><hr><h2 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a><strong>动态分区分配算法</strong></h2><h3 id="首次适应算法"><a href="#首次适应算法" class="headerlink" title="首次适应算法"></a>首次适应算法</h3><p>算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区</p><p>实现方式：空闲分区以地址递增的次序排列，每次分配内存时顺序查找空闲分区表，找到大小能满足要求的第一个空闲分区</p><hr><h3 id="最佳适应算法"><a href="#最佳适应算法" class="headerlink" title="最佳适应算法"></a>最佳适应算法</h3><p>算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域，因此，为了保证当大进程到来时有连续的大片空间，可以尽可能多地留下大片的空闲区，优先使用更小的空闲区</p><p>实现方式：将空闲分区按容量递增次序链接，每次分配内存时顺序查找空闲分区链，找到大小能满足要求的第一个空闲分区</p><p>缺点：每次都选最小的分区进行分配，会留下越来越多的，很小的，难以利用的内存块，这种方法会产生很多的外部碎片</p><hr><h3 id="最坏适应算法"><a href="#最坏适应算法" class="headerlink" title="最坏适应算法"></a>最坏适应算法</h3><p>算法思想：为了解决最佳适应算法的问题，可以在每次分配时优先利用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用</p><p>实现方式：空闲分区按容量递减次序链接，每次分配内存时顺序查找空闲分区链，找到大小能满足要求的第一个空闲分区</p><p>缺点：每次都选最大的分区分配，但是会导致较大的连续空箱区被迅速用完，之后如果有大进程到达，就没有内存分区可用了</p><hr><h3 id="邻近适应算法"><a href="#邻近适应算法" class="headerlink" title="邻近适应算法"></a>邻近适应算法</h3><p>算法思想：首次适应算法每次都从表头开始查找，每次都要经过细小的分区，增加了查找的开销，如果每次都从上次查找结束的位置开始查找，就能解决上述问题</p><p>实现方式：空闲分区以地址递增的顺序排列，每次分配内存时从上次查找结束的位置开始查找空闲分区表，找到大小能满足要求的第一个空闲分区</p><hr><p><img src="https://s2.loli.net/2021/12/28/K5O4I9xVuAzEYSa.png" alt="image-20210801195520986"></p><p>综合来看，首次适应算法效果最好</p><hr><h2 id="分页存储管理方式"><a href="#分页存储管理方式" class="headerlink" title="分页存储管理方式"></a><strong>分页存储管理方式</strong></h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>连续分配方式会形成很多碎片，虽然可以通过紧凑方法将许多碎片拼接成可用的大块空间，但是要付出很大开销，如果允许将一个进程直接分散地装入到许多不相邻接的分区中，便可充分利用内存空间，而无须紧凑，这就是离散分配方式，而离散分配方式又可以分为三种</p><ul><li>分页存储管理方式</li><li>分段存储管理方式</li><li>段页式存储管理方式</li></ul><hr><p><strong>页框</strong>：将内存空间分为一个个大小相等的分区，<strong>每个分区就是一个页框或物理块</strong>，每个页框有一个编号，即页框号，页框号从0开始。</p><p><strong>页面</strong>：将进程的<strong>逻辑地址空间</strong>也分为与页框大小相等的一个个部分，每个部分称为页或页面，每个页面也有一个编号，称为页号，页号也是从0开始</p><p>操作系统以页框为单位为各个进程分配内存空间。进程的每个页面分别放入一个页框中，也就是说，进程的页面与内存的页框有一一对应的关系</p><p>各个页面不必连续存放，可以放到不相邻的各个页框中</p><p><strong>页表</strong>：为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表</p><ul><li>一个进程就对应一张页表</li><li>进程的每个页面对应一个页表项</li><li>页表记录进程页面和实际存放的内存块之间的映射关系</li></ul><p><img src="https://s2.loli.net/2021/12/28/WPDd91chkJjYg2o.png" alt="image-20210801200907245" style="zoom:67%;" /></p><p>内存的块数等于物理内存大小除以页面大小，可以算出需要多少个二进制数来表达具体的内存块数，再转换为字节数</p><p>页表记录的只是内存块号，而不是内存块的起始地址，J号内存块的起始地址等于J×内存块大小</p><hr><p><strong>地址结构</strong></p><p>虽然进程的各个页面是离散存放的，但是页面内部是连续存放的</p><p>如果要访问逻辑结构A，则需要找到A的页号P，然后找到P号页面在内存中的起始地址，确定逻辑地址A的页内偏移量W</p><hr><p>例：在某计算机系统中，页面大小是50B，某进程的逻辑地址空间大小时200B，则逻辑地址的页号和页内偏移量是多少？</p><p>页号=110/2=2 页内偏移量=110%50=10</p><hr><p>而在计算机内部，地址是用二进制表示的，如果页面大小刚好是2的整数幂，则计算机硬件可以很快速的把逻辑地址拆分为页号和页内偏移量</p><p>如果每个页面大小为$2^kB$，用二进制数表示逻辑地址，则末尾K位即为页内偏移量，其余部分就是页号</p><p>分页存储管理的逻辑地址结构如下</p><p><img src="https://s2.loli.net/2021/12/28/DytgG4FR1o26BIh.png" alt="image-20210801210543135"></p><p>地址结构包含两个部分：前一部分为页号，后一部分为页内偏移量，在图中，地址长度为32位，其中0~11位为页内偏移量，或称页内地址，12到31位是页号</p><p><strong>如果有K位表示页内偏移量，则说明该系统中一个页面的大小是$2^k$个内存单元</strong></p><p>如果有M位表示页号，则说明在系统中，一个进程最多允许有$2^M$个页面</p><hr><h3 id="基本地址变化机构"><a href="#基本地址变化机构" class="headerlink" title="基本地址变化机构"></a>基本地址变化机构</h3><p>基本地址变换结构可以借助进程的页表将逻辑地址转换为物理地址</p><p>通常会在系统中设置一个页表寄存器，存放页表在内存中的起始位置F和页表长度M，进程未执行时，页表的起始位置和页表长度放在进程控制块(PCB)中，当进程被调度时，操作系统内核会把它们放在页表寄存器中</p><p>设页面大小为L，逻辑地址A到物理地址E的变换过程如下</p><p><img src="https://s2.loli.net/2021/12/28/ySdpBHliEt6TaLA.png" alt="image-20210801211947435"></p><ol><li>计算页号P和页内偏移量W</li><li>比较页号P和页表长度M，检查P是否小于M</li><li>页表中页号P对应的页表项地址=页表起始地址F+页号P×页表项长度，取出该页表项内容B，即内存快好</li><li>计算得到E=B×L+W，用得到的物理地址E去访存</li></ol><hr><h3 id="具有快表的地址变换结构"><a href="#具有快表的地址变换结构" class="headerlink" title="具有快表的地址变换结构"></a>具有快表的地址变换结构</h3><p><strong>快表</strong>，又称联想寄存器(TLB,translation lookaside buffer)，是一种访问速度比内存快很多的告诉缓存，用来<strong>存放最近访问的页表项的副本</strong>，可以加速地址变换，与此对应，内页中的页表常称为慢表</p><p>变换过程：</p><ol><li>CPU给出逻辑地址，由某个硬件算得页号，页内偏移量，将页号与快表中的所有页号进行比较</li><li>如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元，因此，如果快表命中，则访问某个逻辑地址仅需<strong>一次访存</strong>即可</li><li>如果没有找到匹配的页号，则需要访问内存中的页表，计算得到物理地址后，访问该物理地址对应的内存单元，因此，若快表未命中，则访问某个逻辑地址需要<strong>两次访存</strong>(在找到页表项后，应同时将其存入快表，以便后面可能的再次访问)</li></ol><hr><h3 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a><strong>两级页表</strong></h3><p>单级页表的不便：</p><ul><li>如果要用页号来查询页表项，要在所有的页表项都连续存放的基础上才能用这种方法找到页表项，这违背了离散存储的特性</li><li>很多时候，进程在一段时间内只需要访问某几个页面就可以正常运行了，因此没有必要让整个页表都常驻内存</li></ul><p>解决进程必须在内存中连续存储的问题时，运用了分页的思想，那么解决页表必须连续存放时，同样可以把必须存放的页表再分页</p><p>可以将长长的页表进行分组，使每个内存块刚好可以放入一个分组，为离散分配的页表再建立一张页表，称为<strong>页目录表</strong>，或称外层页表</p><p><img src="https://s2.loli.net/2021/12/28/ew5xI9gTEbiMmjU.png" alt="image-20210802211551250"></p><p><img src="https://s2.loli.net/2021/12/28/184SPyOb5H6ltZE.png" alt="image-20210802211746583"></p><p>其中一级页号可以在页目录表中指示页表的存放内存块号，然后二级页号可以指示页面的具体存放位置</p><p>若采取多级页表机制，则各级页表大小不能超过一个页面</p><p>N级页表访问一个逻辑地址需要N+1次访存</p><hr><h2 id="基本分段存储管理"><a href="#基本分段存储管理" class="headerlink" title="基本分段存储管理"></a>基本分段存储管理</h2><p>进程的地址空间：按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名，每段从0开始</p><p>内存分配规则：以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻，由于是按逻辑功能模块划分，用户编程更方便，刻度性更高</p><p><img src="https://s2.loli.net/2021/12/28/Wu1986k4YF7dpwa.png" alt="image-20210803081423916"></p><p>段号的位数决定了每个进程最多可以分为几个段</p><p>段内地址位数决定了每个段的最大长度是多少</p><p>程序分为多个段，各段离散地装入内存，为了保证程序的运行，就必须从物理内存中找到各个逻辑段的存放位置，为此需要每个进程建立一张段映射表，简称<strong>段表</strong></p><p><img src="https://s2.loli.net/2021/12/28/7TxhgkZL8dBurVX.png" alt="image-20210803081707171"></p><p>每个段对应一个段表项，其中记录了该段内存中的起始位置和段的长度</p><p>各个段表项的长度是相同的，因此，段号可以是隐含的，不占存储空间</p><p><img src="https://s2.loli.net/2021/12/28/bt1MLfahgB6smeZ.png" alt="image-20210803082507660"></p><hr><p><strong>分段，分页管理的对比</strong></p><ul><li><p>页是信息的物理单位，分页的主要目的是为了实现离散分配，提高内存利用率，分页仅仅是系统管理上的需要，对用户不可见</p></li><li><p>段是信息的逻辑单位，分段的主要目的是更好地满足用户需求，一个段通常包含着一组属于一个逻辑模块的信息。分段对用户是可见的</p></li></ul><hr><ul><li><p>分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址</p></li><li><p>分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址</p></li><li>分段比分页更容易实现信息的共享和保护</li></ul><hr><h2 id="段页式管理方式"><a href="#段页式管理方式" class="headerlink" title="段页式管理方式"></a>段页式管理方式</h2><p>分段，分页的优缺点分析</p><p><img src="https://s2.loli.net/2021/12/28/on5CbstlHWiAG3I.png" alt="image-20210803084704937"></p><p>段页式系统的基本原理还是分段和分页原理的结合，即先将用户程序分为若干段，再把每个段分为大小相同的内存块，并为每个段赋予一个段名</p><p><img src="https://s2.loli.net/2021/12/28/7PfF1sTjlknctyX.png" alt="image-20210803091142355"></p><p>段号的位数决定了每个进程最多可以分为几个段</p><p>页号位数决定了每个段最大有多少页</p><p>页内偏移量决定了页面大小，内存块大小</p><p>每个段对应一个段表项，每个段表项由段号，页表长度，页表存放块号组成，每个段表项长度相等，段号是隐含的</p><p><img src="https://s2.loli.net/2021/12/28/GtjNwQeP9YsFO1M.png" alt="image-20210803091514735"></p><p>变换过程</p><p><img src="https://s2.loli.net/2021/12/28/2UznTBkK8i34MQr.png" alt="image-20210803091614851"></p><p>需要三次访存，第一次是访问内存中的段表，第二次是访问内存中的页表，最后才是访问目标内存单元</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p><img src="https://s2.loli.net/2021/12/28/wo8Y5bSRpWDyNm3.png" alt="image-20210811160917953"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.处理机的调度与死锁</title>
      <link href="/post/52793.html"/>
      <url>/post/52793.html</url>
      
        <content type="html"><![CDATA[<h1 id="处理机的调度与死锁"><a href="#处理机的调度与死锁" class="headerlink" title="处理机的调度与死锁"></a>处理机的调度与死锁</h1><h2 id="调度的层次"><a href="#调度的层次" class="headerlink" title="调度的层次"></a>调度的层次</h2><p><strong>调度</strong>：当有很多任务要处理，但由于资源有限，这些事情没法同时处理，这就需要去确定某种规则来决定处理这些任务的<strong>顺序</strong>，这就是调度研究的问题</p><p><strong>作业</strong>：一个具体的任务</p><p><strong>高级调度(作业调度)</strong>：按一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程。每个作业只调入一次，调出一次，作业调入时会建立PCB，调出的时候才撤销PCB</p><p>高级调度主要用于多道批处理系统中，而在分时和实时系统中不设置高级调度</p><p><strong>低级调度(进程调度)</strong>：按照某种策略从就绪队列中选取一个进程，将处理机分配给它</p><p>进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度，频率很高</p><p><strong>中级调度(内存调度)</strong>：按照某种策略将进程在内存和外存中调出和调入，让进程在挂起和运行状态切换</p><p><img src="https://s2.loli.net/2021/12/28/d5KHgFqfIEsix6t.png" alt="image-20210723163601374"></p><hr><h2 id="调度算法的目标"><a href="#调度算法的目标" class="headerlink" title="调度算法的目标"></a>调度算法的目标</h2><h3 id="处理级调度算法的共同目标"><a href="#处理级调度算法的共同目标" class="headerlink" title="处理级调度算法的共同目标"></a>处理级调度算法的共同目标</h3><ol><li><p>CPU利用率：指CPU忙碌的时间占总时间的比例</p></li><li><p>公平性：公平性是指应使各个进程都获得合理的CPU时间，不会发生进程饥饿现象，但是公平是相对的，对相同类型的进程获得相同的服务，不同类型的进程，提供不同的服务</p></li><li>平衡性：由于系统中可能有多种类型的进程，为了使系统中CPU和各种外部设备都能经常处于忙碌状态，调度算法应尽可能保持资源使用的平衡性</li><li>策略强制执行：对所制定的策略其中包括安全策略，只要需要，就必须予以准确地执行，即使会造成某些工作的延迟也要执行</li></ol><hr><h3 id="批处理系统的目标"><a href="#批处理系统的目标" class="headerlink" title="批处理系统的目标"></a>批处理系统的目标</h3><ol><li><p>平均周转时间短</p><p><strong>周转时间</strong>：是指<strong>作业被提交给系统开始，到作业完成为止的这段时间间隔</strong>，包括4部分时间：作业在外存后备队列上等待调度的时间，进程在就绪队列上等待进程调度的时间，进程在CPU上执行的时间，以及进程等待I/O操作完成的时间</p><p>计算机系统的管理者总是希望平均周转时间最短，可以把平均周转时间描述为<strong>(各作业周转时间之和)/(作业数)</strong></p><p>为了进一步反应调度的性能，更清晰地描述各个进程在其周转时间中，等待和执行时间的具体分配情况，往往使用带权周转时间，其值等于<strong>作业周转时间和在CPU上执行的时间的比值</strong>，带权周转时间必然大于等于1，因为在CPU上执行的时间被包括在了周转时间之内</p><hr></li><li><p>系统吞吐量高</p><p><strong>吞吐量</strong>：只在单位时间内系统所完成的作业数，因此与批处理作业的平均长度有关，如果单纯为了获得高的系统吞吐量，就应尽量多地选择短作业运行</p></li><li><p>处理机利用率高</p></li></ol><hr><h3 id="分时系统的目标"><a href="#分时系统的目标" class="headerlink" title="分时系统的目标"></a>分时系统的目标</h3><ol><li><p>响应速度快</p><p><strong>响应速度</strong>：响应速度是选择分时系统中进程调度算法的重要准则，是从通过键盘提交一个请求开始，知道屏幕上显示出处理结果为止的一段时间间隔。</p><p>包括三部分时间：一是请求信息从键盘输入开始，直至将其传送到处理机的时间。二是处理机对请求信息进行处理的时间，三是将所形成的响应信息回送到终端显示器的时间</p><p><strong>响应比</strong>：(等待时间+要求服务时间)/要求服务时间</p></li><li><p>均衡性</p><p>用户对响应时间的要求并非完全相同，所谓均衡性，是指系统响应时间的快慢与用户所请求服务的复杂性相适应</p></li></ol><hr><h3 id="实时系统的目标"><a href="#实时系统的目标" class="headerlink" title="实时系统的目标"></a>实时系统的目标</h3><ol><li><p>截止时间的保证</p><p>截止时间：是指某任务必须开始执行的最迟时间，调度算法的一个主要目标就是保证实时任务对截止时间的要求</p></li><li><p>可预测性</p></li></ol><hr><h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><ol><li>保存处理机的现场信息。如程序计数器，多个通用寄存器中的内容等</li><li>按某种算法选取进程</li><li>把处理器分配给进程，此时需要将选中进程的进程控制块内有关处理机现场的信息装入处理器相应的各个寄存器中，把处理器的控制权交予该进程，让它从上次的断点处恢复</li></ol><h3 id="时机"><a href="#时机" class="headerlink" title="时机"></a>时机</h3><p>进程主动放弃处理机的情况</p><ul><li>进程正常终止</li><li>运行过程中发生异常而终止</li><li>进程主动请求阻塞</li></ul><p>进程被动放弃处理机的情况</p><ul><li>分给进程的时间片用完</li><li>有更紧急的事要处理</li><li>有更高优先级的进程进入就绪队列</li></ul><p>不能进行进程调度的情况</p><ul><li>处理中断的过程中</li><li>进程在操作系统内核程序临界区中</li><li>在原语操作中</li></ul><hr><h3 id="进程调度的方式"><a href="#进程调度的方式" class="headerlink" title="进程调度的方式"></a>进程调度的方式</h3><p>非剥夺调度方式(非抢占方式)</p><p>只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态</p><p>特点：实现简单，系统开销小，只适用于早起的批处理系统</p><hr><p>剥夺调度方式(抢占方式)</p><p>当一个进程正在处理机上运行时，处理机可以立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程</p><p>特点：可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能，适合于分时操作系统，实时操作系统</p><hr><h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><h3 id="先来先服务算法-FCFS-First-Come-First-Serve"><a href="#先来先服务算法-FCFS-First-Come-First-Serve" class="headerlink" title="先来先服务算法(FCFS,First Come First Serve)"></a>先来先服务算法(FCFS,First Come First Serve)</h3><p>算法规则：系统按照作业到达的先后次序来进行调度</p><p>作用范围：可以用于作业调度和进程调度</p><p>算法类型：非抢占式的算法</p><p>优点：公平，算法实现简单</p><p>缺点：排在长作业后面的短作业需要等待很长时间，带权周转时间很大，FCFS算法对长作业有利，对短作业不利</p><p>饥饿：不会导致</p><hr><h3 id="短作业优先算法-SJF-Shortest-Job-First"><a href="#短作业优先算法-SJF-Shortest-Job-First" class="headerlink" title="短作业优先算法(SJF,Shortest Job First )"></a>短作业优先算法(SJF,Shortest Job First )</h3><p>算法规则：最短的作业有点得到服务</p><p>作用范围：可以用于作业调度和进程调度</p><p>算法类型：非抢占式的算法，但是也有抢占式的版本——SRTN</p><p>优点：最短的平均等待时间，平均周转时间</p><p>缺点：不公平，对短作业有利，对长作业不利</p><p>饥饿：会导致饥饿</p><hr><h3 id="高响应比优先算法-HRRN-Highest-Response-Ratio-Next"><a href="#高响应比优先算法-HRRN-Highest-Response-Ratio-Next" class="headerlink" title="高响应比优先算法(HRRN,Highest Response Ratio Next)"></a>高响应比优先算法(HRRN,Highest Response Ratio Next)</h3><p><strong>响应比</strong>：(等待时间+要求服务时间)/要求服务时间</p><p>算法规则：每次调度时先计算各个进程响应比，选择响应比最高的进程</p><p>作用范围：可以用于作业调度和进程调度</p><p>算法类型：非抢占式</p><p>优点：综合考虑了等待时间和运行时间，如果等待时间相同，则要求服务时间小的进程先运行(SJF)，如果要求服务时间相同，则等待时间长的先运行(FCFS)</p><p>饥饿：不会</p><hr><h3 id="时间片轮转调度算法-RR，Round-Robin"><a href="#时间片轮转调度算法-RR，Round-Robin" class="headerlink" title="时间片轮转调度算法(RR，Round-Robin)"></a>时间片轮转调度算法(RR，Round-Robin)</h3><p>算法规则：按照各个进程到达就绪队列的顺序，轮流让各进程执行一个时间片，如果进程未在一个时间片内执行完，就剥夺处理机，并将进程放在就绪队列队尾重新排队</p><p>作用范围：仅进程调度</p><p>算法类型：可抢占式</p><p>优点：公平，响应快</p><p>缺点：由于高频率的进程切换，因此有一定的开销，不区分任务的紧急程度</p><p>饥饿：不会</p><hr><h3 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h3><p>算法规则：每个进程都有各自的优先级，调度时选择最高的优先级进程</p><p>作用范围：可以用于作业调度和进程调度</p><p>算法类型：有抢占式和非抢占式</p><p>优点：用优先级区分紧急程度，适用于实时操作系统</p><p>缺点：若高优先级进程很多，则可能导致饥饿</p><p>饥饿：会</p><p>优先级可以分为静态优先级和动态优先级，静态优先级创建时确定并保持不变，动态优先级创建时有一个初始值，之后会根据情况动态地调整优先级</p><hr><h3 id="多级反馈队列调度算法-multileved-feedback-queue"><a href="#多级反馈队列调度算法-multileved-feedback-queue" class="headerlink" title="多级反馈队列调度算法(multileved feedback queue)"></a>多级反馈队列调度算法(multileved feedback queue)</h3><p>算法规则：</p><ul><li>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大</li><li>新进程到达时，先进入第一级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进入下一级队列队尾，如果已经在最下级，则重新放回队列队尾</li><li>只有第k级队列为空，才会为k+1级队头的进程分配时间片</li></ul><p>作用范围：进程调度</p><p>算法类型：抢占式算法，在k级队列的运行过程中，若更上级的队列中进入了新进程，那么新进程会抢占处理机，原来运行的进程放回k级队尾</p><p>优点：</p><ul><li>对各个进程相对公平(FCFS)</li><li>每个新到达的进程都可以很快响应(RR)</li><li>短进程只用较少时间就可完成(SJF)</li><li>不必实现估计进程的运行时间</li><li>可以灵活的调整对各类进程的偏好程度</li></ul><p>饥饿：会</p><hr><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>死锁：在并发环境下，各进程因争夺资源而造成的一种互相等待对方手里的资源，导致各进程阻塞，都无法向前推进的现象</p><p>产生条件：</p><ul><li>互斥条件：只有对必须互斥使用的资源争抢才会导致死锁</li><li>不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放</li><li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有</li><li>循环等待条件：存在一种进程资源的循环等待链，链中每个进程已获得的资源同时被下一个进程所请求</li></ul><hr><h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><p>已经知道死锁的产生需要4个条件，那么破坏其中任意一个条件就可以破坏死锁</p><p><strong>1. 互斥条件</strong></p><p>如果能把互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态</p><p>比如SPOOLing技术，将独占设备在逻辑上改造为共享设备</p><p>并不是所有的资源都可以改造成可共享使用的资源，并且为了系统安全，很多地方还必须保护这种互斥性，因此，很多情况下都无法破坏互斥条件</p><hr><p><strong>2. 不剥夺条件</strong></p><p>方案一：当某个进程请求新的资源得不到满足，就必须立刻释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件</p><p>方案二：当某个进程需要的资源被其他进程占有的时候，可以由操作系统协助，将想要的资源强行剥夺，这种方式一般要考虑各进程的优先级</p><p>缺点：实现复杂，增加系统开销，方案一会导致饥饿</p><hr><p><strong>3. 请求和保持条件</strong></p><p>采用<strong>静态分配</strong>方法，即进程在运行钱一次申请完它所需要的全部资源，在它的资源未满足前不让它投入运行，一旦投入运行后，这些资源就一直归它所有</p><p>缺点：有些资源可能只需要使用很短的时间，但是一直保持所有资源会让资源利用率极低，另外，也有可能导致某些进程保持饥饿</p><hr><p><strong>4. 循环等待条件</strong></p><p>采用顺序资源分配法，首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求支援，同类资源一次申请完</p><p>原理分析：一个进程只有已占有小编号的资源，才有资格去申请更大编号的资源，有大编号资源的进程不可能逆向回来申请小编号资源，从而不会循环等待</p><p>缺点：不方便增加新的设备，如果与实际顺序不一样，就会浪费资源</p><hr><h3 id="避免死锁——银行家算法"><a href="#避免死锁——银行家算法" class="headerlink" title="避免死锁——银行家算法"></a><strong>避免死锁——</strong>银行家算法</h3><p>安全序列：就是指系统按照这种序列分配资源，则每个进程都能顺利完成，只要能找出一个安全序列，系统就是安全状态</p><p>如果系统在安全状态，就一定不会发生死锁，如果系统进入不安全状态，就可能发生死锁</p><p>银行家算法的<strong>核心思想</strong>是在资源分配之前想判断这次分配是否会导致系统进入不安全状态</p><p>具体执行如下：</p><p>假设系统中有<strong>n个进程，m种资源</strong>，每个进程在运行前先声明对各种资源的最大需求数，则可以用一个n×m的矩阵来表示所有进程对各种资源的最大需求数，称为<strong>最大需求矩阵Max</strong>，同理系统可以用一个n×m的<strong>分配矩阵Allocation</strong>来表示所有进程的资源分配情况，Max-Allocation=<strong>Need矩阵</strong>，表示各进程最多还需要多少各类资源</p><p><img src="https://s2.loli.net/2021/12/28/fGxaKc4WTX1e2dZ.png" alt="image-20210726202126613"></p><p>另外，还需要一个长度为m的一维数组Available表示当前系统中还有多少可用资源，某进程Pi向系统申请资源，可用一个长度为m的以为数组Request表示本次申请的各种资源量，算法执行步骤如下</p><ol><li>如果某进程的Need数组大于该进程的Request数组，则到第2步，否则则出错</li><li>如果某进程的Request数组小于当前的Available数组，则到第3步，否则表示系统尚无足够资源，进程必须等待</li><li>系统试探性把资源分配给进程，并修改相应的数据（并非真的分配，修改数据只是为了预判），修改Available，Request，Allocation的值</li><li>操作系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态，若安全，才正式分配，否则，恢复相应数据</li></ol><p>安全性算法步骤：检查当前剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并且把该进程持有的资源全部回收，不断重复上述过程，看最终是否能让所有进程都加入安全序列</p><hr><h3 id="死锁的检测和解除"><a href="#死锁的检测和解除" class="headerlink" title="死锁的检测和解除"></a>死锁的检测和解除</h3><p>为了能对系统是否发生了死锁进行检测，必须：</p><ul><li>用某种数据结构来保存资源的请求和分配信息</li><li>提供一种算法，利用上述信息来检测系统是否死锁</li></ul><p>利用资源分配图这一数据结构，包含两种结点，进程结点对应包含一个进程，资源结点对应一类资源，可能有多个 包含两种边，进程结点到资源结点是申请边，资源结点到进程结点是分配边</p><p><img src="https://s2.loli.net/2021/12/28/Mah8FxRIl64ByXm.png" alt="image-20210729191739037" style="zoom:50%;" /></p><p>如果剩余资源数可以满足进程的需求，那么进程不会被阻塞，可以顺利地执行下去，如果这个进程结束后归还资源，那么可以让另外一些进程执行下去</p><p>如果按上述过程，最终消除了所有边，那么这个图是可以简化的，并且一定没有发生死锁，如果不能消除，那么一定发生了死锁</p><p>检测死锁的算法：</p><ol><li>在资源分配图中，找出不阻塞不孤立的进程，消去它所有的请求边和分配边，使之孤立，然后释放资源</li><li>释放的资源可以唤醒原来的阻塞进程，然后再重复1过程，直至取去除所有的边</li></ol><p>死锁定理：如果某时刻系统的资源分配图是不可简化的，那么此时系统死锁</p><hr><p>解除死锁的主要方法：</p><ol><li><p>资源剥夺法。挂起某些死锁进程，并抢占它的资源</p></li><li><p>撤销进程法，强制撤销进程</p></li><li><p>进程回退法，将一个或多个进程直接回退到足以避免死锁的地步</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.进程管理</title>
      <link href="/post/14199.html"/>
      <url>/post/14199.html</url>
      
        <content type="html"><![CDATA[<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="进程基础"><a href="#进程基础" class="headerlink" title="进程基础"></a>进程基础</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>进程(Process)是<strong>进程实体</strong>的运行过程，是系统进行<strong>资源分配</strong>和<strong>调度</strong>的一个独立单位</p><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>进程控制块PCB(Process Control Block )是进程存在的唯一标志，当进程被创建时，操作系统会为其创建一个PCB,当进程结束时，会回收PCB</p><p>PCB包括了进程描述信息，进程控制和管理信息，资源分配清单，处理机相关信息</p><p>进程标识符PID(Process ID)是计算机系统用来标识进程的标识符</p><p><img src="https://s2.loli.net/2021/12/28/gfhaxWIEndXGokR.png" alt="image-20211228220221061"></p><p>操作系统对进程进行管理工作所需的信息都存在PCB中</p><hr><p>而进程由<strong>PCB，程序段，数据段</strong>组成，PCB是由操作系统使用，程序段和数据段是给进程自己使用</p><p><img src="https://s2.loli.net/2021/12/28/Ngarjlzt6Mwi5Ie.png" alt="image-20211228220242360"></p><p>程序段：指程序在运行过程中需要的指令</p><p>数据段：包含运行过程中产生的各种数据</p><hr><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p><img src="https://s2.loli.net/2021/12/28/hU27OBmD5LzrGxM.png" alt="image-20211228220251050"></p><hr><h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><p>创建态：进程正在被创建，状态是创建态，这个阶段操作系统会为进程分配资源，初始化PCB</p><p>就绪态：当进程创建完成后，就进入就绪态，处于就绪态的进程已经具备运行条件，但由于没有空闲CPU，就暂时不能运行</p><p>运行态：如果一个进程此时就在CPU上运行，那么这个进程就处于“运行态”，CPU会执行该进程对应的程序</p><p>阻塞态：在进程运行的过程中，可能会请求等待某个事件的发生，在这个事件发生之前，进程无法继续往下执行，此时操作系统会让这个进程下CPU，并让它进入阻塞态</p><p>终止态：执行exit系统调用，请求操作系统终止该进程，操作系统会让该进程下CPU，并回收内存空间等资源，最后还要回收该进程的PCB</p><p><img src="https://s2.loli.net/2021/12/28/X9VWdnRQUTyPN7u.png" alt="image-20211228220334514"></p><p>运行态到阻塞态是一种进程自身作出的主动行为</p><p>阻塞态到就绪态不是进程自身能控制的，是一种被动行为</p><p><img src="https://s2.loli.net/2021/12/28/uTfteY4CbzRd8MV.png" alt="image-20211228220324417"></p><hr><h3 id="进程的组织"><a href="#进程的组织" class="headerlink" title="进程的组织"></a>进程的组织</h3><p>链式方式：通过指针来指向PCB，执行指针指向运行态的程序，就绪队列指针指向在就绪态的PCB</p><p>索引方式：通过索引表来记录进程的状态</p><hr><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程，撤销已有进程，实现进程状态转换等功能</p><p>进程的控制通过<strong>原语</strong>来实现，原语的执行具有原子性，即执行过程只能一气呵成，期间不允许被中断，可以用“<strong>关中断指令</strong>”和“<strong>开中断指令</strong>”这个两个特权指令来实现原子性</p><p>CPU执行了关中断指令后，就不会检查中断指令了</p><hr><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><p>在OS中，允许一个进程去创建另一个进程，通常把创建进程的进程称为父进程，而把被创建的进程叫做子进程</p><p>子进程可以继承父进程所拥有的资源，和父进程并发执行，子进程在被创建的时候会被分配虚拟地址空间</p><p>创建一个进程所使用的原语 </p><p><img src="https://s2.loli.net/2021/12/28/JFAqEZlKBeWCVgp.png" alt="image-20211228220352118"></p><p>导致创建新线程的操作有</p><ul><li>用户登录</li><li>作业调度</li><li>提供服务</li><li>应用请求</li></ul><hr><h3 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h3><p>关闭一个进程所使用的原语</p><p><img src="https://s2.loli.net/2021/12/28/NyAF97rB4XodDtQ.png" alt="image-20211228220434248"></p><p>导致终止进程的操作有：</p><ul><li>正常结束</li><li>异常结束，比如非法指令，越界错误等</li><li>外界干预，比如父进程终止</li></ul><hr><h3 id="进程的阻塞"><a href="#进程的阻塞" class="headerlink" title="进程的阻塞"></a>进程的阻塞</h3><p>阻塞一个进程所使用的原语</p><p><img src="https://s2.loli.net/2021/12/28/c8rSNOXqlJCWd47.png" alt="image-20211228220448166"></p><p>导致进程阻塞的操作有：</p><ul><li>向系统请求共享资源失败</li><li>等待某种操作的完成，比如等待I/O设备</li><li>新数据还没到达</li><li>等待新任务的到达</li></ul><hr><h3 id="进程的唤醒"><a href="#进程的唤醒" class="headerlink" title="进程的唤醒"></a>进程的唤醒</h3><p>让阻塞态的进程变为就绪态的原语</p><p><img src="https://s2.loli.net/2021/12/28/jPnXxK7GvdlBhWV.png" alt="image-20211228220538443"></p><hr><h3 id="进程的切换"><a href="#进程的切换" class="headerlink" title="进程的切换"></a>进程的切换</h3><p>让两个进程的状态发生改变，让进程在就绪状态和运行状态中切换</p><p><img src="https://s2.loli.net/2021/12/28/WYlAF4tqmZQXj1D.png" alt="image-20211228220600497"></p><hr><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>之前已经提到过操作系统具有异步性，各并发执行的进程以独立的，不可预知的速度向前推进</p><p>在管道通信中，读进程和写进程并发地运行，由于并发必然导致异步性，因此写数据和读数据两个操作的执行先后顺序是不确定的，而在实际应用中，又必须按照先写再读的顺序来执行</p><p><strong>进程同步</strong>，就是要对多个相关进程在执行次序上进行协调，使并发执行的多个进程之间能按照<strong>一定的规则</strong>共享系统资源，并能很好地相互合作，从而使执行具有可再现性</p><hr><p><strong>临界资源</strong>：一个时间段只允许一个进程使用的资源称为临界资源，许多物理设备都是临界资源</p><p>对于临界资源的访问，必须要<strong>互斥</strong>的进行。互斥，又称<strong>间接制约关系</strong>，进程互斥指当一个进程访问临界资源的时候，另一个想要访问该临界资源的进程必须等待</p><p>对临界资源的互斥访问，可以在逻辑上划分为以下四个部分</p><p><img src="https://s2.loli.net/2021/12/28/1qldyj6o98shf2W.png" alt="image-20211228220737049"></p><p>进入区：负责检查是否可以进入临界区，如可进入，则应设置正在访问临界资源的标志（上锁），防止其他进程同时进入临界区</p><p><strong>临界区</strong>：每个进程中访问临界资源的那段代码叫做临界区</p><p>退出区：负责解除正在访问临界资源的标志(解锁)</p><p>剩余区：做其他处理</p><hr><p>为了实现对临界资源的互斥访问，同时保证系统性能，需要遵循以下原则：</p><ul><li>空闲让进。当临界区空闲的时候，可以允许一个请求进入临界区的进程立即进入</li><li>忙则等待。当临界区中有进程时，其他试图进入临界区的进程必须等待</li><li>有限等待。对请求访问的进程，应保证能在有限的时间内进入临界区</li><li>让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待</li></ul><hr><h3 id="进程互斥的软件实现方法"><a href="#进程互斥的软件实现方法" class="headerlink" title="进程互斥的软件实现方法"></a>进程互斥的软件实现方法</h3><p><strong>单标志法</strong>：两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程，也就是说每个进程进入临界区的权限只能被另一个进程赋予</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> turn=<span class="number">0</span>;</span><br><span class="line"><span class="comment">// 进程0</span></span><br><span class="line"><span class="keyword">while</span>(turn!=<span class="number">0</span>);</span><br><span class="line">    critical section;</span><br><span class="line">    turn=<span class="number">1</span>;</span><br><span class="line">    remained section;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程1</span></span><br><span class="line"><span class="keyword">while</span>(turn!=<span class="number">1</span>);</span><br><span class="line">    critical section</span><br><span class="line">    turn=<span class="number">0</span>;</span><br><span class="line">    remainder section</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>turn作为标志位，可以实现同一时刻最多只允许一个进程访问临界区</p><p>最大的问题在于，只能轮流访问，如果临界区空闲，但是并不允许其他进程访问，主要问题就是违反了空闲让进原则</p><hr><p><strong>双标志先检查法</strong>：设置一个布尔数组flag[],数组中的各个元素用来标记各进程想要进入临界区的意愿</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> flag[<span class="number">2</span>];</span><br><span class="line">flag[<span class="number">0</span>]=<span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>]=<span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 刚开始设计两个进程都不行进入临界区</span></span><br><span class="line"><span class="comment">//进程0</span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>]);</span><br><span class="line">flag[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">0</span>]=<span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进程1</span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>]);</span><br><span class="line">flag[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">1</span>]=<span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>双标志先检查法的主要问题是：进入区的检查和上锁两个处理不是一气呵成的，检查之，上锁前可能发生进程切换</p><hr><p><strong>双标志后检查法</strong>：如果把while和flag的位置交换，就是后检查法</p><p>虽然解决了忙则等待的问题，但是如果两个进程同时把flag改为1，就都无法进入临界区了，也是不行的</p><hr><p><strong>Peterson算法</strong></p><p>结合双标志法和单标志法，结合轮转和表达意愿</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> flag[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> turn=<span class="number">0</span>;</span><br><span class="line"><span class="comment">// 进程0</span></span><br><span class="line">flag[<span class="number">0</span>]=<span class="literal">true</span>;   <span class="comment">// 我要进入</span></span><br><span class="line">turn=<span class="number">1</span>;        <span class="comment">// 进程1先用</span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>]&amp;&amp;turn==<span class="number">1</span>);</span><br><span class="line">cirtical section;</span><br><span class="line">flag[<span class="number">0</span>]=<span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进程1</span></span><br><span class="line">flag[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">turn=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>]&amp;&amp;turn==<span class="number">0</span>);</span><br><span class="line">cirtical section;</span><br><span class="line">flag[<span class="number">1</span>]=<span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用软件的方法解决了进程互斥问题，遵循了空闲让进，忙着等待，有限等待三个原则，但是依然没有遵循<strong>让权等待</strong>的原则</p><hr><h3 id="进程互斥的硬件实现方法"><a href="#进程互斥的硬件实现方法" class="headerlink" title="进程互斥的硬件实现方法"></a>进程互斥的硬件实现方法</h3><p><strong>1.利用开/关中断</strong></p><p>在进入临界区之前关闭中断，中断关闭后即不允许当前进程被被中断，也必然不会发生进程切换，直到进程访问完临界区，再执行开中断指令，才有可能有别的进程上处理机并访问临界区</p><p>优点：简单，高校</p><p>缺点：滥用关中断权利可能会导致严重后果，关中断时间过长，会影响系统效率，不适用于多CPU系统</p><hr><p><strong>2.利用Test-and-Set指令实现互斥</strong></p><p>借助TSL指令以实现互斥，TS指令用硬件实现，执行的过程不允许被中断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//布尔型共享lock表示当前临界区是否被加锁</span></span><br><span class="line"><span class="comment">//true表示已加锁，false表示未加锁</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TestAndSet</span><span class="params">(<span class="keyword">bool</span> *lock)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> old;</span><br><span class="line">    old=*lock;</span><br><span class="line">    *lock=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用TEL执行实现互斥的算法逻辑</span></span><br><span class="line"><span class="keyword">while</span>(TestAndSet(&amp;lock));<span class="comment">// 上锁并检查</span></span><br><span class="line"><span class="comment">//临界区</span></span><br><span class="line">lock=<span class="literal">false</span>;   <span class="comment">// 解锁</span></span><br><span class="line"><span class="comment">//剩余区</span></span><br></pre></td></tr></table></figure><p>相比软件实现方法，TSL指令把上锁和检查操作用硬件的方式变成了一气呵成的原子操作</p><p>优点：实现简单，无需像软件实现方法那样严格检查是否有逻辑漏洞</p><p>缺点：不满足让权等待</p><hr><p><strong>3.Swap指令</strong></p><p>也叫Exchange指令，或者XCHG指令</p><p>Swap指令是用硬件实现的，执行过程不允许被中断，只能一气呵成</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swap指令就是交换两个变量的值</span></span><br><span class="line">Swap(<span class="keyword">bool</span> *a,<span class="keyword">bool</span> *b)&#123;</span><br><span class="line"><span class="keyword">bool</span> temp;</span><br><span class="line">temp=*a;</span><br><span class="line">*a=*b;</span><br><span class="line">*b=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//lock表示临界区是否被加锁</span></span><br><span class="line"><span class="keyword">bool</span> old=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(old==<span class="literal">true</span>)</span><br><span class="line">    Swap(&amp;lock,&amp;old);</span><br><span class="line"><span class="comment">//临界区代码段</span></span><br><span class="line">lock=<span class="literal">false</span>;</span><br><span class="line"><span class="comment">//剩余区代码段</span></span><br></pre></td></tr></table></figure><p>优缺点和TSL指令一致</p><hr><h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><p>回顾之前解决互斥的方法，都无法实现让权等待的问题，Dijkstra提出了一种方案，就也就是信号量机制</p><p>用户进程可以通过使用操作系统提供的<strong>一对原语</strong>来对信号量进行操作</p><p><strong>信号量</strong>：其实就是一个变量，可以用一个信号量来表示系统中某种资源的数量</p><p><strong>一对原语</strong>：wait(S)原语和signal(S)原语，可以把原语理解为自己写的函数，名字分别为wait和signal，括号里的<strong>信号量S</strong>其实就是函数调用时传入的一个参数</p><p>wait，signal原语常被简称为P,V操作</p><hr><p><strong>整型信号量</strong>：用一个整数型的变量作为信号量，用来表示系统中某种资源的数量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> S=<span class="number">1</span>;<span class="comment">// 初始化整型信号量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> S)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(S&lt;=<span class="number">0</span>);</span><br><span class="line">S--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> S)</span></span>&#123;</span><br><span class="line">S++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进程0</span></span><br><span class="line">wait(S);</span><br><span class="line"><span class="comment">//临界区</span></span><br><span class="line">signal(S)</span><br></pre></td></tr></table></figure><p>和双标志先检查法类似，不过将检查和上锁通过原语操作一气呵成，所以避免了并发和异步的问题</p><p>缺点：依然不满足让权等待的原则</p><hr><p><strong>记录型信号量</strong></p><p>即用记录型数据结构表示的信号量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录型信号量的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"> <span class="keyword">int</span> value;         <span class="comment">//剩余资源数</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">L</span>;</span>  <span class="comment">//等待队列</span></span><br><span class="line">&#125;semaphore</span><br><span class="line"></span><br><span class="line"> <span class="comment">//某进程需要使用资源时，通过wait原语申请</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">wait</span> <span class="params">(semaphore S)</span></span>&#123;</span><br><span class="line">  S.value--;          <span class="comment">// 在等待就将value值-1</span></span><br><span class="line">  <span class="keyword">if</span>(S.value&lt;<span class="number">0</span>)&#123;</span><br><span class="line">      block(S.L)  <span class="comment">//资源数不够就阻塞，并且挂到信号量S的等待队列中去</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进程使用完资源后，通过signal原语释放</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span> <span class="params">(semaphore S)</span></span>&#123;</span><br><span class="line">    s.value++;</span><br><span class="line">    <span class="keyword">if</span>(S.value&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        wakeup(S.L); </span><br><span class="line"><span class="comment">// 释放资源后，若还有别的进程在等待，就使用wakeup原语唤醒一个进程，该进程从阻塞态变为就绪态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>遵循了让权等待的原则</p><hr><p>使用信号量机制实现<strong>进程互斥，进程同步，前驱关系</strong></p><p><strong>进程互斥</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置互斥信号量mutex，初值为1</span></span><br><span class="line">semaphore mutex=<span class="number">1</span>;</span><br><span class="line">P1()&#123;</span><br><span class="line">P(mutex);</span><br><span class="line">....    </span><br><span class="line">V(mutex):</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P2()&#123;</span><br><span class="line">P(mutex);</span><br><span class="line">....    </span><br><span class="line">V&#123;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于不同临界资源设置不同的信号量</p><hr><p><strong>进程同步</strong></p><p>要求让各并发进程按要求有序地推进</p><p>分析在什么地方实现同步关系，设置同步信号量S，初始为0</p><p>在前操作之后执行V(S),后操作之前执行P(S)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">P1()&#123;</span><br><span class="line"> 代码<span class="number">1</span>；</span><br><span class="line"> 代码<span class="number">2</span>；</span><br><span class="line"> V(S);</span><br><span class="line"> 代码<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P2()&#123;</span><br><span class="line"> P(S);</span><br><span class="line"> 代码<span class="number">4</span>;</span><br><span class="line"> 代码<span class="number">5</span>;</span><br><span class="line"> 代码<span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样可以保证代码4一定在代码2之后执行</p><p>若先执行V(S),则S+1后S=1，此时P(S)可以执行，反之，P(S)在S=0时不能执行，要等V(S)执行后唤醒</p><hr><p><strong>前驱关系</strong></p><p>有些进程必须等其他进程执行了之后才具备执行条件，所以要为每一对前驱关系各设置一个同步信号量</p><hr><h3 id="管程机制"><a href="#管程机制" class="headerlink" title="管程机制"></a>管程机制</h3><p>虽然信号量机制是一种方便有效地进程同步机制，但是会产生大量的PV操作，不仅给系统的管理带来了麻烦，而且还会因为同步不当导致系统死锁，为了解决上述问题，所以使用了管程(Monitors)机制</p><p><strong>管程的定义</strong></p><ul><li><p>系统中各种硬件资源和软件资源都可以用数据结构抽象地描述其资源特性，可以利用共享数据结构抽象地表示系统中的共享资源。</p></li><li><p>将对该共享数据结构实施的特定操作定义为一组过程。</p></li><li><p>对局部于管程的共享数据设置初始值的语句</p></li></ul><p><strong>管程的特征</strong></p><ul><li><p>局部于管程的数据只能被局部于管程的过程所访问</p></li><li><p>一个进程只能通过调用管程内的过程才能进入管程访问共享数据</p></li><li><p>每次仅允许一个进程在管程内执行某个内部过程</p></li></ul><p>管程就是面向对象里面封装思想的体现，将复杂的PV操作写进管程里面，从而使主函数变得简洁</p><hr><h2 id="经典的进程同步问题"><a href="#经典的进程同步问题" class="headerlink" title="经典的进程同步问题"></a>经典的进程同步问题</h2><h3 id="生产者与消费者问题"><a href="#生产者与消费者问题" class="headerlink" title="生产者与消费者问题"></a><strong>生产者与消费者问题</strong></h3><p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品在缓冲区，而消费者消费一个产品在缓冲区，生产者，消费者共享一个大小为n的缓冲区，缓冲区是临界资源</p><ul><li>只有缓冲区没满，生产者才能把产品放进去</li><li>只有缓冲区不空，消费者才能从中取出产品</li><li>缓冲区必须互斥访问</li></ul><p>所以需要有3个PV操作</p><hr><p><strong>1.记录型信号量</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex=<span class="number">1</span>; <span class="comment">//互斥信号量，实现对缓冲区的互斥访问 </span></span><br><span class="line">semaphore empty=n; <span class="comment">//同步信号量，表示空闲缓冲区的数量</span></span><br><span class="line">sempahore full=<span class="number">0</span>   <span class="comment">//同步信号量，表示产品的数量</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 可以具象化实现过程，产品等于菜，而空闲缓冲区等于座位，有多少座位就可以上多少道菜，座位和菜是绑定关系，对于生产来说，首先是占一个座位，然后在上面生产出一道菜，对于消费来说，首先是消费了一道菜，然后才会释放一个座位</span></span><br><span class="line">producer()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">       produce;</span><br><span class="line">       P(empty);  </span><br><span class="line">       P(mutex);</span><br><span class="line">       input;</span><br><span class="line">       V(mutex);</span><br><span class="line">       V(full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">comsumer()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(full);</span><br><span class="line">        P(mutex);</span><br><span class="line">        output;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(empty);</span><br><span class="line">        use;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：实现互斥的P操作一定要在实现同步的P操作之后</p><hr><p><strong>2.管程</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">monitor ProducerConsumer</span><br><span class="line">    condition full,empty;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;<span class="comment">//产品数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Item item)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count==N)</span><br><span class="line">        &#123;</span><br><span class="line">            P(empty);</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">        insert_item(item);</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">1</span>)</span><br><span class="line">            V(full);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function">Item <span class="title">remove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(count==<span class="number">0</span>)</span><br><span class="line">        P(full);</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span>(count==N<span class="number">-1</span>)</span><br><span class="line">        V(empty);</span><br><span class="line">    <span class="keyword">return</span> remove_item()</span><br><span class="line">&#125;</span><br><span class="line">end monitor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line">produce()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        item=生产;</span><br><span class="line">        ProducerConsumer.insert(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line">produce()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        item=ProdecuerConsumer.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="哲学家进餐"><a href="#哲学家进餐" class="headerlink" title="哲学家进餐"></a><strong>哲学家进餐</strong></h3><p>该问题是描述有五个哲学家共用一张圆桌，分别坐在周围的五张椅子上，在圆桌上有五个碗和五只筷子，他们的生活方式是交替地进行思考和进餐。平时，一个哲学家进行思考，饥饿时便试图取用其左右最靠近他的筷子，只有在他拿到两只筷子时才能进餐。进餐毕，放下筷子继续思考。</p><p><img src="https://s2.loli.net/2021/12/28/f2cWdCtQoKb3yzH.png" alt="image-20211228220755055"></p><p>首先，有5个哲学家进程，哲学家与左右邻居对其中间筷子的访问是互斥关系，每个哲学家进程需要同时持有两个临界资源才开始吃饭，主要问题在于如何避免死锁</p><p>信号量设置，定义互斥信号量数组chopstick[5]={1,1,1,1,1}用于实现对5个筷子的互斥访问。并对哲学家按0~4编号，哲学家i左边的筷子编号为i，右边的筷子编号为(i+1)%5</p><p>为了防止5个哲学家都持有一只筷子而发生死锁，需要对筷子的拿取设置一定的规则</p><p>比如最多允许4个哲学家同时进餐，或者仅当哲学家的左右筷子均可用时，才允许拿起筷子进餐</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 仅当哲学家的左右筷子均可用时，才允许拿起筷子进餐</span></span><br><span class="line">semaphore chopstick[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;</span><br><span class="line">semaphore mutex=<span class="number">1</span>;</span><br><span class="line">Pi()&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    P(mutex);</span><br><span class="line">    P(chopstick[i]);</span><br><span class="line">    P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">    V(mutex);</span><br><span class="line">    吃饭...</span><br><span class="line">    V(chopstick[i]);</span><br><span class="line">    V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">    思考...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最多允许4个哲学家进餐</span></span><br><span class="line">semaphore chopstick[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;</span><br><span class="line">semaphore x=<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    p(x);</span><br><span class="line">    P(chopstick[i]);</span><br><span class="line">    P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">    就餐</span><br><span class="line">    V(chopstick[i]);</span><br><span class="line">    V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">    V(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a><strong>读者-写者问题</strong></h3><p>一个数据文件或记录可被多个进程共享，我们把只要求读该文件的进程称为”Reader进程”，其他进程则称为”Writer 进程”。</p><p>允许多个进程同时读一个共享对象，因为读操作不会使数据文件混乱。</p><p>但不允许一个 Writer 进程和其他 Reader 进程或 Writer 进程同时访问共享对象。因为这种访问将会引起混乱。</p><p>所谓”读者-写者（Reader-Writer Problem）问题”是指保证一个 Writer 进程必须与其他进程互斥地访问共享对象的同步问题。读者-写者问题常被用来测试新同步原语。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">semaphore rw=<span class="number">1</span>; <span class="comment">//实现对共享文件的互斥访问</span></span><br><span class="line"><span class="keyword">int</span> count =<span class="number">0</span>;  <span class="comment">//记录当前有几个读进程在访问文件</span></span><br><span class="line">semaphore mutex=<span class="number">1</span> <span class="comment">//保证对count变量的互斥访问</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"> writer()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(rw);  <span class="comment">//写之前加锁</span></span><br><span class="line">        <span class="function">Write</span></span><br><span class="line"><span class="function">        <span class="title">V</span><span class="params">(rw)</span></span>;  <span class="comment">//写完了解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">reader()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(mutex)  <span class="comment">//各个读进程互斥访问count</span></span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)<span class="comment">// 由第一个读进程负责</span></span><br><span class="line">            P(rw);   <span class="comment">//读之前加锁</span></span><br><span class="line">        count++;</span><br><span class="line">        V(mutex);</span><br><span class="line">        <span class="function">Read</span></span><br><span class="line"><span class="function">        <span class="title">P</span><span class="params">(mutex)</span></span>;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>) <span class="comment">//由最后一个读进程负责</span></span><br><span class="line">            V(rw);    <span class="comment">//读完了解锁</span></span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="抽烟者问题"><a href="#抽烟者问题" class="headerlink" title="抽烟者问题"></a><strong>抽烟者问题</strong></h3><p>假设一个系统有三个抽烟者进程和一个供应者进程。 每个抽烟者不停地卷烟并抽掉，但是要卷起并抽掉一支烟，抽烟者需要三种材料：烟草、纸和胶水。 三个抽烟者中，第一个拥有烟草，第二个拥有纸，第三个拥有胶水。 供应者无限地提供三种材料，供应者每次讲两种材料挡在桌子上，拥有剩下那种材料的卷烟者卷一根烟并抽掉它，并给供应者一个告诉完成信号，供应者就会放另外两种材料在桌上，这种过程一直重复</p><p>首先分析同步和互斥的关系，桌子可以抽象为容量为1的缓冲区</p><p>将桌子上的两种材料抽象为组合，当桌子上有组合1时，第一个抽烟者取走东西，有组合2时，第二个抽烟者取走东西，有组合3时，第三个抽烟者取走东西，然后都需要发出完成信号，让供应者将下一个组合放到桌上</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">semaphore offer1=<span class="number">0</span>; <span class="comment">// 组合1的数量</span></span><br><span class="line">semaphore offer2=<span class="number">0</span>; <span class="comment">// 组合2的数量</span></span><br><span class="line">semaphore offer3=<span class="number">0</span>; <span class="comment">// 组合3的数量 </span></span><br><span class="line">semaphore finish=<span class="number">0</span>; <span class="comment">// 抽烟是否完成</span></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;            <span class="comment">// 用于实现三个抽烟者轮流抽烟</span></span><br><span class="line">provider()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">            put mix1;</span><br><span class="line">            V(offer1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            put mix2;</span><br><span class="line">            V(offer2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">2</span>)</span><br><span class="line">        &#123;   </span><br><span class="line">            put mix3;</span><br><span class="line">            V(offer3);</span><br><span class="line">        &#125;</span><br><span class="line">        i=(i+<span class="number">1</span>)%<span class="number">3</span>;</span><br><span class="line">        P(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">smoker1()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(offer1);</span><br><span class="line">        smoke;</span><br><span class="line">        V(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">smoker2()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(offer2);</span><br><span class="line">        smoke;</span><br><span class="line">        V(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">smoker3()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(offer3);</span><br><span class="line">        smoke;</span><br><span class="line">        V(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>进程通信就是指进程之间的信息交换</p><p>进程是分配系统资源的单位，因此各进程拥有的内存地址空间相互独立</p><h3 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h3><p>在内存中创建一个共享空间，让两个进程都可以访问，两个进程对共享空间的访问必须是互斥的</p><p>共享存储的方式有基于数据结构的共享和基于存储区的共享</p><ul><li><p>基于数据结构的共享：只能放特定结构的数组，这种共享方式速度慢，限制多，是一种低级通信方式</p></li><li><p>基于存储区的共享：在内存中画出一块共享存储区，数据的形式，存放的位置都由进程控制，这种方式速度更快，是一种高级通信方式</p></li></ul><hr><h3 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h3><p>管道是指用于连接读写进程的一个共享文件，其实就是在内存够中开辟一个大小固定的缓冲区</p><ul><li><p>管道只能采用半双工通信，如果要双向同时通信，则要使用两个管道</p></li><li><p>各个进程要互斥的访问管道</p></li><li><p>数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据取走，当读进程被数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞</p></li><li>如果没写满就不允许读，如果没读空，就不允许写</li><li>读进程最多只能有一个</li></ul><hr><h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><p>进程间的数据交换以格式化的消息为单位，进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换</p><p>一个格式化的消息包括一个消息头和消息尾两个部分</p><p>消息头包含：发送进程ID，接收进程ID，消息类型，消息长度等格式化的消息</p><p>消息传递的直接通信方式直接将消息挂到接收进程的消息缓冲队列上</p><p>间接通信方式是将消息先发到中间体</p><hr><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>线程是一个基本的CPU执行单元，也是程序执行流的最小单位</p><ul><li><p>引入线程后，不仅进程之间可以并发，进程内各线程之间也可以并发，从而进一步提高了系统的并发度</p></li><li><p>引入线程后，进程只作为除CPU之外的系统资源的分配单元</p></li><li><p>引入线程后，并发所带来的系统开销减小</p></li></ul><hr><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li><p>线程是处理机调度的单位</p></li><li><p>同一线程的不同线程共享进程的资源</p></li><li><p>切换进程内的线程，系统开销很小</p></li></ul><hr><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p><strong>用户级线程</strong>：即由应用程序通过线程库实现，所有的线程管理工作都由应用程序负责</p><p><img src="https://s2.loli.net/2021/12/28/9eFva2kxYyu6O4M.png" alt="image-20211228220809437"></p><p>在用户级线程中，线程切换可以在用户态下直接完成</p><p>在用户看来是有多个线程，但是在操作系统内核看来，并意识不到线程的存在，用户级线程就从用户视角能看到的线程</p><p>优点：在用户空间就可以完成，不需要切换到核心态，系统开销小，效率高</p><p>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高，多个进程不可再多核处理机上并发运行</p><hr><p><strong>内核级线程</strong>：操作系统内核支持的线程</p><p><img src="https://s2.loli.net/2021/12/28/dYZPmbVW3pf2IN8.png" alt="image-20211228220829437"></p><p>内核级线程的管理工作由操作系统内核完成</p><p>线程调度，切换等工作都由内核负责，因此内核级线程的切换也必须在核心态下才能完成</p><p>操作系统会为每个内核级线程建立相应的TCB(线程控制块)，通过TCB对线程进行管理。内核级线程就是从操作系统内核视角看能看到的线程</p><p>优点：当一个线程被阻塞后，别的线程还有继续执行，并发能力强</p><p>缺点：一个用户进程会占用多个内核级线程，切换状态的成本高，开销大</p><hr><p><strong>多线程模型</strong></p><p>一对一模型即是内核级线程</p><p>多对一模型即是用户级线程</p><p>多对多模型：n用户及线程映射到m个内核级线程（n&gt;m），每个用户进程对应m个内核级线程</p><p><img src="https://s2.loli.net/2021/12/28/ljSsmoP7vwXUyi3.png" alt="image-20210720154626538" style="zoom:50%;" /></p><p>优点：既克服了多对一模型并发度不高的缺点，有克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点</p><p>内核级线程才是处理机分配的单位，内核级线程可以运行任意一个有映射关系的用户级线程代码，只有两个内核级线程中正在运行的代码逻辑都阻塞时，这个进程才会被阻塞</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.计算机操作系统概述</title>
      <link href="/post/56273.html"/>
      <url>/post/56273.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机操作系统概述"><a href="#计算机操作系统概述" class="headerlink" title="计算机操作系统概述"></a>计算机操作系统概述</h1><h2 id="操作系统的概念和功能"><a href="#操作系统的概念和功能" class="headerlink" title="操作系统的概念和功能"></a>操作系统的概念和功能</h2><p>操作系统（OS）是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，是计算机系统中最基本的系统软件</p><hr><h3 id="1-操作系统是系统资源的管理者"><a href="#1-操作系统是系统资源的管理者" class="headerlink" title="1.操作系统是系统资源的管理者"></a>1.操作系统是系统资源的管理者</h3><p>举例：如果要用QQ和同学视频聊天，首先需要在文件夹中找到QQ安装位置（文件管理），其次双击打开QQ.exe程序（内存管理），QQ程序正常运行（进程管理），开始和朋友视频聊天（输入输出管理）。</p><h3 id="2-操作系统向上层提供方便易用的服务"><a href="#2-操作系统向上层提供方便易用的服务" class="headerlink" title="2.操作系统向上层提供方便易用的服务"></a>2.操作系统向上层提供方便易用的服务</h3><p>GUI：图形化用户接口（Graphical User Interface）用户可以使用形象的图形界面进行操作，而不需要记忆复杂的命令和参数</p><p>联机命令接口，又称交互式命令接口，即在命令提示符中直接输入命令进行交互</p><p>脱机命令接口，即批处理命令接口，可以将命令写成.bat的批处理文件，与系统进行交互</p><p>程序接口：可以在程序中进行系统调用来使用程序接口，即系统调用，用户通过程序间接使用</p><p><img src="https://s2.loli.net/2021/12/28/y3KpgfkSYbrucUE.png" alt="image-20211228220024159"></p><h3 id="3-是最接近硬件的一层软件"><a href="#3-是最接近硬件的一层软件" class="headerlink" title="3.是最接近硬件的一层软件"></a>3.是最接近硬件的一层软件</h3><p>没有任何软件支持的计算机称为裸机，在裸机上安装的操作系统，可以提供资源管理功能和方便的服务功能，通常把覆盖了软件的机器称为扩充机器，又称之为虚拟机</p><hr><h2 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h2><p>一共有4个特征：并发，共享，虚拟，异步</p><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>指两个或多个事件在同一时间间隔内发生，这些事件宏观上是同时发生的，但微观上是交替发生的</p><p>操作系统的并发性指计算机系统中“同时”运行着多个程序，这些程序宏观上看是同时运行的，微观上看是交替运行的</p><p>单核CPU同一时刻只能执行一个程序，各个程序只能并发的执行</p><p>多核CPU同一时刻可以同时执行多个程序，多个程序可以并行的执行</p><hr><h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><p>共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用</p><p>互斥共享：某些资源，虽然可以提供给多个进程使用，但一个时间段只允许一个进程访问该资源</p><p>同时共享：系统中的某些资源，允许一个时间段内由多个进程同时对它们进行访问</p><p>共享和并发互为存在条件</p><hr><h3 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h3><p>虚拟是指把一个物理上的实体变为若干个逻辑上的对应物，物理实体是实际存在的，逻辑上的对应物是用户感受到的</p><p>比如单核CPU的计算机中，可以运行多个程序，这就是虚拟处理器技术，实际只有一个CPU，但是在用户看来似乎用6个CPU在同时服务，这里利用了时分复用技术</p><hr><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是程序的异步性</p><hr><h2 id="操作系统的发展和分类"><a href="#操作系统的发展和分类" class="headerlink" title="操作系统的发展和分类"></a>操作系统的发展和分类</h2><p>手工操作阶段：用户独占全机，人机速度矛盾导致资源利用率极低</p><p><strong>批处理阶段-单道批处理系统</strong>：引入了脱机输入/输出技术，并由监督程序负责作业的输入和输出，</p><p>缺点：内存中仅能有一道程序运行，CPU有大量的时间在空闲等待I/O完成</p><p><strong>批处理阶段-多道批处理系统</strong>：操作系统正式诞生，多道程序并发执行，共享计算机资源。</p><p>优点：</p><ul><li>让CPU处于忙碌状态，利用率高；在内存中装入多道程序提高内存的利用率，此外还可以提高I/O设备的利用率</li><li>系统吞吐量大，仅当作业完成时或运行不下去才进行进程切换，系统开销小</li></ul><p>缺点：</p><ul><li>平均周转时间长</li><li>无交互能力</li></ul><p><strong>分时操作系统</strong>：计算机以时间片为单位轮流为各个用户服务，各个用户可以通过终端与计算机进行交互，用户请求可以被即时响应，解决了人机交互问题，主要缺点是不能处理一些紧急任务</p><p><strong>实时操作系统</strong>：主要优点：能够响应一些紧急任务，某些紧急任务不需要时间片排队，在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且在严格的时限内处理完时间，主要特点是及时性和可靠性</p><hr><h2 id="操作系统的运行机制"><a href="#操作系统的运行机制" class="headerlink" title="操作系统的运行机制"></a>操作系统的运行机制</h2><p>操作系统的内核(Kernel)是操作系统最重要最核心的部分，也是最接近硬件的部分</p><p>操作系统内核为管理者，有时会让CPU执行一些特权指令，如：内存清零指令，这些指令只允许管理者来使用，在CPU设计和生产的时候就划分了特权指令和非特权指令，因此CPU执行一条指令前就能判断其类型</p><p>CPU有两种状态：内核态和用户态</p><p>处于内核态时，说明此时正在运行的是内核程序，此时可以执行特权指令</p><p>处于用户态时，说明此时正在运行的是应用程序，此时只能执行非特权指令</p><p>内核态切换到用户态：执行一条特权指令，修改PSW的标志位为用户态，这个动作意味着操作系统主动让出CPU使用权</p><p>用户态切换到内核态：由中断引发，由<strong>硬件</strong>自动完成变态过程，触发中断信号意味着操作系统强行夺回CPU的使用权</p><hr><h2 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h2><p>中断分为内中断和外中断</p><p>内中断与当前执行的指令有关，中断信号来源于CPU内部，又称异常</p><ul><li>故障（fault），由错误条件引起，可能被内核程序修复。内核程序修复后会把CPU使用权还给应用程序，让它继续执行下去</li><li>终止（abort），由致命错误引起，内核程序无法修复该错误，因此直接终止该应用程序</li><li>陷入（trap），由陷入指令引发，应用程序想请求操作系统内核的服务，此时会执行一条特殊的指令–陷入指令，执行陷入指令意味着主动将CPU控制权还给操作系统</li></ul><p>外中断与当前执行的指令无关，中断信号来源于CPU外部，即是狭义的中断</p><ul><li>时钟中断，时钟部分每隔一个时间给CPU发送一个时钟中断信号</li><li>I/O中断，当输入输出任务完成时，向CPU发送中断信号</li></ul><p>中断机制的基本原理</p><p>不同的中断信号，需要用不同的中断处理程序来处理，当CPU检测到中断信号后，会根据中断信号的类型去查询中断向量表，以此来找到相应的中断处理程序在内存中的存放位置</p><p>中断机制的处理过程</p><p><img src="https://s2.loli.net/2021/12/28/2bWiltvMROuH3FV.png" alt="image-20211228220130496"></p><p>子程序调用会在保存断点步骤中保存程序计数器保存</p><p>中断处理程序会保存程序计数器，程序状态字以及某些通用寄存器的内容</p><hr><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>系统调用是操作系统提供给应用程序使用的接口，可以理解为一种可供应用程序调用的特殊函数，<strong>应用程序可以通过系统调用来请求获得系统内核的服务</strong></p><p>应用程序通过<strong>系统调用</strong>请求操作系统的服务，而系统中的共享资源都由操作系统统一掌管，因此凡是与<strong>共享资源有关</strong>的操作，都必须通过系统调用的方式向操作系统的内核发出<strong>服务请求</strong>，这样可以保证系统的稳定性和安全性</p><p><strong>系统调用的过程：</strong></p><p>传递系统调用参数—&gt;执行陷入指令(用户态)—&gt; 执行相应的内核程序处理系统调用（核心态）—&gt;返回应用程序</p><hr><h2 id="操作系统的体系结构"><a href="#操作系统的体系结构" class="headerlink" title="操作系统的体系结构"></a>操作系统的体系结构</h2><p><img src="https://s2.loli.net/2021/12/28/stMKlxA7Cu8pZ1r.png" alt="image-20211228220105434"></p><p>时钟管理：利用时钟中断实现计时功能</p><p><strong>原语：是一种特殊的程序，这种程序必须被执行完成，不能被中断</strong></p><hr><p>大内核：将操作系统的主要功能模块都作为了系统内核，运行在核心态</p><p>优点：高性能    缺点：内核代码庞大，结构混乱，难以维护</p><p>微内核：只把最基本的功能保留在内核</p><p>优点：内核功能少，结构清晰   缺点：状态切换频繁，性能低</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode栈与队列总结</title>
      <link href="/post/18347.html"/>
      <url>/post/18347.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h3><div class="table-container"><table><thead><tr><th>题目</th><th>难度</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/valid-parentheses">20. 有效的括号</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/min-stack">155. 最小栈</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/implement-stack-using-queues">225. 用队列实现栈</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks">232. 用栈实现队列</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/next-greater-element-i">496. 下一个更大元素 I</a></td><td>简单</td></tr></tbody></table></div><hr><h3 id="技巧与分析"><a href="#技巧与分析" class="headerlink" title="技巧与分析"></a>技巧与分析</h3><p>栈和队列相对来说应用较少，栈一般用来解决成对元素消去的问题</p><p>栈还有一种用途就是单调栈，可以实现下一个更大元素的查找</p><p>逆序遍历数组，并入栈，根据规则出栈并赋值到另一个数组中，即可完成查找</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Leetcode总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode链表相关</title>
      <link href="/post/7321.html"/>
      <url>/post/7321.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h3><div class="table-container"><table><thead><tr><th>题目</th><th>难度</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists">21. 合并两个有序链表</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list">83. 删除排序链表中的重复元素</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/linked-list-cycle">141. 环形链表</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists">160. 相交链表</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/remove-linked-list-elements">203. 移除链表元素</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/reverse-linked-list">206. 反转链表</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/palindrome-linked-list">234. 回文链表</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list">237. 删除链表中的节点</a></td><td>简单</td></tr></tbody></table></div><hr><h3 id="技巧与分析"><a href="#技巧与分析" class="headerlink" title="技巧与分析"></a>技巧与分析</h3><p>对于链表，双指针可以说是基础中的基础了，因为链表本身就是由指针所链接的</p><p>而合并两个有序链表(注意备份)，删除链表中的元素(<code>p-&gt;next=p-&gt;next-&gt;next</code>)，是非常基本操作</p><p>环形链表中的快慢指针判断成环的方法让人眼前一亮</p><p>相交链表中的双指针遍历双链表有点意想不到</p><p>反转链表中的备份也十分关键</p><p>而<a href="https://leetcode-cn.com/problems/palindrome-linked-list">234. 回文链表</a>可以说是链表题目中的精髓，先用快慢指针确定中间节点，然后反转链表再比较，一气呵成</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Leetcode总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode动态规划</title>
      <link href="/post/11404.html"/>
      <url>/post/11404.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h3><div class="table-container"><table><thead><tr><th>题目</th><th>难度</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子数组和</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/climbing-stairs/">70. 爬楼梯</a></td><td>简答</td></tr><tr><td><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/max-consecutive-ones">485. 最大连续 1 的个数</a></td><td>简单</td></tr></tbody></table></div><hr><h3 id="技巧与分析"><a href="#技巧与分析" class="headerlink" title="技巧与分析"></a>技巧与分析</h3><p>动态规划的核心思想就是这个回合的行动取决于之前的结果，所以在代码中常会存储临时变量来进行比较，比如在<code>53</code>中的<code>pre=Math.max(pre,x)</code>这种代码，关键在于看出动态规划的形式</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Leetcode总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode二叉树</title>
      <link href="/post/45354.html"/>
      <url>/post/45354.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h3><div class="table-container"><table><thead><tr><th>题目</th><th>难度</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal">94. 二叉树的中序遍历</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/same-tree">100. 相同的树</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/symmetric-tree">101. 对称二叉树</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree">104. 二叉树的最大深度</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree">108. 将有序数组转换为二叉搜索树</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/balanced-binary-tree">110. 平衡二叉树</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree">111. 二叉树的最小深度</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/path-sum">112. 路径总和</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal">144. 二叉树的前序遍历</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal">145. 二叉树的后序遍历</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/invert-binary-tree">226. 翻转二叉树</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree">235. 二叉搜索树的最近公共祖先</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/binary-tree-paths">257. 二叉树的所有路径</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/sum-of-left-leaves">404. 左叶子之和</a></td><td>简单</td></tr></tbody></table></div><hr><h3 id="分析与总结"><a href="#分析与总结" class="headerlink" title="分析与总结"></a>分析与总结</h3><p>二叉树的操作，三种递归遍历以及非递归遍历是基本常识</p><p>涉及到二叉树的操作，一般都和递归有关，需要根据题目要求涉设计递归函数，难度有点高</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Leetcode总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode数组相关</title>
      <link href="/post/38638.html"/>
      <url>/post/38638.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h3><div class="table-container"><table><thead><tr><th>题目</th><th>难度</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/two-sum">1. 两数之和</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array">26. 删除有序数组中的重复项</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/remove-element">27. 移除元素</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/search-insert-position">35. 搜索插入位置</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/merge-sorted-array">88. 合并两个有序数组</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/pascals-triangle">118. 杨辉三角</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/pascals-triangle-ii">119. 杨辉三角 II</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted">167. 两数之和 II - 输入有序数组</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/majority-element">169. 多数元素</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/contains-duplicate">217. 存在重复元素</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/contains-duplicate-ii">219. 存在重复元素 II</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/summary-ranges">228. 汇总区间</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/missing-number">268. 丢失的数字</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/first-bad-version">278. 第一个错误的版本</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/move-zeroes">283. 移动零</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/range-sum-query-immutable">303. 区域和检索 - 数组不可变</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays">349. 两个数组的交集</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii">350. 两个数组的交集 II</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/third-maximum-number">414. 第三大的数</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array">448. 找到所有数组中消失的数字</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements">453. 最小操作次数使数组元素相等</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/assign-cookies">455. 分发饼干</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/island-perimeter">463. 岛屿的周长</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/teemo-attacking">495. 提莫攻击</a></td><td>简单</td></tr></tbody></table></div><hr><h3 id="技巧与分析"><a href="#技巧与分析" class="headerlink" title="技巧与分析"></a>技巧与分析</h3><p>若是单纯对数组的线性操作，利用List或者Map等数据结构和它们的各种方法，能够实现空间换时间(1,217,219,349)</p><p>但是题目往往没有那么简单，对于数组中各个元素的对比，移动，交换能操作，一般都会用到<strong>双指针</strong>，有时候会将数组先排序后再利用双指针。</p><p>双指针在数组中的应用非常普遍，比如</p><ul><li>对比或交换数组元素的位置(26,27,88,283,453,495)</li><li>缩小范围，直至确定位置(167)</li></ul><p>有些问题可以直接用排序或者是二分查找解决，属于是简单题中的简单题了(35,169,268,278)</p><hr><p>重点思想：</p><p><a href="https://leetcode-cn.com/problems/summary-ranges">228. 汇总区间</a>中的双指针技巧有效的避免的复杂的边界讨论，设置<code>i</code>，然后用<code>low=i</code>，<code>high=i-1</code>来设置，这种思想在<a href="https://leetcode-cn.com/problems/teemo-attacking">495. 提莫攻击</a>中再一次被应用，在寻找一个区间时，尤其好用</p><p><a href="https://leetcode-cn.com/problems/range-sum-query-immutable">303. 区域和检索 - 数组不可变</a>中的确定数组中任意两个元素的差值，所涉及的<strong>前缀和</strong>思想，可以说是非常巧妙</p><p><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii">350. 两个数组的交集 II</a>中的记录数字出现次数，和字符串出现次数可以说是一模一样了</p><p><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array">448. 找到所有数组中消失的数字</a>中的思想，非常重要，可以说是空间换时间的典范，直接用本身的数组就可以起到记录信息的作用</p><p><a href="https://leetcode-cn.com/problems/island-perimeter">463. 岛屿的周长</a>中是第一次遍历矩阵的问题，注意单向遍历，注意不要增加多的空间</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Leetcode总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode字符串相关</title>
      <link href="/post/46225.html"/>
      <url>/post/46225.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h3><div class="table-container"><table><thead><tr><th>题目</th><th>难度</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/roman-to-integer">13. 罗马数字转整数</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/longest-common-prefix">14. 最长公共前缀</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/implement-strstr">28. 实现 strStr()</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/length-of-last-word">58. 最后一个单词的长度</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/valid-palindrome">125. 验证回文串</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/isomorphic-strings">205. 同构字符串</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/valid-anagram">242. 有效的字母异位词</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/word-pattern">290. 单词规律</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/reverse-string">344. 反转字符串</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string">345. 反转字符串中的元音字母</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/ransom-note">383. 赎金信</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string">387. 字符串中的第一个唯一字符</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-the-difference">389. 找不同</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/is-subsequence">392. 判断子序列</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/longest-palindrome">409. 最长回文串</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/fizz-buzz">412. Fizz Buzz</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/number-of-segments-in-a-string">434. 字符串中的单词数</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/repeated-substring-pattern">459. 重复的子字符串</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/license-key-formatting">482. 密钥格式化</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/keyboard-row">500. 键盘行</a></td><td>简单</td></tr></tbody></table></div><hr><h3 id="技巧与分析"><a href="#技巧与分析" class="headerlink" title="技巧与分析"></a>技巧与分析</h3><p>在字符串的题目中，最经典也反复被使用的就是利用<code>HashMap</code>来统计字符串中单词的出现次数，当然，如果统计的是小写字母，也可以创建一个大小为26的数组，利用<code>cnt[c-&#39;a&#39;]</code>来储存字符的出现次数</p><p>经典的题有：<code>242,383,387,409</code></p><p>当涉及到字符串的遍历的时候，一般可以使用字符串的<code>charAt</code>或者<code>toCharArray</code>函数，但有些时候，字符串会以空格分开，这个时候，使用<code>split(&quot; &quot;)</code>函数会有奇效,比如在<code>434</code>中</p><p>哈希表在字符串操作中的用法不止是记录出现次数，在映射关系的题中，哈希表一再出现简化运算，比如在<code>13,205,290</code>中</p><p>而涉及到具体字符的操作，就和数组中一样，使用双指针更加方便，比如在<code>344,345,392</code>中</p><p>而字符串匹配的相关问题，KMP算法一定要掌握，比如在<code>28,459</code>中</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Leetcode总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode位运算与数学</title>
      <link href="/post/50122.html"/>
      <url>/post/50122.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h3><div class="table-container"><table><thead><tr><th>题目</th><th>难度</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/reverse-integer">7. 整数反转</a></td><td>中等</td></tr><tr><td><a href="https://leetcode-cn.com/problems/palindrome-number">9. 回文数</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/powx-n">50. Pow(x, n)</a></td><td>中等</td></tr><tr><td><a href="https://leetcode-cn.com/problems/plus-one">66. 加一</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/add-binary">67. 二进制求和</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/sqrtx">69. Sqrt(x)</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/single-number">136. 只出现一次的数字</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/excel-sheet-column-title">168. Excel表列名称</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/excel-sheet-column-number">171. Excel 表列序号</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/reverse-bits">190. 颠倒二进制位</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/number-of-1-bits">191. 位1的个数</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/happy-number">202. 快乐数</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/power-of-two">231. 2 的幂</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/add-digits">258. 各位相加</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/ugly-number">263. 丑数</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/nim-game">292. Nim 游戏</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/power-of-three">326. 3 的幂</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/counting-bits">338. 比特位计数</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/power-of-four">342. 4的幂</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/valid-perfect-square">367. 有效的完全平方数</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/super-pow">372. 超级次方</a></td><td>中等</td></tr><tr><td><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower">374. 猜数字大小</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/binary-watch">401. 二进制手表</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal">405. 数字转换为十六进制数</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/add-strings">415. 字符串相加</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/arranging-coins">441. 排列硬币</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/hamming-distance">461. 汉明距离</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/number-complement">476. 数字的补数</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/construct-the-rectangle">492. 构造矩形</a></td><td>简单</td></tr></tbody></table></div><hr><h3 id="技巧与分析："><a href="#技巧与分析：" class="headerlink" title="技巧与分析："></a>技巧与分析：</h3><p>关于数学相关的题，一般涉及到<strong>进制转换</strong>，以及<strong>位数颠倒</strong>之类的技巧</p><p>在<code>7.整数反转</code>中就是经典的颠倒顺序，是基本操作需要掌握</p><hr><p>而对于数字的基本运算，需要利用到模拟的思想，用程序<strong>模仿</strong>手算</p><p>比如：</p><ul><li><p><code>66.加1</code>中的运算，就和手算一样，有进位上一位就+1，没有就直接输出</p></li><li><p><code>67.二进制求和</code>中，模拟进位，从低位到高位，也是这一思想的体现，相同的思路在<code>415 字符串相加</code>中再次体现</p></li><li><p><code>168,171</code>中，实际上是模拟26进制与10进制之间的转换</p></li></ul><hr><p>而在<code>202 快乐数</code>中，数字会进入循环，而快慢指针判断成环的方法，从链表应用到数学，非常巧妙</p><p>有些题是无聊的二分查找，比如<code>69,367,374,441,492</code></p><p>还有些题是脑筋急转弯，比如<code>258,292</code></p><hr><p>对于位运算，涉及到的是对具体位的修改与统计，还有异或操作的妙用</p><p>在<code>136 只出现一次的数字</code>中，<strong>异或</strong>操作第一次出现</p><p>在<code>190 颠倒二进制位</code>中n保留最后一位，又逐位反转的方法很有效</p><p>对于<code>n&amp;n-1</code>能让n的最低位1反转这一技巧，被反复用到</p><p>比如在<code>191,231,338,342,461</code>中都有用到</p><p>而构造掩码也是一个技巧，在<code>342.4的幂</code>和<code>476.数字的补数</code>中就是通过巧妙的构造了掩码来简化运算</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Leetcode总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客配置</title>
      <link href="/post/12559.html"/>
      <url>/post/12559.html</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo博客用到的一些配置"><a href="#Hexo博客用到的一些配置" class="headerlink" title="Hexo博客用到的一些配置"></a>Hexo博客用到的一些配置</h1><h2 id="1-分类磁贴"><a href="#1-分类磁贴" class="headerlink" title="1.分类磁贴"></a>1.分类磁贴</h2><p>参考以下链接中提到的方法</p><p><a href="https://ethant.top/articles/hexo541u/#%E9%A6%96%E9%A1%B5%E5%88%86%E7%B1%BB%E7%A3%81%E9%93%81">https://ethant.top/articles/hexo541u/#%E9%A6%96%E9%A1%B5%E5%88%86%E7%B1%BB%E7%A3%81%E9%93%81</a>   </p><p>效果图：</p><p><img src="https://s2.loli.net/2021/12/23/MhlarxNvGpOUwL4.png" alt="image-20211223170308252"></p><hr><h2 id="2-相关推荐置于侧边栏"><a href="#2-相关推荐置于侧边栏" class="headerlink" title="2.相关推荐置于侧边栏"></a>2.相关推荐置于侧边栏</h2><p>参考以下链接中的方法</p><p><a href="https://akilar.top/posts/194e1534/">https://akilar.top/posts/194e1534/</a></p><p>效果图：</p><p><img src="https://s2.loli.net/2021/12/23/aAflKdgGnEHic6N.png" alt="image-20211223170353902"></p><hr><h2 id="3-vercel-github-加速博客访问"><a href="#3-vercel-github-加速博客访问" class="headerlink" title="3.vercel+github 加速博客访问"></a>3.vercel+github 加速博客访问</h2><p><a href="https://vincentqin.tech/posts/speedup-gitpage/">https://vincentqin.tech/posts/speedup-gitpage/</a></p><hr><h2 id="4-typora-picgo-github-一键托管图片"><a href="#4-typora-picgo-github-一键托管图片" class="headerlink" title="4.typora+picgo+github 一键托管图片"></a>4.typora+picgo+github 一键托管图片</h2><p><a href="https://blog.csdn.net/weixin_45965432/article/details/108911937">https://blog.csdn.net/weixin_45965432/article/details/108911937</a></p><hr><h2 id="5-jsDeliver-github使用教程，免费的cdn"><a href="#5-jsDeliver-github使用教程，免费的cdn" class="headerlink" title="5.jsDeliver+github使用教程，免费的cdn"></a>5.jsDeliver+github使用教程，免费的cdn</h2><p><a href="https://www.cnblogs.com/zhsh666/p/11432956.html">https://www.cnblogs.com/zhsh666/p/11432956.html</a></p><hr><h2 id="6-背景效果，页脚渐变，滚动条效果"><a href="#6-背景效果，页脚渐变，滚动条效果" class="headerlink" title="6.背景效果，页脚渐变，滚动条效果"></a>6.背景效果，页脚渐变，滚动条效果</h2><p><a href="https://www.cnblogs.com/antmoe/p/12846393.html">https://www.cnblogs.com/antmoe/p/12846393.html</a></p><hr><h2 id="7-hexo的admin控制台"><a href="#7-hexo的admin控制台" class="headerlink" title="7.hexo的admin控制台"></a>7.hexo的admin控制台</h2><p><a href="https://gitcode.net/mirrors/jaredly/hexo-admin?utm_source=csdn_github_accelerator">https://gitcode.net/mirrors/jaredly/hexo-admin?utm_source=csdn_github_accelerator</a></p><hr><h2 id="8-twikoo评论区以及部署到vercel"><a href="#8-twikoo评论区以及部署到vercel" class="headerlink" title="8.twikoo评论区以及部署到vercel"></a>8.twikoo评论区以及部署到vercel</h2><p><a href="https://twikoo.js.org/quick-start.html">https://twikoo.js.org/quick-start.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA之字符</title>
      <link href="/post/26759.html"/>
      <url>/post/26759.html</url>
      
        <content type="html"><![CDATA[<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="String的创建"><a href="#String的创建" class="headerlink" title="String的创建"></a>String的创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;Runoob&quot;</span>;</span><br><span class="line">String str2=<span class="keyword">new</span> String(<span class="string">&quot;Runoob&quot;</span>);</span><br></pre></td></tr></table></figure><p>同样也可以用<code>str.length()</code>来获取当前字符串的长度</p><hr><h2 id="String方法"><a href="#String方法" class="headerlink" title="String方法"></a>String方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="comment">//返回指定索引处的char值</span></span><br><span class="line"><span class="function">String <span class="title">concat</span><span class="params">(String str)</span></span>;</span><br><span class="line"><span class="comment">//将指定字符串连接到末尾</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span></span>;</span><br><span class="line"><span class="comment">//判断字符串是否相等</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch)</span></span>;</span><br><span class="line"><span class="comment">//返回第一次出现的下标，没有的话返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span></span>;</span><br><span class="line"><span class="comment">//返回指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1</span></span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span></span>;</span><br><span class="line"><span class="comment">//返回一个新的字符串，它是此字符串的一个子字符串。</span></span><br><span class="line"><span class="keyword">char</span>[] toCharArray();</span><br><span class="line"><span class="comment">//将此字符串转换为一个新的字符数组</span></span><br><span class="line"><span class="function">String <span class="title">valueOf</span><span class="params">(datatype x)</span></span>;</span><br><span class="line"><span class="comment">//返回给定datatype类型x参数的字符串表示形式。</span></span><br><span class="line">String [] split(String regex);</span><br><span class="line"><span class="comment">/*对现有的字符串按照正则表达式regex进行切割，并返回一个字符串数组</span></span><br><span class="line"><span class="comment">如果想要把字符串切成一个个字符，就split(&quot;&quot;)即可,如果想让字符串按照空格来进行切割就可以用split(&quot; &quot;)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String Sequence x)</span></span>;</span><br><span class="line"><span class="comment">//判断字符串里面是否有X子串</span></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> a,<span class="keyword">char</span> b)</span></span>;</span><br><span class="line"><span class="comment">//将字符串里面的所有a，都替换成b，并且返回一个替换后的String字符串</span></span><br><span class="line"><span class="function">String <span class="title">replaceFirst</span><span class="params">(String a,String b)</span></span>;</span><br><span class="line"><span class="comment">//将字符串中的第一个a，替换成b，并返回一个替换后的String字符串</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p>字符串转化为List</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="string">&quot;helloworld!&quot;</span></span><br><span class="line">String[] arr = str.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">ArrayList&lt;String&gt; list3 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">Collections.addAll(list3, arr);</span><br></pre></td></tr></table></figure><p>char转换为字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法1.直接在构造String时建立。</span></span><br><span class="line">    <span class="keyword">char</span> data[] = &#123;<span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;k&#x27;</span>&#125;; String str = <span class="keyword">new</span> String(data);</span><br><span class="line"><span class="comment">//方法2.使用String的方法</span></span><br><span class="line">    String.valueOf(<span class="keyword">char</span>[] chr);</span><br></pre></td></tr></table></figure><p>遍历字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="string">&quot;2019 come on&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法一 利用charAt方法，将字符串转换为单个字符输出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; str.length();i++) &#123;</span><br><span class="line"></span><br><span class="line"> System.out.println(str.charAt(i)); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二  用toCharArray方法，将字符串转化为字符数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>[]  c = str.toCharArray();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; c.length;i++) &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(c[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法三 用split()，将字符串转化为字符串数组</span></span><br><span class="line">String[]  s = str.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; s.length;i++) &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="操纵字符串的方法"><a href="#操纵字符串的方法" class="headerlink" title="操纵字符串的方法"></a>操纵字符串的方法</h2><p>如果频繁改变字符串变量，它会新开劈空间，再扔掉原本的空间，非常的浪费，和占用加载时间，但是StringBuffer不会，它会一直在一个空间里</p><p>StringBuffer和StringBuilder相比，保证了线程安全，但运行速度较慢</p><p>支持的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb=<span class="keyword">new</span> StringBuffer(String st); </span><br><span class="line">(StringBuffer) sb.append(<span class="string">&quot;s&quot;</span>);</span><br><span class="line"> <span class="comment">//将指定的字符串追加到此字符序列。</span></span><br><span class="line">(StringBuffer) sb.reverse();</span><br><span class="line"><span class="comment">//用反转形式取代</span></span><br><span class="line"> (<span class="keyword">void</span>)sb.insert(<span class="keyword">int</span> offset, <span class="keyword">int</span> i);</span><br><span class="line"><span class="comment">//将int参数的字符串插入到该序列中</span></span><br><span class="line">(String) toString();</span><br><span class="line"><span class="comment">// 返回此序列中数据的字符串表示形式，也就是将StringBuffer转换为String</span></span><br><span class="line">(StringBuffer) replace(<span class="keyword">int</span> start, <span class="keyword">int</span> end, String str);</span><br><span class="line"><span class="comment">//用指定的字符替换此序列的子字符串中的字符String。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCharAt</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">char</span> ch)</span></span>;</span><br><span class="line"><span class="comment">//指定索引处的字符设置为ch。</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">deleteCharAt</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="comment">//删除索引处的字符</span></span><br></pre></td></tr></table></figure><p>同样，StringBuilder也适用于这些方法</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA之数组</title>
      <link href="/post/50083.html"/>
      <url>/post/50083.html</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA之数组"><a href="#JAVA之数组" class="headerlink" title="JAVA之数组"></a>JAVA之数组</h1><h2 id="数组的创建"><a href="#数组的创建" class="headerlink" title="数组的创建"></a>数组的创建</h2><p>数组是JAVA的特殊队形，它们具有length的简单属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般来说，有两种形式</span></span><br><span class="line"><span class="keyword">int</span> [] a=<span class="keyword">new</span> <span class="keyword">int</span> [n];</span><br><span class="line"><span class="keyword">int</span> [] a=&#123;<span class="number">94</span>,<span class="number">45</span>,<span class="number">45</span>&#125;;</span><br></pre></td></tr></table></figure><p>如果要获取数组的长度，只需要使用<code>a.length</code>就可以了</p><hr><h2 id="For-Each循环"><a href="#For-Each循环" class="headerlink" title="For-Each循环"></a><strong>For-Each循环</strong></h2><p>能在不使用下标的情况下遍历数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Elemtype element:array)&#123;</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h2><p>Arrays类能够方便的操作数组，提供静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Elemtype array;</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">sort</span><span class="params">(array)</span></span>;</span><br><span class="line"><span class="comment">//sort 方法，对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(array,val)</span></span>;</span><br><span class="line"><span class="comment">//将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(array,array1)</span></span>;</span><br><span class="line"><span class="comment">//如果两个指定的 long 型数组彼此相等，则返回 true。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(array,key)</span></span>;</span><br><span class="line"><span class="comment">//用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(插入点) - 1)。</span></span><br><span class="line"><span class="function">ArrayList <span class="title">asList</span><span class="params">(array)</span></span>;</span><br><span class="line"><span class="comment">//将一个数组转变成一个List，准确来说是ArrayList</span></span><br><span class="line"><span class="function">String <span class="title">toString</span><span class="params">(array)</span></span>;</span><br><span class="line"><span class="comment">//将一个数组转变成一个字符串，中间用,隔开</span></span><br><span class="line"><span class="keyword">int</span>[] copyOfRange(<span class="keyword">int</span> [] original ,<span class="keyword">int</span> from,<span class="keyword">int</span> to);</span><br><span class="line"><span class="comment">//复制出一个从from到to的左闭右开的数组</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA之集合---Collection</title>
      <link href="/post/30509.html"/>
      <url>/post/30509.html</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA之集合—-Collection"><a href="#JAVA之集合—-Collection" class="headerlink" title="JAVA之集合—-Collection"></a>JAVA之集合—-Collection</h1><p>数组有很多的缺点，比如</p><ul><li>一旦初始化以后，其长度就不可修改。</li><li>数组中提供的方法非常有限，对于添加、删除、插入数据等操作，非常不便，同时效率不高。</li><li>获取数组中实际元素的个数的需求，数组没有现成的属性或方法可用</li><li>数组存储数据的特点：有序、可重复。对于无序、不可重复的需求，不能满足。</li></ul><p>所以我们使用<strong>集合</strong>来实现</p><p>集合分为<strong>Collection和Map</strong>两种体系</p><ul><li><strong>Collection</strong>：主要由List、Set、Queue接口组成，List代表有序、重复的集合；其中Set代表无序、不可重复的集合；Java 5 又增加了Queue体系集合，代表一种队列集合实现。</li><li><strong>Map</strong>：则代表具有映射关系的键值对集合。</li></ul><p><img src="C:/Users/%E7%83%9B/AppData/Roaming/Typora/typora-user-images/image-20211130204408289.png" alt="image-20211130204408289"></p><h2 id="Collections方法"><a href="#Collections方法" class="headerlink" title="Collections方法"></a>Collections<strong>方法</strong></h2><p>所有的Collection下的实现类都能使用此方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;Integer&gt; coll = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Collection&lt;Integer&gt; coll = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">Collection&lt;Integer&gt; coll = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Elemtype  e)</span></span>;<span class="comment">//添加一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Elemtype e)</span></span>;<span class="comment">//检查集合中指定的元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Eletmtype e)</span></span>;<span class="comment">//移除集合中的元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">max</span><span class="params">(coll)</span> <span class="comment">//根据元素的自然顺序，返回给定集合中的最大元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">min</span><span class="params">(coll)</span><span class="comment">//根据元素的自然顺序，返回给定集合中的最小元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">frequency</span><span class="params">(coll，<span class="keyword">int</span> i)</span> <span class="comment">//返回指定集合中指定元素的出现次数</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure><p>不过有些限定了只能List使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;Integer&gt; coll = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span> <span class="params">(coll)</span></span>;<span class="comment">//反转 List 中元素的顺序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(coll,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>;<span class="comment">//将指定 list 集合中的 i 处元素和 j 处元素进行交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List)</span></span>;<span class="comment">//根据元素的自然顺序对指定 List 集合元素按升序排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List，Comparator)</span></span>;<span class="comment">//根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</span></span><br></pre></td></tr></table></figure><hr><p><img src="http://www.justdojava.com/assets/images/2019/java/image-jay/c25904af60394296a36c41d0c3749ab4.jpg" alt="img"></p><p>Collection接口，是单列数据，定义了一组对象方法的集合</p><ul><li>List：元素有序，可重复的集合</li><li>Set：元素无序，不可重复的集合</li><li>Queue：Queue是一个队列集合，队列通常是指“先进先出”（FIFO）的容器。</li></ul><hr><h2 id="List（有序列表）"><a href="#List（有序列表）" class="headerlink" title="List（有序列表）"></a><strong>List（有序列表）</strong></h2><p>List集合的特点就是存取有序，可以存储重复的元素，可以用<strong>下标</strong>进行元素的操作</p><p>List方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Elemtype <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="comment">//获取此集合中指定索引位置的元素，E 为集合中元素的数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">index</span><span class="params">(Elemtype e)</span></span>;</span><br><span class="line"><span class="comment">//返回此集合中第一次出现指定元素的索引，如果此集合不包含该元素，则返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Elemtype e)</span></span>;</span><br><span class="line"><span class="comment">//返回此集合中最后一次出现指定元素的索引，如果此集合不包含该元素，则返回 -1</span></span><br><span class="line"><span class="function">Elemtype <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, Eelement)</span></span>;</span><br><span class="line"><span class="comment">//将此集合中指定索引位置的元素修改为 element 参数指定的对象。此方法返回此集合中指定索引位置的原元素</span></span><br><span class="line"><span class="function">List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromlndex, <span class="keyword">int</span> tolndex)</span></span>;</span><br><span class="line"><span class="comment">//返回一个新的集合，新集合中包含 fromlndex 和 tolndex 索引之间的所有元素。包含fromlndex 处的元素，不包含 tolndex 索引处的元素</span></span><br></pre></td></tr></table></figure><hr><h3 id="ArrayList（动态数组）"><a href="#ArrayList（动态数组）" class="headerlink" title="ArrayList（动态数组）"></a><strong>ArrayList（动态数组）</strong></h3><p>ArrayList 是一个动态数组结构，支持随机存取，尾部插入删除方便，内部插入删除效率低（因为要移动数组元素）；如果内部数组容量不足则自动扩容，因此当数组很大时，效率较低。</p><p>ArrayList继承了List和Collection的所有方法</p><hr><h3 id="LinkedList（双向链表）"><a href="#LinkedList（双向链表）" class="headerlink" title="LinkedList（双向链表）"></a><strong>LinkedList（双向链表）</strong></h3><p>LinkedList 是一个双向链表结构，在任意位置插入删除都很方便，但是不支持随机取值，每次都只能从一端开始遍历，直到找到查询的对象，然后返回；不过，它不像 ArrayList 那样需要进行内存拷贝，因此相对来说效率较高，但是因为存在额外的前驱和后继节点指针，因此占用的内存比 ArrayList 多一些。</p><p>LinkedList除了继承了List和Collection的所有方法，根据其链表的特性，还特有几种方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span></span>; <span class="comment">//将指定元素添加到此集合的开头</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span></span>; <span class="comment">//将指定元素添加到此集合的末尾</span></span><br><span class="line"><span class="function">Elemtype <span class="title">getFirst</span><span class="params">()</span></span>;    <span class="comment">//返回此集合的第一个元素</span></span><br><span class="line"><span class="function">Elemtype <span class="title">getLast</span><span class="params">()</span></span>; <span class="comment">//返回此集合的最后一个元素</span></span><br><span class="line"><span class="function">Elemtype <span class="title">removeFirst</span><span class="params">()</span></span>; <span class="comment">//删除此集合中的第一个元素</span></span><br><span class="line"><span class="function">Elemtype <span class="title">removeLast</span><span class="params">()</span></span>;  <span class="comment">//删除此集合中的最后一个元素</span></span><br></pre></td></tr></table></figure><hr><h3 id="Vector（动态数组）"><a href="#Vector（动态数组）" class="headerlink" title="Vector（动态数组）"></a><del>Vector（动态数组）</del></h3><p>Vector 也是一个动态数组结构，一个元老级别的类，早在 jdk1.1 就引入进来类，之后在 jdk1.2 里引进 ArrayList，ArrayList 大部分的方法和 Vector 比较相似，两者是不同的，Vector 是允许同步访问的，<strong>Vector 中的操作是线程安全的</strong>，但是效率低，而 ArrayList 所有的操作都是异步的，执行效率高，但不安全！</p><p>因为ArrayList已经有了其他安全的方法，所以没有用Vector的必要</p><hr><h3 id="Stack（栈）"><a href="#Stack（栈）" class="headerlink" title="Stack（栈）"></a><del>Stack（栈）</del></h3><p>Stack 是 Vector 的一个子类，本质也是一个动态数组结构，不同的是，它的数据结构是先进后出，取名叫栈！</p><p>关于<code>Stack</code>，现在用的也很少，因为有个<code>ArrayDeque</code>双端队列，可以替代<code>Stack</code>所有的功能，并且执行效率比它高！</p><hr><h2 id="Queue（队列）"><a href="#Queue（队列）" class="headerlink" title="Queue（队列）"></a><strong>Queue（队列）</strong></h2><p>Queue是一个队列集合，队列通常是指“先进先出”（FIFO）的容器。新元素插入（offer）到队列的尾部，访问元素（poll）操作会返回队列头部的元素。通常，队列不允许随机访问队列中的元素</p><hr><h3 id="ArrayDeque-（双端队列）"><a href="#ArrayDeque-（双端队列）" class="headerlink" title="ArrayDeque （双端队列）"></a>ArrayDeque （双端队列）</h3><p>ArrayQueue是一个基于数组实现的<strong>双端队列</strong>，可以想象，在队列中存在两个指针，一个指向头部，一个指向尾部，因此它具有“FIFO队列”及“栈”的方法特性。</p><p>既可以先进先出，也可以先进后出</p><p>常用方法 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队列常用方法：</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;<span class="comment">//队列空返回真，否则返回假</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">peek</span><span class="params">()</span></span>;<span class="comment">//获取队头元素，但不出栈</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;<span class="comment">//入队</span></span><br><span class="line"><span class="function">Elemtype <span class="title">poll</span><span class="params">()</span></span>;<span class="comment">//出队，获取并移除队头元素，若为空则返回Null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//栈常用方法：</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;<span class="comment">//栈空返回真，否则返回假</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">peek</span><span class="params">()</span></span>;<span class="comment">//获取栈顶元素，但不出栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span></span>;<span class="comment">//入栈</span></span><br><span class="line"><span class="function">Elemtype <span class="title">pop</span><span class="params">(E e)</span></span>;<span class="comment">//出栈,获取并移除栈顶元素，若为空则返回Null</span></span><br></pre></td></tr></table></figure><hr><h3 id="PriorityQueue（优先队列）"><a href="#PriorityQueue（优先队列）" class="headerlink" title="PriorityQueue（优先队列）"></a>PriorityQueue（优先队列）</h3><p>PriorityQueue也是一个队列的实现类，此实现类中存储的元素排列并不是按照元素添加的顺序进行排列，而是内部会按元素的大小顺序进行排列，是一种能够自动排序的队列。</p><hr><h3 id="LinkedList（双向链表）-1"><a href="#LinkedList（双向链表）-1" class="headerlink" title="LinkedList（双向链表）"></a>LinkedList（双向链表）</h3><p>双向链表同样也实现了Queue类</p><hr><h2 id="Set-集"><a href="#Set-集" class="headerlink" title="Set(集)"></a><strong>Set(集)</strong></h2><p>Set集合的特点：元素不重复，存取无序，<strong>无下标</strong>；</p><p><strong>Set 集合的实现，基本都是基于 Map 中的键做文章，使用 Map 中键不能重复、无序的特性；所以，我们只需要重点关注 Map 的实现即可！</strong></p><hr><h3 id="Set转换为数组的办法"><a href="#Set转换为数组的办法" class="headerlink" title="Set转换为数组的办法"></a>Set转换为数组的办法</h3><p>方法1：采用toArray(new Integer[] {})方法直接转为Integer数组，然后再转为整型数组；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] SetToInt(Set&lt;Integer&gt; allSet) &#123;</span><br><span class="line">        <span class="comment">// 先将set集合转为Integer型数组</span></span><br><span class="line">        Set&lt;Integer&gt; allSet = <span class="keyword">new</span> TreeSet&lt;Integer&gt;();</span><br><span class="line">        Integer[] temp = allSet.toArray(<span class="keyword">new</span> Integer[] &#123;&#125;);<span class="comment">//关键语句</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 再将Integer型数组转为int型数组</span></span><br><span class="line">        <span class="keyword">int</span>[] intArray = <span class="keyword">new</span> <span class="keyword">int</span>[temp.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">            intArray[i] = temp[i].intValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intArray;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="HashSet（哈希集）"><a href="#HashSet（哈希集）" class="headerlink" title="HashSet（哈希集）"></a>HashSet（哈希集）</h3><p>HashSet底层是基于 HashMap 的<code>k</code>实现的，元素不可重复，特性同 HashMap。</p><hr><h3 id="LinkedHashSet（链表哈希集）"><a href="#LinkedHashSet（链表哈希集）" class="headerlink" title="LinkedHashSet（链表哈希集）"></a>LinkedHashSet（链表哈希集）</h3><p>LinkedHashSet底层也是基于 LinkedHashMap 的<code>k</code>实现的，一样元素不可重复，特性同 LinkedHashMap。</p><hr><h3 id="TreeSet（树集）"><a href="#TreeSet（树集）" class="headerlink" title="TreeSet（树集）"></a>TreeSet（树集）</h3><p>同样的，TreeSet 也是基于 TreeMap 的<code>k</code>实现的，同样元素不可重复，特性同 TreeMap；</p><h4 id="独特方法"><a href="#独特方法" class="headerlink" title="独特方法"></a>独特方法</h4><p>因为TreeMap实现了具有一些独特方法，所以TreeSet同样也有</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Elemtype <span class="title">ceiling</span><span class="params">(E e)</span></span>;</span><br><span class="line"><span class="comment">//返回在这一组大于或等于e的最小元素，如果没有这样的元素则返回null。</span></span><br><span class="line"><span class="function">Elemtype <span class="title">higher</span><span class="params">(E e)</span></span>;</span><br><span class="line"><span class="comment">//返回Set中大于e的最小元素</span></span><br><span class="line"><span class="function">Elemtype <span class="title">floor</span><span class="params">(E e)</span></span>;</span><br><span class="line"><span class="comment">//返回在这一组中小于或等于e的最大元素,如果没有这样的元素则返回null</span></span><br><span class="line"><span class="function">Elemtype <span class="title">lower</span><span class="params">(E e)</span></span>;</span><br><span class="line"><span class="comment">// 返回Set中小于e的最大元素</span></span><br><span class="line"><span class="function">Elemtype <span class="title">first</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//返回第一个 （最小） 元素</span></span><br><span class="line"><span class="function">Elemtype <span class="title">last</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//返回最后一个(最高)元素</span></span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA之集合---Map</title>
      <link href="/post/8465.html"/>
      <url>/post/8465.html</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA之集合—-Map"><a href="#JAVA之集合—-Map" class="headerlink" title="JAVA之集合—-Map"></a>JAVA之集合—-Map</h1><p>Map是一个双列集合，其中保存的是键值对<strong>(Key-Value)</strong>，键要求保持唯一性，值可以重复。</p><p><img src="C:/Users/%E7%83%9B/AppData/Roaming/Typora/typora-user-images/image-20211130204437880.png" alt="image-20211130204437880"></p><p>Map的创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; Ages = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;(); </span><br></pre></td></tr></table></figure><h2 id="Map方法"><a href="#Map方法" class="headerlink" title="Map方法"></a>Map方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">Value <span class="title">get</span><span class="params">(K key)</span></span>; </span><br><span class="line"><span class="comment">//返回键映射的值，如果该键没有映射值，则返回null</span></span><br><span class="line"><span class="function">Value <span class="title">put</span><span class="params">(K key, V value)</span></span>; </span><br><span class="line"><span class="comment">//将键和值建立映射关系,如果键是第一次存储，就直接存储元素，返回null; 如果键不是第一次存在，就用值把以前的值替换掉，返回以前的值</span></span><br><span class="line"><span class="function">Value <span class="title">remove</span><span class="params">(K key)</span></span>; </span><br><span class="line"><span class="comment">//如果对应键存在映射关系的值，则将其移除，并返回值</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span><span class="title">containsKey</span><span class="params">(Object key)</span></span>; </span><br><span class="line"><span class="comment">//是否存在特定的key</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span><span class="title">containsValue</span><span class="params">(Object value)</span></span>; </span><br><span class="line"><span class="comment">//是否存在特定的value</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span><span class="title">isEmpty</span><span class="params">()</span></span>; </span><br><span class="line"><span class="comment">//判断集合是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>; </span><br><span class="line"><span class="comment">//移除所有的Entry(键值对)</span></span><br><span class="line">Set&lt;Map.Entry&lt;K,V&gt;&gt;entrySet();</span><br><span class="line"><span class="comment">//返回一个键值对的Set集合</span></span><br><span class="line"><span class="function">Set<span class="title">keySet</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//获取集合中所有键的集合</span></span><br><span class="line"><span class="function">Collection <span class="title">values</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//获取集合中所有值的集合</span></span><br><span class="line"><span class="function"><span class="keyword">int</span><span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//返回集合中的键值对的对数</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span></span>;</span><br><span class="line"><span class="comment">//Java8新特性，如果哈希表中有这个Key则获取这个值，如果没有则初始化Key的值为defaultValue</span></span><br></pre></td></tr></table></figure><hr><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>特点：</p><ul><li>无序</li><li>访问速度快</li><li>key不允许重复（只允许存在一个null Key）</li></ul><hr><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><ul><li>有序</li><li>先进先出</li><li>继承于HashMap</li></ul><p>LinkedHashMap它的特点主要在于linked，带有这个字眼的就表示底层用的是链表来进行的存储。</p><p>相对于其他的无序的map实现类，还有像TreeMap这样的排序类，linkedHashMap最大的特点在于有序，但是它的有序主要体现在先进先出FIFO上。没错，LinkedHashMap主要依靠双向链表和hash表来实现的。</p><hr><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a><strong>TreeMap</strong></h2><ul><li><p>对Key排序</p><p>TreeMap也是一个很常用的map实现类，因为它实现了SortMap，所以会对Key进行排序，使用了TreeMap存储键值对，再使用iterator进行输出时，会发现其默认采用key由小到大的顺序输出键值对，如果想要按照其他的方式来排序，需要重写也就是override 它的compartor接口。</p></li></ul><p>因为只有TreeMap实现了SortedMap类，所以它具有一些独特方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Map.<span class="function">Entry&lt;K, V&gt; <span class="title">firstEntry</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//返回该TreeMap的第一个（最小的）映射</span></span><br><span class="line"><span class="function">K <span class="title">firstKey</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//返回该TreeMap的第一个（最小的）映射的key</span></span><br><span class="line">Map.<span class="function">Entry&lt;K, V&gt; <span class="title">lastEntry</span><span class="params">()</span></span>;</span><br><span class="line">返回该TreeMap的最后一个（最大的）映射</span><br><span class="line"><span class="function">K <span class="title">lastKey</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//返回该TreeMap的最后一个（最大的）映射的key</span></span><br><span class="line"><span class="function">v <span class="title">get</span><span class="params">(K key)</span>：返回指定key对应的value</span></span><br><span class="line"><span class="function">SortedMap&lt;K, V&gt; <span class="title">headMap</span><span class="params">(K toKey)</span></span>;</span><br><span class="line"><span class="comment">//返回该TreeMap中严格小于指定key的映射集合</span></span><br><span class="line"><span class="function">SortedMap&lt;K, V&gt; <span class="title">subMap</span><span class="params">(K fromKey, K toKey)</span></span>;</span><br><span class="line"><span class="comment">//返回该TreeMap中指定范围的映射集合（大于等于fromKey，小于toKey）</span></span><br></pre></td></tr></table></figure><hr><h2 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a><del>Hashtable</del></h2><ul><li>无序</li><li>访问速度慢</li><li>同步</li><li>Key和Value都不能为null</li></ul><p>因为HashMap已经可以通过其他方法来保证安全，因此已经很少被使用</p><hr><h2 id="HashMap的遍历"><a href="#HashMap的遍历" class="headerlink" title="HashMap的遍历"></a>HashMap的遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapStudy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//一般来说,最好初始化一下, 小于12的就不要初始化了</span></span><br><span class="line">        <span class="comment">// 默认的就是16,因为加载因子是0.75,也就是到16*0.75=12的时候会扩容</span></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        map.put(<span class="string">&quot;welcome&quot;</span>,<span class="string">&quot;to&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;java&quot;</span>,<span class="string">&quot;study&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;wechat&quot;</span>,<span class="string">&quot;best396975802&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历方法1: 先遍历key , 再取出value</span></span><br><span class="line">        System.out.println(<span class="string">&quot;遍历方法1: 先遍历key , 再取出value&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;key is &quot;</span>+key);</span><br><span class="line">            System.out.println(<span class="string">&quot;value is &quot;</span>+ map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历方法2: 直接遍历value</span></span><br><span class="line">        System.out.println(<span class="string">&quot;遍历方法2: 直接遍历value&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String value : map.values()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;value is &quot;</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历方法3: 通过遍历entry来取Key和value,推荐的方法!!!</span></span><br><span class="line">        System.out.println(<span class="string">&quot;遍历方法3: 通过遍历entry来取Key和value,推荐的方法!!!&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;key is &quot;</span>+entry.getKey());</span><br><span class="line">            System.out.println(<span class="string">&quot;value is &quot;</span>+ entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历方法4: 通过forEach方法直接遍历key和value</span></span><br><span class="line">        System.out.println(<span class="string">&quot;遍历方法4: 通过forEach方法直接遍历&quot;</span>);</span><br><span class="line">        map.forEach((key,value)-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;key is &quot;</span>+ key);</span><br><span class="line">            System.out.println(<span class="string">&quot;value is &quot;</span>+ value);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>500.键盘行</title>
      <link href="/post/33235.html"/>
      <url>/post/33235.html</url>
      
        <content type="html"><![CDATA[<h1 id="500-键盘行"><a href="#500-键盘行" class="headerlink" title="500.键盘行"></a>500.键盘行</h1><p>给你一个字符串数组 <code>words</code> ，只返回可以使用在 <strong>美式键盘</strong> 同一行的字母打印出来的单词。键盘如下图所示。</p><p><strong>美式键盘</strong> 中：</p><ul><li>第一行由字符 <code>&quot;qwertyuiop&quot;</code> 组成。</li><li>第二行由字符 <code>&quot;asdfghjkl&quot;</code> 组成。</li><li>第三行由字符 <code>&quot;zxcvbnm&quot;</code> 组成。</li></ul><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/keyboard.png" alt="American keyboard"></p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [&quot;Hello&quot;,&quot;Alaska&quot;,&quot;Dad&quot;,&quot;Peace&quot;]</span><br><span class="line">输出：[&quot;Alaska&quot;,&quot;Dad&quot;]</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong>：</p><p>当然可以对比，根据<code>383.赎金信</code>的启发，可以使用<code>String</code>的<code>contains</code>以及<code>split(&quot;&quot;)</code>方法来判断单个字符是否在字符串中</p><p>以及<code>350.两个数组的交集2</code>中，用<code>Arrays</code>类的<code>copyofRange</code>方法快捷输出答案数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String[] findWords(String[] words) &#123;</span><br><span class="line">        String s1 = <span class="string">&quot;qwertyuiopQWERTYUIOP&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;asdfghjklASDFGHJKL&quot;</span>;</span><br><span class="line">        String [] ans=<span class="keyword">new</span> String [words.length];</span><br><span class="line">        <span class="keyword">int</span> count =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;words.length;i++)&#123;</span><br><span class="line">            String[] x=words[i].split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> n1 = <span class="number">0</span>, n2 = <span class="number">0</span> , n3 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; x.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s1.contains(x[j])) n1++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s2.contains(x[j])) n2++;</span><br><span class="line">                <span class="keyword">else</span>  n3++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(n1 == x.length || n2 == x.length || n3 == x.length) ans[count++]=words[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(ans,<span class="number">0</span>,count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 哈希表 </category>
          
          <category> 数组 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>496.下一个更大元素</title>
      <link href="/post/56665.html"/>
      <url>/post/56665.html</url>
      
        <content type="html"><![CDATA[<h1 id="496-下一个更大元素"><a href="#496-下一个更大元素" class="headerlink" title="496.下一个更大元素"></a>496.下一个更大元素</h1><p>给你两个 <strong>没有重复元素</strong> 的数组 <code>nums1</code> 和 <code>nums2</code> ，其中<code>nums1</code> 是 <code>nums2</code> 的子集。</p><p>请你找出 <code>nums1</code> 中每个元素在 <code>nums2</code> 中的下一个比其大的值。</p><p><code>nums1</code> 中数字 <code>x</code> 的下一个更大元素是指 <code>x</code> 在 <code>nums2</code> 中对应位置的右边的第一个比 <code>x</code> 大的元素。如果不存在，对应位置输出 <code>-1</code> 。</p><p><strong>示例 1:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 = [<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>], nums2 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>].</span><br><span class="line">输出: [<span class="number">-1</span>,<span class="number">3</span>,<span class="number">-1</span>]</span><br><span class="line">解释:</span><br><span class="line">    对于 num1 中的数字 <span class="number">4</span> ，你无法在第二个数组中找到下一个更大的数字，因此输出 <span class="number">-1</span> 。</span><br><span class="line">    对于 num1 中的数字 <span class="number">1</span> ，第二个数组中数字<span class="number">1</span>右边的下一个较大数字是 <span class="number">3</span> 。</span><br><span class="line">    对于 num1 中的数字 <span class="number">2</span> ，第二个数组中没有下一个更大的数字，因此输出 <span class="number">-1</span> 。</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>我们可以先预处理 <code>nums2</code>，使查询<code>nums1</code>中的每个元素在<code>nums2</code>中对应位置的右边的第一个更大的元素值时不需要再遍历<code>nums2</code>。于是，我们将题目分解为两个子问题：</p><ul><li>第 1 个子问题：如何更高效地计算<code>nums2</code>中每个元素右边的第一个更大的值；</li><li>第 2 个子问题：如何存储第 1 个子问题的结果。</li></ul><p>针对第一个问题，我们可以逆序遍历<code>nums2</code>，同时将结果入栈，如当前元素大于栈顶元素，则让栈顶元素出栈，这种结构称为 单调栈</p><p>针对第二个问题，因为题目规定了<code>nums2</code>是没有重复元素的，所以我们可以使用哈希表来解决第 2个子问题，将元素值与其右边第一个更大的元素值的对应关系存入哈希表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums2.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = nums2[i];</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; num &gt;= stack.peek()) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(num, stack.isEmpty() ? -<span class="number">1</span> : stack.peek());</span><br><span class="line">            stack.push(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.length; ++i) &#123;</span><br><span class="line">            res[i] = map.get(nums1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 哈希表 </category>
          
          <category> 数组 </category>
          
          <category> 栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>495.提莫攻击</title>
      <link href="/post/10922.html"/>
      <url>/post/10922.html</url>
      
        <content type="html"><![CDATA[<h1 id="495-提莫攻击"><a href="#495-提莫攻击" class="headerlink" title="495.提莫攻击"></a>495.提莫攻击</h1><p>在《英雄联盟》的世界中，有一个叫 “提莫” 的英雄。他的攻击可以让敌方英雄艾希（编者注：寒冰射手）进入中毒状态。</p><p>当提莫攻击艾希，艾希的中毒状态正好持续 <code>duration</code> 秒。</p><p>正式地讲，提莫在 <code>t</code> 发起发起攻击意味着艾希在时间区间 <code>[t, t + duration - 1]</code>（含 <code>t</code> 和 <code>t + duration - 1</code>）处于中毒状态。如果提莫在中毒影响结束 <strong>前</strong> 再次攻击，中毒状态计时器将会 <strong>重置</strong> ，在新的攻击之后，中毒影响将会在 <code>duration</code> 秒后结束。</p><p>给你一个 <strong>非递减</strong> 的整数数组 <code>timeSeries</code> ，其中 <code>timeSeries[i]</code> 表示提莫在 <code>timeSeries[i]</code> 秒时对艾希发起攻击，以及一个表示中毒持续时间的整数 <code>duration</code> 。</p><p>返回艾希处于中毒状态的 <strong>总</strong> 秒数。</p><p><strong>示例 1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：timeSeries = [<span class="number">1</span>,<span class="number">4</span>], duration = <span class="number">2</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：提莫攻击对艾希的影响如下：</span><br><span class="line">- 第 <span class="number">1</span> 秒，提莫攻击艾希并使其立即中毒。中毒状态会维持 <span class="number">2</span> 秒，即第 <span class="number">1</span> 秒和第 <span class="number">2</span> 秒。</span><br><span class="line">- 第 <span class="number">4</span> 秒，提莫再次攻击艾希，艾希中毒状态又持续 <span class="number">2</span> 秒，即第 <span class="number">4</span> 秒和第 <span class="number">5</span> 秒。</span><br><span class="line">艾希在第 <span class="number">1</span>、<span class="number">2</span>、<span class="number">4</span>、<span class="number">5</span> 秒处于中毒状态，所以总中毒秒数是 <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong>：</p><p>考虑在<code>228.汇总区间</code>中出现过的双指针技巧,设置两个指针，中毒时间为高指针-低指针的值再加上持续时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPoisonedDuration</span><span class="params">(<span class="keyword">int</span>[] timeSeries, <span class="keyword">int</span> duration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;timeSeries.length)&#123;</span><br><span class="line">            low = i;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;timeSeries.length  &amp;&amp; (timeSeries[i-<span class="number">1</span>]+duration)&gt;timeSeries[i]) </span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            high = i - <span class="number">1</span>;</span><br><span class="line">            sum+=timeSeries[high]-timeSeries[low]+duration;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>492.构造矩形</title>
      <link href="/post/20472.html"/>
      <url>/post/20472.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="492-构造矩形"><a href="#492-构造矩形" class="headerlink" title="492.构造矩形"></a>492.构造矩形</h1><h4 id="492-构造矩形-1"><a href="#492-构造矩形-1" class="headerlink" title="492. 构造矩形"></a><a href="https://leetcode-cn.com/problems/construct-the-rectangle/">492. 构造矩形</a></h4><p>难度简单109</p><p>作为一位web开发者， 懂得怎样去规划一个页面的尺寸是很重要的。 现给定一个具体的矩形页面面积，你的任务是设计一个长度为 L 和宽度为 W 且满足以下要求的矩形的页面。要求：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 你设计的矩形页面必须等于给定的目标面积。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 宽度 W 不应大于长度 L，换言之，要求 L &gt;= W 。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 长度 L 和宽度 W 之间的差距应当尽可能小。</span><br></pre></td></tr></table></figure><p>你需要按顺序输出你设计的页面的长度 L 和宽度 W。</p><p><strong>示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">4</span></span><br><span class="line">输出: [<span class="number">2</span>, <span class="number">2</span>]</span><br><span class="line">解释: 目标面积是 <span class="number">4</span>， 所有可能的构造方案有 [<span class="number">1</span>,<span class="number">4</span>], [<span class="number">2</span>,<span class="number">2</span>], [<span class="number">4</span>,<span class="number">1</span>]。</span><br><span class="line">但是根据要求<span class="number">2</span>，[<span class="number">1</span>,<span class="number">4</span>] 不符合要求; 根据要求<span class="number">3</span>，[<span class="number">2</span>,<span class="number">2</span>] 比 [<span class="number">4</span>,<span class="number">1</span>] 更能符合要求. 所以输出长度 L 为 <span class="number">2</span>， 宽度 W 为 <span class="number">2</span>。</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>利用sqrt(x)函数，在起附近内寻找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] constructRectangle(<span class="keyword">int</span> area) &#123;</span><br><span class="line">        <span class="keyword">int</span> w = (<span class="keyword">int</span>) Math.sqrt(area);</span><br><span class="line">        <span class="keyword">while</span> (area % w != <span class="number">0</span>) &#123;</span><br><span class="line">            --w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;area / w, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>485.最大连续1的个数</title>
      <link href="/post/37001.html"/>
      <url>/post/37001.html</url>
      
        <content type="html"><![CDATA[<h1 id="485-最大连续1的个数"><a href="#485-最大连续1的个数" class="headerlink" title="485.最大连续1的个数"></a>485.最大连续1的个数</h1><p>给定一个二进制数组， 计算其中最大连续 1 的个数。</p><p><strong>示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：开头的两位和最后的三位都是连续 <span class="number">1</span> ，所以最大连续 <span class="number">1</span> 的个数是 <span class="number">3.</span></span><br></pre></td></tr></table></figure><p>还是<code>53.最大子序和</code>的思路</p><hr><p><strong>Solution</strong>:</p><p>遍历数组，设置一个计数器，如果有连续1就加1，没有就直接清零，再设置一个值来记录计数器的最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x:nums)&#123;</span><br><span class="line">               <span class="keyword">if</span>(x==<span class="number">1</span>)&#123;</span><br><span class="line">                   count++;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   count=<span class="number">0</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               max=Math.max(count,max);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>482.密钥格式化</title>
      <link href="/post/5908.html"/>
      <url>/post/5908.html</url>
      
        <content type="html"><![CDATA[<h1 id="482-密钥格式化"><a href="#482-密钥格式化" class="headerlink" title="482.密钥格式化"></a>482.密钥格式化</h1><p>有一个密钥字符串 S ，只包含字母，数字以及 ‘-‘（破折号）。其中， N 个 ‘-‘ 将字符串分成了 N+1 组。</p><p>给你一个数字 K，请你重新格式化字符串，使每个分组恰好包含 K 个字符。特别地，第一个分组包含的字符个数必须小于等于 K，但至少要包含 1 个字符。两个分组之间需要用 ‘-‘（破折号）隔开，并且将所有的小写字母转换为大写字母。</p><p>给定非空字符串 S 和数字 K，按照上面描述的规则进行格式化。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：S = <span class="string">&quot;5F3Z-2e-9-w&quot;</span>, K = <span class="number">4</span></span><br><span class="line">输出：<span class="string">&quot;5F3Z-2E9W&quot;</span></span><br><span class="line">解释：字符串 S 被分成了两个部分，每部分 <span class="number">4</span> 个字符；</span><br><span class="line">     注意，两个额外的破折号需要删掉。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：S = <span class="string">&quot;2-5g-3-J&quot;</span>, K = <span class="number">2</span></span><br><span class="line">输出：<span class="string">&quot;2-5G-3J&quot;</span></span><br><span class="line">解释：字符串 S 被分成了 <span class="number">3</span> 个部分，按照前面的规则描述，第一部分的字符可以少于给定的数量，其余部分皆为 <span class="number">2</span> 个字符。</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">licenseKeyFormatting</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) != <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                ans.append(Character.toUpperCase(s.charAt(i)));<span class="comment">//如果不是破折号就添加进入ans里面，同时将其变为大写字母</span></span><br><span class="line">                <span class="keyword">if</span> (cnt % k == <span class="number">0</span>) &#123;</span><br><span class="line">                    ans.append(<span class="string">&quot;-&quot;</span>);  <span class="comment">//如果此时cnt可以%k，就添加一个-进去</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans.length() &gt; <span class="number">0</span> &amp;&amp; ans.charAt(ans.length() - <span class="number">1</span>) == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            ans.deleteCharAt(ans.length() - <span class="number">1</span>);<span class="comment">//如果最后是&#x27;-&#x27;就删除</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>476.数字的补数</title>
      <link href="/post/34946.html"/>
      <url>/post/34946.html</url>
      
        <content type="html"><![CDATA[<h1 id="476-数字的补数"><a href="#476-数字的补数" class="headerlink" title="476.数字的补数"></a>476.数字的补数</h1><p>对整数的二进制表示取反（<code>0</code> 变 <code>1</code> ，<code>1</code> 变 <code>0</code>）后，再转换为十进制表示，可以得到这个整数的补数。</p><ul><li>例如，整数 <code>5</code> 的二进制表示是 <code>&quot;101&quot;</code> ，取反后得到 <code>&quot;010&quot;</code> ，再转回十进制表示得到补数 <code>2</code> 。</li></ul><p>给你一个整数 <code>num</code> ，输出它的补数。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="number">5</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：<span class="number">5</span> 的二进制表示为 <span class="number">101</span>（没有前导零位），其补数为 <span class="number">010</span>。所以你需要输出 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>思路是找到num的二进制表示的第一个1，之后对每一位进行取反操作</p><p>如果num二进制表示的最高位的1是第<code>i</code>位，那么一定有$2^i≤num≤2^{i+1}$,因此可以用一次遍历找出<code>i</code>的值,之后，可以用过构造掩码的方式，进行异或运算，来得到答案</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(n - <span class="number">1</span> &lt; num)</span><br><span class="line">            n &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (n - <span class="number">1</span>) ^ num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 位运算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>463.岛屿的周长</title>
      <link href="/post/18969.html"/>
      <url>/post/18969.html</url>
      
        <content type="html"><![CDATA[<h1 id="463-岛屿的周长"><a href="#463-岛屿的周长" class="headerlink" title="463.岛屿的周长"></a>463.岛屿的周长</h1><p>给定一个 <code>row x col</code> 的二维网格地图 <code>grid</code> ，其中：<code>grid[i][j] = 1</code> 表示陆地， <code>grid[i][j] = 0</code> 表示水域。</p><p>网格中的格子 <strong>水平和垂直</strong> 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。</p><p>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/island.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">16</span></span><br><span class="line">解释：它的周长是上面图片中的 <span class="number">16</span> 个黄色的边</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>如果有陆地，周长就+4，同时检测其他边的情况，如果周围有相邻的方格，边就-2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//重点关注前面遍历过得方格，如果之前有相邻方格，就-2;</span></span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rsp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    rsp += <span class="number">4</span>;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; grid[i - <span class="number">1</span>][j] == <span class="number">1</span>) &#123;<span class="comment">//只对比一个方向</span></span><br><span class="line">                        rsp -= <span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; grid[i][j - <span class="number">1</span>] == <span class="number">1</span>) &#123;<span class="comment">//只对比一个方向</span></span><br><span class="line">                        rsp -= <span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rsp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>461.汉明距离</title>
      <link href="/post/3381.html"/>
      <url>/post/3381.html</url>
      
        <content type="html"><![CDATA[<h1 id="461-汉明距离"><a href="#461-汉明距离" class="headerlink" title="461.汉明距离"></a>461.汉明距离</h1><p>两个整数之间的 <a href="https://baike.baidu.com/item/汉明距离">汉明距离</a> 指的是这两个数字对应二进制位不同的位置的数目。</p><p>给你两个整数 <code>x</code> 和 <code>y</code>，计算并返回它们之间的汉明距离。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：x = <span class="number">1</span>, y = <span class="number">4</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line"><span class="number">1</span>   (<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>)</span><br><span class="line"><span class="number">4</span>   (<span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span>)</span><br><span class="line">       ↑   ↑</span><br><span class="line">上面的箭头指出了对应二进制位不同的位置。</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>具体地，记 $s =x⊕y$，我们可以不断地检查 <code>s</code> 的最低位，如果最低位为 1，那么令计数器加一，然后我们令 <code>s</code> 整体右移一位，这样 <code>s</code> 的最低位将被舍去，原本的次低位就变成了新的最低位。我们重复这个过程直到 <code>s=0</code> 为止。这样计数器中就累计了 <code>s</code> 的二进制表示中 1 的数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = x ^ y, ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (s != <span class="number">0</span>) &#123;</span><br><span class="line">            s = s &amp; (s-<span class="number">1</span>);</span><br><span class="line">            ret++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 位运算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>459.重复的子字符串</title>
      <link href="/post/53418.html"/>
      <url>/post/53418.html</url>
      
        <content type="html"><![CDATA[<h1 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459.重复的子字符串"></a>459.重复的子字符串</h1><p>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p><p><strong>示例 1:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">&quot;abab&quot;</span></span><br><span class="line"></span><br><span class="line">输出: True</span><br><span class="line"></span><br><span class="line">解释: 可由子字符串 <span class="string">&quot;ab&quot;</span> 重复两次构成。</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>一个原理，将字符串s复制一次，创建一个新的字符串T=s+s，然后去掉T的第一个和最后一个字符，如果s仍然是T的子串，那么说明s是重复的子字符串构成</p><p>子串匹配用KMP算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">repeatedSubstringPattern</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">           String x=s+s;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">return</span> KMP(x,s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">KMP</span><span class="params">(String S,String T)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> []a=<span class="keyword">new</span> <span class="keyword">int</span>[T.length()+<span class="number">1</span>];</span><br><span class="line">        Next(T,a);</span><br><span class="line">        <span class="keyword">while</span>(i&lt;S.length()-<span class="number">1</span>&amp;&amp;j&lt;=T.length())&#123;</span><br><span class="line">            <span class="keyword">if</span>(j==-<span class="number">1</span>||S.charAt(i)==T.charAt(j))&#123;</span><br><span class="line">                     i++;</span><br><span class="line">                     j++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               j=a[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j==T.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Next</span><span class="params">(String m,<span class="keyword">int</span> []next)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        next[<span class="number">0</span>]=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;m.length())&#123;</span><br><span class="line">             <span class="keyword">if</span>(k==-<span class="number">1</span>||m.charAt(j)==m.charAt(k))&#123;</span><br><span class="line">                 j++;</span><br><span class="line">                 k++;</span><br><span class="line">                 next[j]=k;</span><br><span class="line">             &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 k=next[k];</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>455.分发饼干</title>
      <link href="/post/41974.html"/>
      <url>/post/41974.html</url>
      
        <content type="html"><![CDATA[<h1 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455.分发饼干"></a>455.分发饼干</h1><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 <code>i</code>，都有一个胃口值 <code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 <code>j</code>，都有一个尺寸 <code>s[j]</code> 。如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 <code>j</code> 分配给孩子 <code>i</code> ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p><strong>示例 1:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: g = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], s = [<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: </span><br><span class="line">你有三个孩子和两块小饼干，<span class="number">3</span>个孩子的胃口值分别是：<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>。</span><br><span class="line">虽然你有两块小饼干，由于他们的尺寸都是<span class="number">1</span>，你只能让胃口值是<span class="number">1</span>的孩子满足。</span><br><span class="line">所以你应该输出<span class="number">1</span>。</span><br></pre></td></tr></table></figure><p><strong>Solution</strong>:</p><p>先排序，然后用双指针，如果饼干指针元素能满足胃口指针，那么两个指针都指向下一个，如果不能，那么让饼干指针指向下一个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="keyword">int</span>[] g, <span class="keyword">int</span>[] s)</span> </span>&#123;</span><br><span class="line">             Arrays.sort(g);</span><br><span class="line">             Arrays.sort(s);</span><br><span class="line">             <span class="keyword">int</span> need=<span class="number">0</span>;</span><br><span class="line">             <span class="keyword">int</span> food=<span class="number">0</span>;</span><br><span class="line">             <span class="keyword">while</span>(need&lt;g.length&amp;&amp;food&lt;s.length)&#123;</span><br><span class="line">                 <span class="keyword">if</span>(s[food]&gt;=g[need])&#123;</span><br><span class="line">                     need++;</span><br><span class="line">                     food++;</span><br><span class="line">                 &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                     food++;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> need;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>453.最小操作次数使数组元素相等</title>
      <link href="/post/35330.html"/>
      <url>/post/35330.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="453-最小操作次数使数组元素相等"><a href="#453-最小操作次数使数组元素相等" class="headerlink" title="453.最小操作次数使数组元素相等"></a>453.最小操作次数使数组元素相等</h1><p>给你一个长度为 <code>n</code> 的整数数组，每次操作将会使 <code>n - 1</code> 个元素增加 <code>1</code> 。返回让数组所有元素相等的最小操作次数。</p><p><strong>示例 1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">只需要<span class="number">3</span>次操作（注意每次操作会增加两个元素的值）：</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]  =&gt;  [<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>]  =&gt;  [<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>]  =&gt;  [<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>换个方向思考？</p><hr><p><strong>Solution</strong>：</p><p>你们都增大了，不就相当于我减少了吗？</p><p>每个数减少到和最小值一样所需的次数，就是操作次数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMoves</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> minNum = Arrays.stream(nums).min().getAsInt();<span class="comment">//求出数组的最小值</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            res += num - minNum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>448.找到所有数组中消失的数字</title>
      <link href="/post/42765.html"/>
      <url>/post/42765.html</url>
      
        <content type="html"><![CDATA[<h1 id="448-找到所有数组中消失的数字"><a href="#448-找到所有数组中消失的数字" class="headerlink" title="448.找到所有数组中消失的数字"></a>448.找到所有数组中消失的数字</h1><p>给你一个含 <code>n</code> 个整数的数组 <code>nums</code> ，其中 <code>nums[i]</code> 在区间 <code>[1, n]</code> 内。请你找出所有在 <code>[1, n]</code> 范围内但没有出现在 <code>nums</code> 中的数字，并以数组的形式返回结果。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">5</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>和<code>268.丢失的数字</code>对应，不过在268中，只会有一个数字丢失，而在此题中丢失的数字可能有很多个</p><hr><p><strong>Solution</strong>：</p><p>一般的思路是用哈希表记录数组nums中的数字，然后查询缺失的数字，由于数字范围在1~n内，我们也可以用长度为n的数组来代替哈希表</p><p>nums的长度恰好为n，为什么不让nums自身来代替哈希表呢？</p><p>使用数组的下标来标记数字出现与否，出现了就将其下标对应的数组元素设置为负数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x=Math.abs(nums[i]); <span class="comment">//将nums[i]的绝对值标记为x，x-1就是它的下标</span></span><br><span class="line">            <span class="keyword">if</span> (nums[x- <span class="number">1</span>] &gt; <span class="number">0</span>) &#123;  <span class="comment">//如果它的下标没被修改过，那么就设置</span></span><br><span class="line">                nums[x- <span class="number">1</span>] = - nums[x - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                results.add(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 哈希表 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>441.排列硬币</title>
      <link href="/post/59130.html"/>
      <url>/post/59130.html</url>
      
        <content type="html"><![CDATA[<h1 id="441-排列硬币"><a href="#441-排列硬币" class="headerlink" title="441.排列硬币"></a>441.排列硬币</h1><p>你总共有 <code>n</code> 枚硬币，并计划将它们按阶梯状排列。对于一个由 <code>k</code> 行组成的阶梯，其第 <code>i</code> 行必须正好有 <code>i</code> 枚硬币。阶梯的最后一行 <strong>可能</strong> 是不完整的。</p><p>给你一个数字 <code>n</code> ，计算并返回可形成 <strong>完整阶梯行</strong> 的总行数。</p><p><strong>示例 1：</strong></p><p><img src="../../AppData/Roaming/Typora/typora-user-images/image-20211218193448782.png" alt="image-20211218193448782"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：因为第三行不完整，所以返回 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>可以用累加法，也可以根据求和公式用二分查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrangeCoins</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span>(n&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">         i++;</span><br><span class="line">         n-=i;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> i-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>434.字符串中的单词数</title>
      <link href="/post/13589.html"/>
      <url>/post/13589.html</url>
      
        <content type="html"><![CDATA[<h1 id="434-字符串中的单词数"><a href="#434-字符串中的单词数" class="headerlink" title="434.字符串中的单词数"></a>434.字符串中的单词数</h1><p>统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。</p><p>请注意，你可以假定字符串里不包括任何不可打印的字符。</p><p><strong>示例:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">&quot;Hello, my name is John&quot;</span></span><br><span class="line">输出: <span class="number">5</span></span><br><span class="line">解释: 这里的单词是指连续的不是空格的字符，所以 <span class="string">&quot;Hello,&quot;</span> 算作 <span class="number">1</span> 个单词。</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>通过检测空格来判断单词个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSegments</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> segmentCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i == <span class="number">0</span> || s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27; &#x27;</span>) &amp;&amp; s.charAt(i) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                segmentCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> segmentCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>或者直接使用内置的<code>split()</code>函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSegments</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">           String x[]=s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">           <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;x.length;i++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(x[i].equals(<span class="string">&quot;&quot;</span>)==<span class="keyword">false</span>)&#123;</span><br><span class="line">                   count++;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>415.字符串相加</title>
      <link href="/post/30422.html"/>
      <url>/post/30422.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415.字符串相加"></a>415.字符串相加</h1><p>给定两个字符串形式的非负整数 <code>num1</code> 和<code>num2</code> ，计算它们的和并同样以字符串形式返回。</p><p>你不能使用任何內建的用于处理大整数的库（比如 <code>BigInteger</code>）， 也不能直接将输入的字符串转换为整数形式。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：num1 = <span class="string">&quot;11&quot;</span>, num2 = <span class="string">&quot;123&quot;</span></span><br><span class="line">输出：<span class="string">&quot;134&quot;</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>应用在<code>67.二进制求和</code>中的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addStrings</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="keyword">null</span> || a.length() == <span class="number">0</span>) <span class="keyword">return</span> b;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="keyword">null</span> || b.length() == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line">        StringBuilder stb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> i = a.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = b.length() - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;  <span class="comment">// 进位</span></span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">0</span>) c += a.charAt(i --) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= <span class="number">0</span>) c += b.charAt(j --) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            stb.append(c % <span class="number">10</span>);   </span><br><span class="line">            <span class="keyword">if</span>(c&gt;<span class="number">9</span>)&#123;</span><br><span class="line">                c=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                c=<span class="number">0</span>;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125; </span><br><span class="line">        String res = stb.reverse().toString();</span><br><span class="line">        <span class="keyword">return</span> c &gt; <span class="number">0</span> ? <span class="string">&#x27;1&#x27;</span> + res : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>414.第三大的数</title>
      <link href="/post/38826.html"/>
      <url>/post/38826.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="414-第三大的数"><a href="#414-第三大的数" class="headerlink" title="414.第三大的数"></a>414.第三大的数</h1><p>给你一个非空数组，返回此数组中 <strong>第三大的数</strong> 。如果不存在，则返回数组中最大的数。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：第三大的数是 <span class="number">1</span> 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：第三大的数不存在, 所以返回最大的数 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong>：有序集合</p><p>因为是直接返回的数，使用TreeSet的性质</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">thirdMax</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        TreeSet&lt;Integer&gt; s = <span class="keyword">new</span> TreeSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            s.add(num);</span><br><span class="line">            <span class="keyword">if</span> (s.size() &gt; <span class="number">3</span>) &#123;</span><br><span class="line">                s.remove(s.first());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.size() == <span class="number">3</span> ? s.first() : s.last();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>Solution1</strong>：<strong>三个变量</strong></p><p>我们可以遍历数组，并用三个变量 <em>a</em>、<em>b</em> 和 <em>c</em> 来维护数组中的最大值、次大值和第三大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">thirdMax</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> a = Long.MIN_VALUE, b = Long.MIN_VALUE, c = Long.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt; a) &#123;</span><br><span class="line">                c = b;</span><br><span class="line">                b = a;</span><br><span class="line">                a = num;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a &gt; num &amp;&amp; num &gt; b) &#123;</span><br><span class="line">                c = b;</span><br><span class="line">                b = num;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b &gt; num &amp;&amp; num &gt; c) &#123;</span><br><span class="line">                c = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c == Long.MIN_VALUE ? (<span class="keyword">int</span>) a : (<span class="keyword">int</span>) c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>412. Fizz Buzz</title>
      <link href="/post/55931.html"/>
      <url>/post/55931.html</url>
      
        <content type="html"><![CDATA[<h1 id="412-Fizz-Buzz"><a href="#412-Fizz-Buzz" class="headerlink" title="412.Fizz Buzz"></a>412.Fizz Buzz</h1><p>给你一个整数 <code>n</code> ，找出从 <code>1</code> 到 <code>n</code> 各个整数的 Fizz Buzz 表示，并用字符串数组 <code>answer</code>（<strong>下标从 1 开始</strong>）返回结果，其中：</p><ul><li><code>answer[i] == &quot;FizzBuzz&quot;</code> 如果 <code>i</code> 同时是 <code>3</code> 和 <code>5</code> 的倍数。</li><li><code>answer[i] == &quot;Fizz&quot;</code> 如果 <code>i</code> 是 <code>3</code> 的倍数。</li><li><code>answer[i] == &quot;Buzz&quot;</code> 如果 <code>i</code> 是 <code>5</code> 的倍数。</li><li><code>answer[i] == i</code> （以字符串形式）如果上述条件全不满足。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span></span><br><span class="line">输出：[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;Fizz&quot;</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span></span><br><span class="line">输出：[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;Fizz&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;Buzz&quot;</span>]</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>似乎没什么好说的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">fizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; answer = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                sb.append(<span class="string">&quot;Fizz&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                sb.append(<span class="string">&quot;Buzz&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sb.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                sb.append(i);</span><br><span class="line">            &#125;</span><br><span class="line">            answer.add(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>409.最长回文串</title>
      <link href="/post/43435.html"/>
      <url>/post/43435.html</url>
      
        <content type="html"><![CDATA[<h1 id="409-最长回文串"><a href="#409-最长回文串" class="headerlink" title="409.最长回文串"></a>409.最长回文串</h1><p>给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。</p><p>在构造过程中，请注意区分大小写。比如 <code>&quot;Aa&quot;</code> 不能当做一个回文字符串。</p><p><strong>注意:</strong><br>假设字符串的长度不会超过 1010。</p><p><strong>示例 1:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line"><span class="string">&quot;abccccdd&quot;</span></span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"><span class="number">7</span></span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">我们可以构造的最长的回文串是<span class="string">&quot;dccaccd&quot;</span>, 它的长度是 <span class="number">7</span>。</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>这道题当然可以先统计字符出现次数，偶数对的次数×2+1或者就是偶数对的次数×2，不过排序也可以，虽然时间复杂度差了一点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.length()&lt;<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> s.length();</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">char</span> [] c=s.toCharArray();</span><br><span class="line">            Arrays.sort(c);</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(i&lt;c.length-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(c[i]==c[i+<span class="number">1</span>])&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    i+=<span class="number">2</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count*<span class="number">2</span>==s.length())&#123;</span><br><span class="line">                <span class="keyword">return</span> count*<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>  count*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 哈希表 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>405.数字转换为十六进制数</title>
      <link href="/post/54186.html"/>
      <url>/post/54186.html</url>
      
        <content type="html"><![CDATA[<h1 id="405-数字转换为十六进制数"><a href="#405-数字转换为十六进制数" class="headerlink" title="405.数字转换为十六进制数"></a>405.数字转换为十六进制数</h1><p>给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 <a href="https://baike.baidu.com/item/补码/6854613?fr=aladdin">补码运算</a> 方法。</p><p><strong>注意:</strong></p><ol><li>十六进制中所有字母(<code>a-f</code>)都必须是小写。</li><li>十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符<code>&#39;0&#39;</code>来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。 </li><li>给定的数确保在32位有符号整数范围内。</li><li><strong>不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。</strong></li></ol><p><strong>示例 1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line"><span class="number">26</span></span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"><span class="string">&quot;1a&quot;</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toHex</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">7</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">            <span class="keyword">int</span> val = (num &gt;&gt; (<span class="number">4</span> * i)) &amp; <span class="number">0xf</span>;</span><br><span class="line">            <span class="keyword">if</span> (sb.length() &gt; <span class="number">0</span> || val &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">char</span> digit = val &lt; <span class="number">10</span> ? (<span class="keyword">char</span>) (<span class="string">&#x27;0&#x27;</span> + val) : (<span class="keyword">char</span>) (<span class="string">&#x27;a&#x27;</span> + val - <span class="number">10</span>);</span><br><span class="line">                sb.append(digit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
          <category> 位运算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>404.左叶子之和</title>
      <link href="/post/27616.html"/>
      <url>/post/27616.html</url>
      
        <content type="html"><![CDATA[<h1 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404.左叶子之和"></a>404.左叶子之和</h1><p>计算给定二叉树的所有左叶子之和。</p><p><strong>示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">15</span>   <span class="number">7</span></span><br><span class="line"></span><br><span class="line">在这个二叉树中，有两个左叶子，分别是 <span class="number">9</span> 和 <span class="number">15</span>，所以返回 <span class="number">24</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>左叶子，那就只添加左孩子的左孩子为空以及左孩子的右孩子为空的节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right) </span><br><span class="line">           + (root.left!=<span class="keyword">null</span> &amp;&amp; root.left.left==<span class="keyword">null</span> &amp;&amp;                                 root.left.right==<span class="keyword">null</span> ? root.left.val : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>401.二进制手表</title>
      <link href="/post/62874.html"/>
      <url>/post/62874.html</url>
      
        <content type="html"><![CDATA[<h1 id="401-二进制手表"><a href="#401-二进制手表" class="headerlink" title="401.二进制手表"></a>401.二进制手表</h1><p>二进制手表顶部有 4 个 LED 代表 <strong>小时（0-11）</strong>，底部的 6 个 LED 代表 <strong>分钟（0-59）</strong>。每个 LED 代表一个 0 或 1，最低位在右侧。</p><ul><li>例如，下面的二进制手表读取 <code>&quot;3:25&quot;</code> 。</li></ul><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/03/29/binary_clock_samui_moon.jpg" alt="img"></p><p>给你一个整数 <code>turnedOn</code> ，表示当前亮着的 LED 的数量，返回二进制手表可以表示的所有可能时间。你可以 <strong>按任意顺序</strong> 返回答案。</p><p>小时不会以零开头：</p><ul><li>例如，<code>&quot;01:00&quot;</code> 是无效的时间，正确的写法应该是 <code>&quot;1:00&quot;</code> 。</li></ul><p>分钟必须由两位数组成，可能会以零开头：</p><ul><li>例如，<code>&quot;10:2&quot;</code> 是无效的时间，正确的写法应该是 <code>&quot;10:02&quot;</code> 。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：turnedOn = <span class="number">1</span></span><br><span class="line">输出：[<span class="string">&quot;0:01&quot;</span>,<span class="string">&quot;0:02&quot;</span>,<span class="string">&quot;0:04&quot;</span>,<span class="string">&quot;0:08&quot;</span>,<span class="string">&quot;0:16&quot;</span>,<span class="string">&quot;0:32&quot;</span>,<span class="string">&quot;1:00&quot;</span>,<span class="string">&quot;2:00&quot;</span>,<span class="string">&quot;4:00&quot;</span>,<span class="string">&quot;8:00&quot;</span>]</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>枚举</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">readBinaryWatch</span><span class="params">(<span class="keyword">int</span> turnedOn)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; <span class="number">12</span>; ++h) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; <span class="number">60</span>; ++m) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Integer.bitCount(h) + Integer.bitCount(m) == turnedOn) &#123;</span><br><span class="line">                    ans.add(h + <span class="string">&quot;:&quot;</span> + (m &lt; <span class="number">10</span> ? <span class="string">&quot;0&quot;</span> : <span class="string">&quot;&quot;</span>) + m);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 位运算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>392.判断子序列</title>
      <link href="/post/65372.html"/>
      <url>/post/65372.html</url>
      
        <content type="html"><![CDATA[<h1 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392.判断子序列"></a>392.判断子序列</h1><p>给定字符串 <strong>s</strong> 和 <strong>t</strong> ，判断 <strong>s</strong> 是否为 <strong>t</strong> 的子序列。</p><p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，<code>&quot;ace&quot;</code>是<code>&quot;abcde&quot;</code>的一个子序列，而<code>&quot;aec&quot;</code>不是）。</p><p><strong>示例 1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;abc&quot;</span>, t = <span class="string">&quot;ahbgdc&quot;</span></span><br><span class="line">输出：<span class="keyword">true</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>采用双指针的思想，一个指针指向s，另一个指向t，如果t中有s指针指向的字母，s指针指向下一个元素，判断s指针的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubsequence</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;t.length())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(t.charAt(i)==s.charAt(j))</span><br><span class="line">            &#123;     </span><br><span class="line">                   j++;</span><br><span class="line">                   <span class="keyword">if</span>(j==s.length())</span><br><span class="line">                   &#123;</span><br><span class="line">                       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 动态规划 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>389.找不同</title>
      <link href="/post/3008.html"/>
      <url>/post/3008.html</url>
      
        <content type="html"><![CDATA[<h1 id="389-找不同"><a href="#389-找不同" class="headerlink" title="389.找不同"></a>389.找不同</h1><p>给定两个字符串 <strong><em>s</em></strong> 和 <strong><em>t</em></strong>，它们只包含小写字母。</p><p>字符串 <strong><em>t\</em></strong> 由字符串 <strong><em>s\</em></strong> 随机重排，然后在随机位置添加一个字母。</p><p>请找出在 <strong><em>t</em></strong> 中被添加的字母。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;abcd&quot;</span>, t = <span class="string">&quot;abcde&quot;</span></span><br><span class="line">输出：<span class="string">&quot;e&quot;</span></span><br><span class="line">解释：<span class="string">&#x27;e&#x27;</span> 是那个被添加的字母。</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong>：求和</p><p>将每个字符用ASCII码相加起来，最后的差值就是多添加的数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">findTheDifference</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> as = <span class="number">0</span>, at = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            as += s.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); ++i) &#123;</span><br><span class="line">            at += t.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">char</span>) (at - as);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 哈希表 </category>
          
          <category> 字符串 </category>
          
          <category> 位运算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>387.字符串中的第一个唯一字符</title>
      <link href="/post/53571.html"/>
      <url>/post/53571.html</url>
      
        <content type="html"><![CDATA[<h1 id="387-字符串中的第一个唯一字符"><a href="#387-字符串中的第一个唯一字符" class="headerlink" title="387.字符串中的第一个唯一字符"></a>387.字符串中的第一个唯一字符</h1><p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p><p><strong>示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;leetcode&quot;</span></span><br><span class="line">返回 <span class="number">0</span></span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;loveleetcode&quot;</span></span><br><span class="line">返回 <span class="number">2</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>经典Map统计字符出现频数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">      String[] x=s.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">      Map&lt;String,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">       <span class="keyword">int</span> count = map.getOrDefault(x[i],<span class="number">0</span>)+<span class="number">1</span>;</span><br><span class="line">        map.put(x[i],count);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;s.length();j++)&#123;</span><br><span class="line">       <span class="keyword">if</span>(map.get(x[j])==<span class="number">1</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> j;</span><br><span class="line">       &#125;</span><br><span class="line">      &#125;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 哈希表 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>374.猜数字大小</title>
      <link href="/post/19295.html"/>
      <url>/post/19295.html</url>
      
        <content type="html"><![CDATA[<h1 id="374-猜数字大小"><a href="#374-猜数字大小" class="headerlink" title="374.猜数字大小"></a>374.猜数字大小</h1><p>猜数字游戏的规则如下：</p><ul><li>每轮游戏，我都会从 <strong>1</strong> 到 <strong><em>n</em></strong> 随机选择一个数字。 请你猜选出的是哪个数字。</li><li>如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。</li></ul><p>你可以通过调用一个预先定义好的接口 <code>int guess(int num)</code> 来获取猜测结果，返回值一共有 3 种可能的情况（<code>-1</code>，<code>1</code> 或 <code>0</code>）：</p><ul><li>-1：我选出的数字比你猜的数字小 <code>pick &lt; num</code></li><li>1：我选出的数字比你猜的数字大 <code>pick &gt; num</code></li><li>0：我选出的数字和你猜的数字一样。恭喜！你猜对了！<code>pick == num</code></li></ul><p>返回我选出的数字。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">10</span>, pick = <span class="number">6</span></span><br><span class="line">输出：<span class="number">6</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>二分查找答案</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">GuessGame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">guessNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = n;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 循环直至区间左右端点相同</span></span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>; <span class="comment">// 防止计算时溢出</span></span><br><span class="line">            <span class="keyword">if</span> (guess(mid) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                right = mid; <span class="comment">// 答案在区间 [left, mid] 中</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>; <span class="comment">// 答案在区间 [mid+1, right] 中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时有 left == right，区间缩为一个点，即为答案</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>383.赎金信</title>
      <link href="/post/37889.html"/>
      <url>/post/37889.html</url>
      
        <content type="html"><![CDATA[<h1 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383.赎金信"></a>383.赎金信</h1><p>为了不在赎金信中暴露字迹，从杂志上搜索各个需要的字母，组成单词来表达意思。</p><p>给你一个赎金信 (<code>ransomNote</code>) 字符串和一个杂志(<code>magazine</code>)字符串，判断 <code>ransomNote</code> 能不能由 <code>magazines</code> 里面的字符构成。</p><p>如果可以构成，返回 <code>true</code> ；否则返回 <code>false</code> 。</p><p><code>magazine</code> 中的每个字符只能在 <code>ransomNote</code> 中使用一次。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：ransomNote = <span class="string">&quot;a&quot;</span>, magazine = <span class="string">&quot;b&quot;</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>小写字母的词频统计</p><hr><p><strong>Solution</strong>：</p><p>只要统计字符串<code>magazine</code>中每个英文字母的频率，都大于等于<code>reansomNote</code>的频率，就可以成立</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ransomNote.length() &gt; magazine.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] cnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : magazine.toCharArray()) &#123;</span><br><span class="line">            cnt[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : ransomNote.toCharArray()) &#123;</span><br><span class="line">            cnt[c - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="keyword">if</span>(cnt[c - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Solution1</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初次提交的做法，可以说是熟练使用String方法了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> </span>&#123;</span><br><span class="line">        String[] arr = ransomNote.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ransomNote.length();i++)&#123;</span><br><span class="line">             <span class="keyword">if</span>(magazine.contains(arr[i]))&#123;</span><br><span class="line">                magazine=magazine.replaceFirst(arr[i],<span class="string">&quot;1&quot;</span>);</span><br><span class="line">             &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             &#125;</span><br><span class="line">           </span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 哈希表 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>367.有效的完全平方数</title>
      <link href="/post/20356.html"/>
      <url>/post/20356.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="367-有效的完全平方数"><a href="#367-有效的完全平方数" class="headerlink" title="367.有效的完全平方数"></a>367.有效的完全平方数</h1><p>给定一个 <strong>正整数</strong> <code>num</code> ，编写一个函数，如果 <code>num</code> 是一个完全平方数，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p><p><strong>进阶：不要</strong> 使用任何内置的库函数，如 <code>sqrt</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="number">16</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>二分查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = num;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">            <span class="keyword">long</span> square = (<span class="keyword">long</span>) mid * mid;</span><br><span class="line">            <span class="keyword">if</span> (square &lt; num) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (square &gt; num) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>350.两个数组的交集2</title>
      <link href="/post/1618.html"/>
      <url>/post/1618.html</url>
      
        <content type="html"><![CDATA[<h1 id="350-两个数组的交集2"><a href="#350-两个数组的交集2" class="headerlink" title="350.两个数组的交集2"></a>350.两个数组的交集2</h1><p>给你两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>], nums2 = [<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><hr><p>Solution：</p><p>根据<code>136：只出现一次的数字</code>的启发，可以用HashMap数据结构来储存nums1以及元素出现次数，然后对比nums2和Map中的元素，如果元素出现了就添加进答案数组里面，然后将元素出现次数-1，如果为0，直接移除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1.length &gt; nums2.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> intersect(nums2, nums1);</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums1) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">            map.put(num, count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] intersection = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums2) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = map.getOrDefault(num, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                intersection[index++] = num;</span><br><span class="line">                count--;</span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    map.put(num, count);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    map.remove(num);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(intersection, <span class="number">0</span>, index);</span><br><span class="line">        <span class="comment">//copyOfRange 直接输出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 哈希表 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>349.两个数组的交集</title>
      <link href="/post/15820.html"/>
      <url>/post/15820.html</url>
      
        <content type="html"><![CDATA[<h1 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349.两个数组的交集"></a>349.两个数组的交集</h1><p>给定两个数组，编写一个函数来计算它们的交集。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">输出：[2]</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong>：</p><p>用一个Set集合储存一个nums1，然后遍历nums2中的元素，来测出nums1和nums2交集，因为答案数组不能有重复元素，所以创建第二个Set来存储交集，如果Set1中包含了这一元素，说明是交集，添加进入Set2中</p><p>最后将Set转换为int数组输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">       Set &lt;Integer&gt; set=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums1.length;i++)&#123;</span><br><span class="line">           set.add(nums1[i]);</span><br><span class="line">       &#125;</span><br><span class="line">      </span><br><span class="line">       Set &lt;Integer&gt; a=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums2.length;j++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(set.contains(nums2[j])==<span class="keyword">true</span>)&#123;</span><br><span class="line">               a.add(nums2[j]);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">      </span><br><span class="line">      Integer[] array = a.toArray(<span class="keyword">new</span> Integer[<span class="number">0</span>]);</span><br><span class="line">      <span class="comment">// 再将Integer型数组转为int型数组</span></span><br><span class="line">        <span class="keyword">int</span>[] intArray = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            intArray[i] = array[i].intValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intArray;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 哈希表 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>344.反转字符串</title>
      <link href="/post/53197.html"/>
      <url>/post/53197.html</url>
      
        <content type="html"><![CDATA[<h1 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344.反转字符串"></a>344.反转字符串</h1><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>s</code> 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须<strong><a href="https://baike.baidu.com/item/原地算法">原地</a>修改输入数组</strong>、使用 O(1) 的额外空间解决这一问题。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = [<span class="string">&quot;h&quot;</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;l&quot;</span>,<span class="string">&quot;l&quot;</span>,<span class="string">&quot;o&quot;</span>]</span><br><span class="line">输出：[<span class="string">&quot;o&quot;</span>,<span class="string">&quot;l&quot;</span>,<span class="string">&quot;l&quot;</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;h&quot;</span>]</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>原地修改，双指针就行了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>; left &lt; right; ++left, --right) &#123;</span><br><span class="line">            <span class="keyword">char</span> tmp = s[left];</span><br><span class="line">            s[left] = s[right];</span><br><span class="line">            s[right] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>345.反转字符串中的元音字母</title>
      <link href="/post/38257.html"/>
      <url>/post/38257.html</url>
      
        <content type="html"><![CDATA[<h1 id="345-反转字符串中的元音字母"><a href="#345-反转字符串中的元音字母" class="headerlink" title="345.反转字符串中的元音字母"></a>345.反转字符串中的元音字母</h1><p>给你一个字符串 <code>s</code> ，仅反转字符串中的所有元音字母，并返回结果字符串。</p><p>元音字母包括 <code>&#39;a&#39;</code>、<code>&#39;e&#39;</code>、<code>&#39;i&#39;</code>、<code>&#39;o&#39;</code>、<code>&#39;u&#39;</code>，且可能以大小写两种形式出现。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;hello&quot;</span></span><br><span class="line">输出：<span class="string">&quot;holle&quot;</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>先设置一个字符串来存储元音字符，然后设置双指针来遍历字符串s，把指针指向的字母和原因字符对比，就可以判断是否是元音字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseVowels</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">int</span> j=s.length()-<span class="number">1</span>;</span><br><span class="line">         StringBuilder sb=<span class="keyword">new</span> StringBuilder(s);</span><br><span class="line">      </span><br><span class="line">         <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">          <span class="keyword">while</span>(i&lt;j&amp;&amp;isVowel(sb.charAt(i))&lt;<span class="number">0</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              i++;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">         <span class="keyword">while</span>(j&gt;i&amp;&amp;!isVowel(sb.charAt(j))&lt;<span class="number">0</span>)</span><br><span class="line">         &#123;    </span><br><span class="line">              j--;</span><br><span class="line">         &#125;</span><br><span class="line">      </span><br><span class="line">        sb.setCharAt(i,s.charAt(j));</span><br><span class="line">        sb.setCharAt(j,s.charAt(i));</span><br><span class="line">       </span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    String x=sb.toString();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span>  <span class="title">vowel</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;aeiouAEIOU&quot;</span>.indexOf(ch);<span class="comment">//如果不是的话，就回返回-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>342.4的幂</title>
      <link href="/post/25999.html"/>
      <url>/post/25999.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="342-4的幂"><a href="#342-4的幂" class="headerlink" title="342.4的幂"></a>342.4的幂</h1><p>给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>整数 <code>n</code> 是 4 的幂次方需满足：存在整数 <code>x</code> 使得 <code>n == 4x</code></p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">16</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>在2的幂的基础上，构造一个掩码<em>mask</em>=10101010101010101010101010101010，进行与操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span> &amp;&amp; (n &amp; <span class="number">0xaaaaaaaa</span>) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
          <category> 位运算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>338.比特位计数</title>
      <link href="/post/59365.html"/>
      <url>/post/59365.html</url>
      
        <content type="html"><![CDATA[<h1 id="338-比特位计数"><a href="#338-比特位计数" class="headerlink" title="338.比特位计数"></a>338.比特位计数</h1><p>给你一个整数 <code>n</code> ，对于 <code>0 &lt;= i &lt;= n</code> 中的每个 <code>i</code> ，计算其二进制表示中 <strong><code>1</code> 的个数</strong> ，返回一个长度为 <code>n + 1</code> 的数组 <code>ans</code> 作为答案。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">解释：</span><br><span class="line"><span class="number">0</span> --&gt; <span class="number">0</span></span><br><span class="line"><span class="number">1</span> --&gt; <span class="number">1</span></span><br><span class="line"><span class="number">2</span> --&gt; <span class="number">10</span></span><br></pre></td></tr></table></figure><hr><p><strong>Soluiton</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] bits = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            bits[i] = countOnes(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bits;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countOnes</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ones = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            x &amp;= (x - <span class="number">1</span>);</span><br><span class="line">            ones++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ones;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 动态规划 </category>
          
          <category> 位运算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>326.3的幂</title>
      <link href="/post/31275.html"/>
      <url>/post/31275.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="326-3的幂"><a href="#326-3的幂" class="headerlink" title="326.3的幂"></a>326.3的幂</h1><p>给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>整数 <code>n</code> 是 3 的幂次方需满足：存在整数 <code>x</code> 使得 <code>n == 3x</code></p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">27</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>试除法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span> &amp;&amp; n % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            n /= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>303. 区域和检索 - 数组不可变</title>
      <link href="/post/62527.html"/>
      <url>/post/62527.html</url>
      
        <content type="html"><![CDATA[<h1 id="303-区域和检索-数组不可变"><a href="#303-区域和检索-数组不可变" class="headerlink" title="303. 区域和检索 - 数组不可变"></a>303. 区域和检索 - 数组不可变</h1><p>给定一个整数数组  <code>nums</code>，求出数组从索引 <code>i</code> 到 <code>j</code>（<code>i ≤ j</code>）范围内元素的总和，包含 <code>i</code>、<code>j</code>两点。</p><p>实现 <code>NumArray</code> 类：</p><ul><li><code>NumArray(int[] nums)</code> 使用数组 <code>nums</code> 初始化对象</li><li><code>int sumRange(int i, int j)</code> 返回数组 <code>nums</code> 从索引 <code>i</code> 到 <code>j</code><em>（</em><code>i ≤ j</code>）范围内元素的总和，包含 <code>i</code>、<code>j</code>两点（也就是 <code>sum(nums[i], nums[i + 1], ... , nums[j])</code>）</li></ul><p><strong>示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">&quot;NumArray&quot;</span>, <span class="string">&quot;sumRange&quot;</span>, <span class="string">&quot;sumRange&quot;</span>, <span class="string">&quot;sumRange&quot;</span>]</span><br><span class="line">[[[<span class="number">-2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">-5</span>, <span class="number">2</span>, <span class="number">-1</span>]], [<span class="number">0</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">5</span>], [<span class="number">0</span>, <span class="number">5</span>]]</span><br><span class="line">输出：</span><br><span class="line">[null, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-3</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">NumArray numArray = <span class="keyword">new</span> NumArray([<span class="number">-2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">-5</span>, <span class="number">2</span>, <span class="number">-1</span>]);</span><br><span class="line">numArray.sumRange(<span class="number">0</span>, <span class="number">2</span>); <span class="comment">// return 1 ((-2) + 0 + 3)</span></span><br><span class="line">numArray.sumRange(<span class="number">2</span>, <span class="number">5</span>); <span class="comment">// return -1 (3 + (-5) + 2 + (-1)) </span></span><br><span class="line">numArray.sumRange(<span class="number">0</span>, <span class="number">5</span>); <span class="comment">// return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>题目要求是返回一个数组间从下标i到下标j元素之间的和，如果采用暴力算法，循环计算，由于每次检索的时间和检索的下标范围有关，因此时间复杂度较高</p><p>所以能实现计算出前缀和，那么可以将时间复杂度降低到O(1)</p><p>具体实现方面，假设数组 <em>nums</em> 的长度为 <em>n</em>，创建长度为 <em>n+1</em> 的前缀和数组<em>sums</em>，对于<em>0≤i＜n</em>都有sums[i+1]=sums[i]+nums[i]，sums[i]表示数组nums从下标0到下标i-1的前缀和</p><p>前缀和计算方法：sumRrage(i,j)=sums[j+1]-nums[i]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] sums;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        sums = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sums[i + <span class="number">1</span>] = sums[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> sums[right + <span class="number">1</span>] - sums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>292.Nim游戏</title>
      <link href="/post/221.html"/>
      <url>/post/221.html</url>
      
        <content type="html"><![CDATA[<h1 id="292-Nim游戏"><a href="#292-Nim游戏" class="headerlink" title="292.Nim游戏"></a>292.Nim游戏</h1><p>你和你的朋友，两个人一起玩 <a href="https://baike.baidu.com/item/Nim游戏/6737105">Nim 游戏</a>：</p><ul><li>桌子上有一堆石头。</li><li>你们轮流进行自己的回合，你作为先手。</li><li>每一回合，轮到的人拿掉 1 - 3 块石头。</li><li>拿掉最后一块石头的人就是获胜者。</li></ul><p>假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 <code>n</code> 的情况下赢得游戏。如果可以赢，返回 <code>true</code>；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span></span><br><span class="line">输出：<span class="literal">false</span> </span><br><span class="line">解释：如果堆中有 <span class="number">4</span> 块石头，那么你永远不会赢得比赛；</span><br><span class="line">     因为无论你拿走 <span class="number">1</span> 块、<span class="number">2</span> 块 还是 <span class="number">3</span> 块石头，最后一块石头总是会被你的朋友拿走。</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>不是4的倍数就好</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canWinNim</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n % <span class="number">4</span> != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>290.单词规律</title>
      <link href="/post/19884.html"/>
      <url>/post/19884.html</url>
      
        <content type="html"><![CDATA[<h1 id="290-单词规律"><a href="#290-单词规律" class="headerlink" title="290.单词规律"></a>290.单词规律</h1><p>给定一种规律 <code>pattern</code> 和一个字符串 <code>str</code> ，判断 <code>str</code> 是否遵循相同的规律。</p><p>这里的 <strong>遵循</strong> 指完全匹配，例如， <code>pattern</code> 里的每个字母和字符串 <code>str</code> 中的每个非空单词之间存在着双向连接的对应规律。</p><p><strong>示例1:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: pattern = <span class="string">&quot;abba&quot;</span>, str = <span class="string">&quot;dog cat cat dog&quot;</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入:pattern = <span class="string">&quot;abba&quot;</span>, str = <span class="string">&quot;dog cat cat fish&quot;</span></span><br><span class="line">输出: <span class="keyword">false</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>这道题显示是<code>205 同构字符串</code>的升级版本，当然也可以用其解法，难点在与需要以空格来隔断字符串，并且用<code>substring</code>函数来断开字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordPattern</span><span class="params">(String pattern, String str)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Character&gt; str2ch = <span class="keyword">new</span> HashMap&lt;String, Character&gt;();</span><br><span class="line">        Map&lt;Character, String&gt; ch2str = <span class="keyword">new</span> HashMap&lt;Character, String&gt;();</span><br><span class="line">        <span class="keyword">int</span> m = str.length();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; pattern.length(); ++p) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = pattern.charAt(p);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= m) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; m &amp;&amp; str.charAt(j) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            String tmp = str.substring(i, j);</span><br><span class="line">            <span class="keyword">if</span> (str2ch.containsKey(tmp) &amp;&amp; str2ch.get(tmp) != ch) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ch2str.containsKey(ch) &amp;&amp; !tmp.equals(ch2str.get(ch))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            str2ch.put(tmp, ch);</span><br><span class="line">            ch2str.put(ch, tmp);</span><br><span class="line">            i = j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i &gt;= m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>也正如<code>205</code>一样，该题也有更为简单的办法，因为是以空格断开字符，直接用JAVA中的<code>split(&quot; &quot;)</code>就可以断开字符串了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordPattern</span><span class="params">(String pattern, String str)</span> </span>&#123;</span><br><span class="line">        String[] words = str.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (words.length != pattern.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Object, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//巧妙的采取Object类，让char和String都能存储进去</span></span><br><span class="line">        <span class="keyword">for</span> (Integer i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.put(pattern.charAt(i), i) != map.put(words[i], i)) &#123;<span class="comment">//这里运用了put函数的特性，如果输入了已经拥有Key，那就返回之前的Key的value值</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 哈希表 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>278.第一个错误的版本</title>
      <link href="/post/8460.html"/>
      <url>/post/8460.html</url>
      
        <content type="html"><![CDATA[<h1 id="278-第一个错误的版本"><a href="#278-第一个错误的版本" class="headerlink" title="278.第一个错误的版本"></a>278.第一个错误的版本</h1><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p><p>假设你有 <code>n</code> 个版本 <code>[1, 2, ..., n]</code>，你想找出导致之后所有版本出错的第一个错误的版本。</p><p>你可以通过调用 <code>bool isBadVersion(version)</code> 接口来判断版本号 <code>version</code> 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, bad = <span class="number">4</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：</span><br><span class="line">调用 isBadVersion(<span class="number">3</span>) -&gt; <span class="literal">false</span> </span><br><span class="line">调用 isBadVersion(<span class="number">5</span>) -&gt; <span class="literal">true</span> </span><br><span class="line">调用 isBadVersion(<span class="number">4</span>) -&gt; <span class="literal">true</span></span><br><span class="line">所以，<span class="number">4</span> 是第一个错误的版本。</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>二分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">VersionControl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = n;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 循环直至区间左右端点相同</span></span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>; <span class="comment">// 防止计算时溢出</span></span><br><span class="line">            <span class="keyword">if</span> (isBadVersion(mid)) &#123;</span><br><span class="line">                right = mid; <span class="comment">// 答案在区间 [left, mid] 中</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>; <span class="comment">// 答案在区间 [mid+1, right] 中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时有 left == right，区间缩为一个点，即为答案</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>283.移动零</title>
      <link href="/post/28492.html"/>
      <url>/post/28492.html</url>
      
        <content type="html"><![CDATA[<h1 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283.移动零"></a>283.移动零</h1><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>示例:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">12</span>]</span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><strong>说明</strong>:</p><ol><li>必须在原数组上操作，不能拷贝额外的数组。</li><li>尽量减少操作次数。</li></ol><hr><p><strong>Solution</strong>：</p><p>可以先将非零元素移动到数组前面，然后再给在给数组后端赋予0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span> low=<span class="number">0</span>;</span><br><span class="line">           <span class="keyword">int</span> high=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">           </span><br><span class="line">           <span class="keyword">while</span>(high&lt;nums.length)&#123;</span><br><span class="line">               <span class="keyword">if</span>(nums[high]!=<span class="number">0</span>)&#123;</span><br><span class="line">                   nums[low]=nums[high];</span><br><span class="line">                   low++;</span><br><span class="line">               &#125;</span><br><span class="line">               high++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=low;i&lt;high;i++)&#123;</span><br><span class="line">               nums[i]=<span class="number">0</span>;</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>268.丢失的数字</title>
      <link href="/post/46193.html"/>
      <url>/post/46193.html</url>
      
        <content type="html"><![CDATA[<h1 id="268-丢失的数字"><a href="#268-丢失的数字" class="headerlink" title="268. 丢失的数字"></a>268. 丢失的数字</h1><p>给定一个包含 <code>[0, n]</code> 中 <code>n</code> 个数的数组 <code>nums</code> ，找出 <code>[0, n]</code> 这个范围内没有出现在数组中的那个数。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：n = <span class="number">3</span>，因为有 <span class="number">3</span> 个数字，所以所有的数字都在范围 [<span class="number">0</span>,<span class="number">3</span>] 内。<span class="number">2</span> 是丢失的数字，因为它没有出现在 nums 中。</span><br></pre></td></tr></table></figure><ul><li><code>nums</code> 中的所有数字都 <strong>独一无二</strong></li></ul><hr><p><strong>Solution</strong>：排序</p><p>很容易想到先讲数组排序，然后直接输出下标的办法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">         Arrays.sort(nums);</span><br><span class="line">    </span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">             <span class="keyword">if</span>(i!=nums[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> nums.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Solution1</strong>：位运算</p><p>数组 <em>nums</em> 中有 <em>n</em> 个数，在这 <em>n</em> 个数的后面添加从 0 到 <em>n</em> 的每个整数，则添加了 <em>n</em>+1 个整数，共有 2<em>n</em>+1 个整数。</p><p>在 2<em>n</em>+1 个整数中，丢失的数字只在后面 <em>n</em>+1 个整数中出现一次，其余的数字在前面 <em>n</em> 个整数中（即数组中）和后面 <em>n</em>+1 个整数中各出现一次，即其余的数字都出现了两次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> xor = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            xor ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            xor ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> xor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 哈希表 </category>
          
          <category> 数组 </category>
          
          <category> 位运算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>263.丑数</title>
      <link href="/post/34631.html"/>
      <url>/post/34631.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="263-丑数"><a href="#263-丑数" class="headerlink" title="263.丑数"></a>263.丑数</h1><p>给你一个整数 <code>n</code> ，请你判断 <code>n</code> 是否为 <strong>丑数</strong> 。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>丑数</strong> 就是只包含质因数 <code>2</code>、<code>3</code> 和/或 <code>5</code> 的正整数。</p><p><strong>示例 1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">6</span></span><br><span class="line">输出：<span class="keyword">true</span></span><br><span class="line">解释：<span class="number">6</span> = <span class="number">2</span> × <span class="number">3</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>n反复除2,3,5就行了，最后的结果为1的话说明是丑数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] factors = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> factor : factors) &#123;</span><br><span class="line">            <span class="keyword">while</span> (n % factor == <span class="number">0</span>) &#123;</span><br><span class="line">                n /= factor;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>258.各位相加</title>
      <link href="/post/7241.html"/>
      <url>/post/7241.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="258-各位相加"><a href="#258-各位相加" class="headerlink" title="258.各位相加"></a>258.各位相加</h1><p>给定一个非负整数 <code>num</code>，反复将各个位上的数字相加，直到结果为一位数。</p><p><strong>示例:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">38</span></span><br><span class="line">输出: <span class="number">2</span> </span><br><span class="line">解释: 各位相加的过程为：<span class="number">3</span> + <span class="number">8</span> = <span class="number">11</span>, <span class="number">1</span> + <span class="number">1</span> = <span class="number">2</span>。 由于 <span class="number">2</span> 是一位数，所以返回 <span class="number">2</span>。</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>$ x×100+y×10+z=x×99+y×9+(x+y+z) $</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addDigits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (num - <span class="number">1</span>) % <span class="number">9</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>257.二叉树的所有路径</title>
      <link href="/post/3179.html"/>
      <url>/post/3179.html</url>
      
        <content type="html"><![CDATA[<h1 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257.二叉树的所有路径"></a>257.二叉树的所有路径</h1><p>给你一个二叉树的根节点 <code>root</code> ，按 <strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,null,<span class="number">5</span>]</span><br><span class="line">输出：[<span class="string">&quot;1-&gt;2-&gt;5&quot;</span>,<span class="string">&quot;1-&gt;3&quot;</span>]</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>深度遍历，设置一个List数组，一个字符串，遍历一次就将字符串加入到List数组中去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; paths = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        StringBuilder s=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        dfs(paths, root,s );</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;String&gt; res, TreeNode node,  StringBuilder s)</span> </span>&#123;</span><br><span class="line">s.append(node.val);</span><br><span class="line"><span class="keyword">if</span> (node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">res.add(s.toString());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">         <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">dfs(res, node.left, <span class="keyword">new</span> StringBuilder(s).append(<span class="string">&quot;-&gt;&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">dfs(res, node.right, <span class="keyword">new</span> StringBuilder(s).append(<span class="string">&quot;-&gt;&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>242.有效的字母异位词</title>
      <link href="/post/44708.html"/>
      <url>/post/44708.html</url>
      
        <content type="html"><![CDATA[<h1 id="242-有效的字符异位词"><a href="#242-有效的字符异位词" class="headerlink" title="242.有效的字符异位词"></a>242.有效的字符异位词</h1><p>给定两个字符串 <code>*s*</code> 和 <code>*t*</code> ，编写一个函数来判断 <code>*t*</code> 是否是 <code>*s*</code> 的字母异位词。</p><p><strong>注意：</strong>若 <code>*s*</code> 和 <code>*t*</code> 中每个字符出现的次数都相同，则称 <code>*s*</code> 和 <code>*t*</code> 互为字母异位词。</p><p><strong>示例 1:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;anagram&quot;</span>, t = <span class="string">&quot;nagaram&quot;</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;rat&quot;</span>, t = <span class="string">&quot;car&quot;</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong>：哈希表</p><p>用一个Map记录字符串s中字符的出现次数，然后遍历字符串t，字符没出现一次就出现次数就-1，如果出现次数最后&lt;0，说明不匹配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Character, Integer&gt; table = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">            table.put(ch, table.getOrDefault(ch, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = t.charAt(i);</span><br><span class="line">            table.put(ch, table.getOrDefault(ch, <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (table.get(ch) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 哈希表 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>237.删除链表中的节点</title>
      <link href="/post/55666.html"/>
      <url>/post/55666.html</url>
      
        <content type="html"><![CDATA[<h1 id="237-删除链表中的节点"><a href="#237-删除链表中的节点" class="headerlink" title="237.删除链表中的节点"></a>237.删除链表中的节点</h1><p>请编写一个函数，用于 <strong>删除单链表中某个特定节点</strong> 。在设计函数时需要注意，你无法访问链表的头节点 <code>head</code> ，只能直接访问 <strong>要被删除的节点</strong> 。</p><p>题目数据保证需要删除的节点 <strong>不是末尾节点</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>], node = <span class="number">5</span></span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">1</span>,<span class="number">9</span>]</span><br><span class="line">解释：指定链表中值为 <span class="number">5</span> 的第二个节点，那么在调用了你的函数之后，该链表应变为 <span class="number">4</span> -&gt; <span class="number">1</span> -&gt; <span class="number">9</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>直接修改要被删除的结点，使之成为自己的下一个结点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        node.val = node.next.val;</span><br><span class="line">        node.next = node.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>235.二叉搜索树的最近公共祖先</title>
      <link href="/post/31088.html"/>
      <url>/post/31088.html</url>
      
        <content type="html"><![CDATA[<h1 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235.二叉搜索树的最近公共祖先"></a>235.二叉搜索树的最近公共祖先</h1><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p>例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png" alt="img"></p><p><strong>示例 1:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [<span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,null,null,<span class="number">3</span>,<span class="number">5</span>], p = <span class="number">2</span>, q = <span class="number">8</span></span><br><span class="line">输出: <span class="number">6</span> </span><br><span class="line">解释: 节点 <span class="number">2</span> 和节点 <span class="number">8</span> 的最近公共祖先是 <span class="number">6</span>。</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>同时比较p，q和当前root的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        TreeNode ancestor = root;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.val &lt; ancestor.val &amp;&amp; q.val &lt; ancestor.val) &#123;</span><br><span class="line">                ancestor = ancestor.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.val &gt; ancestor.val &amp;&amp; q.val &gt; ancestor.val) &#123;</span><br><span class="line">                ancestor = ancestor.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ancestor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>234.回文链表</title>
      <link href="/post/55897.html"/>
      <url>/post/55897.html</url>
      
        <content type="html"><![CDATA[<h1 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234.回文链表"></a>234.回文链表</h1><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="keyword">true</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong>：</p><p>直接知道中间结点，将结点分成两份，利用<code>206 反转链表</code>中的方法，将后面的链表反转过来，对比是否一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到前半部分链表的尾节点并反转后半部分链表</span></span><br><span class="line">        ListNode firstHalfEnd = endOfFirstHalf(head);</span><br><span class="line">        ListNode secondHalfStart = reverseList(firstHalfEnd.next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否回文</span></span><br><span class="line">        ListNode p1 = head;</span><br><span class="line">        ListNode p2 = secondHalfStart;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (result &amp;&amp; p2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1.val != p2.val) &#123;</span><br><span class="line">                result = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;        </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 还原链表并返回结果</span></span><br><span class="line">        firstHalfEnd.next = reverseList(secondHalfStart);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode nextTemp = curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = nextTemp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">/* 用快慢指针寻找链表的中间结点</span></span><br><span class="line"><span class="comment"> slow指针走一步，而fast指针走两步，则最后fast指针为null的之后，slow指针就是链表的中间结点*/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">endOfFirstHalf</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 栈 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>232.用栈实现队列</title>
      <link href="/post/44957.html"/>
      <url>/post/44957.html</url>
      
        <content type="html"><![CDATA[<h1 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232.用栈实现队列"></a>232.用栈实现队列</h1><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p><p>实现 <code>MyQueue</code> 类：</p><ul><li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li><li><code>int pop()</code> 从队列的开头移除并返回元素</li><li><code>int peek()</code> 返回队列开头的元素</li><li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li></ul><p><strong>说明：</strong></p><ul><li>你只能使用标准的栈操作 —— 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。</li><li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li></ul><p><strong>进阶：</strong></p><ul><li>你能否实现每个操作均摊时间复杂度为 <code>O(1)</code> 的队列？换句话说，执行 <code>n</code> 个操作的总时间复杂度为 <code>O(n)</code> ，即使其中一个操作可能花费较长时间。</li></ul><p><strong>示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">&quot;MyQueue&quot;</span>, <span class="string">&quot;push&quot;</span>, <span class="string">&quot;push&quot;</span>, <span class="string">&quot;peek&quot;</span>, <span class="string">&quot;pop&quot;</span>, <span class="string">&quot;empty&quot;</span>]</span><br><span class="line">[[], [<span class="number">1</span>], [<span class="number">2</span>], [], [], []]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, <span class="number">1</span>, <span class="number">1</span>, <span class="literal">false</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyQueue myQueue = <span class="keyword">new</span> MyQueue();</span><br><span class="line">myQueue.push(<span class="number">1</span>); <span class="comment">// queue is: [1]</span></span><br><span class="line">myQueue.push(<span class="number">2</span>); <span class="comment">// queue is: [1, 2] (leftmost is front of the queue)</span></span><br><span class="line">myQueue.peek(); <span class="comment">// return 1</span></span><br><span class="line">myQueue.pop(); <span class="comment">// return 1, queue is [2]</span></span><br><span class="line">myQueue.empty(); <span class="comment">// return false</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>用两个栈，栈1用来和队列同步，当要出栈的时候，把栈1的元素全部转移到栈2中去，就和队列的结构一样了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; stack1;</span><br><span class="line">    Stack&lt;Integer&gt; stack2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> Stack&lt;&gt;(); <span class="comment">// 负责进栈</span></span><br><span class="line">        stack2 = <span class="keyword">new</span> Stack&lt;&gt;(); <span class="comment">// 负责出栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        dumpStack1();</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dumpStack1();</span><br><span class="line">        <span class="keyword">return</span> stack2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.isEmpty() &amp;&amp; stack2.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果stack2为空，那么将stack1中的元素全部放到stack2中</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dumpStack1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.isEmpty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>231.2的幂</title>
      <link href="/post/45896.html"/>
      <url>/post/45896.html</url>
      
        <content type="html"><![CDATA[<h1 id="231-2的幂"><a href="#231-2的幂" class="headerlink" title="231.2的幂"></a>231.2的幂</h1><p>给你一个整数 <code>n</code>，请你判断该整数是否是 2 的幂次方。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>如果存在一个整数 <code>x</code> 使得 <code>n == 2x</code> ，则认为 <code>n</code> 是 2 的幂次方。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：<span class="number">20</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><hr><p><strong>Soluiton</strong></p><p><code>n&amp;n-1</code>操作可以直接将<code>n</code>的二进制表示的最低一位1给移除掉，而2的幂的二进制表示只会有1个1，所以如果移除掉的结果是0的话，说明是2的幂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
          <category> 位运算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>228.汇总区间</title>
      <link href="/post/49765.html"/>
      <url>/post/49765.html</url>
      
        <content type="html"><![CDATA[<h1 id="228-汇总区间"><a href="#228-汇总区间" class="headerlink" title="228.汇总区间"></a>228.汇总区间</h1><p>给定一个无重复元素的有序整数数组 <code>nums</code> 。</p><p>返回 <strong>恰好覆盖数组中所有数字</strong> 的 <strong>最小有序</strong> 区间范围列表。也就是说，<code>nums</code> 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 <code>nums</code> 的数字 <code>x</code> 。</p><p>列表中的每个区间范围 <code>[a,b]</code> 应该按如下格式输出：</p><ul><li><code>&quot;a-&gt;b&quot;</code> ，如果 <code>a != b</code></li><li><code>&quot;a&quot;</code> ，如果 <code>a == b</code></li></ul><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>]</span><br><span class="line">输出：[<span class="string">&quot;0-&gt;2&quot;</span>,<span class="string">&quot;4-&gt;5&quot;</span>,<span class="string">&quot;7&quot;</span>]</span><br><span class="line">解释：区间范围是：</span><br><span class="line">[<span class="number">0</span>,<span class="number">2</span>] --&gt; <span class="string">&quot;0-&gt;2&quot;</span></span><br><span class="line">[<span class="number">4</span>,<span class="number">5</span>] --&gt; <span class="string">&quot;4-&gt;5&quot;</span></span><br><span class="line">[<span class="number">7</span>,<span class="number">7</span>] --&gt; <span class="string">&quot;7&quot;</span></span><br></pre></td></tr></table></figure><hr><p><strong>对比检查</strong>数组中的连续出现数组</p><p><strong>Solution</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">summaryRanges</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; ret = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">int</span> low = i;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] + <span class="number">1</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> high = i - <span class="number">1</span>;</span><br><span class="line">            String lows;</span><br><span class="line">            String highs;</span><br><span class="line">            lows= String.valueOf(nums[low]);</span><br><span class="line">            highs =String.valueOf(nums[high]);</span><br><span class="line">            <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">                ret.add(lows+<span class="string">&quot;-&gt;&quot;</span>+highs);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ret.add(lows);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>226.翻转二叉树</title>
      <link href="/post/20107.html"/>
      <url>/post/20107.html</url>
      
        <content type="html"><![CDATA[<h1 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226.翻转二叉树"></a>226.翻转二叉树</h1><p>翻转一棵二叉树。</p><p><strong>示例：</strong></p><p>输入：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">4</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">2</span>     <span class="number">7</span></span><br><span class="line"> / \   / \</span><br><span class="line"><span class="number">1</span>   <span class="number">3</span> <span class="number">6</span>   <span class="number">9</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">4</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">7</span>     <span class="number">2</span></span><br><span class="line"> / \   / \</span><br><span class="line"><span class="number">9</span>   <span class="number">6</span> <span class="number">3</span>   <span class="number">1</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>采用递归的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode left = invertTree(root.left);</span><br><span class="line">        TreeNode right = invertTree(root.right);</span><br><span class="line">        root.left = right;</span><br><span class="line">        root.right = left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>225.用队列实现栈</title>
      <link href="/post/3620.html"/>
      <url>/post/3620.html</url>
      
        <content type="html"><![CDATA[<h1 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225.用队列实现栈"></a>225.用队列实现栈</h1><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（<code>push</code>、<code>top</code>、<code>pop</code> 和 <code>empty</code>）。</p><p>实现 <code>MyStack</code> 类：</p><ul><li><code>void push(int x)</code> 将元素 x 压入栈顶。</li><li><code>int pop()</code> 移除并返回栈顶元素。</li><li><code>int top()</code> 返回栈顶元素。</li><li><code>boolean empty()</code> 如果栈是空的，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li></ul><p><strong>注意：</strong></p><ul><li>你只能使用队列的基本操作 —— 也就是 <code>push to back</code>、<code>peek/pop from front</code>、<code>size</code> 和 <code>is empty</code> 这些操作。</li><li>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li></ul><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">&quot;MyStack&quot;</span>, <span class="string">&quot;push&quot;</span>, <span class="string">&quot;push&quot;</span>, <span class="string">&quot;top&quot;</span>, <span class="string">&quot;pop&quot;</span>, <span class="string">&quot;empty&quot;</span>]</span><br><span class="line">[[], [<span class="number">1</span>], [<span class="number">2</span>], [], [], []]</span><br><span class="line">输出：</span><br><span class="line">[<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="keyword">false</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyStack myStack = <span class="keyword">new</span> MyStack();</span><br><span class="line">myStack.push(<span class="number">1</span>);</span><br><span class="line">myStack.push(<span class="number">2</span>);</span><br><span class="line">myStack.top(); <span class="comment">// 返回 2</span></span><br><span class="line">myStack.pop(); <span class="comment">// 返回 2</span></span><br><span class="line">myStack.empty(); <span class="comment">// 返回 False</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = queue.size();</span><br><span class="line">        queue.offer(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            queue.offer(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>219.存在重复元素2</title>
      <link href="/post/65152.html"/>
      <url>/post/65152.html</url>
      
        <content type="html"><![CDATA[<h1 id="219-存在重复元素2"><a href="#219-存在重复元素2" class="headerlink" title="219.存在重复元素2"></a>219.存在重复元素2</h1><p>给定一个整数数组和一个整数 <em>k</em>，判断数组中是否存在两个不同的索引 <em>i</em> 和 <em>j</em>，使得 <strong>nums [i] = nums [j]</strong>，并且 <em>i</em> 和 <em>j</em> 的差的 <strong>绝对值</strong> 至多为 <em>k</em>。</p><p><strong>示例 1:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>], k = <span class="number">3</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure><hr><p>数组中的重复元素，并且相差不超过k</p><p><strong>Solution</strong></p><p>在217的基础上，基于Set的特性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(nums[i])) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        set.add(nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (set.size() &gt; k) &#123;</span><br><span class="line">            set.remove(nums[i - k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 哈希表 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>217.存在重复元素</title>
      <link href="/post/60940.html"/>
      <url>/post/60940.html</url>
      
        <content type="html"><![CDATA[<h1 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217.存在重复元素"></a>217.存在重复元素</h1><p>给定一个整数数组，判断是否存在重复元素。</p><p>如果存在一值在数组中出现至少两次，函数返回 <code>true</code> 。如果数组中每个元素都不相同，则返回 <code>false</code> 。</p><p><strong>示例 1:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure><hr><p>有个元素会出现多次，而其他的<strong>仅有一次</strong></p><p><strong>Solution</strong>：排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>Solution1</strong>：HashSet</p><p>利用Set的特性，不会加入重复的元素，并且会返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">            HashSet&lt;Integer&gt; set=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x:nums)&#123;</span><br><span class="line">                <span class="keyword">if</span>(set.add(x)==<span class="keyword">false</span>)&#123; <span class="comment">//add添加失败会返回false</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 哈希表 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>206.反转链表</title>
      <link href="/post/47679.html"/>
      <url>/post/47679.html</url>
      
        <content type="html"><![CDATA[<h1 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h1><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>在指针转向的过程中，需要注意到几个问题</p><ol><li><p>如果表示要反转的2个结点?</p></li><li><p>假设结点从2指向了1，那么怎么找到3？</p></li></ol><p>答案是双指针和用临时变量储存3这个结点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;   <span class="comment">//前一个节点</span></span><br><span class="line">        ListNode curr = head;   <span class="comment">//当前指针</span></span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">           ListNode next = curr.next; <span class="comment">//临时变量储存当前结点的下一个结点，防止找不到</span></span><br><span class="line">           curr.next = prev;        <span class="comment">// 改变指针方向</span></span><br><span class="line">           prev = curr;            <span class="comment">// 前一个指针往后移动</span></span><br><span class="line">           curr = next;           <span class="comment">//当前指针向后移动</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;            <span class="comment">//最后是prev！=null</span></span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>205.同构字符串</title>
      <link href="/post/7985.html"/>
      <url>/post/7985.html</url>
      
        <content type="html"><![CDATA[<h1 id="205-同构字符串"><a href="#205-同构字符串" class="headerlink" title="205.同构字符串"></a>205.同构字符串</h1><p>给定两个字符串 <strong><em>s</em></strong> 和 <strong>t</strong>，判断它们是否是同构的。</p><p>如果 <strong><em>s</em></strong> 中的字符可以按某种映射关系替换得到 <strong>t</strong> ，那么这两个字符串是同构的。</p><p>每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。</p><p><strong>示例 1:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;egg&quot;</span>, t = <span class="string">&quot;add&quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;foo&quot;</span>, t = <span class="string">&quot;bar&quot;</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong>：</p><p>可以建立Map结构来建立映射，建立两个哈希表,分别检测映射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIsomorphic</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">     Map&lt;Character, Character&gt; s2t = <span class="keyword">new</span> HashMap&lt;Character, Character&gt;();</span><br><span class="line">     Map&lt;Character, Character&gt; t2s = <span class="keyword">new</span> HashMap&lt;Character, Character&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> x = s.charAt(i), y = t.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>  ((s2t.containsKey(x) &amp;&amp; s2t.get(x) != y) ||                               (t2s.containsKey(y) &amp;&amp; t2s.get(y) != x)) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s2t.put(x, y);    </span><br><span class="line">            t2s.put(y, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更好的办法有，用String类的indexOf函数，会返回该字符第一次出现的位置，如果不一样就说明对应不上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIsomorphic</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">              <span class="keyword">if</span>(s.indexOf(s.charAt(i)) != t.indexOf(t.charAt(i)))&#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;  </span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 哈希表 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>203.移除链表元素</title>
      <link href="/post/10614.html"/>
      <url>/post/10614.html</url>
      
        <content type="html"><![CDATA[<h1 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h1><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,6,3,4,5,6], val = 6</span><br><span class="line">输出：[1,2,3,4,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [], val = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>], val = <span class="number">7</span></span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>参考<code>237.删除链表中的节点</code>，因为有可能要删除<code>head</code>，所以设置一个指针来指向<code>head</code>，其余的都是删除的常见操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        ListNode temp = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next.val == val) &#123;</span><br><span class="line">                temp.next = temp.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>202.快乐数</title>
      <link href="/post/37661.html"/>
      <url>/post/37661.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202.快乐数"></a>202.快乐数</h1><p>编写一个算法来判断一个数 <code>n</code> 是不是快乐数。</p><p>「快乐数」定义为：</p><ul><li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li><li>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。</li><li>如果 <strong>可以变为</strong> 1，那么这个数就是快乐数。</li></ul><p>如果 <code>n</code> 是快乐数就返回 <code>true</code> ；不是，则返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">19</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：</span><br><span class="line"><span class="number">1</span>*<span class="number">1</span> + <span class="number">9</span>*<span class="number">9</span> = <span class="number">82</span></span><br><span class="line"><span class="number">8</span>*<span class="number">8</span> + <span class="number">2</span>*<span class="number">2</span> = <span class="number">68</span></span><br><span class="line"><span class="number">6</span>*<span class="number">6</span> + <span class="number">8</span>*<span class="number">8</span> = <span class="number">100</span></span><br><span class="line"><span class="number">1</span>*<span class="number">1</span> + <span class="number">0</span>*<span class="number">0</span> + <span class="number">0</span>*<span class="number">0</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p><img src="C:/Users/%E7%83%9B/AppData/Roaming/Typora/typora-user-images/1.jpg" alt="img"></p><p>最后都会进循环，可以通过快慢指针法来判断最后是否循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = n % <span class="number">10</span>;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">            totalSum += d * d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slowRunner = n;</span><br><span class="line">        <span class="keyword">int</span> fastRunner = getNext(n);</span><br><span class="line">        <span class="keyword">while</span> (fastRunner != <span class="number">1</span> &amp;&amp; slowRunner != fastRunner) &#123;</span><br><span class="line">            slowRunner = getNext(slowRunner);</span><br><span class="line">            fastRunner = getNext(getNext(fastRunner));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fastRunner == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
          <category> 哈希表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>191.位1的个数</title>
      <link href="/post/24815.html"/>
      <url>/post/24815.html</url>
      
        <content type="html"><![CDATA[<h1 id="191-位1的个数"><a href="#191-位1的个数" class="headerlink" title="191.位1的个数"></a>191.位1的个数</h1><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为<a href="https://baike.baidu.com/item/汉明重量">汉明重量</a>）。</p><p><strong>提示：</strong></p><ul><li>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li><li>在 Java 中，编译器使用<a href="https://baike.baidu.com/item/二进制补码/5295284">二进制补码</a>记法来表示有符号整数。因此，在上面的 <strong>示例 3</strong> 中，输入表示有符号整数 <code>-3</code>。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="number">00000000000000000000000000001011</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：输入的二进制串 <span class="number">00000000000000000000000000001011</span> 中，共有三位为 <span class="string">&#x27;1&#x27;</span>。</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>利用<code>x&amp;(x-1)</code>会让x中最低位的1变为0的技巧，不断反转x，直到x变为0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            n &amp;= n - <span class="number">1</span>;</span><br><span class="line">            ret++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 位运算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>190.颠倒二进制位</title>
      <link href="/post/17633.html"/>
      <url>/post/17633.html</url>
      
        <content type="html"><![CDATA[<h1 id="190-颠倒二进制位"><a href="#190-颠倒二进制位" class="headerlink" title="190.颠倒二进制位"></a>190.颠倒二进制位</h1><p>颠倒给定的 32 位无符号整数的二进制位。</p><p><strong>提示：</strong></p><ul><li>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li><li>在 Java 中，编译器使用<a href="https://baike.baidu.com/item/二进制补码/5295284">二进制补码</a>记法来表示有符号整数。因此，在 <strong>示例 2</strong> 中，输入表示有符号整数 <code>-3</code>，输出表示有符号整数 <code>-1073741825</code>。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">00000010100101000001111010011100</span></span><br><span class="line">输出：<span class="number">964176192</span> (<span class="number">00111001011110000010100101000000</span>)</span><br><span class="line">解释：输入的二进制串 <span class="number">00000010100101000001111010011100</span> 表示无符号整数 <span class="number">43261596</span>，</span><br><span class="line">     因此返回 <span class="number">964176192</span>，其二进制表示形式为 <span class="number">00111001011110000010100101000000</span>。</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>逐位颠倒</p><p><code>n&amp;1</code>是让n保留最后一位，<code>&lt;&lt;(31-i)</code>是让被改变位移动带rev的位置，|让rev和和n移动后的位相同</p><p>最后的<code>n&gt;&gt;&gt;=1</code>是让n右移，因为JAVA特性使用无符号右移</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span> &amp;&amp; n != <span class="number">0</span>; ++i) &#123;</span><br><span class="line">            rev |= (n &amp; <span class="number">1</span>) &lt;&lt; (<span class="number">31</span> - i);</span><br><span class="line">            n &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 位运算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>171.Excel表列序号</title>
      <link href="/post/38963.html"/>
      <url>/post/38963.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="171-Excel表列序号"><a href="#171-Excel表列序号" class="headerlink" title="171.Excel表列序号"></a>171.Excel表列序号</h1><p>给你一个字符串 <code>columnTitle</code> ，表示 Excel 表格中的列名称。返回该列名称对应的列序号。</p><p>例如，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; <span class="number">1</span></span><br><span class="line">B -&gt; <span class="number">2</span></span><br><span class="line">C -&gt; <span class="number">3</span></span><br><span class="line">...</span><br><span class="line">Z -&gt; <span class="number">26</span></span><br><span class="line">AA -&gt; <span class="number">27</span></span><br><span class="line">AB -&gt; <span class="number">28</span> </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>示例 1:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: columnTitle = <span class="string">&quot;A&quot;</span></span><br><span class="line">输出: <span class="number">1</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>先将字符串转换为数组，然后计算sum，从最高位开始，按照其他进制转10进制的方法，值=26的n次方×本身字符的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">titleToNumber</span><span class="params">(String columnTitle)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">char</span> []a=columnTitle.toCharArray();</span><br><span class="line">         <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">                 sum+=(a[i]-<span class="string">&#x27;A&#x27;</span>+<span class="number">1</span>)*Math.pow(<span class="number">26</span>,a.length-<span class="number">1</span>-i);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>169.多数元素</title>
      <link href="/post/1059.html"/>
      <url>/post/1059.html</url>
      
        <content type="html"><![CDATA[<h1 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169.多数元素"></a>169.多数元素</h1><p>给定一个大小为 <em>n</em> 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure><hr><p>在数组中占比已经超过一半的数字</p><p><strong>Solution</strong>：排序查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">         Arrays.sort(nums);</span><br><span class="line">         <span class="keyword">return</span> nums[nums.length/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为元素在数组中的出现次数大于了n/2，所以下标为n/2的元素一定是多数元素</p><p><strong>Solution1</strong>：Boyer-Moore 投票算法</p><p>Boyer-Moore 算法,我们首先给出 Boyer-Moore 算法的详细步骤：</p><ul><li>我们维护一个候选众数 <code>candidate</code> 和它出现的次数 <code>count</code>。初始时 <code>candidate</code> 可以为任意值，<code>count</code> 为 <code>0</code>；</li><li>我们遍历数组 <code>nums</code> 中的所有元素，对于每个元素 <code>x</code>，在判断 <code>x</code> 之前，如果 <code>count</code> 的值为 <code>0</code>，我们先将 <code>x</code> 的值赋予 <code>candidate</code>，随后我们判断 <code>x</code>：<ul><li>如果 <code>x</code> 与 <code>candidate</code> 相等，那么计数器 <code>count</code> 的值增加 <code>1</code>；</li><li>如果 <code>x</code> 与 <code>candidate</code> 不等，那么计数器 <code>count</code> 的值减少 <code>1</code>。</li></ul></li><li>在遍历完成后，<code>candidate</code> 即为整个数组的众数。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        Integer candidate = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                candidate = num;</span><br><span class="line">            &#125;</span><br><span class="line">            count += (num == candidate) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>投票算法证明：</p><ol><li>如果候选人不是<code>major</code>则<code>major</code>会和其他非候选人一起反对候选人,所以候选人一定会下台(<code>coumt==0</code>时发生换届选举)</li><li>如果候选人是<code>major</code> , 则<code>major</code> 会支持自己，其他候选人会反对，同样因为<code>major</code> 票数超过一半，所以<code>major</code> 一定会成功当选</li></ol>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 哈希表 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>168.Excel表列名称</title>
      <link href="/post/43063.html"/>
      <url>/post/43063.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="168-Excel列名称"><a href="#168-Excel列名称" class="headerlink" title="168.Excel列名称"></a>168.Excel列名称</h1><p>给你一个整数 <code>columnNumber</code> ，返回它在 Excel 表中相对应的列名称。</p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; <span class="number">1</span></span><br><span class="line">B -&gt; <span class="number">2</span></span><br><span class="line">C -&gt; <span class="number">3</span></span><br><span class="line">...</span><br><span class="line">Z -&gt; <span class="number">26</span></span><br><span class="line">AA -&gt; <span class="number">27</span></span><br><span class="line">AB -&gt; <span class="number">28</span> </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：columnNumber = <span class="number">1</span></span><br><span class="line">输出：<span class="string">&quot;A&quot;</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>因为A代表的是1，所以将数字-1，然后%26，再加上ASCII码，经过char转换后最后就得到了字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> columnNumber)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span> (columnNumber != <span class="number">0</span>) &#123;</span><br><span class="line">            columnNumber--;</span><br><span class="line">            sb.append((<span class="keyword">char</span>)(columnNumber % <span class="number">26</span> + <span class="string">&#x27;A&#x27;</span>));</span><br><span class="line">            columnNumber /= <span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>167.两数之和2</title>
      <link href="/post/90.html"/>
      <url>/post/90.html</url>
      
        <content type="html"><![CDATA[<h1 id="167-两数之和2"><a href="#167-两数之和2" class="headerlink" title="167.两数之和2"></a>167.两数之和2</h1><p>给定一个已按照 <strong>非递减顺序排列</strong> 的整数数组 <code>numbers</code> ，请你从数组中找出两个数满足相加之和等于目标数 <code>target</code> 。</p><p>函数应该以长度为 <code>2</code> 的整数数组的形式返回这两个数的下标值<em>。</em><code>numbers</code> 的下标 <strong>从 1 开始计数</strong> ，所以答案数组应当满足 <code>1 &lt;= answer[0] &lt; answer[1] &lt;= numbers.length</code> 。</p><p>你可以假设每个输入 <strong>只对应唯一的答案</strong> ，而且你 <strong>不可以</strong> 重复使用相同的元素。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：numbers = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">解释：<span class="number">2</span> 与 <span class="number">7</span> 之和等于目标数 <span class="number">9</span> 。因此 index1 = <span class="number">1</span>, index2 = <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><hr><p>已经是<strong>非递减</strong>顺序的数组，求其中两个元素的和</p><p><strong>Solution</strong>：双指针</p><p>既然是非递减数组，那么考虑双指针法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> []a=&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=numbers.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&gt;left)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[right]+numbers[left]&gt;target)&#123;</span><br><span class="line">                right--;<span class="comment">// 和大于target就让右指针左移</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(numbers[right]+numbers[left]&lt;target)&#123;</span><br><span class="line">                left++; <span class="comment">// 和小于target就让左指针右移</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                a[<span class="number">0</span>]=left+<span class="number">1</span>;</span><br><span class="line">                a[<span class="number">1</span>]=right+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>160.相交链表</title>
      <link href="/post/45512.html"/>
      <url>/post/45512.html</url>
      
        <content type="html"><![CDATA[<h1 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160.相交链表"></a>160.相交链表</h1><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p><p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p><p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p><p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p><hr><p><strong>Solution</strong>：双指针</p><p>两个指针分别从两个链表起始处出发，同时增加，如果到了尽头，就从另一个链表起始处开始，如果两个链表相交，则指针必会在相交处相等，如果不相交，则必会同时到尽头</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pA = headA, pB = headB;</span><br><span class="line">        <span class="keyword">while</span> (pA != pB) &#123;</span><br><span class="line">            pA = pA == <span class="keyword">null</span> ? headB : pA.next;</span><br><span class="line">            pB = pB == <span class="keyword">null</span> ? headA : pB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 哈希表 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>155.最小栈</title>
      <link href="/post/20751.html"/>
      <url>/post/20751.html</url>
      
        <content type="html"><![CDATA[<h1 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155.最小栈"></a>155.最小栈</h1><p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p><ul><li><code>push(x)</code> —— 将元素 x 推入栈中。</li><li><code>pop()</code> —— 删除栈顶的元素。</li><li><code>top()</code> —— 获取栈顶元素。</li><li><code>getMin()</code> —— 检索栈中的最小元素。</li></ul><p><strong>示例:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">&quot;MinStack&quot;</span>,<span class="string">&quot;push&quot;</span>,<span class="string">&quot;push&quot;</span>,<span class="string">&quot;push&quot;</span>,<span class="string">&quot;getMin&quot;</span>,<span class="string">&quot;pop&quot;</span>,<span class="string">&quot;top&quot;</span>,<span class="string">&quot;getMin&quot;</span>]</span><br><span class="line">[[],[<span class="number">-2</span>],[<span class="number">0</span>],[<span class="number">-3</span>],[],[],[],[]]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[null,null,null,null,<span class="number">-3</span>,null,<span class="number">0</span>,<span class="number">-2</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MinStack minStack = <span class="keyword">new</span> MinStack();</span><br><span class="line">minStack.push(<span class="number">-2</span>);</span><br><span class="line">minStack.push(<span class="number">0</span>);</span><br><span class="line">minStack.push(<span class="number">-3</span>);</span><br><span class="line">minStack.getMin();   --&gt; 返回 <span class="number">-3.</span></span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 <span class="number">0.</span></span><br><span class="line">minStack.getMin();   --&gt; 返回 <span class="number">-2.</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution：辅助栈</strong></p><p>我们只需要设计一个数据结构，使得每个元素 <code>a</code> 与其相应的最小值 <code>m</code> 时刻保持一一对应。因此我们可以使用一个辅助栈，与元素栈同步插入与删除，用于存储与每个元素对应的最小值。</p><ul><li>当一个元素要入栈时，我们取当前辅助栈的栈顶存储的最小值，与当前元素比较得出最小值，将这个最小值插入辅助栈中；</li><li>当一个元素要出栈时，我们把辅助栈的栈顶元素也一并弹出；</li><li>在任意一个时刻，栈内元素的最小值就存储在辅助栈的栈顶元素中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    Deque&lt;Integer&gt; xStack;</span><br><span class="line">    Deque&lt;Integer&gt; minStack;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        xStack = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        minStack.push(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        xStack.push(x);</span><br><span class="line">        minStack.push(Math.min(minStack.peek(), x));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        xStack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> xStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>145.二叉树的后序遍历</title>
      <link href="/post/62169.html"/>
      <url>/post/62169.html</url>
      
        <content type="html"><![CDATA[<h1 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145.二叉树的后序遍历"></a>145.二叉树的后序遍历</h1><p>给定一个二叉树，返回它的 <em>后序</em> 遍历。</p><p><strong>示例:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,null,<span class="number">2</span>,<span class="number">3</span>]  </span><br><span class="line">   <span class="number">1</span></span><br><span class="line">    \</span><br><span class="line">     <span class="number">2</span></span><br><span class="line">    /</span><br><span class="line">   <span class="number">3</span> </span><br><span class="line"></span><br><span class="line">输出: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        postorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        postorder(root.left, res);</span><br><span class="line">        postorder(root.right, res);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List &lt;Integer&gt; list =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Stack &lt;TreeNode&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Map &lt;TreeNode,Integer&gt; flag =<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(root!=<span class="keyword">null</span>||stack.isEmpty()==<span class="keyword">false</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">               stack.push(root);</span><br><span class="line">               flag.put(root,<span class="number">1</span>);</span><br><span class="line">               root=root.left;</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">             root=stack.peek();</span><br><span class="line">               <span class="keyword">if</span>(flag.get(root)==<span class="number">1</span>)&#123;</span><br><span class="line">                   flag.put(root,<span class="number">2</span>);</span><br><span class="line">                   root=root.right;</span><br><span class="line">                   </span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   root=stack.pop();</span><br><span class="line">                   list.add(root.val);</span><br><span class="line">                   root=<span class="keyword">null</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>144.二叉树的前序遍历</title>
      <link href="/post/24235.html"/>
      <url>/post/24235.html</url>
      
        <content type="html"><![CDATA[<h1 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144.二叉树的前序遍历"></a>144.二叉树的前序遍历</h1><p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p><p><strong>示例 1：</strong></p><p><img src="C:/Users/%E7%83%9B/AppData/Roaming/Typora/typora-user-images/inorder_1-16395569119431.jpg" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>,null,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        preorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        preorder(root.left, res);</span><br><span class="line">        preorder(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() || node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">                res.add(node.val);</span><br><span class="line">                stack.push(node);</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = stack.pop();</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>141.环形链表</title>
      <link href="/post/17557.html"/>
      <url>/post/17557.html</url>
      
        <content type="html"><![CDATA[<h1 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141.环形链表"></a>141.环形链表</h1><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">-4</span>], pos = <span class="number">1</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong>：<strong>快慢指针</strong></p><p>本方法需要读者对「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解。</p><p>假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</p><p>我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 <code>head</code>，而快指针在位置 <code>head.next</code>。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head.next;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 哈希表 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>136.只出现一次的数字</title>
      <link href="/post/18653.html"/>
      <url>/post/18653.html</url>
      
        <content type="html"><![CDATA[<h1 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136.只出现一次的数字"></a>136.只出现一次的数字</h1><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现<strong>两次</strong>。找出那个只出现了一次的元素。</p><p><strong>说明：</strong></p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p><strong>示例 1:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">1</span></span><br></pre></td></tr></table></figure><hr><p>数组中的元素<strong>出现次数</strong>，有特殊出现次数的数字</p><p><strong>Solution</strong>：位运算</p><p>考虑异或运算，相同为0，相异为1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> single = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            single ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> single;<span class="comment">//除了single以外的其他数，出现了两次，所以异或为0，而single和0异或，结果为</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Solution</strong>1:Hash表</p><p>位运算只能说是取巧解法，假设其他数字出现两次以上，那么异或运算就不成立了，所以关于数组里面的元素出现次数的通用解法应该是HashMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Class Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">            map.put(num, count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Integer i:map.keySet())&#123;</span><br><span class="line">           Integer ans=map.get(i);</span><br><span class="line">           <span class="keyword">if</span>(ans==<span class="number">1</span>)&#123;</span><br><span class="line">               <span class="keyword">return</span> i;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数组 </category>
          
          <category> 位运算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>125.验证回文串</title>
      <link href="/post/12585.html"/>
      <url>/post/12585.html</url>
      
        <content type="html"><![CDATA[<h1 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125.验证回文串"></a>125.验证回文串</h1><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p><p><strong>说明：</strong>本题中，我们将空字符串定义为有效的回文串。</p><p><strong>示例 1:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">&quot;A man, a plan, a canal: Panama&quot;</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释：<span class="string">&quot;amanaplanacanalpanama&quot;</span> 是回文串</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>最简单的方法是对字符串s进行一次遍历，并将其中的字母和数字字符进行保留，放在另一个字符串 <em>sgood</em> 中。这样我们只需要判断 <em>sgood</em> 是否是一个普通的回文串即可。</p><p>判断的方法有两种。第一种是使用语言中的字符串翻转 API 得到 <em>sgood</em> 的逆序字符串 <em>sgood_rev</em>，只要这两个字符串相同，那么 <em>sgood</em> 就是回文串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuffer sgood = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (Character.isLetterOrDigit(ch)) &#123;</span><br><span class="line">                sgood.append(Character.toLowerCase(ch));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuffer sgood_rev = <span class="keyword">new</span> StringBuffer(sgood).reverse();</span><br><span class="line">        <span class="keyword">return</span> sgood.toString().equals(sgood_rev.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>121.买卖股票的最佳时机</title>
      <link href="/post/35904.html"/>
      <url>/post/35904.html</url>
      
        <content type="html"><![CDATA[<h1 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121.买卖股票的最佳时机"></a>121.买卖股票的最佳时机</h1><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：在第 <span class="number">2</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">5</span> 天（股票价格 = <span class="number">6</span>）的时候卖出，最大利润 = <span class="number">6</span><span class="number">-1</span> = <span class="number">5</span> 。</span><br><span class="line">     注意利润不能是 <span class="number">7</span><span class="number">-1</span> = <span class="number">6</span>, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure><hr><p>是否卖出股票，这要根据<strong>之前</strong>的最大利润来决定</p><p><strong>Solution</strong>：动态规划</p><p>可以采取动态规划的思想，首先从后往前遍历，记录股票最高的时候，用股票最高的时候去减当前的价格，记录利润最高的时候</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=prices.length;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max=prices[len-<span class="number">1</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=len-<span class="number">2</span>;i&gt;-<span class="number">1</span>;i--)&#123;        <span class="comment">//从倒数第二天开始遍历</span></span><br><span class="line">        max=Math.max(max,prices[i]);     <span class="comment">//股票最高的时候</span></span><br><span class="line">        ans=Math.max(max-prices[i],ans); <span class="comment">// 利润最多的时候</span></span><br><span class="line">           &#125;</span><br><span class="line">         <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>119.杨辉三角2</title>
      <link href="/post/65032.html"/>
      <url>/post/65032.html</url>
      
        <content type="html"><![CDATA[<h1 id="119-杨辉三角2"><a href="#119-杨辉三角2" class="headerlink" title="119.杨辉三角2"></a>119.杨辉三角2</h1><p>给定一个非负索引 <code>rowIndex</code>，返回「杨辉三角」的第 <code>rowIndex</code> 行。</p><p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p><p><img src="https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif" alt="img"></p><p><strong>示例 1:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: rowIndex = <span class="number">3</span></span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>Solution</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= rowIndex; ++i) &#123;</span><br><span class="line">            List&lt;Integer&gt; row = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span> || j == i) &#123;</span><br><span class="line">                    row.add(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    row.add(ret.get(i - <span class="number">1</span>).get(j - <span class="number">1</span>) + ret.get(i - <span class="number">1</span>).get(j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ret.add(row);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret.get(rowIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数组 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>118.杨辉三角</title>
      <link href="/post/34917.html"/>
      <url>/post/34917.html</url>
      
        <content type="html"><![CDATA[<h1 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118.杨辉三角"></a>118.杨辉三角</h1><p>给定一个非负整数 <em><code>numRows</code>，</em>生成「杨辉三角」的前 <em><code>numRows</code></em> 行。</p><p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p><p><img src="https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif" alt="img"></p><p><strong>示例 1:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: numRows = <span class="number">5</span></span><br><span class="line">输出: [[<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure><p><strong>Solution</strong>：</p><p>每个数字等于上一行的左右两个数字之和，可用此性质写出整个杨辉三角。即第 n 行的第 i 个数等于第 n-1 行的第 i-1个数和第 i 个数之和。这也是组合数的性质之一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRows; ++i) &#123;</span><br><span class="line">            List&lt;Integer&gt; row = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span> || j == i) &#123;</span><br><span class="line">                    row.add(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    row.add(ret.get(i - <span class="number">1</span>).get(j - <span class="number">1</span>) + ret.get(i - <span class="number">1</span>).get(j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ret.add(row);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数组 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>112.路径总和</title>
      <link href="/post/50065.html"/>
      <url>/post/50065.html</url>
      
        <content type="html"><![CDATA[<h1 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112.路径总和"></a>112.路径总和</h1><p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><p><img src="C:/Users/%E7%83%9B/AppData/Roaming/Typora/typora-user-images/pathsum1.jpg" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">11</span>,null,<span class="number">13</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,null,null,null,<span class="number">1</span>], targetSum = <span class="number">22</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：等于目标和的根节点到叶节点路径如上图所示。</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>从上到下，如果不是叶子结点，就减去当前结点的val值，如果是的话就判断值和val是否相等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sum == root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, sum - root.val) ||                                    hasPathSum(root.right, sum - root.val);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>111.二叉树的最小深度</title>
      <link href="/post/43317.html"/>
      <url>/post/43317.html</url>
      
        <content type="html"><![CDATA[<h1 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111.二叉树的最小深度"></a>111.二叉树的最小深度</h1><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p><strong>说明：</strong>叶子节点是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,null,null,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> min_depth = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            min_depth = Math.min(minDepth(root.left), min_depth);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            min_depth = Math.min(minDepth(root.right), min_depth);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min_depth + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>110.平衡二叉树</title>
      <link href="/post/51901.html"/>
      <url>/post/51901.html</url>
      
        <content type="html"><![CDATA[<h1 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110.平衡二叉树"></a>110.平衡二叉树</h1><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><blockquote><p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 。</p></blockquote><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,null,null,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>如何判断一棵二叉树是否平衡呢？需要比较其子树的深度差，采取从底向上的遍历方法，如果其子树不是平衡二叉树，那么会返回-1，如果是，那么就返回他的最大深度，只要结点的左子树，右子树，或者左右高度差大于1满足一个条件，就会返回-1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> height(root) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftHeight = height(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightHeight = height(root.right);</span><br><span class="line">        <span class="keyword">if</span> (leftHeight == -<span class="number">1</span> || rightHeight == -<span class="number">1</span> || Math.abs(leftHeight - rightHeight) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>108.将有序数组转换为二叉搜索树</title>
      <link href="/post/17850.html"/>
      <url>/post/17850.html</url>
      
        <content type="html"><![CDATA[<h1 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108.将有序数组转换为二叉搜索树"></a>108.将有序数组转换为二叉搜索树</h1><p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 <strong>高度平衡</strong> 二叉搜索树。</p><p><strong>高度平衡</strong> 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-10</span>,<span class="number">-3</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">9</span>]</span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">-3</span>,<span class="number">9</span>,<span class="number">-10</span>,null,<span class="number">5</span>]</span><br><span class="line">解释：[<span class="number">0</span>,<span class="number">-10</span>,<span class="number">5</span>,null,<span class="number">-3</span>,null,<span class="number">9</span>] 也将被视为正确答案：</span><br></pre></td></tr></table></figure><hr><p>有序数组转换为二叉树，需要<strong>创建二叉树</strong>，并且是<strong>有序的</strong></p><p><strong>Solution</strong>：中序遍历</p><p>相当于是根据中序遍历来还原平衡二叉搜索树,有点类似于二分查找和创建二叉树的结合，也就是利用二分查找来查找树以及其子树的根节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct TreeNode* <span class="title">helper</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 总是选择中间位置左边的数字作为根节点</span></span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">root</span> =</span> (struct TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TreeNode));</span><br><span class="line">    root-&gt;val = nums[mid];</span><br><span class="line">    root-&gt;left = helper(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">    root-&gt;right = helper(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> helper(nums, <span class="number">0</span>, numsSize - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JAVA</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 总是选择中间位置左边的数字作为根节点</span></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        root.left = helper(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">        root.right = helper(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>104.二叉树的最大深度</title>
      <link href="/post/5758.html"/>
      <url>/post/5758.html</url>
      
        <content type="html"><![CDATA[<h1 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104.二叉树的最大深度"></a>104.二叉树的最大深度</h1><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p><strong>示例：</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><p>返回它的最大深度 3 。</p><hr><p><strong>Solution</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> depthval;</span><br><span class="line">    <span class="keyword">if</span> ( root==<span class="keyword">null</span>) depthval = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> depthLeft = maxDepth( root.left );</span><br><span class="line">    <span class="keyword">int</span> depthRight= maxDepth( root.right);</span><br><span class="line">    depthval = <span class="number">1</span> + (depthLeft &gt; depthRight ?depthLeft : depthRight);</span><br><span class="line">         &#125; </span><br><span class="line">    <span class="keyword">return</span> depthval;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>101.对称二叉树</title>
      <link href="/post/46824.html"/>
      <url>/post/46824.html</url>
      
        <content type="html"><![CDATA[<h1 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101.对称二叉树"></a>101.对称二叉树</h1><p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">2</span></span><br><span class="line"> / \ / \</span><br><span class="line"><span class="number">3</span>  <span class="number">4</span> <span class="number">4</span>  <span class="number">3</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>可以通过递归调用的方式来解决问题，<code>check</code>函数应该在除去特殊情况后，返回对比后的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> check(root, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p.val == q.val &amp;&amp; check(p.left, q.right) &amp;&amp; check(p.right, q.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>100.相同的树</title>
      <link href="/post/61464.html"/>
      <url>/post/61464.html</url>
      
        <content type="html"><![CDATA[<h1 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100.相同的树"></a>100.相同的树</h1><p>给你两棵二叉树的根节点 <code>p</code> 和 <code>q</code> ，编写一个函数来检验这两棵树是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：p = [1,2,3], q = [1,2,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>如果两棵树都不为空，就遍历它们的左子树和右子树，可以使用递归的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="keyword">null</span> || q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.val != q.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>94.二叉树的中序遍历</title>
      <link href="/post/5409.html"/>
      <url>/post/5409.html</url>
      
        <content type="html"><![CDATA[<h1 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94.二叉树的中序遍历"></a>94.二叉树的中序遍历</h1><p>给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>中序</strong> 遍历。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,null,2,3]</span><br><span class="line">输出：[1,3,2]</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong>：递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList &lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    inorderTraversal(root.left);</span><br><span class="line">    list.add(root.val);</span><br><span class="line">    inorderTraversal(root.right);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Solution1</strong>: 栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stk = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span> || !stk.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stk.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.pop();</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>88.合并两个有序数组</title>
      <link href="/post/18592.html"/>
      <url>/post/18592.html</url>
      
        <content type="html"><![CDATA[<h1 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88.合并两个有序数组"></a>88.合并两个有序数组</h1><p>给你两个按 <strong>非递减顺序</strong> 排列的整数数组 <code>nums1</code> 和 <code>nums2</code>，另有两个整数 <code>m</code> 和 <code>n</code> ，分别表示 <code>nums1</code> 和 <code>nums2</code> 中的元素数目。</p><p>请你 <strong>合并</strong> <code>nums2</code> 到 <code>nums1</code> 中，使合并后的数组同样按 <strong>非递减顺序</strong> 排列。</p><p><strong>注意：</strong>最终，合并后数组不应由函数返回，而是存储在数组 <code>nums1</code> 中。为了应对这种情况，<code>nums1</code> 的初始长度为 <code>m + n</code>，其中前 <code>m</code> 个元素表示应合并的元素，后 <code>n</code> 个元素为 <code>0</code> ，应忽略。<code>nums2</code> 的长度为 <code>n</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], m = <span class="number">3</span>, nums2 = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>], n = <span class="number">3</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">解释：需要合并 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] 和 [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>] 。</span><br><span class="line">合并结果是 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>] ，其中斜体加粗标注的为 nums1 中的元素。</span><br></pre></td></tr></table></figure><hr><p>合并数组，并且让他们按<strong>非递减</strong>顺序，需要<strong>比较</strong>和遍历数组中的元素</p><p><strong>Solution1：先合并再排序</strong></p><p>先将两个数组合并，再采用排序方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设是快排</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != n; ++i) &#123;</span><br><span class="line">            nums1[m + i] = nums2[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Solution2</strong>：双指针比较，创造一个新的数组</p><p>方法一没有利用数组 <em>nums</em>1 与 <em>nums</em>2 已经被排序的性质。为了利用这一性质，我们可以使用双指针方法。这一方法将两个数组看作队列，每次从两个数组头部取出比较小的数字放到结果中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] sorted = <span class="keyword">new</span> <span class="keyword">int</span>[m + n];</span><br><span class="line">        <span class="keyword">int</span> cur;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt; m || p2 &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1 == m) &#123;         <span class="comment">// 如果p1到头了，那么剩下的元素都是p2</span></span><br><span class="line">                cur = nums2[p2++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p2 == n) &#123;</span><br><span class="line">                cur = nums1[p1++];    <span class="comment">//// 如果p2到头了，那么剩下的元素都是p1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[p1] &lt; nums2[p2]) &#123;</span><br><span class="line">                cur = nums1[p1++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = nums2[p2++];</span><br><span class="line">            &#125;</span><br><span class="line">            sorted[p1 + p2 - <span class="number">1</span>] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != m + n; ++i) &#123;</span><br><span class="line">            nums1[i] = sorted[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>Solution3</strong>：逆向双指针</p><p>方法2之所以需要辅助数组，是怕把<code>num1</code>数组直接覆盖掉，如果我们从后往前插入<code>nums1</code>数组中去，就不需要构造辅助数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = m - <span class="number">1</span>, p2 = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tail = m + n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cur;</span><br><span class="line">        <span class="keyword">while</span> (p1 &gt;= <span class="number">0</span> || p2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1 == -<span class="number">1</span>) &#123;</span><br><span class="line">                cur = nums2[p2--];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p2 == -<span class="number">1</span>) &#123;</span><br><span class="line">                cur = nums1[p1--];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[p1] &gt; nums2[p2]) &#123;</span><br><span class="line">                cur = nums1[p1--];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = nums2[p2--];</span><br><span class="line">            &#125;</span><br><span class="line">            nums1[tail--] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>83.删除链表中的重复元素</title>
      <link href="/post/30438.html"/>
      <url>/post/30438.html</url>
      
        <content type="html"><![CDATA[<h1 id="83-删除链表中的重复元素"><a href="#83-删除链表中的重复元素" class="headerlink" title="83.删除链表中的重复元素"></a>83.删除链表中的重复元素</h1><p>存在一个按升序排列的链表，给你这个链表的头节点 <code>head</code> ，请你删除所有重复的元素，使每个元素 <strong>只出现一次</strong> 。</p><p>返回同样按升序排列的结果链表。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/list1.jpg" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong>：</p><p>如果发现了当前结点和下个结点的值相同，就将当前结点指向下下个结点，遍历链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.val == cur.next.val) &#123;</span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>70.爬楼梯</title>
      <link href="/post/18439.html"/>
      <url>/post/18439.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a>70.爬楼梯</h1><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： <span class="number">2</span></span><br><span class="line">输出： <span class="number">2</span></span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line"><span class="number">1.</span>  <span class="number">1</span> 阶 + <span class="number">1</span> 阶</span><br><span class="line"><span class="number">2.</span>  <span class="number">2</span> 阶</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>很经典的动态规划题目，每爬一阶楼梯的方法取决于前一节和前两节的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            p = q; </span><br><span class="line">            q = r; </span><br><span class="line">            r = p + q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>69.Sqrt(x)</title>
      <link href="/post/60532.html"/>
      <url>/post/60532.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="69-Sqrt-x"><a href="#69-Sqrt-x" class="headerlink" title="69.Sqrt(x)"></a>69.Sqrt(x)</h1><p>给你一个非负整数 <code>x</code> ，计算并返回 <code>x</code> 的 <strong>算术平方根</strong> 。</p><p>由于返回类型是整数，结果只保留 <strong>整数部分</strong> ，小数部分将被 <strong>舍去 。</strong></p><p><strong>注意：</strong>不允许使用任何内置指数函数和算符，例如 <code>pow(x, 0.5)</code> 或者 <code>x ** 0.5</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = <span class="number">4</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>和<code>367 有效的完全平方数</code>一样，都是二分查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = x, ans = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">long</span>) mid * mid &lt;= x) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>67.二进制求和</title>
      <link href="/post/38912.html"/>
      <url>/post/38912.html</url>
      
        <content type="html"><![CDATA[<h1 id="67-二进制求和"><a href="#67-二进制求和" class="headerlink" title="67.二进制求和"></a>67.二进制求和</h1><p>给你两个二进制字符串，返回它们的和（用二进制表示）。</p><p>输入为 <strong>非空</strong> 字符串且只包含数字 <code>1</code> 和 <code>0</code>。</p><p><strong>示例 1:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: a = <span class="string">&quot;11&quot;</span>, b = <span class="string">&quot;1&quot;</span></span><br><span class="line">输出: <span class="string">&quot;100&quot;</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>模仿手算，用一个变量来表示进位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(a == <span class="keyword">null</span> || a.length() == <span class="number">0</span>) <span class="keyword">return</span> b;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="keyword">null</span> || b.length() == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line">        StringBuilder stb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> i = a.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = b.length() - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;  <span class="comment">// 进位</span></span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">0</span>) c += a.charAt(i --) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= <span class="number">0</span>) c += b.charAt(j --) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            stb.append(c % <span class="number">2</span>);   <span class="comment">//如果是2的话就会添加0,3的话就是1</span></span><br><span class="line">            c &gt;&gt;= <span class="number">1</span>;            <span class="comment">//c/2，如果是2的话会变成</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        String res = stb.reverse().toString();</span><br><span class="line">        <span class="keyword">return</span> c &gt; <span class="number">0</span> ? <span class="string">&#x27;1&#x27;</span> + res : res;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 位运算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>66.加1</title>
      <link href="/post/41236.html"/>
      <url>/post/41236.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="66-加一"><a href="#66-加一" class="headerlink" title="66.加一"></a>66.加一</h1><p>给定一个由 <strong>整数</strong> 组成的 <strong>非空</strong> 数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储<strong>单个</strong>数字。</p><p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line">解释：输入数组表示数字 <span class="number">123</span>。</span><br></pre></td></tr></table></figure><hr><p>+1，是从低位向高位开始</p><p><strong>Solution</strong>：</p><p>思路就是，先从末位开始+1，如果没有进位就是直接return，如果有，就让上一位+1，如果最后循环结束还没返回，说明每一位都是9，那么将数组的长度+1，首位设置为1，其他位设置为0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> len = digits.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            digits[i] = (digits[i] + <span class="number">1</span>) % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (digits[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> digits;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        digits = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>];</span><br><span class="line">        digits[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> digits;                                    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>58.最后一个单词的长度</title>
      <link href="/post/28928.html"/>
      <url>/post/28928.html</url>
      
        <content type="html"><![CDATA[<h1 id="58-最后一个单词的长度"><a href="#58-最后一个单词的长度" class="headerlink" title="58.最后一个单词的长度"></a>58.最后一个单词的长度</h1><p>给你一个字符串 <code>s</code>，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中最后一个单词的长度。</p><p><strong>单词</strong> 是指仅由字母组成、不包含任何空格字符的最大子字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>先把末尾的空格消去了，再从后往前遍历即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (s.charAt(index) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> wordLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &gt;= <span class="number">0</span> &amp;&amp; s.charAt(index) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            wordLength++;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> wordLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>53.最大子序和</title>
      <link href="/post/31352.html"/>
      <url>/post/31352.html</url>
      
        <content type="html"><![CDATA[<h1 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53.最大子序和"></a>53.最大子序和</h1><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：连续子数组 [<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>] 的和最大，为 <span class="number">6</span> 。</span><br></pre></td></tr></table></figure><hr><p><strong>每加入</strong>一个元素进入子序中，都需要<strong>判断</strong>其和</p><p><strong>Solution1</strong>:动态规划</p><p>问题的关键在于 <code>nums[i]</code>到底是单独成为一段，还是加入到<code>f&#123;i-1&#125;</code>对应的那一段中去</p><p>这取决于<code>nums[i]</code>和<code>f&#123;i-1&#125;+nums[i]</code>的大小，如果前者比后者大，那么就是单独成为一段</p><p><code>f&#123;i&#125;</code>只与<code>f&#123;i-1&#125;</code>有关，所以用一个变量pre来维护当前<code>f&#123;i&#125;</code>的<code>f&#123;i-1&#125;</code>的值</p><p>精髓在于段的选取，用pre标志表示了当前的段的和，而maxAns表示了所达到的最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>, maxAns = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            pre = Math.max(pre + x, x);</span><br><span class="line">            maxAns = Math.max(maxAns, pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxAns;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数组 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>35.搜索插入位置</title>
      <link href="/post/30535.html"/>
      <url>/post/30535.html</url>
      
        <content type="html"><![CDATA[<h1 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35.搜索插入位置"></a>35.搜索插入位置</h1><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p><p><strong>示例 1:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], target = <span class="number">5</span></span><br><span class="line">输出: <span class="number">2</span></span><br></pre></td></tr></table></figure><hr><p><strong>寻找</strong>数组中的某个位置</p><p><strong>Solution</strong>:</p><p>既然题目要求了时间复杂度，那么只有用二分查找解决</p><p>如果nums数组内有target，那么二分查找可以找到并返回，如果没有target，那么最后的mid的值正好是其插入位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid =(left+right+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">       <span class="keyword">while</span>(right&gt;=left)&#123;</span><br><span class="line">          <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">              right=mid-<span class="number">1</span>;</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">              left=mid+<span class="number">1</span>;</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              <span class="keyword">return</span> mid;</span><br><span class="line">          &#125;</span><br><span class="line">          mid=(left+right+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> mid ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>28.实现strStr()</title>
      <link href="/post/19927.html"/>
      <url>/post/19927.html</url>
      
        <content type="html"><![CDATA[<h1 id="28-实现strStr"><a href="#28-实现strStr" class="headerlink" title="28.实现strStr()"></a>28.实现strStr()</h1><p>实现 <a href="https://baike.baidu.com/item/strstr/811469">strStr()</a> 函数。</p><p>给你两个字符串 <code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 <code>-1</code> 。</p><p><strong>说明：</strong></p><p>当 <code>needle</code> 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p><p>对于本题而言，当 <code>needle</code> 是空字符串时我们应当返回 0 。这与 C 语言的 <a href="https://baike.baidu.com/item/strstr/811469">strstr()</a> 以及 Java 的 <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String">indexOf()</a>) 定义相符。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：haystack = <span class="string">&quot;hello&quot;</span>, needle = <span class="string">&quot;ll&quot;</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>没什么好说的，KMP算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">char</span> []a=haystack.toCharArray();</span><br><span class="line">          <span class="keyword">char</span> []b=needle.toCharArray();</span><br><span class="line">          <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">          <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span> (needle.equals(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">int</span>  []next=<span class="keyword">new</span> <span class="keyword">int</span> [b.length+<span class="number">1</span>];</span><br><span class="line">          getNext(b,next);</span><br><span class="line">          <span class="keyword">while</span>(i&lt;a.length)&#123;</span><br><span class="line">              <span class="keyword">if</span>(j==-<span class="number">1</span>||a[i]==b[j])&#123;</span><br><span class="line">                  i++;</span><br><span class="line">                  j++;</span><br><span class="line">              &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  j=next[j];</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span>(j==b.length)&#123;</span><br><span class="line">                  <span class="keyword">return</span> i-j;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        </span><br><span class="line">          <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="keyword">char</span>[] b,<span class="keyword">int</span> []next )</span></span></span><br><span class="line"><span class="function">    </span>&#123;       <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> k=-<span class="number">1</span>;</span><br><span class="line">           </span><br><span class="line">            next[<span class="number">0</span>]=-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;b.length)&#123;</span><br><span class="line">                <span class="keyword">if</span>(k==-<span class="number">1</span>||b[j]==b[k])&#123;</span><br><span class="line">                    j++;</span><br><span class="line">                    k++;</span><br><span class="line">                    next[j]=k;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                     k=next[k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>27.移除元素</title>
      <link href="/post/50510.html"/>
      <url>/post/50510.html</url>
      
        <content type="html"><![CDATA[<h1 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27.移除元素"></a>27.移除元素</h1><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/原地算法">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并 <strong><a href="https://baike.baidu.com/item/原地算法">原地 </a>修改输入数组</strong>。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>], val = <span class="number">3</span></span><br><span class="line">输出：<span class="number">2</span>, nums = [<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">解释：函数应该返回新的长度 <span class="number">2</span>, 并且 nums 中的前两个元素均为 <span class="number">2</span>。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 <span class="number">2</span> ，而 nums = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>] 或 nums = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>]，也会被视作正确答案。</span><br></pre></td></tr></table></figure><hr><p>遍历并且<strong>移除</strong>数组中的某些元素，这肯定也需要<strong>对比</strong></p><p><strong>Solution1</strong>:双指针</p><p>由于题目要求删除数组中等于 <em>val</em> 的元素，因此输出数组的长度一定小于等于输入数组的长度，我们可以把输出的数组直接写在输入数组上。可以使用双指针：右指针 <em>right</em> 指向当前将要处理的元素，左指针 <em>left</em> 指向下一个将要赋值的位置。</p><ul><li>如果右指针指向的元素不等于 <em>val</em>，它一定是输出数组的一个元素，我们就将右指针指向的元素复制到左指针位置，然后将左右指针同时右移；</li><li>如果右指针指向的元素等于 <em>val</em>，它不能在输出数组里，此时左指针不动，右指针右移一位。</li></ul><p>整个过程保持不变的性质是：区间 [0,<em>left</em>) 中的元素都不等于 <em>val</em>。当左右指针遍历完输入数组以后，<em>left</em> 的值就是输出数组的长度。</p><p>这样的算法在最坏情况下（输入数组中没有元素等于<em>val</em>），左右指针各遍历了数组一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> right = <span class="number">0</span>; right &lt; n; right++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[right] != val) &#123;</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>26.删除有序数组中的重复项</title>
      <link href="/post/42066.html"/>
      <url>/post/42066.html</url>
      
        <content type="html"><![CDATA[<h1 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26.删除有序数组中的重复项"></a>26.删除有序数组中的重复项</h1><p>给你一个有序数组 <code>nums</code> ，请你<strong><a href="http://baike.baidu.com/item/原地算法"> 原地</a></strong> 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 <strong><a href="https://baike.baidu.com/item/原地算法">原地 </a>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">2</span>, nums = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">解释：函数应该返回新的长度 <span class="number">2</span> ，并且原数组 nums 的前两个元素被修改为 <span class="number">1</span>, <span class="number">2</span> 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><hr><p>删除<strong>有序</strong>数组中的<strong>重复</strong>项目，<strong>遍历</strong>并且需要<strong>对比</strong>数组中的重复项</p><p><strong>Solution1</strong>：双指针</p><p>思路就是既然只需要输出不重复的项，那么遍历数组，将不一样的值放入数组前列，因为是有序数组，所以降低了难度。</p><p>定义两个指针 fast和 slow分别为快指针和慢指针，快指针表示遍历数组到达的下标位置，慢指针表示下一个不同元素要填入的下标位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> slow=<span class="number">0</span>;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> fast=<span class="number">1</span>;fast&lt;nums.length;fast++)&#123;</span><br><span class="line">              <span class="keyword">if</span>(nums[slow]!=nums[fast])&#123;</span><br><span class="line">                  nums[slow+<span class="number">1</span>]=nums[fast];</span><br><span class="line">                  slow++;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">       <span class="keyword">return</span> s+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20.有效的括号</title>
      <link href="/post/63451.html"/>
      <url>/post/63451.html</url>
      
        <content type="html"><![CDATA[<h1 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a>20.有效的括号</h1><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ol><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;()&quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;()[]&#123;&#125;&quot;</span></span><br><span class="line">输出：<span class="keyword">true</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong>：</p><p>首先考虑用栈的思想，如果遇到左括号，就入栈，碰到了右括号，就出栈，对比栈顶元素和右括号是否匹配</p><p>注意到括号都是对应的，所以可以用Map简化操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;Character, Character&gt; pairs = <span class="keyword">new</span> HashMap&lt;Character, Character&gt;() &#123;&#123;</span><br><span class="line">            put(<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            put(<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">            put(<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        Deque&lt;Character&gt; stack = <span class="keyword">new</span> LinkedList&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (pairs.containsKey(ch)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty() || stack.peek() != pairs.get(ch)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21.合并两个有序链表</title>
      <link href="/post/29474.html"/>
      <url>/post/29474.html</url>
      
        <content type="html"><![CDATA[<h1 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21.合并两个有序链表"></a>21.合并两个有序链表</h1><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>], l2 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure><ol><li>如何同时对比两个链表的值？</li><li>最后如何返回头结点？</li></ol><hr><p><strong>Solution</strong>：双指针</p><p>双指针+备份</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode prehead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode prev = prehead; </span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">                prev.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = prev.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span></span><br><span class="line">        prev.next = (l1 == <span class="keyword">null</span>) ? l2 : l1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prehead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14.最长公共前缀</title>
      <link href="/post/14391.html"/>
      <url>/post/14391.html</url>
      
        <content type="html"><![CDATA[<h1 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14.最长公共前缀"></a>14.最长公共前缀</h1><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：strs = [<span class="string">&quot;flower&quot;</span>,<span class="string">&quot;flow&quot;</span>,<span class="string">&quot;flight&quot;</span>]</span><br><span class="line">输出：<span class="string">&quot;fl&quot;</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：strs = [<span class="string">&quot;dog&quot;</span>,<span class="string">&quot;racecar&quot;</span>,<span class="string">&quot;car&quot;</span>]</span><br><span class="line">输出：<span class="string">&quot;&quot;</span></span><br><span class="line">解释：输入不存在公共前缀。</span><br></pre></td></tr></table></figure><p>问题：</p><ol><li>在比较各个字符串的前缀中，如果保证数组不越界？最后返回的有几种情况？</li></ol><hr><p><strong>Solution</strong></p><ol><li>首先以第一个字符串的长度为标准，只有两种情况，比第一个字符串短，或者长，每次在对比其他字符串的字符时，首先确认当前遍历的字符没有超过其长度，如果超过，直接以其最短长度返回前缀，</li></ol><p>​      对于比第一字符串长的情况，如果当最后都相同，那么直接返回第一个字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = strs[<span class="number">0</span>].length();</span><br><span class="line">        <span class="keyword">int</span> count = strs.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = strs[<span class="number">0</span>].charAt(i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; count; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == strs[j].length() || strs[j].charAt(i) != c) &#123;</span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13.罗马数字转整数</title>
      <link href="/post/57384.html"/>
      <url>/post/57384.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13.罗马数字转整数"></a>13.罗马数字转整数</h1><p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><p>例如， 罗马数字 <code>2</code> 写做 <code>II</code> ，即为两个并列的 1 。<code>12</code> 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 <code>27</code> 写做 <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p><ul><li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li><li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。 </li><li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个罗马数字，将其转换成整数。</p><hr><p><strong>Solution</strong></p><p>这种特殊字符对应值的问题，首先考虑用Map结构，然后在观察罗马数字的结构，小的数字一般都在大的数字的右边</p><p>若存在小的数字在大的数字的左边的情况，根据规则需要减去小的数字。</p><p>从右到左遍历，记录当前遇到的最大的数字，遇到更大的就加，并且更新最大数，遇到小的就减</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">      HashMap &lt;Character,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&#x27;I&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;V&#x27;</span>, <span class="number">5</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;X&#x27;</span>, <span class="number">10</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;L&#x27;</span>, <span class="number">50</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;C&#x27;</span>, <span class="number">100</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;D&#x27;</span>, <span class="number">500</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;M&#x27;</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> highestLevel = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> [] c=s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=c.length-<span class="number">1</span>;i&gt;-<span class="number">1</span>;i--)&#123;</span><br><span class="line">             <span class="keyword">int</span> level=map.get(c[i]);</span><br><span class="line">             <span class="keyword">if</span> (level&gt;=highestLevel)&#123;</span><br><span class="line">             result+=level;</span><br><span class="line">             highestLevel=level;</span><br><span class="line">             &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             result-=level;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">             <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
          <category> 哈希表 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.回文数</title>
      <link href="/post/15753.html"/>
      <url>/post/15753.html</url>
      
        <content type="html"><![CDATA[<h1 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9.回文数"></a>9.回文数</h1><p>给你一个整数 <code>x</code> ，如果 <code>x</code> 是一个回文整数，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，<code>121</code> 是回文，而 <code>123</code> 不是。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = <span class="number">121</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：x = <span class="number">-121</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：从左向右读, 为 <span class="number">-121</span> 。 从右向左读, 为 <span class="number">121</span>- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">bool <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况：</span></span><br><span class="line">        <span class="comment">// 如上所述，当 x &lt; 0 时，x 不是回文数。</span></span><br><span class="line">        <span class="comment">// 同样地，如果数字的最后一位是 0，为了使该数字为回文，</span></span><br><span class="line">        <span class="comment">// 则其第一位数字也应该是 0</span></span><br><span class="line">        <span class="comment">// 只有 0 满足这一属性</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> revertedNumber = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; revertedNumber) &#123;</span><br><span class="line">            revertedNumber = revertedNumber * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。</span></span><br><span class="line">        <span class="comment">// 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，</span></span><br><span class="line">        <span class="comment">// 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。</span></span><br><span class="line">        <span class="keyword">return</span> x == revertedNumber || x == revertedNumber / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.两数之和</title>
      <link href="/post/52823.html"/>
      <url>/post/52823.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h1><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">解释：因为 nums[<span class="number">0</span>] + nums[<span class="number">1</span>] == <span class="number">9</span> ，返回 [<span class="number">0</span>, <span class="number">1</span>] 。</span><br></pre></td></tr></table></figure><hr><p>检索某几个数组元素之间<strong>关系</strong>，并且要求返回它们对应的<strong>下标</strong></p><ol><li>需要返回的是两个数组的下标，也就是要遍历很多遍数组</li><li>有没有办法只遍历一次数组？</li></ol><p><strong>Solution 1</strong>：bp算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bp算法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> []a=&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]==target)&#123;</span><br><span class="line">                       a[<span class="number">0</span>]=i;</span><br><span class="line">                       a[<span class="number">1</span>]=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单设置两个for循环来遍历数组</p><hr><p><strong>Solution2</strong>：HashMap</p><p>因为要返回的是数组下标，所有用HashMap求解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//key值是nums[i],Value值是下标</span></span><br><span class="line">        HashMap&lt;Integer,Integer&gt; hashmap=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hashmap.containsKey(target-nums[i])) <span class="comment">//如果key值有target-nums[i]</span></span><br><span class="line">        &#123;      </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span> []&#123;hashmap.get(target-nums[i]),i&#125;;<span class="comment">//返回下标</span></span><br><span class="line">        &#125;</span><br><span class="line">            hashmap.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 哈希表 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
