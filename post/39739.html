<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>6.图 | Night's Watch</title><meta name="keywords" content="数据结构"><meta name="author" content="Candle"><meta name="copyright" content="Candle"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="图逻辑结构定义图是由顶点的有穷非空集合和顶点之间边的集合组成， 通常表示为: G（V，E）， 其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合  线性表可以是空表，树可以是空树，但是图不可以是空，即V一定是非空集  类型 无向图：如果E是由无向边的有限集合时，则图G为无向图 度：对于无向图，顶点的度指依附于该顶点的边的条数 无向完全图：在无向图中，如果任意两个顶点之间都存在边，则称该图">
<meta property="og:type" content="article">
<meta property="og:title" content="6.图">
<meta property="og:url" content="http://candle1220.github.io/post/39739.html">
<meta property="og:site_name" content="Night&#39;s Watch">
<meta property="og:description" content="图逻辑结构定义图是由顶点的有穷非空集合和顶点之间边的集合组成， 通常表示为: G（V，E）， 其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合  线性表可以是空表，树可以是空树，但是图不可以是空，即V一定是非空集  类型 无向图：如果E是由无向边的有限集合时，则图G为无向图 度：对于无向图，顶点的度指依附于该顶点的边的条数 无向完全图：在无向图中，如果任意两个顶点之间都存在边，则称该图">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/data.png">
<meta property="article:published_time" content="2023-12-21T08:21:52.995Z">
<meta property="article:modified_time" content="2023-09-25T15:35:16.000Z">
<meta property="article:author" content="Candle">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/data.png"><link rel="shortcut icon" href="/img/candle.png"><link rel="canonical" href="http://candle1220.github.io/post/39739"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/node-snackbar/0.1.16/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#55d5fc","bgDark":"#121212","position":"top-center"},
  source: {
    jQuery: 'https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/jquery/3.6.0/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.js',
      css: 'https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '6.图',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-25 23:35:16'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    document.addEventListener('pjax:complete', detectApple)})(window)</script><link rel="stylesheet" href="/css/background.css"><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/Swiper/8.0.6/swiper-bundle.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">195</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-crow"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/background.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Night's Watch</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-crow"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">6.图</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-21T08:21:52.995Z" title="发表于 2023-12-21 16:21:52">2023-12-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-25T15:35:16.000Z" title="更新于 2023-09-25 23:35:16">2023-09-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/408/">408</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="6.图"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>图</strong>是由顶点的有穷非空集合和顶点之间边的集合组成， 通常表示为: G（V，E）， 其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合</p>
<p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/OLvaXWJd3z5qGgx.png" alt="image-20220512210137535"></p>
<p>线性表可以是空表，树可以是空树，但是图不可以是空，即V一定是非空集</p>
<hr>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/z1KmcbnPL4iZDrw.png" alt="image-20220512210442402"></p>
<p><strong>无向图</strong>：如果E是由无向边的有限集合时，则图G为无向图</p>
<p><strong>度</strong>：对于无向图，顶点的度指依附于该顶点的边的条数</p>
<p><strong>无向完全图</strong>：在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。含有n个顶点的无向完全图有$\frac{n(n+1)}{2}$条边</p>
<p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/mqi15snV4zdSKaA.png" alt="image-20220512210814592"></p>
<p><strong>有向图</strong>：若E是有向边(弧)的有限集合时，则图G为有向图，弧是顶点的有序对，记为<em><v,w></em>，其中v,w是顶点，<em>v</em>称为弧尾，<em>w</em>称为弧头，<em><v,w></em>称为从顶点<em>v</em>到顶点<em>w</em>的弧，<em><v,w>≠<w,v></em>；</p>
<p><strong>入度，出度</strong>：对于有向图，入度是以顶点为终点的有向边的数目，记为ID(<em>v</em>)，出度是以顶点为起点的有向边的数目，记为OD(<em>v</em>)，顶点的度等于其入度和出度之和，对于有向图，图的总入度和总出度肯定是相同的</p>
<p><strong>有向完全图</strong>：在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。含有<code>n</code>个顶点的有向完全图有<code>n× (n-1)</code>条边</p>
<hr>
<p><strong>子图</strong>： 假设有两个图<code>G= (V，&#123;E&#125;</code>)和<code>G&#39;= (V&#39;，&#123;E&#39;&#125;)</code>，如果V’是V的子集，且E’是E的子集，则称G’为G的子图。如下图带底纹的图均为左侧无向图与有向图的子图。</p>
<p><strong>路径和路径的长度</strong>：从顶点A到顶点B的路径是一个顶点序列。路径的长度是路径上的边或弧的数目。有向图的路径也是有向的</p>
<p><strong>回路</strong>：第一个顶点和最后一个顶点相同的路径称为回路</p>
<p><strong>简单路径、简单回路或简单环</strong>：序列中顶点不重复出现的路径称为简单路径。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环</p>
<p><strong>点与点的距离</strong>：从顶点<code>u</code>出发到顶点<code>v</code>的最短路径若存在，则此路径的长度称为从<code>u</code>到<code>v</code>的距离，若不存在路径，则记该距离为无穷($\infty$)</p>
<hr>
<p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/QeLfHRSBV56qz2U.png" alt="image-20220517160124855" style="zoom:67%;" /></p>
<p><strong>连通、连通图和连通分量</strong>：在无向图G中，如果从顶点v到顶点v’有路径，则称v和v’是连通的。 如果对于图中任意两个顶点vi、vj ∈E， vi，和vj都是连通的，则称G是连通图</p>
<p><strong>无向图</strong>中的<strong>极大连通子图</strong>称为<strong>连通分量</strong>。注意连通分量的概念，它强调:</p>
<ul>
<li>要是子图；</li>
<li>子图要是连通的；</li>
<li>连通子图含有极大顶点数；</li>
<li>具有极大顶点数的连通子图包含依附于这些顶点的所有边。</li>
</ul>
<p>图2，图3，图4都是无向图1的子图，图2是极大连通子图，图3也极大连通子图，图4不满足极大的特点</p>
<p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/TS2H3xYQXLJDGuE.png" alt="image-20220517160843870" style="zoom:67%;" /></p>
<p><strong>强连通图和强连通分量</strong>：在有向图G中，如果对于每一对vi，vj属于E，从vi到vj和vj 到vi都有路径，则称G是强连通图。有向图中的极大强连通子图称作有向图的强连通分量。</p>
<p>即ABCDE组成了一个强连通分量，而F缺乏到B的路径，没有包含在内，F和G单独为一个强连通分量</p>
<p>每一个孤立结点都构成连通分量</p>
<hr>
<p><strong>生成树</strong>：一个极小的连通子图， 它含有图中全部的n个顶点，但只有足以构成一棵树的n-1条边，简而言之就是用最少的边连接所有顶点</p>
<p><strong>权和网</strong>：有些图的边或弧具有与它相关的数字，这种与图的边或弧相关的数叫做权。这些权可以表示从一个顶点到另一个顶点的距离或耗费。这种带权的图通常称为网</p>
<p><strong>树</strong>是一种不存在回路，且连通的无向图</p>
<hr>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>无向图边数的2倍等于各顶点的度数的总和</p>
<hr>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="邻接矩阵法"><a href="#邻接矩阵法" class="headerlink" title="邻接矩阵法"></a>邻接矩阵法</h3><p>图的邻接矩阵存储方式是用<strong>两个数组来表示图</strong>。一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息</p>
<p>定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VertexMax 100 <span class="comment">//最大顶点数为100</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxInt 32767 <span class="comment">//表示最大整数，表示 ∞</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Maxsize 100 <span class="comment">//队列最大元素个数100 </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VertexType; <span class="comment">//每个顶点数据类型为字符型</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">int</span> dataType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> Vertex[<span class="number">100</span>];<span class="comment">//存放顶点元素的一维数组,VertexType表示元素的数据类型</span></span><br><span class="line">	<span class="keyword">int</span> AdjMatrix[<span class="number">1</span>][<span class="number">100</span>];<span class="comment">//邻接矩阵二维数组 </span></span><br><span class="line">	<span class="keyword">int</span> vexnum, arcnum;<span class="comment">//图的顶点数和边数</span></span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找元素v在一维数组 Vertex[] 中的下标，并返回下标 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateVex</span><span class="params">(MGraph* G, <span class="keyword">char</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (v == G-&gt;Vertex[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;No Such Vertex!\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结点数为n的图G中，邻接矩阵是<code>n×n</code>大小的，初始化数值为<code>0</code>，如果<code>i</code>行<code>j</code>列数值为<code>1</code>，表示第<code>i</code>个元素到第<code>j</code>个元素存在路径，在无向图中，是双向的，即<code>i</code>行<code>j</code>列以及<code>j</code>行<code>i</code>列数值都会为<code>1</code>，而在有向图中，是单向的</p>
<p>无向图：</p>
<p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/LyCzKNQmqZjD64B.png" alt="image-20220517170049835"></p>
<p>有向图：</p>
<p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/4G9PYVzwNU3Mqds.png" alt="image-20220517170107887"></p>
<p>创建邻接矩阵</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无向图和有向图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateUDG</span><span class="params">(MGraph* G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="comment">//1.输入顶点数和边数</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入顶点个数和边数(用逗号隔开)：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>, &amp;G-&gt;vexnum, &amp;G-&gt;arcnum);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.输入顶点元素 </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入顶点元素(无需空格隔开)：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, G-&gt;Vertex);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="comment">//3.矩阵初始化</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i++)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G-&gt;vexnum; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			G-&gt;AdjMatrix[i][j] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//4.构建邻接矩阵</span></span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	cv1, v2;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入边的信息：\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;arcnum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot; %c%c&quot;</span>, &amp;v1, &amp;v2);</span><br><span class="line">		n = LocateVex(G, v1); <span class="comment">//获取v1所对应的在Vertex数组中的坐标 </span></span><br><span class="line">		m = LocateVex(G, v2); <span class="comment">//获取v2所对应的在Vertex数组中的坐标</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">-1</span> || m == <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;NO This Vertex!\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		G-&gt;AdjMatrix[n][m] = <span class="number">1</span>;   <span class="comment">// 创建有向图</span></span><br><span class="line">	<span class="comment">//	G-&gt;AdjMatrix[m][n] = 1;      创建无向图</span></span><br><span class="line">    <span class="comment">//  G-&gt;AdjMatrix[n][m] = w;      将1改为w，而将0改为∞，则是网</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>对于带权图（网）来说，将矩阵里面的值初始化为<code>∞</code>，如果存在路径，则路径的值为权值</p>
<p>无向网：</p>
<p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/Hzq8dinVEOs7myg.png" alt="image-20220517171039499"></p>
<p>有向网：</p>
<p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/VcxEn2s5zFteZrM.png" alt="image-20220517171059855"></p>
<hr>
<p>对有向图来说</p>
<p>第<code>i</code>个结点的出度=第<code>i</code>行非零元素个数</p>
<p>第<code>i</code>个结点的入度=第<code>i</code>列非零元素个数</p>
<p>第<code>i</code>个结点的度=第<code>i</code>行，第<code>i</code>列非零元素个数之和</p>
<p>邻接矩阵法求顶点的度的时间复杂度为<code>O(n)</code>，空间复杂度为<code>O(n²)</code>，之和顶点数有关，和实际边数无关，适用用于存储稠密图，而且无向图的邻接矩阵是对称矩阵，可以压缩存储</p>
<div class="note primary simple"><p><strong>设图G的邻接矩阵为A，则$A^n$的元素$A^n[i][j]$等于由顶点<code>i</code>到顶点<code>j</code>的长度为<code>n</code>的路径的数目</strong></p>
</div>
<hr>
<h3 id="邻接表法"><a href="#邻接表法" class="headerlink" title="邻接表法"></a>邻接表法</h3><p>邻接表由顶点表和边表组成，顶点表是结构体数组，边表是一环一环的链节</p>
<p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/ZiDEqIHxLljbrnQ.png" alt="image-20220518144342896"></p>
<p><strong>顶点表</strong>是结构体数组，其中的每个元素有两个域：</p>
<ul>
<li><p>数据域（用于存放顶点元素如V1、V2、V3或A、B、C之类的）</p>
</li>
<li><p>指针域，用于连接边表。</p>
</li>
</ul>
<p><strong>边表</strong>是结构体，其中每个结点也有两个域：</p>
<ul>
<li>下标域，存储的是对应元素在顶点表中的下标。</li>
<li>指针域，用于连接后续结点</li>
</ul>
<div class="note primary simple"><p>邻接表法和树的孩子表示法一模一样，都是顺序+链式存储</p>
</div>
<p>定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>//边表 </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> adjvex;<span class="comment">//存储的是该顶点在顶点数组即AdjList[]中的位置  下标域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">next</span>;</span>  <span class="comment">//指针域，用于连接后续结点</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span> //单个顶点 </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	 <span class="keyword">int</span> vertex;  <span class="comment">//数据域   </span></span><br><span class="line">	<span class="comment">//int weight；//存储网的时候需要添加此项</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">firstarc</span>;</span>   <span class="comment">//第一个孩子节点  指针域，用于连接边表</span></span><br><span class="line">&#125;VNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> //顶点表 </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	VNode AdjList[VertexMax];<span class="comment">//由顶点构成的结构体数组 </span></span><br><span class="line">	<span class="keyword">int</span> vexnum,arcnum; <span class="comment">//顶点数n和边数e </span></span><br><span class="line">&#125;ALGraph;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/EnHsg9ONylz8rBI.png" alt="image-20220518144643827"></p>
<p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/qRZ6A4sWnladHtx.png" alt="image-20220518150702207"></p>
<p>对于无向图，边节点的数量是<code>2n</code>，整体空间复杂度为<code>V+2n</code></p>
<p>对于有向图，边节点的数量是<code>n</code>，整体空间复杂度为<code>V+n</code></p>
<p>在无向图中，如果要求节点的度，遍历节点的边表即可，在有向图中，如果要找有向边的入度，那么需要遍历所有结点</p>
<p>图的邻接表表示并不唯一，空间复杂度低，适合存放稀疏图</p>
<hr>
<h3 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h3><p>因为邻接表法在存储无向图的时候会存储冗余数据，所以利用十字链表的方法，使用邻接多重表来存储无向图</p>
<p>比起十字链表法，邻接多重表只有边表被扩充了</p>
<p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/yl4YrtRKDTAaqiM.png" alt="image-20220518160212613" style="zoom:67%;" /></p>
<p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/VeQGfR4NdKtcig5.png" alt="image-20220518160235586"></p>
<p>空间复杂度<code>V+n</code>，而且删除边和节点操作变得简单，只适合用存储无向图</p>
<hr>
<h3 id="十字链表法"><a href="#十字链表法" class="headerlink" title="十字链表法"></a>十字链表法</h3><p>邻接表法容易求顶点的出度，但不容易求顶点的入度</p>
<p>如果我们更改邻接表的定义，将有向图中指向该结点的弧记录为孩子，那么就变成了逆邻接表，容易求顶点的入度，但不容易求顶点的出度</p>
<p>如果把邻接表和逆邻接表结合起来，既可以方便求入度，也可以方便求出度，这就是十字链表法</p>
<p>顶点结点：</p>
<p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/4I9fbS8hveVa5Tr.png" alt="image-20220518154636296" style="zoom:67%;" /></p>
<p>弧结点：</p>
<p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/Srt9pvRxMNOZBsQ.png" alt="image-20220518154311640" style="zoom:67%;" /></p>
<p>相比于邻接表法，顶点表多了一个firstin区域，用于记录指向结点的弧</p>
<p>边表扩充了一倍，同时记录了弧头顶点编号和弧头相同的下一条弧（橙色部分）</p>
<p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/nRTih6tqUpdE9xu.png" alt="image-20220518155636604"></p>
<p>（如果把橙色区域以及指针全去了，就是邻接表法）</p>
<p>空间复杂度为V+n，只适合存储有向图</p>
<hr>
<p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/dUvxYiXfDN2jtVJ.png" alt="image-20220518161142466"></p>
<hr>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/JSxVpUYeB7lKvg9.gif" alt="img"></p>
<h3 id="广度优先遍历-BFS"><a href="#广度优先遍历-BFS" class="headerlink" title="广度优先遍历(BFS)"></a>广度优先遍历(BFS)</h3><p>类似于树的层次遍历</p>
<p>即先从某个结点开始，先遍历最离其最近的结点，再遍历到深层的结点</p>
<p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/dlCsAfBb1SkPnOI.png" alt="image-20220518163613467"></p>
<p>基本步骤：</p>
<ol>
<li><p>设置全局变量<code>visited</code>数组并初始化为全0，代表所有节点均未被访问</p>
</li>
<li><p>设置起始点：包括对起始点进行<strong>输出、标记成已访问、入队</strong></p>
</li>
<li><p>对后续结点进行操作：由起始点开始，对后续结点进行操作（<strong>输出、标记成已访问、入队</strong>）<br>（步骤2-3为<strong>广度优先搜索</strong>）</p>
</li>
<li><p>循环重复2-3的操作避免有“孤岛”结点被遗漏。<br>（步骤4 循环执行广度优先搜索避免遗漏“孤岛”结点，就是广度优先遍历）</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接矩阵法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> visitedBFS[VertexMax];<span class="comment">//定义&quot;标志&quot;数组为全局变量 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(MGraph *G,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	CyQueue q;    <span class="comment">//队列</span></span><br><span class="line">	create(&amp;q);   <span class="comment">//初始化队列</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//1.设置起始点 </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,G-&gt;Vertex[i]);<span class="comment">//1.输出起始结点 </span></span><br><span class="line">	visited[i]=<span class="number">1</span>;<span class="comment">//2.将已访问的结点标志成1</span></span><br><span class="line">	EnQueue(&amp;q,i);<span class="comment">//3.将第一个结点入队 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.由起始点开始，对后续结点进行操作 </span></span><br><span class="line">	<span class="keyword">while</span>(!QueueEmpty(&amp;q))<span class="comment">//队列非空</span></span><br><span class="line">	&#123;</span><br><span class="line">		DeQueue(&amp;q,&amp;i);	  <span class="comment">//出队  i的值根据出队的元素在变</span></span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G-&gt;vexnum;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(G-&gt;AdjMatrix[i][j]==<span class="number">1</span>&amp;&amp;visited[j]==<span class="number">0</span>) <span class="comment">//如果矩阵内存在路径</span></span><br><span class="line">			&#123;</span><br><span class="line">			   <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,G-&gt;Vertex[j]);<span class="comment">//输出符合条件的顶点 </span></span><br><span class="line">	            visitedBFS[j]=<span class="number">1</span>;<span class="comment">//设置成已访问状态1 </span></span><br><span class="line">	            EnQueue(&amp;q,j);<span class="comment">//入队 j的值根据入队的元素在变</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; 	</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//为了避免孤岛结点无法被遍历到，需要确认visit数组都为1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(MGraph *G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//数组初始化为全0 </span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;vexnum;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		visited[i]=<span class="number">0</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;vexnum;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(visited[i]==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			BFS(G,i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于BFS，邻接矩阵的遍历序列唯一，邻接表不唯一</p>
<p>对于无向图，调用BFS函数的次数等于连通分量的次数</p>
<p>空间复杂度：来自于辅助队列，大小为<code>O(n)</code></p>
<p>时间复杂度：</p>
<p>对于邻接矩阵：针对每一个元素<code>i</code>，都会扫描<code>j</code>列来确定是否邻接，所以其时间复杂度为<code>O(n²)</code></p>
<p>对于邻接表：针对每一个元素<code>i</code>，只需要找其边表即可确定邻接的点，所以时间复杂度为<code>O(n)</code></p>
<hr>
<h3 id="深度优先遍历-DFS"><a href="#深度优先遍历-DFS" class="headerlink" title="深度优先遍历(DFS)"></a>深度优先遍历(DFS)</h3><p>类似于树的先序遍历</p>
<p>基本步骤</p>
<ol>
<li>设置全局变量<code>visited</code>数组并初始化为全0，代表所有节点均未被访问</li>
<li>选取初始端点：对初始端点进行访问，并在<code>visited</code>数值中标记成已访问状态（代码演示的初始端点是<code>G-&gt;Vertex[i]</code>，此时<code>i=0</code>）</li>
<li>循环对所有节点都执行步骤2，前提是该节点未被访问！（对应函数<code>DFSTraverse</code>，主要用于非连通图能访问到每一个结点）</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> visitedDFS[VertexMax];<span class="comment">//定义&quot;标志&quot;数组为全局变量 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(MGraph* G, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1.处理起始点 </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, G-&gt;Vertex[i]);<span class="comment">//1.输出起始结点 </span></span><br><span class="line">	visitedDFS[i] = <span class="number">1</span>;<span class="comment">//2.将已访问的结点标志成1</span></span><br><span class="line"></span><br><span class="line">	 <span class="comment">//2.由起始点开始，对后续结点进行操作</span></span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G-&gt;vexnum; j++)<span class="comment">//依次搜索vi的邻接点 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (G-&gt;AdjMatrix[i][j] == <span class="number">1</span> &amp;&amp; visitedDFS[j] == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//当满足有边且未被访问过时，递归调用去查找该邻接点 </span></span><br><span class="line">		&#123;</span><br><span class="line">			DFS(G, j);<span class="comment">//注意此处的G已经是指针类型，不需要再&amp;G </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(MGraph* G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="comment">//初始化&quot;标志&quot;数组为0，代表未访问</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		visitedDFS[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (visitedDFS[i] == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			DFS(G, i);<span class="comment">//注意此处的G已经是指针类型，不需要再&amp;G </span></span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于BFS，邻接矩阵的遍历序列唯一，邻接表不唯一</p>
<p>空间复杂度：来自于递归调用工作栈，大小为<code>O(n)</code></p>
<p>时间复杂度：</p>
<p>对于邻接矩阵：针对每一个元素<code>i</code>，都会扫描<code>j</code>列来确定是否邻接，所以其时间复杂度为<code>O(n²)</code></p>
<p>对于邻接表：针对每一个元素<code>i</code>，只需要找其边表即可确定邻接的点，所以时间复杂度为<code>O(n)</code></p>
<hr>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>在无向网中，所有路径的权值之和最小的生成树，称为最小生成树(Minimum Cost Spanning Tree)</p>
<h3 id="普里姆算法-Prim"><a href="#普里姆算法-Prim" class="headerlink" title="普里姆算法(Prim)"></a>普里姆算法(Prim)</h3><p>对<strong>顶点</strong>操作，在<strong>最小生成树的顶点集U</strong>和<strong>待处理顶点集V-U</strong>中，不断地寻找<strong>最短边(代价最小边)</strong>，找到后将对应顶点<strong>加入集合U</strong>，直到所有顶点均处理完毕(V-U里没有剩余顶点)</p>
<ol>
<li><p>首先我们需要一个结构体数组：最短路径数组<code>shortedge</code>来存储当前各个顶点之间的最短路径信息，其中的<code>adjvex</code>用于存储最短边的邻接点，<code>lowcost</code>是其对应权值，也就是当前最小的代价</p>
</li>
<li><p>对<code>shortedge</code>数组写入初始化信息，将起始点放入集合U中，即 <code>shortedge[k].lowcost=0;</code>lowcost为0表示该顶点属于U集合,<code>k</code>是起始点的位置</p>
</li>
<li><p>求最小值的函数（<code>minimal</code>）：只需要在当前<code>shortage</code>数组中比较出<code>lowcost</code>最小的元素，返回它的下标<code>loc</code>即可在<code>Vertex</code>数组中找到该元素。</p>
</li>
<li><p>对后续顶点处理：通过<code>minimal</code>函数找到最小路径所对应的的顶点， 将此路径对应的顶点放入集合<code>U</code>中（将其对应的<code>lowcost</code>改为<code>0</code>），更新<code>shortedge</code>数组（集合U中加入新的顶点，阵营U中有可能生成新的最小路径到达阵营V-U中）</p>
<p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/xpSlz9HwgGi3mkd.png" alt="image-20220518203726957"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//1.结构体数组存储最短路径</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>//最短路径数组结构体(候选最短边) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> adjvex;<span class="comment">//候选最短边的邻接点 </span></span><br><span class="line">	<span class="keyword">int</span> lowcost;<span class="comment">//候选最短边的权值 </span></span><br><span class="line">&#125;ShortEdge;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 求最小值的函数(minimal):只需要在当前shortage数组中比较出lowcost最小的元素</span></span><br><span class="line"><span class="comment">//    返回它的下标loc即可在Vertex数组中找到该元素。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimal</span><span class="params">(MGraph* G, ShortEdge* shortedge)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> min, loc;</span><br><span class="line"></span><br><span class="line">	min = MaxInt;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; G-&gt;vexnum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (min &gt; shortedge[i].lowcost &amp;&amp; shortedge[i].lowcost != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			min = shortedge[i].lowcost;</span><br><span class="line">			loc = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> loc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MiniSpanTree_Prim</span><span class="params">(MGraph* G, VertexType start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, k;</span><br><span class="line">	ShortEdge shortedge[VertexMax];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.处理起始点start，写入初始信息</span></span><br><span class="line">	k = LocateVex(G, start);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		shortedge[i].adjvex = start;</span><br><span class="line">		shortedge[i].lowcost = G-&gt;AdjMatrix[k][i]; </span><br><span class="line">        <span class="comment">//G是无向网，AdjMatrix[k][i]中存的是权值</span></span><br><span class="line">	&#125;</span><br><span class="line">	shortedge[k].lowcost = <span class="number">0</span>;<span class="comment">//lowcost为0表示该顶点属于U集合 </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//4.处理后续结点 </span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;vexnum - <span class="number">1</span>; i++)<span class="comment">//对集合U，去找最短路径的顶点 </span></span><br><span class="line">	&#123;</span><br><span class="line">		k = minimal(G, shortedge);<span class="comment">//找最短路径的顶点 </span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%c-&gt;%c,%d\n&quot;</span>, shortedge[k].adjvex, G-&gt;Vertex[k], shortedge[k].lowcost);</span><br><span class="line">        <span class="comment">//输出找到的最短路径顶，及路径权值 </span></span><br><span class="line">		shortedge[k].lowcost = <span class="number">0</span>;<span class="comment">//将找到的最短路径顶点加入集合U中 </span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G-&gt;vexnum; j++)</span><br><span class="line">            <span class="comment">//U中加入了新的K节点，可能出现新的最短路径，故更新shortedge数组 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (G-&gt;AdjMatrix[k][j] &lt; shortedge[j].lowcost)</span><br><span class="line">                <span class="comment">//有更短路径出现时，将其替换进shortedge数组 </span></span><br><span class="line">			&#123;</span><br><span class="line">				shortedge[j].lowcost = G-&gt;AdjMatrix[k][j];</span><br><span class="line">				shortedge[j].adjvex = G-&gt;Vertex[k];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>时间复杂度：<code>O(n²)</code>，显然有个嵌套，第一个嵌套是遍历<code>n-1</code>个节点，时间复杂度是<code>O(n)</code>，第二个嵌套中，先要找到最短路径的顶点，即<code>miniaml</code>函数，时间复杂度是<code>O(n)</code>，找到后需要更新<code>shortedge</code>数组，时间复杂度是<code>O(n)</code>，共<code>O(2n)</code>，所有总时间复杂度为<code>O(n²)</code></p>
<p><strong>适合于稠密图</strong></p>
<hr>
<h3 id="克鲁斯卡尔算法-Kruskal"><a href="#克鲁斯卡尔算法-Kruskal" class="headerlink" title="克鲁斯卡尔算法(Kruskal)"></a>克鲁斯卡尔算法(Kruskal)</h3><p><strong>每次选取最短边，但不能构成回路</strong></p>
<p>如果用邻接矩阵和邻接表，每次寻找最短边都要搜索所有边，故邻接矩阵和邻接表均不合适，所以最终选用了边集数组</p>
<p><strong>边集数组edge</strong>是一个结构体数组，每一个单元包含起点、终点、权值</p>
<p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/HvqWrK6ynBQFa43.png" alt="image-20220518205130127" style="zoom:67%;" /></p>
<p>定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	VertexType begin;<span class="comment">//起点</span></span><br><span class="line">	VertexType end;<span class="comment">//终点</span></span><br><span class="line">	<span class="keyword">int</span> weight;</span><br><span class="line">&#125;Edge;<span class="comment">//边集数组edge[]的单元 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	VertexType Vertex[VertexMax];<span class="comment">//顶点数组 </span></span><br><span class="line">	Edge edge[VertexMax];<span class="comment">//边集数组 </span></span><br><span class="line">	<span class="keyword">int</span> vexnum;<span class="comment">//顶点数 </span></span><br><span class="line">	<span class="keyword">int</span> edgenum;<span class="comment">//边数 </span></span><br><span class="line">&#125;EdgeGraph;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>选取最短边的关键：排序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选用简单排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(EdgeGraph *E)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	Edge temp;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;E-&gt;edgenum<span class="number">-1</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;E-&gt;edgenum;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(E-&gt;edge[i].weight&gt;E-&gt;edge[j].weight)</span><br><span class="line">			&#123;</span><br><span class="line">				temp=E-&gt;edge[i];</span><br><span class="line">				E-&gt;edge[i]=E-&gt;edge[j];</span><br><span class="line">				E-&gt;edge[j]=temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>检查回路：只需要看两个顶点所属的树是否有相同的根节点，使用了<strong>并查集</strong>判断是否成环</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindRoot</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> parent[])</span><span class="comment">//t接收到是结点在Vertex数组中的下标 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(parent[t]&gt;<span class="number">-1</span>)<span class="comment">//parent=-1表示没有双亲，即没有根节点 </span></span><br><span class="line">	&#123;</span><br><span class="line">		t=parent[t];<span class="comment">//逐代查找根节点 </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> t;<span class="comment">//将找到的根节点返回，若没有根节点返回自身 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MiniSpanTree_Kruskal</span><span class="params">(EdgeGraph *E)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> num;<span class="comment">//生成边计数器，当num=顶点数-1 就代表最小生成树生成完毕 </span></span><br><span class="line">	<span class="keyword">int</span> root1,root2; </span><br><span class="line">	<span class="keyword">int</span> LocVex1,LocVex2; </span><br><span class="line">	<span class="keyword">int</span> parent[VertexMax];</span><br><span class="line">    <span class="comment">//用于查找顶点的双亲，判断两个顶点间是否有共同的双亲，来判断生成树是否会成环 </span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//1.按权值从小到大排序 </span></span><br><span class="line">	sort(E);</span><br><span class="line">	print(E);</span><br><span class="line">	<span class="comment">//2.初始化parent数组 </span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;E-&gt;vexnum;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		parent[i]=<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n 最小生成树(Kruskal):\n\n&quot;</span>);</span><br><span class="line">	<span class="comment">//3.</span></span><br><span class="line">	<span class="keyword">for</span>(num=<span class="number">0</span>,i=<span class="number">0</span>;i&lt;E-&gt;edgenum;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		LocVex1=LocateVex(E,E-&gt;edge[i].begin);</span><br><span class="line">		LocVex2=LocateVex(E,E-&gt;edge[i].end);</span><br><span class="line">		root1=FindRoot(LocVex1,parent);</span><br><span class="line">		root2=FindRoot(LocVex2,parent);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(root1!=root2)<span class="comment">//若不会成环，则在最小生成树中构建此边 </span></span><br><span class="line">		&#123;</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;\t\t%c-%c w=%d\n&quot;</span>,E-&gt;edge[i].begin,E-&gt;edge[i].end,E&gt;edge[i].weight);</span><br><span class="line">            <span class="comment">//输出此边 </span></span><br><span class="line">			parent[root2]=root1;<span class="comment">//合并生成树</span></span><br><span class="line">			num++;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(num==E-&gt;vexnum<span class="number">-1</span>)<span class="comment">//若num=顶点数-1，代表树生成完毕，提前返回 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>排序算法决定了克鲁斯卡尔算法的时间复杂度</strong>。若采用插入排序，时间复杂度为$O(n²)$ ，若采用堆排序或者快速排序，那么时间复杂度为$O(nlog_2n)$ [注：$n$为边数]，也就是说克鲁斯卡尔算法的时间复杂度<strong>取决于边数，所以适合稀疏图</strong></p>
<hr>
<h2 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h2><p>最短路径算法</p>
<ul>
<li>对于网（带权图）而言，求两点之间的最短路径有两种算法：迪杰斯特拉（Dijkstra算法）和 弗洛伊德（Floyd算法）</li>
</ul>
<ol>
<li>单源最短路径—迪杰斯特拉算法：从一个起始点出发，到达一个终点</li>
<li>多源最短路径—弗洛伊德算法：求每一对顶点之间的最短路径</li>
</ol>
<h3 id="迪杰斯特拉算法-Dijkstra"><a href="#迪杰斯特拉算法-Dijkstra" class="headerlink" title="迪杰斯特拉算法(Dijkstra)"></a>迪杰斯特拉算法(Dijkstra)</h3><p><strong>迪杰斯特拉算</strong>法处处可见<strong>普里姆算法</strong>的影子，大体上两者都是在寻找当前情况下的最短边，而不同之处在于，<strong>迪杰斯特拉算法做了路程的累加</strong></p>
<p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/Nc1AOkTHBLmiXZy.png" alt="image-20220523141139432"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindMinDist</span><span class="params">(<span class="keyword">int</span> dist[],<span class="keyword">int</span> s[],<span class="keyword">int</span> vexnum)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> loc;</span><br><span class="line">	<span class="keyword">int</span> min=MaxInt+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;vexnum;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(s[i]==<span class="number">0</span>)<span class="comment">//只对s[i]=0的顶点进行查找 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(dist[i]&lt;min)</span><br><span class="line">			&#123;</span><br><span class="line">				min=dist[i];</span><br><span class="line">				loc=i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> loc;<span class="comment">//返回dist中最小元素的下标 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShortestPath_Dijkstra</span><span class="params">(MGraph *G,VertexType start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j,num;</span><br><span class="line">	<span class="keyword">int</span> loc;</span><br><span class="line">	<span class="keyword">int</span> min;</span><br><span class="line">	<span class="keyword">int</span> dist[VertexMax];<span class="comment">//最短路径长度数组 </span></span><br><span class="line">	<span class="keyword">int</span> path[VertexMax];<span class="comment">//最短路径数组 </span></span><br><span class="line">	<span class="keyword">int</span> s[VertexMax];</span><br><span class="line">    <span class="comment">//代表集合S（1代表该顶点已处理，属于集合S；0代表该顶点未处理，不属于集合S，属于集合V-S） </span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//1.初始化dist和path数组 </span></span><br><span class="line">	loc=LocateVex(G,start);<span class="comment">//获取源点的下标位置 </span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;vexnum;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		dist[i]=G-&gt;AdjMatrix[loc][i];<span class="comment">//初始化dist数组</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(dist[i]!=MaxInt)<span class="comment">//初始化path数组</span></span><br><span class="line">		&#123;</span><br><span class="line">			path[i]=loc;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			path[i]=<span class="number">-1</span>;</span><br><span class="line">		&#125;	  </span><br><span class="line">	&#125; </span><br><span class="line">    </span><br><span class="line"><span class="comment">//2.初始化S数组(s数组：代表集合S，1代表该元素属于集合S(已处理的顶点),0该元素不属于集合S(未处理的顶点)) </span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;vexnum;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		s[i]=<span class="number">0</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	s[loc]=<span class="number">1</span>;<span class="comment">//代表起始点(源点)以处理完毕 </span></span><br><span class="line">	num=<span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3.</span></span><br><span class="line">	<span class="keyword">while</span>(num&lt;G-&gt;vexnum)</span><br><span class="line">	&#123;</span><br><span class="line">		min=FindMinDist(dist,s,G-&gt;vexnum);</span><br><span class="line">        <span class="comment">//在dist数组中查找其对应s[i]=0，即未处理的最小值元素 </span></span><br><span class="line">		s[min]=<span class="number">1</span>;<span class="comment">//将找到的最短边所对应的的顶点加入集合S</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;vexnum;i++)<span class="comment">//加入新的顶点后，更新dist和path数组 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>((s[i]==<span class="number">0</span>)&amp;&amp;(dist[i]&gt;dist[min]+G-&gt;AdjMatrix[min][i]))<span class="comment">//路径累加</span></span><br><span class="line">			&#123;</span><br><span class="line">				dist[i]=dist[min]+G-&gt;AdjMatrix[min][i];</span><br><span class="line">				path[i]=min;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	    num++;	</span><br><span class="line">	&#125;    </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>时间复杂度：<code>O(n²)</code></p>
<hr>
<h3 id="弗洛伊德算法（Floyd）"><a href="#弗洛伊德算法（Floyd）" class="headerlink" title="弗洛伊德算法（Floyd）"></a>弗洛伊德算法（Floyd）</h3><p>多源点意为多起始点，也就是图中所有顶点都将作为起始点，求此顶点到达图中其他所有顶点的最短路径</p>
<p>在之前学习的Dijskra算法，我们知道Dijskra算法是求解<strong>单源点最短路径</strong>的算法，使用Dijskra算法可以求出一个源点到其他所有顶点的最短路径，那么我们将Dijskra算法循环执行n次（n为顶点数），每次带入图中的一个顶点，不就实现了求解多源最短路吗？</p>
<p>Dijskra算法执行单次的时间复杂度为$O(n^2)$，其中n为顶点个数，循环执行n次，那么使用Dijskra算法求解多源点最短路径的整体时间复杂度为$O(n^3)$</p>
<p>此次我们引入的求解多源点最短路径问题的算法是——Floyd算法，时间复杂度也为$O(n^3)$，但是在算法构造和算法可读性上优于执行<code>n</code>次的Dijskra算法</p>
<p>弗洛伊德的核心思想是：对于网中的任意两个顶点（例如顶点 A 到顶点 B）来说，之间的最短路径不外乎有 2 种情况：</p>
<ol>
<li>直接从顶点 A 到顶点 B 的边的权值为顶点 A 到顶点 B 的最短路径。</li>
<li>从顶点 A 开始，经过若干个顶点，最终达到顶点 B，期间经过的边的权值和为顶点 A 到顶点 B 的最短路径</li>
</ol>
<p>所以，弗洛伊德算法的核心为：对于从顶点 A 到顶点 B 的最短路径，拿出网中所有的顶点进行如下判断：<br><code>Dist（A，K）+ Dist（K，B）&lt; Dist（A，B）</code><br>其中，K 表示网中所有的顶点；Dist（A，B） 表示顶点 A 到顶点 B 的距离</p>
<p>也就是说，拿出所有的顶点 K，判断经过顶点 K 是否存在一条可行路径比直达的路径的权值小，如果式子成立，说明确实存在 一条权值更小的路径，此时只需要更新记录的权值和即可</p>
<p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/w5vzrhAyQ8L6cZV.png" alt="image-20220523142527193"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dist[VertexMax][VertexMax];</span><br><span class="line"><span class="keyword">int</span> path[VertexMax][VertexMax];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShortestPath_Floyd</span><span class="params">(MGraph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j,k;</span><br><span class="line">    <span class="comment">//初始化部分</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			dist[i][j]=G.AdjMatrix[i][j];</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(dist[i][j]!=MaxInt)</span><br><span class="line">		            &#123;</span><br><span class="line">		              	path[i][j]=i;<span class="comment">//存入前驱 </span></span><br><span class="line">					&#125;</span><br><span class="line">			<span class="keyword">else</span> path[i][j]=<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">   <span class="comment">//Floyd算法核心部分</span></span><br><span class="line">	<span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;G.vexnum;k++)<span class="comment">//拿出每个顶点作为遍历条件</span></span><br><span class="line">	 <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">	  <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;j++)</span><br><span class="line">	   &#123;</span><br><span class="line">	   	    <span class="keyword">if</span>(dist[i][j]&gt;dist[i][k]+dist[k][j])</span><br><span class="line">	   	    &#123;</span><br><span class="line">	   	    	dist[i][j]=dist[i][k]+dist[k][j];</span><br><span class="line">	   	    	path[i][j]=path[k][j];<span class="comment">//存入前驱 </span></span><br><span class="line">			&#125; </span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">&#125;	  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/coYdWz1hGAVp2B7.png" alt="image-20220523142855434"></p>
<hr>
<h2 id="有向无环图描述表达式"><a href="#有向无环图描述表达式" class="headerlink" title="有向无环图描述表达式"></a>有向无环图描述表达式</h2><ol>
<li>把各个操作数不重复地排成一排</li>
<li>标出各个运算符的生效顺序</li>
<li>按顺序加入运算符，注意分层</li>
<li>从底向上逐层检查同层的运算符是否可以合体</li>
</ol>
<p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/CUnbVxqmprfkwL5.png" alt="image-20220523144808573" style="zoom:67%;" /></p>
<hr>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>AOV网（Activity On Vertex NetWork）：用顶点表示活动，边表示活动发生的 <strong>先后关系</strong></p>
<p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/CLkYwEX1WgKHPoN.png" alt="image-20220523152946305"></p>
<p>拓扑序列：在AOV网（无环图）中，由顶点$V_i$到顶点$V_j$有一条路径，则在该线性序列中的顶点$V_i$必定在顶点$V_j$之前。</p>
<p><strong>拓扑排序</strong>：将AOV网中的顶点序列排成拓扑序列就叫拓扑排序。</p>
<p>拓扑排序条件：必须是<strong>有向无环图</strong>（Directed Acycline Graph），AOV网满足有向无环图条件，若是有向成环图，则会进入死循环。</p>
<div class="note primary flat"><p>有向无环图只在意图中是否有环，即使不是连通图，也可以是有向无环图</p>
</div>
<p>拓扑排序的执行过程相当于每次 删去<strong>入度为0的顶点</strong>和<strong>这个顶点发射出去的边</strong>，那么我们每次删去一个顶点和其发射边，就会生成一个新图，在这个新图上继续执行删去<strong>入度为0的顶点</strong>和<strong>这个顶点发射出去的边</strong>，直到所有顶点都被删完。删除每个顶点的顺序，就是拓扑序列</p>
<p>步骤：</p>
<ol>
<li>我们首先找到入度为0的顶点，然后对其进行输出，接着根据邻接表的邻接关系，找到与其邻接的其他顶点，再去对其他顶点进行相同的处理，由此往复。</li>
<li>我们需要一个 <strong>临时存取空间space</strong>，我们每次把入度为0的顶点放入space中，然后按顺序（顺序可以从头开始、从尾开始、甚至可以任意取）从space中取出，然后进行<strong>步骤1</strong>的处理，再将更新后入度为0的顶点放入space中，直到space中的元素被取空，即拓扑排序结束。</li>
<li><strong>临时存取空间space的存取顺序可以是任意的</strong>，所以，这个space可以是栈结构，队列结构，也可以是一个数组，甚至可以是其他（源代码用数组模拟栈结构）。由此可见，存取顺序的不同，直接导致了拓扑排序结果不唯一。</li>
<li>总结一下拓扑排序在程序中的执行流程：首先我们搞了一个<strong>临时存储空间space</strong>，然后将入度为0的顶点放入space，再按顺序取出，每去取出一次，就根据邻接表的邻接关系，查找当前取出的顶点的邻接点，对每个邻接点入度-1，更新完入度后，看看有没有出现新的入度为0的结点，将其放入space中，直到space为空时，即所有顶点处理完毕，输出的序列就是拓扑序列</li>
</ol>
<p>邻接表法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>//边表 </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> adjvex;<span class="comment">//存储的是该顶点在顶点数组即AdjList[]中的位置 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span> //单个顶点 </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> data;  <span class="comment">//数据域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">firstarc</span>;</span>   <span class="comment">//第一个孩子节点</span></span><br><span class="line">&#125;VNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> //顶点表 </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	VNode AdjList[MAX];<span class="comment">//由顶点构成的结构体数组 </span></span><br><span class="line">	<span class="keyword">int</span> vexnum,arcnum; <span class="comment">//顶点数n和边数e </span></span><br><span class="line">&#125;ALGraph;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> indegree[MAX];<span class="comment">//用来存储所有节点的入度之和</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindInputDgeree</span><span class="params">(ALGraph G)</span></span>&#123;<span class="comment">//计算所有节点的入度</span></span><br><span class="line">	ArcNode *p;   <span class="comment">//临时边表变量</span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; i ++)</span><br><span class="line">		indegree[i] = <span class="number">0</span>;         <span class="comment">//初始化入度数组</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; i ++)&#123;</span><br><span class="line">		p = G.AdjList[i].firstarc;    <span class="comment">//p设置为顶点的第一条边</span></span><br><span class="line"> </span><br><span class="line">		<span class="keyword">while</span>(p)&#123;            <span class="comment">//如果边不为空</span></span><br><span class="line">			indegree[p-&gt;adjvex] ++;  <span class="comment">//顶点的对应位置的度+1</span></span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TopologicalSort</span><span class="params">(ALGraph *G)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"> <span class="comment">//用于统计拓扑排序生成的结点数（若生成结点数 &lt; 图的结点数，则代表图中有环，拓扑排序不成功） </span></span><br><span class="line"> <span class="comment">//顺便检测了图中是否存在环</span></span><br><span class="line">    SqStack S;   <span class="comment">//文中说的space就是此处的栈结构</span></span><br><span class="line">    ArcNode *p;<span class="comment">//临时边表变量 </span></span><br><span class="line">    </span><br><span class="line">    InitStack(S);   <span class="comment">//初始化栈</span></span><br><span class="line">    </span><br><span class="line">	FindInputDegree(G); <span class="comment">//求入度</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.初始化部分：将初始入度为0的顶点序号入栈</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;vexnum;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(indegree[i]==<span class="number">0</span>)   </span><br><span class="line">		&#123;</span><br><span class="line">			Push(S,i);    </span><br><span class="line">		&#125;	</span><br><span class="line">	&#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.拓扑排序</span></span><br><span class="line">    <span class="keyword">while</span>(!StackEmpty(S))&#123;</span><br><span class="line">		Pop(S,i);    <span class="comment">//pop操作会改变i的值</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,G.AdjList[i].data);	 <span class="comment">//输出栈顶元素 </span></span><br><span class="line">                count++;</span><br><span class="line"> </span><br><span class="line">		p = G.AdjList[i].firstarc;  <span class="comment">//p为结点的第一条边</span></span><br><span class="line">		<span class="keyword">while</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">             indegree[p-&gt;adjvex]--;       <span class="comment">//p-&gt;adjvex代表的的A--&gt;B中的B的序号1</span></span><br><span class="line">			<span class="keyword">if</span>(indegree[p-&gt;adjvex]==<span class="number">0</span>)<span class="comment">//判断去掉一条边后节点的入度是否为零</span></span><br><span class="line">            &#123;</span><br><span class="line">                Push(S,p-&gt;adjvex);  <span class="comment">//如果入度为0，压入栈中</span></span><br><span class="line">            &#125;</span><br><span class="line">			p = p-&gt;next;     <span class="comment">//下一条边</span></span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//4.判断拓扑排序是否成功（生成结点数 &lt; 图的结点数，则代表图中有环，拓扑排序不成功） </span></span><br><span class="line">	<span class="keyword">if</span>(count&lt;G-&gt;vexnum) </span><br><span class="line">	   <span class="built_in">printf</span>(<span class="string">&quot;TopologicalSort Failed!\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span>;     </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>邻接矩阵法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接矩阵实现拓扑排序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindInDegree</span><span class="params">(MGraph G)</span></span>&#123;<span class="comment">//计算图中各节点的入度</span></span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; i ++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.vexnum; j ++)</span><br><span class="line">			<span class="keyword">if</span>(G.AdjMatrix[i][j])<span class="comment">//当两顶点之间存在边时，入度自加</span></span><br><span class="line">				indegree[j] ++;  <span class="comment">//列表示入度</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TopologicalSort</span><span class="params">(MGraph G)</span></span>&#123;</span><br><span class="line">	FindInDegree(G);</span><br><span class="line">	SqStack S;                <span class="comment">//使用栈存储</span></span><br><span class="line">	<span class="keyword">int</span> i,j,count = <span class="number">0</span>;</span><br><span class="line">	InitStack(S);           <span class="comment">//初始化栈</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; i ++)</span><br><span class="line">		<span class="keyword">if</span>(indegree[i]==<span class="number">0</span>)</span><br><span class="line">			Push(S,i);<span class="comment">//把入度为零的节点压栈</span></span><br><span class="line">     </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;拓扑序列如下:\n&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span>(!StackEmpty(S))&#123;</span><br><span class="line">		Pop(S,i);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,G.Vertex[i]);		</span><br><span class="line">         count ++;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.vexnum; j ++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(G.AdjMatrix[i][j]！=<span class="number">0</span>)&#123;</span><br><span class="line">                indegree[j]--;       <span class="comment">//删除出栈结点向对应的边，让其相邻结点的入度-1</span></span><br><span class="line">				<span class="keyword">if</span>(indegree[j]==<span class="number">0</span>)   <span class="comment">//如果入度为0，进栈</span></span><br><span class="line">					Push(S,j);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span>(count &lt; G.vexnum)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;此图有环存在!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note primary flat"><p><strong>拓扑排序可以判断图中是否存在环</strong></p>
</div>
<hr>
<p>逆拓扑排序：根据拓扑排序的思路，如果用逆邻接表来存储图，先输出出度为为0的结点，自然构成了逆拓扑排序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(MGraph* G, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1.处理起始点 </span></span><br><span class="line"></span><br><span class="line">	visitedDFS[i] = <span class="number">1</span>;<span class="comment">//2.将已访问的结点标志成1</span></span><br><span class="line"></span><br><span class="line">	 <span class="comment">//2.由起始点开始，对后续结点进行操作</span></span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G-&gt;vexnum; j++)<span class="comment">//依次搜索vi的邻接点 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (G-&gt;AdjMatrix[i][j] == <span class="number">1</span> &amp;&amp; visitedDFS[j] == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//当满足有边且未被访问过时，递归调用去查找该邻接点 </span></span><br><span class="line">		&#123;</span><br><span class="line">			DFS(G, j);<span class="comment">//注意此处的G已经是指针类型，不需要再&amp;G </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, G-&gt;Vertex[i]);<span class="comment">//逆拓扑排序，在出栈时输出 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此，DFS当然也可以用于拓扑排序，只要用队列来存储访问到的结点，就是拓扑排序</p>
<div class="note prime flat"><p>不如说，利用队列+DFS的方法是代码量最少实现拓扑排序的办法</p>
</div>
<p>时间复杂度：邻接表：<code>O(V+E)</code>  邻接矩阵：<code>O(V²)</code></p>
<hr>
<h2 id="判断图中是否有环"><a href="#判断图中是否有环" class="headerlink" title="判断图中是否有环"></a>判断图中是否有环</h2><p><strong>DFS</strong></p>
<p>思路如下，在利用DFS遍历节点时，将遍历节点的<code>visitedDFS[i]</code>数组设置为-1，表示正在访问，如果在之后的递归过程中发现有节点的<code>visitedDFS[i]</code>为-1，则表示有环</p>
<p>这种方法只能用于有向图，如果要用DFS检测无向图的环，需要一个<code>parent</code>数组记录其父节点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(MGraph* G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="comment">//初始化&quot;标志&quot;数组为0，代表未访问</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		visitedDFS[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (visitedDFS[i] == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> x;</span><br><span class="line">			x= DFS(G, i);<span class="comment">//注意此处的G已经是指着类型，不需要再&amp;G </span></span><br><span class="line">			<span class="keyword">if</span> (x == <span class="literal">false</span>) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;false&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*深度优先遍历DFS*/</span></span><br><span class="line"><span class="keyword">int</span> visitedDFS[VertexMax];<span class="comment">//定义&quot;标志&quot;数组为全局变量 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DFS</span><span class="params">(MGraph* G, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="comment">//1.处理起始点 </span></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">1</span> == visitedDFS[i])</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="number">-1</span> == visitedDFS[i])</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	visitedDFS[i] = <span class="number">-1</span>;</span><br><span class="line">	 <span class="comment">//2.由起始点开始，对后续结点进行操作</span></span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G-&gt;vexnum; j++)<span class="comment">//依次搜索vi的邻接点 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (G-&gt;AdjMatrix[i][j] == <span class="number">1</span>)<span class="comment">//当满足有边时，递归调用去查找该邻接点 </span></span><br><span class="line">    <span class="comment">//此处要把visitedDFS[j] == 0的条件删掉，因为有向无环图是不可能递归到父节点的</span></span><br><span class="line">		&#123;</span><br><span class="line">			DFS(G, j);<span class="comment">//注意此处的G已经是指针类型，不需要再&amp;G </span></span><br><span class="line">			<span class="keyword">if</span> (DFS(G,j) == <span class="literal">false</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	visitedDFS[i] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>拓扑排序</strong></p>
<p>在上一小节中已经使用了拓扑排序来判断是否存在有向环了，而使用拓扑排序同样可以判断一个无向图中是否存在环，只要将入栈条件从度为0的结点，改成度为0或1的结点即可</p>
<hr>
<p><strong>并查集</strong></p>
<p>并查集可以找到无向图的环，在最小生成树的克鲁斯卡尔算法（使用了边集数组）中，就已经使用了并查集来寻找图中的环</p>
<hr>
<p>总结<br>无向图：</p>
<ul>
<li>DFS(需要数组记录父节点)</li>
<li>拓扑排序(将度为0和1的结点压入栈)</li>
<li>并查集(克鲁斯卡尔算法)</li>
</ul>
<p>有向图：</p>
<ul>
<li>DFS(给visit数组多设置一个状态变量表示正在搜索)</li>
<li>拓扑排序(将度为1的结点压入栈)</li>
</ul>
<hr>
<h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h2><p><strong>AOE网（Activity On Edge NetWork）</strong>：在带权有向图中若以顶点表示事件，有向边表示活动，边上的权值表示该活动持续的时间，AOE网通常用于 <strong>估算事件/工程完成的工期（时间）</strong></p>
<p>从定义上来看，很容易看出两种网的不同，AOV网的活动以顶点表示，而AOE网的活动以有向边来表示，<strong>AOV网的有向边仅仅表示活动的先后次序</strong>。纵观这两种网图，其实它们总体网络结构是一样的，仅仅是活动所表示的方式不同，因此可以猜想从AOV网转换成AOE网应该是可行的</p>
<p><strong>关键路径</strong>：在AOE网中仅有一个入度为0的点，称为开始顶点，它表示整个工程的开始，也仅有一个出度为0的点，称为结束顶点，代表整个工程的结束，这两个点之间的距离有很多条，<strong>在所有路径中，具有最大路径长度的路径称为关键路径，而把关键路径上的活动称为关键活动</strong></p>
<div class="note primary flat"><p>所以求关键路径非常简单，只需要在图中找出权值和最大的一条或多条路即可，关键活动的最早和最晚发生时间一致，而非关键活动的最晚发生时间只需要和关键活动同时发生就行了</p>
</div>
<p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/Uckt7lqYhPpGEK8.png" alt="image-20220523160028568"></p>
<ol>
<li>事件$v_i$的最早发生时间ve(i)：事件$v_i$的最早发生时间是等待$v_i$之前的所有活动都完成，所以ve(i)是从源点到vi的最长路径长度。起始点（源点）的最早发生时间为0。（$v_k$是$v_i$的前驱事件）<br>所以可以推出：<br><code>ve(0) = 0;</code>（源点的<strong>最早发生时间</strong>为0）<br><code>i∈[1,n]时，ve(i) = Max&#123; ve(k) + weight（k-&gt;i）&#125; ;</code></li>
<li>事件$v_i$的最晚发生时间vl(i)：不拖延工期的前提下，事件vi被允许的最晚发生时间。（$v_k$是$v_i$的后续事件）活动ai=&lt;$v_i$,$v_k$&gt;,$v_i$的最晚发生时间，取决于这个活动<strong>被允许的最晚结束时间</strong>，而所被<strong>允许的最晚结束时间</strong>也正是vk的最晚开始时间，也就是vl（k），所以我们就得到等式:<br><code>最晚发生时间vl（i）+ 活动持续时间weight = 最晚结束时间vl（k）</code><br>所以可以推出：<br><code>vl(n-1) = ve(n-1);</code>（汇点的<strong>最早发生时间</strong>与<strong>最晚发生时间</strong>相等）<br><code>i∈[0,n-2]时，vl(i) = Min&#123; vl(k) - weight（i-&gt;k）&#125; ;</code></li>
</ol>
<hr>
<p>步骤：</p>
<ol>
<li>求出事件最早发生时间ve[i]：顺拓扑序</li>
<li>求出事件最晚发生时间vl[i]：逆拓扑序</li>
<li>通过ve[i]和vl[i]计算出活动最早开始时间（e） 与 活动最晚开始时间（l）</li>
<li>若<code>e(i)==l(i)</code>则当前i所指向的活动是关键活动（Critical Activity）</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CriticalPath</span><span class="params">(ALGraph *G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> j,k;<span class="comment">// &lt;Vj,Vk&gt;</span></span><br><span class="line">	<span class="keyword">int</span> e,l;<span class="comment">//活动最早开始时间/活动最晚开始时间  </span></span><br><span class="line">	<span class="keyword">int</span> topo[VertexMax];<span class="comment">//拓扑数组，用于存储拓扑排序结果（存储内容是每个结点的坐标） </span></span><br><span class="line">	<span class="keyword">int</span> ve[VertexMax]; <span class="comment">//事件vi的最早发生时间 </span></span><br><span class="line">	<span class="keyword">int</span> vl[VertexMax]; <span class="comment">//事件vi的最晚发生时间 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">p</span>;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//1.调用拓扑排序，检测图是否存在环 </span></span><br><span class="line">	<span class="keyword">if</span>(!TopologicalSort(G,topo))<span class="comment">//若拓扑排序成功，topo数组也将处理完毕 </span></span><br><span class="line">		 <span class="keyword">return</span>; </span><br><span class="line">		 </span><br><span class="line">	<span class="comment">//2.正拓扑排序，求出事件最早发生时间 </span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;vexnum;i++)</span><br><span class="line">	    ve[i]=<span class="number">0</span>;<span class="comment">//所有ve都初始化为0</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;vexnum;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		j=topo[i];<span class="comment">//j为起始点，k为终点 </span></span><br><span class="line">		p=G-&gt;AdjList[j].firstarc;<span class="comment">//用指针p去依次寻找j的每一个邻接点 </span></span><br><span class="line">		<span class="keyword">while</span>(p)</span><br><span class="line">		&#123;</span><br><span class="line">			k=p-&gt;adjvex;</span><br><span class="line">			<span class="keyword">if</span>(ve[k]&lt;ve[j]+p-&gt;weight)</span><br><span class="line">             <span class="comment">//根据j的邻接点k，不断更新ve[]的值（选出最大值，原理类似于选择排序） </span></span><br><span class="line">			&#123;</span><br><span class="line">				ve[k]=ve[j]+p-&gt;weight;</span><br><span class="line">			&#125;</span><br><span class="line">			p=p-&gt;next;    </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	 </span><br><span class="line">	<span class="comment">//3.逆拓扑排序，求出事件最迟发生时间 </span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;vexnum;i++)</span><br><span class="line">	    vl[i]=ve[G-&gt;vexnum<span class="number">-1</span>];<span class="comment">//所有vl都初始化为ve[G-&gt;vexnum-1]</span></span><br><span class="line">	<span class="keyword">for</span>(i=G-&gt;vexnum<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		j=topo[i];</span><br><span class="line">		p=G-&gt;AdjList[j].firstarc;<span class="comment">//让p去依次查找邻接点 </span></span><br><span class="line">		<span class="keyword">while</span>(p)</span><br><span class="line">		&#123;</span><br><span class="line">			k=p-&gt;adjvex;</span><br><span class="line">			<span class="keyword">if</span>(vl[j]&gt;vl[k]-p-&gt;weight)</span><br><span class="line">               <span class="comment">//根据j的邻接点k，不断更新vl[]的值（选出最小值，原理类似于选择排序）</span></span><br><span class="line">			&#123;</span><br><span class="line">				vl[j]=vl[k]-p-&gt;weight;</span><br><span class="line">			&#125;</span><br><span class="line">			p=p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;      	 </span><br><span class="line">	<span class="comment">//4.计算e和l，通过判断e是否等于l确定该活动是否是关键活动，从而确定关键路径</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;vexnum;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		p=G-&gt;AdjList[i].firstarc;<span class="comment">//让p去依次查找邻接点 </span></span><br><span class="line">		<span class="keyword">while</span>(p)</span><br><span class="line">		&#123;</span><br><span class="line">			j=p-&gt;adjvex;</span><br><span class="line">			e=ve[i];<span class="comment">//计算活动最早开始时间 e </span></span><br><span class="line">			l=vl[j]-p-&gt;weight;<span class="comment">//计算活动最晚开始时间 l </span></span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(e==l)<span class="comment">//如果e=l，说明该活动是关键活动 </span></span><br><span class="line">			&#123;</span><br><span class="line">			    <span class="comment">//把每个关键活动输出，即是关键路径</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\t%c-&gt;%c(%d)\n&quot;</span>,G-&gt;AdjList[i].vertex,G-&gt;AdjList[j].vertex,p-&gt;weight);</span><br><span class="line">			&#125;</span><br><span class="line">			p=p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post_share"><div class="social-share" data-image="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/data.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/social-share.js/1.0.16/css/share.min.css" media="print" onload="this.media='all'"><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/social-share.js/1.0.16/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/30685.html"><img class="prev-cover" src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/data.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">5.树</div></div></a></div><div class="next-post pull-right"><a href="/post/12586.html"><img class="next-cover" src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/data.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">7.查找</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Candle</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">195</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number">1.</span> <span class="toc-text">图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">逻辑结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%B4%A8"><span class="toc-number">1.1.3.</span> <span class="toc-text">性质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E6%B3%95"><span class="toc-number">1.2.1.</span> <span class="toc-text">邻接矩阵法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8%E6%B3%95"><span class="toc-number">1.2.2.</span> <span class="toc-text">邻接表法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8"><span class="toc-number">1.2.3.</span> <span class="toc-text">邻接多重表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%E6%B3%95"><span class="toc-number">1.2.4.</span> <span class="toc-text">十字链表法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%8D%E5%8E%86"><span class="toc-number">1.3.</span> <span class="toc-text">遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86-BFS"><span class="toc-number">1.3.1.</span> <span class="toc-text">广度优先遍历(BFS)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86-DFS"><span class="toc-number">1.3.2.</span> <span class="toc-text">深度优先遍历(DFS)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">1.4.</span> <span class="toc-text">最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%87%8C%E5%A7%86%E7%AE%97%E6%B3%95-Prim"><span class="toc-number">1.4.1.</span> <span class="toc-text">普里姆算法(Prim)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95-Kruskal"><span class="toc-number">1.4.2.</span> <span class="toc-text">克鲁斯卡尔算法(Kruskal)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.5.</span> <span class="toc-text">最短路径问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95-Dijkstra"><span class="toc-number">1.5.1.</span> <span class="toc-text">迪杰斯特拉算法(Dijkstra)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95%EF%BC%88Floyd%EF%BC%89"><span class="toc-number">1.5.2.</span> <span class="toc-text">弗洛伊德算法（Floyd）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E6%8F%8F%E8%BF%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.6.</span> <span class="toc-text">有向无环图描述表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">1.7.</span> <span class="toc-text">拓扑排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%9B%BE%E4%B8%AD%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF"><span class="toc-number">1.8.</span> <span class="toc-text">判断图中是否有环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="toc-number">1.9.</span> <span class="toc-text">关键路径</span></a></li></ol></li></ol></div></div><div class="card-widget card-recommend-post"><div class="item-headline"><i class="fas fa-dharmachakra"></i><span>相关推荐</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/10659.html" title="1.绪论"><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/data.png" alt="1.绪论"></a><div class="content"><a class="title" href="/post/10659.html" title="1.绪论">1.绪论</a><time datetime="2023-12-21" title="������ 2023-12-21">2023-12-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/6371.html" title="874数据结构大题"><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/data.png" alt="874数据结构大题"></a><div class="content"><a class="title" href="/post/6371.html" title="874数据结构大题">874数据结构大题</a><time datetime="2023-12-21" title="������ 2023-12-21">2023-12-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/42354.html" title="2.线性表"><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/data.png" alt="2.线性表"></a><div class="content"><a class="title" href="/post/42354.html" title="2.线性表">2.线性表</a><time datetime="2023-12-21" title="������ 2023-12-21">2023-12-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/5702.html" title="4.字符串"><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/data.png" alt="4.字符串"></a><div class="content"><a class="title" href="/post/5702.html" title="4.字符串">4.字符串</a><time datetime="2023-12-21" title="������ 2023-12-21">2023-12-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/43592.html" title="3.栈和队列"><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/data.png" alt="3.栈和队列"></a><div class="content"><a class="title" href="/post/43592.html" title="3.栈和队列">3.栈和队列</a><time datetime="2023-12-21" title="������ 2023-12-21">2023-12-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/30685.html" title="5.树"><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/data.png" alt="5.树"></a><div class="content"><a class="title" href="/post/30685.html" title="5.树">5.树</a><time datetime="2023-12-21" title="������ 2023-12-21">2023-12-21</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2024 By Candle</div><div class="framework-info"><span>Powered by </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a></div><div class="footer_custom_text">So Long, and Thanks for All the Fish</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/node-snackbar/0.1.16/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-y/mathjax/3.2.0/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script src="https://npm.elemecdn.com/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.removeEventListener('scroll', window.tocScrollFn)
  window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>