<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>9.0 现代循环神经网络</title>
      <link href="/post/6823.html"/>
      <url>/post/6823.html</url>
      
        <content type="html"><![CDATA[<h1 id="现代循环神经网络"><a href="#现代循环神经网络" class="headerlink" title="现代循环神经网络"></a>现代循环神经网络</h1><h2 id="门控循环单元GRU"><a href="#门控循环单元GRU" class="headerlink" title="门控循环单元GRU"></a>门控循环单元GRU</h2><p>并非所有的观测值都有意义，也不是所有的观测值都一样重要</p><ul><li>可能会遇到这样的情况：早期观测值对预测所有未来观测值具有非常重要的意义。 考虑一个极端情况，其中第一个观测值包含一个校验和， 目标是在序列的末尾辨别校验和是否正确。 在这种情况下，第一个词元的影响至关重要。 我们希望有某些机制能够在一个记忆元里<strong>存储重要的早期信息</strong>。 如果没有这样的机制，我们将不得不给这个观测值指定一个非常大的梯度， 因为它会影响所有后续的观测值。</li><li>我们可能会遇到这样的情况：一些词元没有相关的观测值。 例如，在对网页内容进行情感分析时， 可能有一些辅助HTML代码与网页传达的情绪无关。 我们希望有一些机制来<strong><em>跳过</em></strong>隐状态表示中的此类词元。</li><li>我们可能会遇到这样的情况：序列的各个部分之间存在逻辑中断。 例如，书的章节之间可能会有过渡存在， 或者证券的熊市和牛市之间可能会有过渡存在。 在这种情况下，最好有一种方法来<strong><em>重置</em></strong>我们的内部状态表示。</li></ul><hr><h3 id="门控隐状态"><a href="#门控隐状态" class="headerlink" title="门控隐状态"></a>门控隐状态</h3><p>门控循环单元与普通的循环神经网络之间的关键区别在于： 前者支持隐状态的门控。 这意味着模型有专门的机制来确定应该何时更新隐状态， 以及应该何时重置隐状态</p><p>这些机制是<strong>可学习</strong>的，并且能够解决了上面列出的问题。 例如，如果第一个词元非常重要， 模型将学会在第一次观测之后不更新隐状态。 同样，模型也可以学会跳过不相关的临时观测。 最后，模型还将学会在需要的时候重置隐状态。 下面我们将详细讨论各类门控。</p><p><strong>重置门和更新门</strong></p><p>首先介绍<strong><em>重置门</em></strong>（reset gate）和<strong><em>更新门</em></strong>（update gate）。 我们把它们设计成(0,1)区间中的向量， 这样我们就可以进行凸组合。 重置门允许我们控制“可能还想记住”的过去状态的数量； 更新门将允许我们控制新状态中有多少个是旧状态的副本。</p><p>我们从构造这些门控开始。 图描述了门控循环单元中的重置门和更新门的输入， 输入是由当前时间步的输入和前一时间步的隐状态给出。 两个门的输出是由使用sigmoid激活函数的两个全连接层给出。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoragru-1.svg" alt="../_images/gru-1.svg"></p><p>对于给定的时间步$t$，假设输入是一个小批量$\mathbf{X}_t \in \mathbb{R}^{n \times d}$（样本个数$n$，输入个数$d$），上一个时间步的隐状态是$\mathbf{H}_{t-1} \in \mathbb{R}^{n \times h}$（隐藏单元个数$h$）。那么，重置门$\mathbf{R}_t \in \mathbb{R}^{n \times h}$和更新门$\mathbf{Z}_t \in \mathbb{R}^{n \times h}$的计算如下所示：</p><script type="math/tex; mode=display">\begin{aligned}\mathbf{R}_t = \sigma(\mathbf{X}_t \mathbf{W}_{xr} + \mathbf{H}_{t-1} \mathbf{W}_{hr} + \mathbf{b}_r),\\\mathbf{Z}_t = \sigma(\mathbf{X}_t \mathbf{W}_{xz} + \mathbf{H}_{t-1} \mathbf{W}_{hz} + \mathbf{b}_z),\end{aligned}</script><p>其中$\mathbf{W}_{xr}, \mathbf{W}_{xz} \in \mathbb{R}^{d \times h}$和$\mathbf{W}_{hr}, \mathbf{W}_{hz} \in \mathbb{R}^{h \times h}$是权重参数，$\mathbf{b}_r, \mathbf{b}_z \in \mathbb{R}^{1 \times h}$是偏置参数。请注意，在求和过程中会触发广播机制，我们使用sigmoid函数将输入值转换到区间$(0, 1)$。</p><hr><p><strong>候选隐状态</strong></p><p>接下来，让我们将重置门$\mathbf{R}_t$与RNN中的常规隐状态更新机制集成，得到在时间步$t$的<strong>候选隐状态</strong>$\tilde{\mathbf{H}}_t \in \mathbb{R}^{n \times h}$</p><script type="math/tex; mode=display">\tilde{\mathbf{H}}_t = \tanh(\mathbf{X}_t \mathbf{W}_{xh} + \left(\mathbf{R}_t \odot \mathbf{H}_{t-1}\right) \mathbf{W}_{hh} + \mathbf{b}_h)</script><p>其中$\mathbf{W}_{xh} \in \mathbb{R}^{d \times h}$和$\mathbf{W}_{hh} \in \mathbb{R}^{h \times h}$是权重参数，$\mathbf{b}_h \in \mathbb{R}^{1 \times h}$是偏置项，符号$\odot$是Hadamard积（按元素乘积）运算符。在这里，我们使用$tanh$非线性激活函数来确保候选隐状态中的值保持在区间$(-1, 1)$中。</p><p>与常规公式相比，候选隐状态中的$\mathbf{R}_t$和$\mathbf{H}_{t-1}$的元素相乘可以减少以往状态的影响。每当重置门$\mathbf{R}_t$中的项接近$1$时，我们恢复一个普通的循环神经网络。当重置门中的项接近0时，意味着忽略之前的隐状态，让模型“忘记”之前的信息。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoragru-2.svg" alt="../_images/gru-2.svg"></p><hr><p><strong>隐状态</strong></p><p>上述的计算结果只是候选隐状态，我们仍然需要结合更新门$\mathbf{Z}_t$的效果。这一步确定新的隐状态$\mathbf{H}_t \in \mathbb{R}^{n \times h}$在多大程度上来自旧的状态$\mathbf{H}_{t-1}$和新的候选状态$\tilde{\mathbf{H}}_t$。更新门$\mathbf{Z}_t$仅需要在$\mathbf{H}_{t-1}$和$\tilde{\mathbf{H}}_t$之间进行按元素的凸组合就可以实现这个目标。</p><p>这就得出了门控循环单元的最终更新公式：</p><script type="math/tex; mode=display">\mathbf{H}_t = \mathbf{Z}_t \odot \mathbf{H}_{t-1}  + (1 - \mathbf{Z}_t) \odot \tilde{\mathbf{H}}_t</script><p>每当更新门$\mathbf{Z}_t$接近$1$时，模型就倾向只保留旧状态。此时，来自$\mathbf{X}_t$的信息基本上被忽略，从而有效地跳过了依赖链条中的时间步$t$。相反，当$\mathbf{Z}_t$接近$0$时，新的隐状态$\mathbf{H}_t$就会接近候选隐状态$\tilde{\mathbf{H}}_t$。</p><p>这些设计可以帮助我们处理循环神经网络中的梯度消失问题，并更好地捕获时间步距离很长的序列的依赖关系。例如，如果整个子序列的所有时间步的更新门都接近于$1$，则无论序列的长度如何，在序列起始时间步的旧隐状态都将很容易保留并传递到序列结束。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoragru-3.svg" alt="../_images/gru-3.svg"></p><p>总之，门控循环单元具有以下两个显著特征：</p><ul><li>重置门有助于捕获序列中的短期依赖关系；</li><li>更新门有助于捕获序列中的长期依赖关系。</li></ul><hr><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import torch</span><br><span class="line">from torch import nn</span><br><span class="line">from d2l import torch as d2l</span><br><span class="line"></span><br><span class="line">batch_size, num_steps = 32, 35</span><br><span class="line">train_iter, vocab = d2l.load_data_time_machine(batch_size, num_steps)</span><br></pre></td></tr></table></figure><p>下一步是初始化模型参数。 我们从标准差为0.01的高斯分布中提取权重， 并将偏置项设为0，超参数<code>num_hiddens</code>定义隐藏单元的数量， 实例化与更新门、重置门、候选隐状态和输出层相关的所有权重和偏置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_params</span>(<span class="params">vocab_size, num_hiddens, device</span>):</span></span><br><span class="line">    num_inputs = num_outputs = vocab_size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">normal</span>(<span class="params">shape</span>):</span></span><br><span class="line">        <span class="keyword">return</span> torch.randn(size=shape, device=device)*<span class="number">0.01</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">three</span>():</span></span><br><span class="line">        <span class="keyword">return</span> (normal((num_inputs, num_hiddens)),</span><br><span class="line">                normal((num_hiddens, num_hiddens)),</span><br><span class="line">                torch.zeros(num_hiddens, device=device))</span><br><span class="line"></span><br><span class="line">    W_xz, W_hz, b_z = three()  <span class="comment"># 更新门参数</span></span><br><span class="line">    W_xr, W_hr, b_r = three()  <span class="comment"># 重置门参数</span></span><br><span class="line">    W_xh, W_hh, b_h = three()  <span class="comment"># 候选隐状态参数</span></span><br><span class="line">    <span class="comment"># 输出层参数</span></span><br><span class="line">    W_hq = normal((num_hiddens, num_outputs))</span><br><span class="line">    b_q = torch.zeros(num_outputs, device=device)</span><br><span class="line">    <span class="comment"># 附加梯度</span></span><br><span class="line">    params = [W_xz, W_hz, b_z, W_xr, W_hr, b_r, W_xh, W_hh, b_h, W_hq, b_q]</span><br><span class="line">    <span class="keyword">for</span> param <span class="keyword">in</span> params:</span><br><span class="line">        param.requires_grad_(<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> params</span><br></pre></td></tr></table></figure><p>现在我们将定义隐状态的初始化函数<code>init_gru_state</code>。 与在循环网络RNN中定义的<code>init_rnn_state</code>函数一样， 此函数返回一个形状为（批量大小，隐藏单元个数）的张量，张量的值全部为零。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_gru_state</span>(<span class="params">batch_size, num_hiddens, device</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (torch.zeros((batch_size, num_hiddens), device=device), )</span><br></pre></td></tr></table></figure><p>现在我们准备定义门控循环单元模型， 模型的架构与基本的循环神经网络单元是相同的， 只是权重更新公式更为复杂。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gru</span>(<span class="params">inputs, state, params</span>):</span></span><br><span class="line">    W_xz, W_hz, b_z, W_xr, W_hr, b_r, W_xh, W_hh, b_h, W_hq, b_q = params</span><br><span class="line">    H, = state</span><br><span class="line">    outputs = []</span><br><span class="line">    <span class="keyword">for</span> X <span class="keyword">in</span> inputs:</span><br><span class="line">        Z = torch.sigmoid((X @ W_xz) + (H @ W_hz) + b_z)</span><br><span class="line">        R = torch.sigmoid((X @ W_xr) + (H @ W_hr) + b_r)</span><br><span class="line">        H_tilda = torch.tanh((X @ W_xh) + ((R * H) @ W_hh) + b_h)</span><br><span class="line">        H = Z * H + (<span class="number">1</span> - Z) * H_tilda</span><br><span class="line">        Y = H @ W_hq + b_q</span><br><span class="line">        outputs.append(Y)</span><br><span class="line">    <span class="keyword">return</span> torch.cat(outputs, dim=<span class="number">0</span>), (H,)</span><br></pre></td></tr></table></figure><p>训练和预测的工作方式与循环神经网络RNN完全相同。 训练结束后，我们分别打印输出训练集的困惑度， 以及前缀“time traveler”和“traveler”的预测序列上的困惑度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vocab_size, num_hiddens, device = <span class="built_in">len</span>(vocab), <span class="number">256</span>, d2l.try_gpu()</span><br><span class="line">num_epochs, lr = <span class="number">500</span>, <span class="number">1</span></span><br><span class="line">model = d2l.RNNModelScratch(<span class="built_in">len</span>(vocab), num_hiddens, device, get_params,</span><br><span class="line">                            init_gru_state, gru)</span><br><span class="line">d2l.train_ch8(model, train_iter, vocab, lr, num_epochs, device)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">perplexity 1.1, 19911.5 tokens/sec on cuda:0</span></span><br><span class="line"><span class="string">time traveller firenis i heidfile sook at i jomer and sugard are</span></span><br><span class="line"><span class="string">travelleryou can show black is white by argument said filby</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraoutput_gru_b77a34_66_1.svg" alt="../_images/output_gru_b77a34_66_1.svg"></p><hr><p><strong>简洁实现</strong></p><p>高级API包含了前文介绍的所有配置细节， 所以我们可以直接实例化门控循环单元模型。 这段代码的运行速度要快得多， 因为它使用的是编译好的运算符而不是Python来处理之前阐述的许多细节。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num_inputs = vocab_size</span><br><span class="line">gru_layer = nn.GRU(num_inputs, num_hiddens)</span><br><span class="line">model = d2l.RNNModel(gru_layer, <span class="built_in">len</span>(vocab))</span><br><span class="line">model = model.to(device)</span><br><span class="line">d2l.train_ch8(model, train_iter, vocab, lr, num_epochs, device)</span><br></pre></td></tr></table></figure><hr><h2 id="长短期记忆网络LSTM"><a href="#长短期记忆网络LSTM" class="headerlink" title="长短期记忆网络LSTM"></a>长短期记忆网络LSTM</h2><h3 id="门控记忆元"><a href="#门控记忆元" class="headerlink" title="门控记忆元"></a>门控记忆元</h3><p>可以说，长短期记忆网络的设计灵感来自于计算机的逻辑门。 长短期记忆网络引入了<strong><em>记忆元</em></strong>（memory cell），或简称为<em>单元</em>（cell）。 有些文献认为记忆元是隐状态的一种特殊类型， 它们与隐状态具有相同的形状，其设计目的是用于记录附加的信息。 为了控制记忆元，我们需要许多门。 其中一个门用来从单元中输出条目，我们将其称为<strong><em>输出门</em></strong>（output gate）。 另外一个门用来决定何时将数据读入单元，我们将其称为<strong><em>输入门</em></strong>（input gate）。 我们还需要一种机制来重置单元的内容，由<strong><em>遗忘门</em></strong>（forget gate）来管理， 这种设计的动机与门控循环单元相同， 能够通过专用机制决定什么时候记忆或忽略隐状态中的输入。</p><p><strong>输入门，遗忘门，输出门</strong></p><p>就如在门控循环单元中一样， 当前时间步的输入和前一个时间步的隐状态 作为数据送入长短期记忆网络的门中， 如图所示。 它们由三个具有sigmoid激活函数的全连接层处理， 以计算输入门、遗忘门和输出门的值。 因此，这三个门的值都在(0,1)的范围内。<img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoralstm-0.svg" alt="../_images/lstm-0.svg"></p><p>我们来细化一下长短期记忆网络的数学表达。假设有$h$个隐藏单元，批量大小为$n$，输入数为$d$。</p><p>因此，输入为$\mathbf{X}_t \in \mathbb{R}^{n \times d}$，前一时间步的隐状态为$\mathbf{H}_{t-1} \in \mathbb{R}^{n \times h}$。</p><p>相应地，时间步$t$的门被定义如下：</p><p>输入门是$\mathbf{I}_t \in \mathbb{R}^{n \times h}$，</p><p>遗忘门是$\mathbf{F}_t \in \mathbb{R}^{n \times h}$，</p><p>输出门是$\mathbf{O}_t \in \mathbb{R}^{n \times h}$。</p><p>它们的计算方法如下：</p><script type="math/tex; mode=display">\begin{aligned}\mathbf{I}_t &= \sigma(\mathbf{X}_t \mathbf{W}_{xi} + \mathbf{H}_{t-1} \mathbf{W}_{hi} + \mathbf{b}_i),\\\mathbf{F}_t &= \sigma(\mathbf{X}_t \mathbf{W}_{xf} + \mathbf{H}_{t-1} \mathbf{W}_{hf} + \mathbf{b}_f),\\\mathbf{O}_t &= \sigma(\mathbf{X}_t \mathbf{W}_{xo} + \mathbf{H}_{t-1} \mathbf{W}_{ho} + \mathbf{b}_o),\end{aligned}</script><p>其中$\mathbf{W}_{xi}, \mathbf{W}_{xf}, \mathbf{W}_{xo} \in \mathbb{R}^{d \times h}$和$\mathbf{W}_{hi}, \mathbf{W}_{hf}, \mathbf{W}_{ho} \in \mathbb{R}^{h \times h}$是权重参数，$\mathbf{b}_i, \mathbf{b}_f, \mathbf{b}_o \in \mathbb{R}^{1 \times h}$是偏置参数。</p><hr><p><strong>候选记忆元</strong></p><p>由于还没有指定各种门的操作，所以先介绍<strong>候选记忆元</strong>（candidate memory cell）$\tilde{\mathbf{C}}_t \in \mathbb{R}^{n \times h}$。</p><p>它的计算与上面描述的三个门的计算类似，但是使用$\tanh$函数作为激活函数，函数的值范围为$(-1, 1)$。</p><p>下面导出在时间步$t$处的方程：</p><script type="math/tex; mode=display">\tilde{\mathbf{C}}_t = \text{tanh}(\mathbf{X}_t \mathbf{W}_{xc} + \mathbf{H}_{t-1} \mathbf{W}_{hc} + \mathbf{b}_c)</script><p>其中$\mathbf{W}_{xc} \in \mathbb{R}^{d \times h}$和$\mathbf{W}_{hc} \in \mathbb{R}^{h \times h}$是权重参数，$\mathbf{b}_c \in \mathbb{R}^{1 \times h}$是偏置参数。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoralstm-1.svg" alt="../_images/lstm-1.svg"></p><hr><p><strong>记忆元</strong></p><p>在门控循环单元中，有一种机制来控制输入和遗忘（或跳过）。类似地，在长短期记忆网络中，也有两个门用于这样的目的：输入门$\mathbf{I}_t$控制采用多少来自$\tilde{\mathbf{C}}_t$的新数据，而遗忘门$\mathbf{F}_t$控制保留多少过去的记忆元$\mathbf{C}_{t-1} \in \mathbb{R}^{n \times h}$的内容。</p><p>使用按元素乘法，得出：</p><script type="math/tex; mode=display">\mathbf{C}_t = \mathbf{F}_t \odot \mathbf{C}_{t-1} + \mathbf{I}_t \odot \tilde{\mathbf{C}}_t</script><p>如果遗忘门始终为$1$且输入门始终为$0$，则过去的记忆元$\mathbf{C}_{t-1}$将随时间被保存并传递到当前时间步。引入这种设计是为了缓解梯度消失问题，并更好地捕获序列中的长距离依赖关系。</p><p>这样我们就得到了计算记忆元的流程图</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoralstm-2.svg" alt="../_images/lstm-2.svg"></p><hr><p><strong>隐状态</strong></p><p>最后，我们需要定义如何计算隐状态$\mathbf{H}_t \in \mathbb{R}^{n \times h}$，这就是输出门发挥作用的地方。在长短期记忆网络中，它仅仅是记忆元的$\tanh$的门控版本。这就确保了$\mathbf{H}_t$的值始终在区间$(-1, 1)$内：</p><script type="math/tex; mode=display">\mathbf{H}_t = \mathbf{O}_t \odot \tanh(\mathbf{C}_t)</script><p>只要输出门接近$1$，我们就能够有效地将所有记忆信息传递给预测部分，</p><p>而对于输出门接近$0$，我们只保留记忆元内的所有信息，而不需要更新隐状态。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoratyporalstm-3.svg" alt="../_images/lstm-3.svg"></p><p>尽管记忆元和隐状态在功能上有重叠，它们的存在并不是重复的，而是相互补充的：</p><ul><li><strong>记忆元</strong>专注于长期信息的存储和传递。它能够在很长的序列中维持重要的状态信息，因为它通过门控机制精细地控制信息的保留和遗忘。</li><li><strong>隐状态</strong>则提供了一种机制来输出短期的信息。它反映了当前时间点的网络状态，是基于最近的输入和过去的长期信息（通过记忆元传递）计算得出的。</li></ul><hr><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> np, npx</span><br><span class="line"><span class="keyword">from</span> mxnet.gluon <span class="keyword">import</span> rnn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> mxnet <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line">npx.set_np()</span><br><span class="line"></span><br><span class="line">batch_size, num_steps = <span class="number">32</span>, <span class="number">35</span></span><br><span class="line">train_iter, vocab = d2l.load_data_time_machine(batch_size, num_steps)</span><br></pre></td></tr></table></figure><p>接下来，我们需要定义和初始化模型参数。 如前所述，超参数<code>num_hiddens</code>定义隐藏单元的数量。 我们按照标准差0.01的高斯分布初始化权重，并将偏置项设为0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_lstm_params</span>(<span class="params">vocab_size, num_hiddens, device</span>):</span></span><br><span class="line">    num_inputs = num_outputs = vocab_size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">normal</span>(<span class="params">shape</span>):</span></span><br><span class="line">        <span class="keyword">return</span> torch.randn(size=shape, device=device)*<span class="number">0.01</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">three</span>():</span></span><br><span class="line">        <span class="keyword">return</span> (normal((num_inputs, num_hiddens)),</span><br><span class="line">                normal((num_hiddens, num_hiddens)),</span><br><span class="line">                torch.zeros(num_hiddens, device=device))</span><br><span class="line"></span><br><span class="line">    W_xi, W_hi, b_i = three()  <span class="comment"># 输入门参数</span></span><br><span class="line">    W_xf, W_hf, b_f = three()  <span class="comment"># 遗忘门参数</span></span><br><span class="line">    W_xo, W_ho, b_o = three()  <span class="comment"># 输出门参数</span></span><br><span class="line">    W_xc, W_hc, b_c = three()  <span class="comment"># 候选记忆元参数</span></span><br><span class="line">    <span class="comment"># 输出层参数</span></span><br><span class="line">    W_hq = normal((num_hiddens, num_outputs))</span><br><span class="line">    b_q = torch.zeros(num_outputs, device=device)</span><br><span class="line">    <span class="comment"># 附加梯度</span></span><br><span class="line">    params = [W_xi, W_hi, b_i, W_xf, W_hf, b_f, W_xo, W_ho, b_o, W_xc, W_hc,</span><br><span class="line">              b_c, W_hq, b_q]</span><br><span class="line">    <span class="keyword">for</span> param <span class="keyword">in</span> params:</span><br><span class="line">        param.requires_grad_(<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> params</span><br></pre></td></tr></table></figure><hr><p>在初始化函数中， 长短期记忆网络的隐状态需要返回一个<em>额外</em>的记忆元， 单元的值为0，形状为（批量大小，隐藏单元数）。 因此，我们得到以下的状态初始化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_lstm_state</span>(<span class="params">batch_size, num_hiddens, device</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (torch.zeros((batch_size, num_hiddens), device=device),</span><br><span class="line">            torch.zeros((batch_size, num_hiddens), device=device))</span><br></pre></td></tr></table></figure><p>实际模型的定义与我们前面讨论的一样： 提供三个门和一个额外的记忆元。 请注意，只有隐状态才会传递到输出层， 而记忆元$C_t$不直接参与输出计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lstm</span>(<span class="params">inputs, state, params</span>):</span></span><br><span class="line">    [W_xi, W_hi, b_i, W_xf, W_hf, b_f, W_xo, W_ho, b_o, W_xc, W_hc, b_c,</span><br><span class="line">     W_hq, b_q] = params</span><br><span class="line">    (H, C) = state</span><br><span class="line">    outputs = []</span><br><span class="line">    <span class="keyword">for</span> X <span class="keyword">in</span> inputs:</span><br><span class="line">        I = torch.sigmoid((X @ W_xi) + (H @ W_hi) + b_i)</span><br><span class="line">        F = torch.sigmoid((X @ W_xf) + (H @ W_hf) + b_f)</span><br><span class="line">        O = torch.sigmoid((X @ W_xo) + (H @ W_ho) + b_o)</span><br><span class="line">        C_tilda = torch.tanh((X @ W_xc) + (H @ W_hc) + b_c)</span><br><span class="line">        C = F * C + I * C_tilda</span><br><span class="line">        H = O * torch.tanh(C)</span><br><span class="line">        Y = (H @ W_hq) + b_q</span><br><span class="line">        outputs.append(Y)</span><br><span class="line">    <span class="keyword">return</span> torch.cat(outputs, dim=<span class="number">0</span>), (H, C)</span><br></pre></td></tr></table></figure><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vocab_size, num_hiddens, device = <span class="built_in">len</span>(vocab), <span class="number">256</span>, d2l.try_gpu()</span><br><span class="line">num_epochs, lr = <span class="number">500</span>, <span class="number">1</span></span><br><span class="line">model = d2l.RNNModelScratch(<span class="built_in">len</span>(vocab), num_hiddens, device, get_lstm_params,</span><br><span class="line">                            init_lstm_state, lstm)</span><br><span class="line">d2l.train_ch8(model, train_iter, vocab, lr, num_epochs, device)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">perplexity 1.3, 17736.0 tokens/sec on cuda:0</span></span><br><span class="line"><span class="string">time traveller for so it will leong go it we melenot ir cove i s</span></span><br><span class="line"><span class="string">traveller care be can so i ngrecpely as along the time dime</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraoutput_lstm_86eb9f_66_1.svg" alt="../_images/output_lstm_86eb9f_66_1.svg"></p><p>长短期记忆网络是典型的具有重要状态控制的隐变量自回归模型。 多年来已经提出了其许多变体，例如，多层、残差连接、不同类型的正则化。 然而，由于序列的<strong>长距离依赖性</strong>，训练长短期记忆网络 和其他序列模型（例如门控循环单元）的成本是相当高的。 在后面的内容中，我们将讲述更高级的替代模型，如<code>Transformer</code>。</p><hr><h2 id="深度循环神经网络"><a href="#深度循环神经网络" class="headerlink" title="深度循环神经网络"></a>深度循环神经网络</h2><p>事实上，我们可以将多层循环神经网络堆叠在一起， 通过对几个简单层的组合，产生了一个灵活的机制。 特别是，数据可能与不同层的堆叠有关。 例如，我们可能希望保持有关金融市场状况 （熊市或牛市）的宏观数据可用， 而微观数据只记录较短期的时间动态。</p><p>描述了一个具有$L$个隐藏层的深度循环神经网络， 每个隐状态都连续地传递到当前层的下一个时间步和下一层的当前时间步</p><p><img src="https://zh-v2.d2l.ai/_images/deep-rnn.svg" alt="../_images/deep-rnn.svg"></p><hr><h3 id="函数依赖关系"><a href="#函数依赖关系" class="headerlink" title="函数依赖关系"></a><strong>函数依赖关系</strong></h3><p>我们可以将深度架构中的函数依赖关系形式化，这个架构是由图中描述了$L$个隐藏层构成。后续的讨论主要集中在经典的循环神经网络模型上，但是这些讨论也适应于其他序列模型。</p><p>假设在时间步$t$有一个小批量的输入数据$\mathbf{X}_t \in \mathbb{R}^{n \times d}$（样本数：$n$，每个样本中的输入数：$d$）。同时，将$l^\mathrm{th}$隐藏层（$l=1,\ldots,L$）的隐状态设为$\mathbf{H}_t^{(l)}  \in \mathbb{R}^{n \times h}$（隐藏单元数：$h$），输出层变量设为$\mathbf{O}_t \in \mathbb{R}^{n \times q}$（输出数：$q$）。设置$\mathbf{H}_t^{(0)} = \mathbf{X}_t$，第$l$个隐藏层的隐状态使用激活函数$\phi_l$，则：</p><script type="math/tex; mode=display">\mathbf{H}_t^{(l)} = \phi_l(\mathbf{H}_t^{(l-1)} \mathbf{W}_{xh}^{(l)} + \mathbf{H}_{t-1}^{(l)} \mathbf{W}_{hh}^{(l)}  + \mathbf{b}_h^{(l)})</script><p>其中，权重$\mathbf{W}_{xh}^{(l)} \in \mathbb{R}^{h \times h}$，$\mathbf{W}_{hh}^{(l)} \in \mathbb{R}^{h \times h}$和偏置$\mathbf{b}_h^{(l)} \in \mathbb{R}^{1 \times h}$都是第$l$个隐藏层的模型参数。</p><p>最后，输出层的计算仅基于第$l$个隐藏层最终的隐状态：</p><script type="math/tex; mode=display">\mathbf{O}_t = \mathbf{H}_t^{(L)} \mathbf{W}_{hq} + \mathbf{b}_q</script><p>其中，权重$\mathbf{W}_{hq} \in \mathbb{R}^{h \times q}$和偏置$\mathbf{b}_q \in \mathbb{R}^{1 \times q}$都是输出层的模型参数。</p><p>与多层感知机一样，隐藏层数目$L$和隐藏单元数目$h$都是超参数。也就是说，它们可以由我们调整的。另外，用门控循环单元或长短期记忆网络的隐状态来代替图中的隐状态进行计算，可以很容易地得到深度门控循环神经网络或深度长短期记忆神经网络。</p><hr><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>实现多层循环神经网络所需的许多逻辑细节在高级API中都是现成的。 简单起见，我们仅示范使用此类内置函数的实现方式。 以长短期记忆网络模型为例， 该代码与之前在上一节中使用的代码非常相似， 实际上唯一的区别是我们指定了层的数量， 而不是使用单一层这个默认值。 像往常一样，我们从加载数据集开始。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line">batch_size, num_steps = <span class="number">32</span>, <span class="number">35</span></span><br><span class="line">train_iter, vocab = d2l.load_data_time_machine(batch_size, num_steps)</span><br></pre></td></tr></table></figure><p>因为我们有不同的词元，所以输入和输出都选择相同数量，即<code>vocab_size</code>。 隐藏单元的数量仍然是256。 唯一的区别是，我们现在通过<code>num_layers</code>的值来设定隐藏层数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vocab_size, num_hiddens, num_layers = <span class="built_in">len</span>(vocab), <span class="number">256</span>, <span class="number">2</span></span><br><span class="line">num_inputs = vocab_size</span><br><span class="line">device = d2l.try_gpu()</span><br><span class="line">lstm_layer = nn.LSTM(num_inputs, num_hiddens, num_layers)</span><br><span class="line">model = d2l.RNNModel(lstm_layer, <span class="built_in">len</span>(vocab))</span><br><span class="line">model = model.to(device)</span><br></pre></td></tr></table></figure><p>由于使用了长短期记忆网络模型来实例化两个层，因此训练速度被大大降低了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">num_epochs, lr = <span class="number">500</span>, <span class="number">2</span></span><br><span class="line">d2l.train_ch8(model, train_iter, vocab, lr*<span class="number">1.0</span>, num_epochs, device)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">perplexity 1.0, 186005.7 tokens/sec on cuda:0</span></span><br><span class="line"><span class="string">time traveller for so it will be convenient to speak of himwas e</span></span><br><span class="line"><span class="string">travelleryou can show black is white by argument said filby</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraoutput_deep-rnn_d70a11_30_1.svg" alt="../_images/output_deep-rnn_d70a11_30_1.svg"></p><hr><h2 id="机器翻译与数据集"><a href="#机器翻译与数据集" class="headerlink" title="机器翻译与数据集"></a>机器翻译与数据集</h2><p>语言模型是自然语言处理的关键， 而<em>机器翻译</em>是语言模型最成功的基准测试。 因为机器翻译正是将输入序列转换成输出序列的 <strong><em>序列转换模型</em></strong> 的核心问题。 序列转换模型在各类现代人工智能应用中发挥着至关重要的作用， 因此我们将其做为本章剩余部分和注意力机制的重点。 为此，本节将介绍机器翻译问题及其后文需要使用的数据集</p><p><strong><em>机器翻译</em></strong>指的是 将序列从一种语言自动翻译成另一种语言。基于神经网络的方法通常被称为 <strong><em>神经机器翻译</em></strong>， 用于将两种翻译模型区分开来</p><p>与之前的语料库是单一语言的语言模型问题存在不同， 机器翻译的数据集是由源语言和目标语言的文本序列对组成的。 因此，我们需要一种完全不同的方法来预处理机器翻译数据集， 而不是复用语言模型的预处理程序。 下面，我们看一下如何将预处理后的数据加载到小批量中用于训练。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br></pre></td></tr></table></figure><hr><h3 id="下载和预处理数据集"><a href="#下载和预处理数据集" class="headerlink" title="下载和预处理数据集"></a>下载和预处理数据集</h3><p>首先，下载一个由<a href="http://www.manythings.org/anki/">Tatoeba项目的双语句子对</a> 组成的“英－法”数据集，数据集中的每一行都是制表符分隔的文本序列对， 序列对由英文文本序列和翻译后的法语文本序列组成。 请注意，每个文本序列可以是一个句子， 也可以是包含多个句子的一个段落。 在这个将英语翻译成法语的机器翻译问题中， 英语是<strong><em>源语言</em></strong>， 法语是<strong><em>目标语言</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line">d2l.DATA_HUB[<span class="string">&#x27;fra-eng&#x27;</span>] = (d2l.DATA_URL + <span class="string">&#x27;fra-eng.zip&#x27;</span>,</span><br><span class="line">                           <span class="string">&#x27;94646ad1522d915e7b0f9296181140edcf86a4f5&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_data_nmt</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;载入“英语－法语”数据集&quot;&quot;&quot;</span></span><br><span class="line">    data_dir = d2l.download_extract(<span class="string">&#x27;fra-eng&#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(data_dir, <span class="string">&#x27;fra.txt&#x27;</span>), <span class="string">&#x27;r&#x27;</span>,</span><br><span class="line">             encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">return</span> f.read()</span><br><span class="line"></span><br><span class="line">raw_text = read_data_nmt()</span><br><span class="line"><span class="built_in">print</span>(raw_text[:<span class="number">75</span>])</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Go. Va !</span></span><br><span class="line"><span class="string">Hi. Salut !</span></span><br><span class="line"><span class="string">Run!        Cours !</span></span><br><span class="line"><span class="string">Run!        Courez !</span></span><br><span class="line"><span class="string">Who?        Qui ?</span></span><br><span class="line"><span class="string">Wow!        Ça alors !</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>下载数据集后，原始文本数据需要经过几个预处理步骤。 例如，我们用空格代替<em>不间断空格</em>（non-breaking space）， 使用小写字母替换大写字母，并在单词和标点符号之间插入空格。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preprocess_nmt</span>(<span class="params">text</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;预处理“英语－法语”数据集&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">no_space</span>(<span class="params">char, prev_char</span>):</span></span><br><span class="line">        <span class="keyword">return</span> char <span class="keyword">in</span> <span class="built_in">set</span>(<span class="string">&#x27;,.!?&#x27;</span>) <span class="keyword">and</span> prev_char != <span class="string">&#x27; &#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用空格替换不间断空格</span></span><br><span class="line">    <span class="comment"># 使用小写字母替换大写字母</span></span><br><span class="line">    text = text.replace(<span class="string">&#x27;\u202f&#x27;</span>, <span class="string">&#x27; &#x27;</span>).replace(<span class="string">&#x27;\xa0&#x27;</span>, <span class="string">&#x27; &#x27;</span>).lower()</span><br><span class="line">    <span class="comment"># 在单词和标点符号之间插入空格</span></span><br><span class="line">    out = [<span class="string">&#x27; &#x27;</span> + char <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> no_space(char, text[i - <span class="number">1</span>]) <span class="keyword">else</span> char</span><br><span class="line">           <span class="keyword">for</span> i, char <span class="keyword">in</span> <span class="built_in">enumerate</span>(text)]</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(out)</span><br><span class="line"></span><br><span class="line">text = preprocess_nmt(raw_text)</span><br><span class="line"><span class="built_in">print</span>(text[:<span class="number">80</span>])</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">go .        va !</span></span><br><span class="line"><span class="string">hi .        salut !</span></span><br><span class="line"><span class="string">run !       cours !</span></span><br><span class="line"><span class="string">run !       courez !</span></span><br><span class="line"><span class="string">who ?       qui ?</span></span><br><span class="line"><span class="string">wow !       ça alors !</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><hr><h3 id="词元化"><a href="#词元化" class="headerlink" title="词元化"></a>词元化</h3><p>在机器翻译中，我们更喜欢单词级词元化 （最先进的模型可能使用更高级的词元化技术）。 下面的<code>tokenize_nmt</code>函数对前<code>num_examples</code>个文本序列对进行词元， 其中每个词元要么是一个词，要么是一个标点符号。 此函数返回两个词元列表：<code>source</code>和<code>target</code>： <code>source[i]</code>是源语言（这里是英语）第$i$个文本序列的词元列表， <code>target[i]</code>是目标语言（这里是法语）第$i$个文本序列的词元列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tokenize_nmt</span>(<span class="params">text, num_examples=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;词元化“英语－法语”数据数据集&quot;&quot;&quot;</span></span><br><span class="line">    source, target = [], []</span><br><span class="line">    <span class="keyword">for</span> i, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(text.split(<span class="string">&#x27;\n&#x27;</span>)):</span><br><span class="line">        <span class="keyword">if</span> num_examples <span class="keyword">and</span> i &gt; num_examples:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        parts = line.split(<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(parts) == <span class="number">2</span>:</span><br><span class="line">            source.append(parts[<span class="number">0</span>].split(<span class="string">&#x27; &#x27;</span>))</span><br><span class="line">            target.append(parts[<span class="number">1</span>].split(<span class="string">&#x27; &#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> source, target</span><br><span class="line"></span><br><span class="line">source, target = tokenize_nmt(text)</span><br><span class="line">source[:<span class="number">6</span>], target[:<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">([[&#x27;go&#x27;, &#x27;.&#x27;],</span></span><br><span class="line"><span class="string">  [&#x27;hi&#x27;, &#x27;.&#x27;],</span></span><br><span class="line"><span class="string">  [&#x27;run&#x27;, &#x27;!&#x27;],</span></span><br><span class="line"><span class="string">  [&#x27;run&#x27;, &#x27;!&#x27;],</span></span><br><span class="line"><span class="string">  [&#x27;who&#x27;, &#x27;?&#x27;],</span></span><br><span class="line"><span class="string">  [&#x27;wow&#x27;, &#x27;!&#x27;]],</span></span><br><span class="line"><span class="string"> [[&#x27;va&#x27;, &#x27;!&#x27;],</span></span><br><span class="line"><span class="string">  [&#x27;salut&#x27;, &#x27;!&#x27;],</span></span><br><span class="line"><span class="string">  [&#x27;cours&#x27;, &#x27;!&#x27;],</span></span><br><span class="line"><span class="string">  [&#x27;courez&#x27;, &#x27;!&#x27;],</span></span><br><span class="line"><span class="string">  [&#x27;qui&#x27;, &#x27;?&#x27;],</span></span><br><span class="line"><span class="string">  [&#x27;ça&#x27;, &#x27;alors&#x27;, &#x27;!&#x27;]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><hr><h3 id="词表"><a href="#词表" class="headerlink" title="词表"></a>词表</h3><p>由于机器翻译数据集由语言对组成， 因此我们可以分别为源语言和目标语言构建两个词表。 使用单词级词元化时，词表大小将明显大于使用字符级词元化时的词表大小。 为了缓解这一问题，这里我们将出现次数少于2次的低频率词元 视为相同的未知（<code>&lt;unk&gt;</code>）词元。 除此之外，我们还指定了额外的特定词元， 例如在小批量时用于将序列填充到相同长度的填充词元（<code>&lt;pad&gt;</code>）， 以及序列的开始词元（<code>&lt;bos&gt;</code>）和结束词元（<code>&lt;eos&gt;</code>）。 这些特殊词元在自然语言处理任务中比较常用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># source: 包含文本数据的变量，通常是一个列表，其中每个元素是一个句子或单词。</span></span><br><span class="line"><span class="comment"># min_freq=2: 表示只有在数据集中出现至少两次的单词才会被加入到词汇表中。</span></span><br><span class="line"><span class="comment">#             这有助于去除一些罕见词，减少模型的复杂度。</span></span><br><span class="line"><span class="comment"># reserved_tokens=[&#x27;&lt;pad&gt;&#x27;, &#x27;&lt;bos&gt;&#x27;, &#x27;&lt;eos&gt;&#x27;]: 指定了一些保留的标记（tokens），</span></span><br><span class="line"><span class="comment">#             分别是填充标记（&lt;pad&gt;）、句子开始标记（&lt;bos&gt;）和句子结束标记（&lt;eos&gt;）。</span></span><br><span class="line"><span class="comment">#             这些标记在训练循环神经网络时非常有用，例如在自然语言处理任务中。</span></span><br><span class="line">src_vocab = d2l.Vocab(source, min_freq=<span class="number">2</span>,</span><br><span class="line">                      reserved_tokens=[<span class="string">&#x27;&lt;pad&gt;&#x27;</span>, <span class="string">&#x27;&lt;bos&gt;&#x27;</span>, <span class="string">&#x27;&lt;eos&gt;&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取词汇表的长度，即词汇表中不同单词的总数。</span></span><br><span class="line"><span class="comment"># 这个长度包括了因min_freq条件而筛选的单词，以及添加的保留标记。</span></span><br><span class="line"><span class="built_in">len</span>(src_vocab)</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="加载数据集"><a href="#加载数据集" class="headerlink" title="加载数据集"></a>加载数据集</h3><p>回想一下，语言模型中的序列样本都有一个固定的长度， 无论这个样本是一个句子的一部分还是跨越了多个句子的一个片断。 这个固定长度是由语言模型这节中的 <code>num_steps</code>（时间步数或词元数量）参数指定的。 在机器翻译中，每个样本都是由源和目标组成的文本序列对， 其中的每个文本序列可能具有不同的长度。</p><p>为了提高计算效率，我们仍然可以通过<strong><em>截断</em></strong>（truncation）和 <strong><em>填充</em></strong>（padding）方式实现一次只处理一个小批量的文本序列。 假设同一个小批量中的每个序列都应该具有相同的长度<code>num_steps</code>， 那么如果文本序列的词元数目少于<code>num_steps</code>时， 我们将继续在其末尾添加特定<code>&lt;pad&gt;</code>词元， 直到其长度达到<code>num_steps</code>； 反之，我们将截断文本序列时，只取其前<code>num_steps</code> 个词元， 并且丢弃剩余的词元。这样，每个文本序列将具有相同的长度， 以便以相同形状的小批量进行加载。</p><p>如前所述，下面的<code>truncate_pad</code>函数将截断或填充文本序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">truncate_pad</span>(<span class="params">line, num_steps, padding_token</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;截断或填充文本序列&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(line) &gt; num_steps:</span><br><span class="line">        <span class="keyword">return</span> line[:num_steps]  <span class="comment"># 截断</span></span><br><span class="line">    <span class="keyword">return</span> line + [padding_token] * (num_steps - <span class="built_in">len</span>(line))  <span class="comment"># 填充</span></span><br><span class="line"></span><br><span class="line">truncate_pad(src_vocab[source[<span class="number">0</span>]], <span class="number">10</span>, src_vocab[<span class="string">&#x27;&lt;pad&gt;&#x27;</span>])</span><br></pre></td></tr></table></figure><p>现在我们定义一个函数，可以将文本序列 转换成小批量数据集用于训练。 我们将特定的<code>&lt;eos&gt;</code>词元添加到所有序列的末尾， 用于表示序列的结束。 当模型通过一个词元接一个词元地生成序列进行预测时， 生成的<code>&lt;eos&gt;</code>词元说明完成了序列输出工作。 此外，我们还记录了每个文本序列的长度， 统计长度时排除了填充词元， 在稍后将要介绍的一些模型会需要这个长度信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_array_nmt</span>(<span class="params">lines, vocab, num_steps</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    将机器翻译的文本序列转换成小批量。</span></span><br><span class="line"><span class="string">    lines: 包含多个句子的列表，其中每个句子是由单词组成的列表。</span></span><br><span class="line"><span class="string">    vocab: 一个Vocab类的实例，用于将文本数据转换为数字索引。</span></span><br><span class="line"><span class="string">    num_steps: 指定每个句子在转换后的最大长度，如果句子长度不足会进行填充，过长则会被截断。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将每个句子中的单词转换为对应的索引。</span></span><br><span class="line">    lines = [vocab[l] <span class="keyword">for</span> l <span class="keyword">in</span> lines]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 在每个索引列表的末尾添加&#x27;&lt;eos&gt;&#x27;标记的索引。</span></span><br><span class="line">    lines = [l + [vocab[<span class="string">&#x27;&lt;eos&gt;&#x27;</span>]] <span class="keyword">for</span> l <span class="keyword">in</span> lines]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 对每个索引列表进行填充或截断，使它们的长度统一为num_steps。</span></span><br><span class="line">    <span class="comment"># 使用vocab[&#x27;&lt;pad&gt;&#x27;]的索引值作为填充值。</span></span><br><span class="line">    array = torch.tensor([truncate_pad(</span><br><span class="line">        l, num_steps, vocab[<span class="string">&#x27;&lt;pad&gt;&#x27;</span>]) <span class="keyword">for</span> l <span class="keyword">in</span> lines])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算每个序列的有效长度（不包括填充部分）。</span></span><br><span class="line">    valid_len = (array != vocab[<span class="string">&#x27;&lt;pad&gt;&#x27;</span>]).<span class="built_in">type</span>(torch.int32).<span class="built_in">sum</span>(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 返回处理后的索引列表和每个列表的有效长度。</span></span><br><span class="line">    <span class="keyword">return</span> array, valid_len</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p>最后，我们定义<code>load_data_nmt</code>函数来返回数据迭代器， 以及源语言和目标语言的两种词表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data_nmt</span>(<span class="params">batch_size, num_steps, num_examples=<span class="number">600</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    返回翻译数据集的迭代器和词表。</span></span><br><span class="line"><span class="string">    batch_size: 指定每个小批量的样本数量。</span></span><br><span class="line"><span class="string">    num_steps: 指定每个样本的最大长度（超过这个长度的部分将被截断，不足的部分将被填充）。</span></span><br><span class="line"><span class="string">    num_examples: 从数据集中读取的样本数量，默认为600。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 预处理数据集，包括读取数据和初步处理。</span></span><br><span class="line">    text = preprocess_nmt(read_data_nmt())</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将文本数据分割成源语言数据和目标语言数据，并根据num_examples限制样本数量。</span></span><br><span class="line">    source, target = tokenize_nmt(text, num_examples)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 为源语言和目标语言各自创建词汇表。</span></span><br><span class="line">    <span class="comment"># min_freq=2表示只包括至少出现两次的单词。</span></span><br><span class="line">    <span class="comment"># reserved_tokens包括特殊标记：&lt;pad&gt;填充标记，&lt;bos&gt;句子开始标记，&lt;eos&gt;句子结束标记。</span></span><br><span class="line">    src_vocab = d2l.Vocab(source, min_freq=<span class="number">2</span>,</span><br><span class="line">                          reserved_tokens=[<span class="string">&#x27;&lt;pad&gt;&#x27;</span>, <span class="string">&#x27;&lt;bos&gt;&#x27;</span>, <span class="string">&#x27;&lt;eos&gt;&#x27;</span>])</span><br><span class="line">    tgt_vocab = d2l.Vocab(target, min_freq=<span class="number">2</span>,</span><br><span class="line">                          reserved_tokens=[<span class="string">&#x27;&lt;pad&gt;&#x27;</span>, <span class="string">&#x27;&lt;bos&gt;&#x27;</span>, <span class="string">&#x27;&lt;eos&gt;&#x27;</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将源语言和目标语言的文本数据转换为小批量的数值数据（包括填充或截断处理）。</span></span><br><span class="line">    src_array, src_valid_len = build_array_nmt(source, src_vocab, num_steps)</span><br><span class="line">    tgt_array, tgt_valid_len = build_array_nmt(target, tgt_vocab, num_steps)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将处理后的数据组合成一个元组，准备进行批量读取。</span></span><br><span class="line">    data_arrays = (src_array, src_valid_len, tgt_array, tgt_valid_len)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 使用d2l.load_array创建数据迭代器，用于批量读取数据。</span></span><br><span class="line">    data_iter = d2l.load_array(data_arrays, batch_size)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 返回数据迭代器和两个语言的词汇表。</span></span><br><span class="line">    <span class="keyword">return</span> data_iter, src_vocab, tgt_vocab</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面我们读出“英语－法语”数据集中的第一个小批量数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">train_iter, src_vocab, tgt_vocab = load_data_nmt(batch_size=<span class="number">2</span>, num_steps=<span class="number">8</span>)</span><br><span class="line"><span class="keyword">for</span> X, X_valid_len, Y, Y_valid_len <span class="keyword">in</span> train_iter:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;X:&#x27;</span>, X.<span class="built_in">type</span>(torch.int32))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;X的有效长度:&#x27;</span>, X_valid_len)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Y:&#x27;</span>, Y.<span class="built_in">type</span>(torch.int32))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Y的有效长度:&#x27;</span>, Y_valid_len)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">X: tensor([[ 7, 43,  4,  3,  1,  1,  1,  1],</span></span><br><span class="line"><span class="string">        [44, 23,  4,  3,  1,  1,  1,  1]], dtype=torch.int32)</span></span><br><span class="line"><span class="string">X的有效长度: tensor([4, 4])</span></span><br><span class="line"><span class="string">Y: tensor([[ 6,  7, 40,  4,  3,  1,  1,  1],</span></span><br><span class="line"><span class="string">        [ 0,  5,  3,  1,  1,  1,  1,  1]], dtype=torch.int32)</span></span><br><span class="line"><span class="string">Y的有效长度: tensor([5, 3])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><hr><h2 id="编码器和解码器"><a href="#编码器和解码器" class="headerlink" title="编码器和解码器"></a>编码器和解码器</h2><p>机器翻译是序列转换模型的一个核心问题， 其输入和输出都是长度可变的序列。 为了处理这种类型的输入和输出， 我们可以设计一个包含两个主要组件的架构： 第一个组件是一个<strong><em>编码器</em></strong>（encoder）： 它接受一个长度可变的序列作为输入， 并将其转换为具有固定形状的编码状态。 第二个组件是<strong><em>解码器</em></strong>（decoder）： 它将固定形状的编码状态映射到长度可变的序列。 这被称为<strong><em>编码器-解码器</em></strong>（encoder-decoder）架构</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraencoder-decoder.svg" alt="../_images/encoder-decoder.svg"></p><p>以英语到法语的机器翻译为例： 给定一个英文的输入序列：“They”“are”“watching”“.”。 首先，这种“编码器－解码器”架构将长度可变的输入序列编码成一个“状态”， 然后对该状态进行解码， 一个词元接着一个词元地生成翻译后的序列作为输出： “Ils”“regordent”“.”。 由于“编码器－解码器”架构是形成后续章节中不同序列转换模型的基础， 因此本节将把这个架构转换为接口方便后面的代码实现。</p><hr><h3 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h3><p>在编码器接口中，我们只指定长度可变的序列作为编码器的输入<code>X</code>。 任何继承这个<code>Encoder</code>基类的模型将完成代码实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Encoder</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;编码器-解码器架构的基本编码器接口&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Encoder, self).__init__(**kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, X, *args</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br></pre></td></tr></table></figure><hr><h3 id="解码器"><a href="#解码器" class="headerlink" title="解码器"></a>解码器</h3><p>在下面的解码器接口中，我们新增一个<code>init_state</code>函数， 用于将编码器的输出（<code>enc_outputs</code>）转换为编码后的状态。 注意，此步骤可能需要额外的输入，例如：输入序列的有效长度， 为了逐个地生成长度可变的词元序列， 解码器在每个时间步都会将输入 （例如：在前一时间步生成的词元）和编码后的状态 映射成当前时间步的输出词元。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decoder</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;编码器-解码器架构的基本解码器接口&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Decoder, self).__init__(**kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init_state</span>(<span class="params">self, enc_outputs, *args</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, X, state</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br></pre></td></tr></table></figure><hr><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>总而言之，“编码器-解码器”架构包含了一个编码器和一个解码器， 并且还拥有可选的额外的参数。 在前向传播中，编码器的输出用于生成编码状态， 这个状态又被解码器作为其输入的一部分</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 引入必要的库</span></span><br><span class="line"><span class="keyword">import</span> nn  <span class="comment"># 假设这是从某个深度学习框架中导入的神经网络库</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EncoderDecoder</span>(<span class="params">nn.Block</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;编码器-解码器架构的基类。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    这个类是编码器-解码器架构的一个通用实现，可以用于多种不同的任务，如机器翻译、</span></span><br><span class="line"><span class="string">    自动摘要等。它由两部分组成：一个编码器和一个解码器。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    encoder: 编码器部分，负责处理输入数据，将其转换成一个内部表示。</span></span><br><span class="line"><span class="string">    decoder: 解码器部分，负责将编码器的输出转换成最终的输出序列。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, encoder, decoder, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(EncoderDecoder, self).__init__(**kwargs)</span><br><span class="line">        <span class="comment"># 初始化编码器和解码器</span></span><br><span class="line">        self.encoder = encoder</span><br><span class="line">        self.decoder = decoder</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, enc_X, dec_X, *args</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        前向传播方法。</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        参数:</span></span><br><span class="line"><span class="string">        enc_X: 编码器的输入数据。</span></span><br><span class="line"><span class="string">        dec_X: 解码器的输入数据。</span></span><br><span class="line"><span class="string">        *args: 可能会传递给编码器和解码器的额外参数。</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        返回:</span></span><br><span class="line"><span class="string">        解码器的输出，这通常是一个序列，比如翻译的文本或者生成的文本摘要。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 通过编码器处理输入</span></span><br><span class="line">        enc_outputs = self.encoder(enc_X, *args)</span><br><span class="line">        <span class="comment"># 使用编码器的输出来初始化解码器的状态</span></span><br><span class="line">        dec_state = self.decoder.init_state(enc_outputs, *args)</span><br><span class="line">        <span class="comment"># 使用解码器生成最终的输出序列</span></span><br><span class="line">        <span class="keyword">return</span> self.decoder(dec_X, dec_state)</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="序列到序列学习seq2seq"><a href="#序列到序列学习seq2seq" class="headerlink" title="序列到序列学习seq2seq"></a>序列到序列学习seq2seq</h2><p> 本节，我们将使用两个循环神经网络的编码器和解码器， 并将其应用于<strong><em>序列到序列</em></strong>（sequence to sequence，seq2seq）类的学习任务 </p><p>遵循编码器－解码器架构的设计原则， 循环神经网络编码器使用长度可变的序列作为输入， 将其转换为固定形状的隐状态。 换言之，输入序列的信息被<strong><em>编码</em></strong>到循环神经网络编码器的隐状态中。 为了连续生成输出序列的词元， 独立的循环神经网络解码器是<strong>基于输入序列的编码信息 和输出序列已经看见的或者生成的词元来预测下一个词元</strong>。图中演示了 如何在机器翻译中使用两个循环神经网络进行序列到序列学习</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraseq2seq.svg" alt="../_images/seq2seq.svg"></p><p>特定的<code>&lt;eos&gt;</code>表示序列结束词元。 一旦输出序列生成此词元，模型就会停止预测。 在循环神经网络解码器的初始化时间步，有两个特定的设计决定： 首先，特定的<code>&lt;bos&gt;</code>表示序列开始词元，它是解码器的输入序列的第一个词元。 其次，使用循环神经网络编码器最终的隐状态来初始化解码器的隐状态。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br></pre></td></tr></table></figure><hr><h3 id="编码器-1"><a href="#编码器-1" class="headerlink" title="编码器"></a>编码器</h3><p>从技术上讲，编码器将长度可变的输入序列转换成 形状固定的上下文变量$c$， 并且将输入序列的信息在该上下文变量中进行编码</p><p>考虑由一个序列组成的样本（批量大小是$1$）。假设输入序列是$x_1, \ldots, x_T$，其中$x_t$是输入文本序列中的第$t$个词元。在时间步$t$，循环神经网络将词元$x_t$的输入特征向量$\mathbf{x}_t$和$\mathbf{h} _{t-1}$（即上一时间步的隐状态）转换为$\mathbf{h}_t$（即当前步的隐状态）。使用一个函数$f$来描述循环神经网络的循环层所做的变换：</p><script type="math/tex; mode=display">\mathbf{h}_t = f(\mathbf{x}_t, \mathbf{h}_{t-1})</script><p>总之，编码器通过选定的函数$q$，将所有时间步的隐状态转换为上下文变量：</p><script type="math/tex; mode=display">\mathbf{c} =  q(\mathbf{h}_1, \ldots, \mathbf{h}_T)</script><p>比如，当选择$q(\mathbf{h}_1, \ldots, \mathbf{h}_T) = \mathbf{h}_T$时，上下文变量仅仅是输入序列在最后时间步的隐状态$\mathbf{h}_T$。</p><p>现在，让我们实现循环神经网络编码器。 注意，我们使用了<strong><em>嵌入层</em></strong>（embedding layer） 来获得输入序列中每个词元的特征向量。 嵌入层的权重是一个矩阵， 其行数等于输入词表的大小（<code>vocab_size</code>）， 其列数等于特征向量的维度（<code>embed_size</code>）。 对于任意输入词元的索引$i$， 嵌入层获取权重矩阵的第$i$行（从0开始）以返回其特征向量。 另外，本文选择了一个多层门控循环单元来实现编码器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Seq2SeqEncoder</span>(<span class="params">d2l.Encoder</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;用于序列到序列学习的循环神经网络编码器&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, vocab_size, embed_size, num_hiddens, num_layers,</span></span></span><br><span class="line"><span class="params"><span class="function">                 dropout=<span class="number">0</span>, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Seq2SeqEncoder, self).__init__(**kwargs)</span><br><span class="line">        <span class="comment"># 嵌入层</span></span><br><span class="line">        self.embedding = nn.Embedding(vocab_size, embed_size)</span><br><span class="line">        self.rnn = nn.GRU(embed_size, num_hiddens, num_layers,</span><br><span class="line">                          dropout=dropout)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, X, *args</span>):</span></span><br><span class="line">        <span class="comment"># 输出&#x27;X&#x27;的形状：(batch_size,num_steps,embed_size)</span></span><br><span class="line">        X = self.embedding(X)</span><br><span class="line">        <span class="comment"># 在循环神经网络模型中，第一个轴对应于时间步</span></span><br><span class="line">        X = X.permute(<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">        <span class="comment"># 如果未提及状态，则默认为0</span></span><br><span class="line">        output, state = self.rnn(X)</span><br><span class="line">        <span class="comment"># output的形状:(num_steps,batch_size,num_hiddens)</span></span><br><span class="line">        <span class="comment"># state的形状:(num_layers,batch_size,num_hiddens)</span></span><br><span class="line">        <span class="keyword">return</span> output, state</span><br></pre></td></tr></table></figure><p>面，我们实例化上述编码器的实现： 我们使用一个两层门控循环单元编码器，其隐藏单元数为16。 给定一小批量的输入序列<code>X</code>（批量大小为4，时间步为7）。 在完成所有时间步后， 最后一层的隐状态的输出是一个张量（<code>output</code>由编码器的循环层返回）， 其形状为（时间步数，批量大小，隐藏单元数）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">encoder = Seq2SeqEncoder(vocab_size=<span class="number">10</span>, embed_size=<span class="number">8</span>, num_hiddens=<span class="number">16</span>,</span><br><span class="line">                         num_layers=<span class="number">2</span>)</span><br><span class="line">encoder.<span class="built_in">eval</span>()</span><br><span class="line">X = torch.zeros((<span class="number">4</span>, <span class="number">7</span>), dtype=torch.long)</span><br><span class="line">output, state = encoder(X)</span><br><span class="line">output.shape</span><br></pre></td></tr></table></figure><p>由于这里使用的是门控循环单元， 所以在最后一个时间步的多层隐状态的形状是 （隐藏层的数量，批量大小，隐藏单元的数量）。 如果使用长短期记忆网络，state中还将包含记忆单元信息。</p><hr><h3 id="解码器-1"><a href="#解码器-1" class="headerlink" title="解码器"></a>解码器</h3><p>正如上文提到的，编码器输出的上下文变量$\mathbf{c}$对整个输入序列$x_1, \ldots, x_T$进行编码。来自训练数据集的输出序列$y_1, y_2, \ldots, y_{T’}$，对于每个时间步$t’$（与输入序列或编码器的时间步$t$不同），解码器输出$y_{t’}$的概率取决于先前的输出子序列$y_1, \ldots, y_{t’-1}$和上下文变量$\mathbf{c}$，即$P(y_{t’} \mid y_1, \ldots, y_{t’-1}, \mathbf{c})$。</p><p>为了在序列上模型化这种条件概率，我们可以使用另一个循环神经网络作为解码器。在输出序列上的任意时间步$t^\prime$，循环神经网络将来自上一时间步的输出$y_{t^\prime-1}$和上下文变量$\mathbf{c}$作为其输入，然后在当前时间步将它们和上一隐状态$\mathbf{s}_{t^\prime-1}$转换为隐状态$\mathbf{s}_{t^\prime}$。因此，可以使用函数$g$来表示解码器的隐藏层的变换：</p><script type="math/tex; mode=display">\mathbf{s}_{t^\prime} = g(y_{t^\prime-1}, \mathbf{c}, \mathbf{s}_{t^\prime-1})</script><p>当实现解码器时， 我们直接使用编码器最后一个时间步的隐状态来初始化解码器的隐状态。 这就要求使用循环神经网络实现的编码器和解码器具有相同数量的层和隐藏单元。 为了进一步包含经过编码的输入序列的信息， 上下文变量在所有的时间步与解码器的输入进行<strong>拼接</strong>。 为了预测输出词元的概率分布， 在循环神经网络解码器的最后一层使用全连接层来变换隐状态。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> d2l  <span class="comment"># 假设d2l是已经导入的深度学习库</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Seq2SeqDecoder</span>(<span class="params">d2l.Decoder</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;用于序列到序列学习的循环神经网络解码器。&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, vocab_size, embed_size, num_hiddens, num_layers,</span></span></span><br><span class="line"><span class="params"><span class="function">                 dropout=<span class="number">0</span>, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Seq2SeqDecoder, self).__init__(**kwargs)</span><br><span class="line">        <span class="comment"># 词嵌入层：将词索引转换为词向量。</span></span><br><span class="line">        self.embedding = nn.Embedding(vocab_size, embed_size)</span><br><span class="line">        <span class="comment"># GRU层：循环神经网络核心，处理输入序列和上下文向量。</span></span><br><span class="line">        self.rnn = nn.GRU(embed_size + num_hiddens, num_hiddens, num_layers,</span><br><span class="line">                          dropout=dropout)</span><br><span class="line">        <span class="comment"># 全连接层：将RNN的输出转换为最终的词汇表预测。</span></span><br><span class="line">        self.dense = nn.Linear(num_hiddens, vocab_size)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init_state</span>(<span class="params">self, enc_outputs, *args</span>):</span></span><br><span class="line">        <span class="comment"># 初始化解码器的状态，这里简单地使用编码器的最终隐藏状态。</span></span><br><span class="line">        <span class="keyword">return</span> enc_outputs[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, X, state</span>):</span></span><br><span class="line">        <span class="comment"># 将输入序列X通过嵌入层转换为词向量。</span></span><br><span class="line">        X = self.embedding(X).permute(<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>)  <span class="comment"># 改变X的形状以匹配RNN的输入要求。</span></span><br><span class="line">        <span class="comment"># 获取上下文向量，并扩展其维度以匹配输入序列的时间步。</span></span><br><span class="line">        context = state[-<span class="number">1</span>].repeat(X.shape[<span class="number">0</span>], <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 将词向量和上下文向量在特征维度上连接。</span></span><br><span class="line">        X_and_context = torch.cat((X, context), <span class="number">2</span>)</span><br><span class="line">        <span class="comment"># 通过GRU处理输入序列。</span></span><br><span class="line">        output, state = self.rnn(X_and_context, state)</span><br><span class="line">        <span class="comment"># 将RNN的输出通过全连接层转换为词汇预测。</span></span><br><span class="line">        output = self.dense(output).permute(<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">        <span class="comment"># 返回输出和新的隐藏状态。</span></span><br><span class="line">        <span class="comment"># output的形状:(batch_size, num_steps, vocab_size)</span></span><br><span class="line">        <span class="comment"># state的形状:(num_layers, batch_size, num_hiddens)</span></span><br><span class="line">        <span class="keyword">return</span> output, state</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用与前面提到的编码器中相同的超参数来实例化解码器。 如我们所见，解码器的输出形状变为（批量大小，时间步数，词表大小）， 其中张量的最后一个维度存储预测的词元分布。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">decoder = Seq2SeqDecoder(vocab_size=<span class="number">10</span>, embed_size=<span class="number">8</span>, num_hiddens=<span class="number">16</span>,</span><br><span class="line">                         num_layers=<span class="number">2</span>)</span><br><span class="line">decoder.<span class="built_in">eval</span>()</span><br><span class="line">state = decoder.init_state(encoder(X))</span><br><span class="line">output, state = decoder(X, state)</span><br><span class="line">output.shape, state.shape</span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraseq2seq-details.svg" alt="../_images/seq2seq-details.svg"></p><hr><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>在每个时间步，解码器预测了输出词元的概率分布。 类似于语言模型，可以使用softmax来获得分布， 并通过计算交叉熵损失函数来进行优化，但是，我们应该将填充词元的预测排除在损失函数的计算之外。</p><p>为此，我们可以使用下面的<code>sequence_mask</code>函数 通过零值化屏蔽不相关的项， 以便后面任何不相关预测的计算都是与零的乘积，结果都等于零。 例如，如果两个序列的有效长度（不包括填充词元）分别为1和2， 则第一个序列的第一项和第二个序列的前两项之后的剩余项将被清除为零。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sequence_mask</span>(<span class="params">X, valid_len, value=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    在序列中屏蔽不相关的项。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    X: 输入的张量，形状为(batch_size, sequence_length)，包含了需要被屏蔽处理的序列。</span></span><br><span class="line"><span class="string">    valid_len: 一个张量，形状为(batch_size,)，包含了每个序列中有效元素的数量。</span></span><br><span class="line"><span class="string">    value: 屏蔽后的填充值，默认为0。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">    经过屏蔽处理的输入张量X。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 获取输入序列的最大长度。</span></span><br><span class="line">    maxlen = X.size(<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 生成一个与序列长度相同的掩码，掩码中每个位置的值表示该位置是否应该被保留。</span></span><br><span class="line">    mask = torch.arange((maxlen), dtype=torch.float32,</span><br><span class="line">                        device=X.device)[<span class="literal">None</span>, :] &lt; valid_len[:, <span class="literal">None</span>]</span><br><span class="line">    <span class="comment"># 使用生成的掩码对输入X进行屏蔽处理，不需要的元素被设置为指定的value。</span></span><br><span class="line">    X[~mask] = value</span><br><span class="line">    <span class="keyword">return</span> X</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例输入序列</span></span><br><span class="line">X = torch.tensor([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="comment"># 应用序列掩码，指定每个序列的有效长度。</span></span><br><span class="line">sequence_mask(X, torch.tensor([<span class="number">1</span>, <span class="number">2</span>]))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在，我们可以通过扩展softmax交叉熵损失函数来遮蔽不相关的预测。 最初，所有预测词元的掩码都设置为1。 一旦给定了有效长度，与填充词元对应的掩码将被设置为0。 最后，将所有词元的损失乘以掩码，以过滤掉损失中填充词元产生的不相关预测。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaskedSoftmaxCELoss</span>(<span class="params">nn.CrossEntropyLoss</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;带遮蔽的softmax交叉熵损失函数。&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, pred, label, valid_len</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        前向传播方法，计算损失。</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        参数:</span></span><br><span class="line"><span class="string">        pred: 预测值，形状为(batch_size, num_steps, vocab_size)，其中包含了对每个时间步的词汇预测。</span></span><br><span class="line"><span class="string">        label: 真实标签，形状为(batch_size, num_steps)，包含了每个时间步的真实词汇索引。</span></span><br><span class="line"><span class="string">        valid_len: 有效长度，形状为(batch_size,)，指示了每个序列中有效词汇的数量。</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        返回:</span></span><br><span class="line"><span class="string">        加权的损失值，其中不应计算损失的部分已被遮蔽。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 创建一个与label形状相同的权重张量，初始全为1。</span></span><br><span class="line">        weights = torch.ones_like(label)</span><br><span class="line">        <span class="comment"># 使用sequence_mask函数根据valid_len遮蔽weights中的不相关部分。</span></span><br><span class="line">        weights = sequence_mask(weights, valid_len)</span><br><span class="line">        <span class="comment"># 设置损失计算模式为&#x27;none&#x27;，以获取逐个元素的损失而不是平均损失。</span></span><br><span class="line">        self.reduction = <span class="string">&#x27;none&#x27;</span></span><br><span class="line">        <span class="comment"># 计算未加权的损失，需要调整pred的维度以符合CrossEntropyLoss的输入要求。</span></span><br><span class="line">        unweighted_loss = <span class="built_in">super</span>(MaskedSoftmaxCELoss, self).forward(</span><br><span class="line">            pred.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>), label)</span><br><span class="line">        <span class="comment"># 将未加权的损失与权重相乘，然后沿着时间步的维度取平均，得到加权损失。</span></span><br><span class="line">        weighted_loss = (unweighted_loss * weights).mean(dim=<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 返回加权损失的平均值。</span></span><br><span class="line">        <span class="keyword">return</span> weighted_loss</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="训练-1"><a href="#训练-1" class="headerlink" title="训练"></a>训练</h3><p>在下面的循环训练过程中，如图所示， 特定的序列开始词元（<code>&lt;bos</code>）和 原始的输出序列（不包括序列结束词元<code>&lt;eos&gt;</code>） 拼接在一起作为解码器的输入。 这被称为<strong><em>强制教学</em></strong>（teacher forcing）， 因为原始的输出序列（词元的标签）被送入解码器。 或者，将来自上一个时间步的<strong><em>预测</em></strong> 得到的词元作为解码器的当前输入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> d2l  <span class="comment"># 假设d2l是已经导入的深度学习库</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_seq2seq</span>(<span class="params">net, data_iter, lr, num_epochs, tgt_vocab, device</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;训练序列到序列模型&quot;&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xavier_init_weights</span>(<span class="params">m</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用Xavier初始化网络权重&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(m) == nn.Linear:</span><br><span class="line">        nn.init.xavier_uniform_(m.weight)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(m) == nn.GRU:</span><br><span class="line">        <span class="keyword">for</span> param <span class="keyword">in</span> m._flat_weights_names:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;weight&quot;</span> <span class="keyword">in</span> param:</span><br><span class="line">                nn.init.xavier_uniform_(m._parameters[param])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用权重初始化，并将模型移动到指定的设备上</span></span><br><span class="line">net.apply(xavier_init_weights)</span><br><span class="line">net.to(device)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用Adam优化器</span></span><br><span class="line">optimizer = torch.optim.Adam(net.parameters(), lr=lr)</span><br><span class="line"><span class="comment"># 使用自定义的MaskedSoftmaxCELoss计算损失</span></span><br><span class="line">loss = MaskedSoftmaxCELoss()</span><br><span class="line">net.train()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用d2l库的Animator绘制训练过程中的损失变化</span></span><br><span class="line">animator = d2l.Animator(xlabel=<span class="string">&#x27;epoch&#x27;</span>, ylabel=<span class="string">&#x27;loss&#x27;</span>, xlim=[<span class="number">10</span>, num_epochs])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">    timer = d2l.Timer()</span><br><span class="line">    metric = d2l.Accumulator(<span class="number">2</span>)  <span class="comment"># 用于累积损失和词元数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> batch <span class="keyword">in</span> data_iter:</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        X, X_valid_len, Y, Y_valid_len = [x.to(device) <span class="keyword">for</span> x <span class="keyword">in</span> batch]</span><br><span class="line">        <span class="comment"># 准备解码器的输入，包括开始符号</span></span><br><span class="line">        bos = torch.tensor([tgt_vocab[<span class="string">&#x27;&lt;bos&gt;&#x27;</span>]] * Y.shape[<span class="number">0</span>], device=device).reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        dec_input = torch.cat([bos, Y[:, :-<span class="number">1</span>]], <span class="number">1</span>)  <span class="comment"># 使用强制教学</span></span><br><span class="line">        Y_hat, _ = net(X, dec_input, X_valid_len)</span><br><span class="line">        l = loss(Y_hat, Y, Y_valid_len)</span><br><span class="line">        l.<span class="built_in">sum</span>().backward()  <span class="comment"># 反向传播</span></span><br><span class="line">        d2l.grad_clipping(net, <span class="number">1</span>)  <span class="comment"># 梯度裁剪</span></span><br><span class="line">        num_tokens = Y_valid_len.<span class="built_in">sum</span>()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            metric.add(l.<span class="built_in">sum</span>(), num_tokens)  <span class="comment"># 更新累积的损失和词元数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 每隔一定epoch更新动画</span></span><br><span class="line">    <span class="keyword">if</span> (epoch + <span class="number">1</span>) % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">        animator.add(epoch + <span class="number">1</span>, (metric[<span class="number">0</span>] / metric[<span class="number">1</span>],))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印训练损失和速度</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;loss <span class="subst">&#123;metric[<span class="number">0</span>] / metric[<span class="number">1</span>]:<span class="number">.3</span>f&#125;</span>, <span class="subst">&#123;metric[<span class="number">1</span>] / timer.stop():<span class="number">.1</span>f&#125;</span> &#x27;</span></span><br><span class="line">      <span class="string">f&#x27;tokens/sec on <span class="subst">&#123;<span class="built_in">str</span>(device)&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><p>现在，在机器翻译数据集上，我们可以 创建和训练一个循环神经网络“编码器－解码器”模型用于序列到序列的学习。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">embed_size, num_hiddens, num_layers, dropout = <span class="number">32</span>, <span class="number">32</span>, <span class="number">2</span>, <span class="number">0.1</span></span><br><span class="line">batch_size, num_steps = <span class="number">64</span>, <span class="number">10</span></span><br><span class="line">lr, num_epochs, device = <span class="number">0.005</span>, <span class="number">300</span>, d2l.try_gpu()</span><br><span class="line"></span><br><span class="line">train_iter, src_vocab, tgt_vocab = d2l.load_data_nmt(batch_size, num_steps)</span><br><span class="line">encoder = Seq2SeqEncoder(<span class="built_in">len</span>(src_vocab), embed_size, num_hiddens, num_layers,</span><br><span class="line">                        dropout)</span><br><span class="line">decoder = Seq2SeqDecoder(<span class="built_in">len</span>(tgt_vocab), embed_size, num_hiddens, num_layers,</span><br><span class="line">                        dropout)</span><br><span class="line">net = d2l.EncoderDecoder(encoder, decoder)</span><br><span class="line">train_seq2seq(net, train_iter, lr, num_epochs, tgt_vocab, device)</span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraoutput_seq2seq_13725e_171_1.svg" alt="../_images/output_seq2seq_13725e_171_1.svg"></p><hr><h3 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraseq2seq-predict.svg" alt="../_images/seq2seq-predict.svg"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict_seq2seq</span>(<span class="params">net, src_sentence, src_vocab, tgt_vocab, num_steps,</span></span></span><br><span class="line"><span class="params"><span class="function">                    device, save_attention_weights=<span class="literal">False</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;序列到序列模型的预测&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 在预测时将net设置为评估模式</span></span><br><span class="line">    net.<span class="built_in">eval</span>()</span><br><span class="line">    src_tokens = src_vocab[src_sentence.lower().split(<span class="string">&#x27; &#x27;</span>)] + [</span><br><span class="line">        src_vocab[<span class="string">&#x27;&lt;eos&gt;&#x27;</span>]]</span><br><span class="line">    enc_valid_len = torch.tensor([<span class="built_in">len</span>(src_tokens)], device=device)</span><br><span class="line">    src_tokens = d2l.truncate_pad(src_tokens, num_steps, src_vocab[<span class="string">&#x27;&lt;pad&gt;&#x27;</span>])</span><br><span class="line">    <span class="comment"># 添加批量轴</span></span><br><span class="line">    enc_X = torch.unsqueeze(</span><br><span class="line">        torch.tensor(src_tokens, dtype=torch.long, device=device), dim=<span class="number">0</span>)</span><br><span class="line">    enc_outputs = net.encoder(enc_X, enc_valid_len)</span><br><span class="line">    dec_state = net.decoder.init_state(enc_outputs, enc_valid_len)</span><br><span class="line">    <span class="comment"># 添加批量轴</span></span><br><span class="line">    dec_X = torch.unsqueeze(torch.tensor(</span><br><span class="line">        [tgt_vocab[<span class="string">&#x27;&lt;bos&gt;&#x27;</span>]], dtype=torch.long, device=device), dim=<span class="number">0</span>)</span><br><span class="line">    output_seq, attention_weight_seq = [], []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_steps):</span><br><span class="line">        Y, dec_state = net.decoder(dec_X, dec_state)</span><br><span class="line">        <span class="comment"># 我们使用具有预测最高可能性的词元，作为解码器在下一时间步的输入</span></span><br><span class="line">        dec_X = Y.argmax(dim=<span class="number">2</span>)</span><br><span class="line">        pred = dec_X.squeeze(dim=<span class="number">0</span>).<span class="built_in">type</span>(torch.int32).item()</span><br><span class="line">        <span class="comment"># 保存注意力权重（稍后讨论）</span></span><br><span class="line">        <span class="keyword">if</span> save_attention_weights:</span><br><span class="line">            attention_weight_seq.append(net.decoder.attention_weights)</span><br><span class="line">        <span class="comment"># 一旦序列结束词元被预测，输出序列的生成就完成了</span></span><br><span class="line">        <span class="keyword">if</span> pred == tgt_vocab[<span class="string">&#x27;&lt;eos&gt;&#x27;</span>]:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        output_seq.append(pred)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(tgt_vocab.to_tokens(output_seq)), attention_weight_seq</span><br></pre></td></tr></table></figure><hr><h3 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h3><p>我们可以通过与真实的标签序列进行比较来评估预测序列。 BLEU（bilingual evaluation understudy） 最先是用于评估机器翻译的结果， 但现在它已经被广泛用于测量许多应用的输出序列的质量。 原则上说，对于预测序列中的任意$n$元语法（n-grams）， BLEU的评估都是这个$n$元语法是否出现在标签序列中。</p><script type="math/tex; mode=display">\exp\left(\min\left(0, 1 - \frac{\mathrm{len}_{\text{label}}}{\mathrm{len}_{\text{pred}}}\right)\right) \prod_{n=1}^k p_n^{1/2^n},</script><p>其中$\mathrm{len}_{\text{label}}$表示标签序列中的词元数和$\mathrm{len}_{\text{pred}}$表示预测序列中的词元数，$k$是用于匹配的最长的$n$元语法。</p><p>另外，用$p_n$表示$n$元语法的精确度，它是两个数量的比值：第一个是预测序列与标签序列中匹配的$n$元语法的数量，第二个是预测序列中$n$元语法的数量的比率。具体地说，给定标签序列$A$、$B$、$C$、$D$、$E$、$F$和预测序列$A$、$B$、$B$、$C$、$D$，我们有$p_1 = 4/5$、$p_2 = 3/4$、$p_3 = 1/3$和$p_4 = 0$。</p><p>当预测序列与标签序列完全相同时，BLEU为$1$。此外，由于$n$元语法越长则匹配难度越大，所以BLEU为更长的$n$元语法的精确度分配更大的权重。具体来说，当$p_n$固定时，$p_n^{1/2^n}$会随着$n$的增长而增加（原始论文使用$p_n^{1/n}$）。而且，由于预测的序列越短获得的$p_n$值越高，</p><p>所以公式中中乘法项之前的系数用于惩罚较短的预测序列。例如，当$k=2$时，给定标签序列$A$、$B$、$C$、$D$、$E$、$F$和预测序列$A$、$B$，尽管$p_1 = p_2 = 1$，惩罚因子$\exp(1-6/2) \approx 0.14$会降低BLEU。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bleu</span>(<span class="params">pred_seq, label_seq, k</span>):</span>  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算BLEU分数。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    pred_seq: 预测序列，即机器翻译的输出文本。</span></span><br><span class="line"><span class="string">    label_seq: 标签序列，即参考翻译的文本。</span></span><br><span class="line"><span class="string">    k: 最高考虑的n-gram的阶数。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">    BLEU分数。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 将预测序列和标签序列分割成单词列表。</span></span><br><span class="line">    pred_tokens, label_tokens = pred_seq.split(<span class="string">&#x27; &#x27;</span>), label_seq.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    len_pred, len_label = <span class="built_in">len</span>(pred_tokens), <span class="built_in">len</span>(label_tokens)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算长度惩罚项。</span></span><br><span class="line">    score = math.exp(<span class="built_in">min</span>(<span class="number">0</span>, <span class="number">1</span> - len_label / len_pred))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 对于从1到k的每个n，计算n-gram精确度。</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, k + <span class="number">1</span>):</span><br><span class="line">        num_matches = <span class="number">0</span></span><br><span class="line">        label_subs = collections.defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 为标签序列中的所有n-gram建立字典。</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(len_label - n + <span class="number">1</span>):</span><br><span class="line">            label_subs[<span class="string">&#x27; &#x27;</span>.join(label_tokens[i: i + n])] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 对于预测序列中的每个n-gram，如果在标签序列的字典中，则匹配数加1。</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(len_pred - n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> label_subs[<span class="string">&#x27; &#x27;</span>.join(pred_tokens[i: i + n])] &gt; <span class="number">0</span>:</span><br><span class="line">                num_matches += <span class="number">1</span></span><br><span class="line">                label_subs[<span class="string">&#x27; &#x27;</span>.join(pred_tokens[i: i + n])] -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算n-gram精确度并累乘到分数中。</span></span><br><span class="line">        score *= math.<span class="built_in">pow</span>(num_matches / (len_pred - n + <span class="number">1</span>), math.<span class="built_in">pow</span>(<span class="number">0.5</span>, n))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 返回最终的BLEU分数。</span></span><br><span class="line">    <span class="keyword">return</span> score</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="table-container"><table><thead><tr><th>特点/模型</th><th>GRU</th><th>LSTM</th><th>深度循环神经网络</th><th>Seq2Seq</th></tr></thead><tbody><tr><td><strong>基本结构</strong></td><td>2个门（重置门和更新门）</td><td>3个门（遗忘门、输入门、输出门）加上一个细胞状态</td><td>多层RNN堆叠而成</td><td>编码器-解码器结构，可基于RNN、GRU或LSTM</td></tr><tr><td><strong>参数数量</strong></td><td>比LSTM少，因为只有两个门</td><td>相对较多，因为有三个门和一个细胞状态</td><td>随层数增加而大幅增加</td><td>取决于编码器和解码器的具体实现</td></tr><tr><td><strong>记忆能力</strong></td><td>较好，尤其是在较短的序列中</td><td>非常好，能处理长期依赖问题</td><td>通过增加层数增强记忆能力</td><td>优于单一RNN，因为编码器将所有信息压缩成一个上下文向量</td></tr><tr><td><strong>处理长序列能力</strong></td><td>优于基本RNN，但可能不如LSTM</td><td>优于GRU和基本RNN</td><td>通过深层结构提高处理能力，但容易遇到梯度问题</td><td>通过注意力机制（在高级实现中）可以更好地处理长序列</td></tr><tr><td><strong>训练难度</strong></td><td>相对容易，参数少</td><td>相对困难，参数多</td><td>更难，因为层数增多导致的梯度消失或爆炸问题</td><td>取决于序列的长度和复杂性，以及是否使用注意力机制</td></tr><tr><td><strong>应用场景</strong></td><td>序列数据处理，如语言模型、文本生成</td><td>同GRU，但尤其适合需要处理更长依赖的任务</td><td>同GRU和LSTM，但适用于更复杂的序列处理任务</td><td>机器翻译、文本摘要、语音识别等需要序列转换的任务</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.0 循环神经网络</title>
      <link href="/post/53892.html"/>
      <url>/post/53892.html</url>
      
        <content type="html"><![CDATA[<h1 id="循环神经网络"><a href="#循环神经网络" class="headerlink" title="循环神经网络"></a>循环神经网络</h1><h2 id="序列模型"><a href="#序列模型" class="headerlink" title="序列模型"></a>序列模型</h2><p>处理序列数据需要统计工具和新的深度神经网络架构。</p><p>为了简单起见，我们以图中所示的股票价格（富时100指数）为例。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraftse100.png" alt="../_images/ftse100.png" style="zoom:67%;" /></p><p>其中，用$x_t$表示价格，即在<strong>时间步</strong>（time step）$t \in \mathbb{Z}^+$时，观察到的价格$x_t$。请注意，$t$对于本文中的序列通常是离散的，并在整数或其子集上变化。假设一个交易员想在$t$日的股市中表现良好，于是通过以下途径预测$x_t$：</p><script type="math/tex; mode=display">x_t \sim P(x_t \mid x_{t-1}, \ldots, x_1)</script><hr><h3 id="自回归模型"><a href="#自回归模型" class="headerlink" title="自回归模型"></a>自回归模型</h3><p>为了实现这个预测，交易员可以使用<strong>回归模型</strong>，仅有一个主要问题：输入数据的数量，输入$x_{t-1}, \ldots, x_1$本身因$t$而异。也就是说，输入数据的数量这个数字将会随着我们遇到的数据量的增加而增加，因此需要一个近似方法来使这个计算变得容易处理。</p><p>本章后面的大部分内容将围绕着如何有效估计$P(x_t \mid x_{t-1}, \ldots, x_1)$展开。简单地说，它归结为以下两种策略。</p><p>第一种策略，假设在现实情况下相当长的序列$x_{t-1}, \ldots, x_1$可能是不必要的，因此我们只需要满足某个长度为$\tau$的时间跨度，即使用观测序列$x_{t-1}, \ldots, x_{t-\tau}$。当下获得的最直接的好处就是参数的数量总是不变的，至少在$t &gt; \tau$时如此，这就使我们能够训练一个上面提及的深度网络。这种模型被称为<strong>自回归模型</strong>，因为它们是对自己执行回归。</p><p>第二种策略，如图所示，是保留一些对过去观测的总结$h_t$，并且同时更新预测$\hat{x}_t$和总结$h_t$。这就产生了基于$\hat{x}_t = P(x_t \mid h_{t})$估计$x_t$，以及公式$h_t = g(h_{t-1}, x_{t-1})$更新的模型。由于$h_t$从未被观测到，这类模型也被称为<strong>隐变量自回归模型</strong>。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typorasequence-model.svg" alt="../_images/sequence-model.svg"></p><p>这两种情况都有一个显而易见的问题：如何生成训练数据？</p><p>一个经典方法是使用历史观测来预测下一个未来观测。显然，我们并不指望时间会停滞不前。然而，一个常见的假设是虽然特定值$x_t$可能会改变，但是序列本身的动力学不会改变。这样的假设是合理的，因为新的动力学一定受新的数据影响，而我们不可能用目前所掌握的数据来预测新的动力学。统计学家称不变的动力学为<strong>静止的</strong>。因此，整个序列的估计值都将通过以下的方式获得：</p><script type="math/tex; mode=display">P(x_1, \ldots, x_T) = \prod_{t=1}^T P(x_t \mid x_{t-1}, \ldots, x_1).</script><p>注意，如果我们处理的是离散的对象（如单词），而不是连续的数字，则上述的考虑仍然有效。唯一的差别是，对于离散的对象，我们需要使用分类器而不是回归模型来估计$P(x_t \mid  x_{t-1}, \ldots, x_1)$。</p><hr><h3 id="马尔科夫模型"><a href="#马尔科夫模型" class="headerlink" title="马尔科夫模型"></a>马尔科夫模型</h3><p>回想一下，在自回归模型的近似法中，我们使用$x_{t-1}, \ldots, x_{t-\tau}$而不是$x_{t-1}, \ldots, x_1$来估计$x_t$。只要这种是近似精确的，我们就说序列满足<strong>马尔可夫条件</strong>（Markov condition）。特别是，如果$\tau = 1$，得到一个<strong>一阶马尔可夫模型</strong>，$P(x)$由下式给出：</p><script type="math/tex; mode=display">P(x_1, \ldots, x_T) = \prod_{t=1}^T P(x_t \mid x_{t-1}) \text{ 当 } P(x_1 \mid x_0) = P(x_1)</script><p>当假设$x_t$仅是离散值时，这样的模型特别棒，因为在这种情况下，使用动态规划可以沿着马尔可夫链精确地计算结果。例如，我们可以高效地计算$P(x_{t+1} \mid x_{t-1})$：</p><script type="math/tex; mode=display">\begin{aligned}P(x_{t+1} \mid x_{t-1})&= \frac{\sum_{x_t} P(x_{t+1}, x_t, x_{t-1})}{P(x_{t-1})}\\&= \frac{\sum_{x_t} P(x_{t+1} \mid x_t, x_{t-1}) P(x_t, x_{t-1})}{P(x_{t-1})}\\&= \sum_{x_t} P(x_{t+1} \mid x_t) P(x_t \mid x_{t-1})\end{aligned}</script><p>利用这一事实，我们只需要考虑过去观察中的一个非常短的历史：$P(x_{t+1} \mid x_t, x_{t-1}) = P(x_{t+1} \mid x_t)$。</p><p>隐马尔可夫模型中的动态规划超出了本节的范围，而动态规划这些计算工具已经在控制算法和强化学习算法广泛使用。</p><hr><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p>首先，我们生成一些数据：使用正弦函数和一些可加性噪声来生成序列数据， 时间步为1,2,…,1000。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line">T = <span class="number">1000</span>  <span class="comment"># 总共产生1000个点</span></span><br><span class="line">time = torch.arange(<span class="number">1</span>, T + <span class="number">1</span>, dtype=torch.float32)</span><br><span class="line">x = torch.sin(<span class="number">0.01</span> * time) + torch.normal(<span class="number">0</span>, <span class="number">0.2</span>, (T,))</span><br><span class="line">d2l.plot(time, [x], <span class="string">&#x27;time&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, xlim=[<span class="number">1</span>, <span class="number">1000</span>], figsize=(<span class="number">6</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraoutput_sequence_ce248f_6_0.svg" alt="../_images/output_sequence_ce248f_6_0.svg"></p><p>接下来，我们将这个序列转换为模型的<strong>特征－标签</strong>（feature-label）对。基于嵌入维度$\tau$，我们将数据映射为<strong>数据对</strong>$y_t = x_t$和$\mathbf{x}_t = [x_{t-\tau}, \ldots, x_{t-1}]$。</p><p>这比我们提供的数据样本少了$\tau$个，因为我们没有足够的历史记录来描述前$\tau$个数据样本。一个简单的解决办法是：如果拥有足够长的序列就丢弃这几项；另一个方法是用零填充序列。</p><p>在这里，我们仅使用前600个“特征－标签”对进行训练。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假定x是先前定义的包含时间序列数据的张量，T是时间序列的总长度</span></span><br><span class="line">tau = <span class="number">4</span>  <span class="comment"># tau代表我们用于预测未来一个数据点的过去观测值的数量</span></span><br><span class="line">features = torch.zeros((T - tau, tau))  <span class="comment"># 初始化特征矩阵，每一行包含了tau个连续时间点的数据</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(tau):</span><br><span class="line">    <span class="comment"># 为features矩阵的每一列赋值，每一列的数据对应于时间序列的一个滞后</span></span><br><span class="line">    features[:, i] = x[i: T - tau + i]</span><br><span class="line"><span class="comment"># labels是我们要预测的目标，即在给定过去tau个观测值的情况下，下一个时间点的值</span></span><br><span class="line">labels = x[tau:].reshape((-<span class="number">1</span>, <span class="number">1</span>))  <span class="comment"># 将标签数据调整为列向量</span></span><br><span class="line"></span><br><span class="line">batch_size, n_train = <span class="number">16</span>, <span class="number">600</span>  <span class="comment"># 定义批量大小和训练样本数量</span></span><br><span class="line"><span class="comment"># 使用d2l.load_array创建数据迭代器，只有前n_train个样本用于训练</span></span><br><span class="line"><span class="comment"># 这里假设d2l.load_array是一个辅助函数，用于将特征和标签组合成小批量数据</span></span><br><span class="line">train_iter = d2l.load_array((features[:n_train], labels[:n_train]),</span><br><span class="line">                            batch_size, is_train=<span class="literal">True</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这里，我们使用一个相当简单的架构训练模型： 一个拥有两个全连接层的多层感知机，ReLU激活函数和平方损失。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化网络权重的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_weights</span>(<span class="params">m</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(m) == nn.Linear:</span><br><span class="line">        nn.init.xavier_uniform_(m.weight)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个简单的多层感知机</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_net</span>():</span></span><br><span class="line">    net = nn.Sequential(nn.Linear(<span class="number">4</span>, <span class="number">10</span>),</span><br><span class="line">                        nn.ReLU(),</span><br><span class="line">                        nn.Linear(<span class="number">10</span>, <span class="number">1</span>))</span><br><span class="line">    net.apply(init_weights)</span><br><span class="line">    <span class="keyword">return</span> net</span><br><span class="line"></span><br><span class="line"><span class="comment"># 平方损失。注意：MSELoss计算平方误差时不带系数1/2</span></span><br><span class="line">loss = nn.MSELoss(reduction=<span class="string">&#x27;none&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">net, train_iter, loss, epochs, lr</span>):</span></span><br><span class="line">    trainer = torch.optim.Adam(net.parameters(), lr)</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> train_iter:</span><br><span class="line">            trainer.zero_grad()</span><br><span class="line">            l = loss(net(X), y)</span><br><span class="line">            l.<span class="built_in">sum</span>().backward()</span><br><span class="line">            trainer.step()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;epoch <span class="subst">&#123;epoch + <span class="number">1</span>&#125;</span>, &#x27;</span></span><br><span class="line">              <span class="string">f&#x27;loss: <span class="subst">&#123;d2l.evaluate_loss(net, train_iter, loss):f&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">net = get_net()</span><br><span class="line">train(net, train_iter, loss, <span class="number">5</span>, <span class="number">0.01</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h3><p>由于训练损失很小，因此我们期望模型能有很好的工作效果。 让我们看看这在实践中意味着什么。 首先是检查模型预测下一个时间步的能力， 也就是<strong><em>单步预测</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">onestep_preds = net(features)</span><br><span class="line">d2l.plot([time, time[tau:]],</span><br><span class="line">         [x.detach().numpy(), onestep_preds.detach().numpy()], <span class="string">&#x27;time&#x27;</span>,</span><br><span class="line">         <span class="string">&#x27;x&#x27;</span>, legend=[<span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;1-step preds&#x27;</span>], xlim=[<span class="number">1</span>, <span class="number">1000</span>],</span><br><span class="line">         figsize=(<span class="number">6</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraoutput_sequence_ce248f_66_0.svg" alt="../_images/output_sequence_ce248f_66_0.svg"></p><p>正如我们所料，单步预测效果不错。 即使这些预测的时间步超过了600+4（<code>n_train + tau</code>）， 其结果看起来仍然是可信的。 然而有一个小问题：如果数据观察序列的时间步只到604， 我们需要一步一步地向前迈进：</p><script type="math/tex; mode=display">\begin{split}\hat{x}_{605} = f(x_{601}, x_{602}, x_{603}, x_{604}), \\\hat{x}_{606} = f(x_{602}, x_{603}, x_{604}, \hat{x}_{605}), \\\hat{x}_{607} = f(x_{603}, x_{604}, \hat{x}_{605}, \hat{x}_{606}),\\\hat{x}_{608} = f(x_{604}, \hat{x}_{605}, \hat{x}_{606}, \hat{x}_{607}),\\\hat{x}_{609} = f(\hat{x}_{605}, \hat{x}_{606}, \hat{x}_{607}, \hat{x}_{608}),\\\ldots\end{split}</script><p>通常，对于直到$x_t$的观测序列，其在时间步$t+k$处的预测输出$\hat{x}_{t+k}$称为$k$<strong>步预测</strong>由于我们的观察已经到了$x_{604}$，它的$k$步预测是$\hat{x}_{604+k}$。换句话说，我们必须使用我们自己的预测（而不是原始数据）来<strong>进行多步预测</strong>。让我们看看效果如何。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化一个全零的张量用于存储多步预测的结果，长度与时间序列相同</span></span><br><span class="line">multistep_preds = torch.zeros(T)</span><br><span class="line"><span class="comment"># 将训练数据和前tau个观测值直接赋值给multistep_preds的对应位置</span></span><br><span class="line">multistep_preds[: n_train + tau] = x[: n_train + tau]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从n_train + tau开始，逐个生成多步预测的值</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_train + tau, T):</span><br><span class="line">    <span class="comment"># 对于每一步，使用前tau个观测值作为输入来预测下一个值</span></span><br><span class="line">    <span class="comment"># 这里的预测是基于模型已经预测出的值（包括训练数据和之前的预测值）</span></span><br><span class="line">    multistep_preds[i] = net(</span><br><span class="line">        multistep_preds[i - tau:i].reshape((<span class="number">1</span>, -<span class="number">1</span>)))</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 绘制原始数据、单步预测和多步预测的结果</span></span><br><span class="line">d2l.plot([time, time[tau:], time[n_train + tau:]],</span><br><span class="line">         [x.detach().numpy(), onestep_preds.detach().numpy(),</span><br><span class="line">          multistep_preds[n_train + tau:].detach().numpy()], <span class="string">&#x27;time&#x27;</span>,</span><br><span class="line">         <span class="string">&#x27;x&#x27;</span>, legend=[<span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;1-step preds&#x27;</span>, <span class="string">&#x27;multistep preds&#x27;</span>],</span><br><span class="line">         xlim=[<span class="number">1</span>, <span class="number">1000</span>], figsize=(<span class="number">6</span>, <span class="number">3</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraoutput_sequence_ce248f_81_0.svg" alt="../_images/output_sequence_ce248f_81_0.svg"></p><p>如上面的例子所示，绿线的预测显然并不理想。经过几个预测步骤之后，预测的结果很快就会衰减到一个常数。</p><p>事实是由于错误的累积：假设在步骤$1$之后，我们积累了一些错误$\epsilon_1 = \bar\epsilon$。于是，步骤$2$的输入被扰动了$\epsilon_1$，结果积累的误差是依照次序的$\epsilon_2 = \bar\epsilon + c \epsilon_1$，其中$c$为某个常数，后面的预测误差依此类推。</p><p>因此误差可能会相当快地偏离真实的观测结果。例如，未来$24$小时的天气预报往往相当准确，但超过这一点，精度就会迅速下降。基于$k = 1, 4, 16, 64$，通过对整个序列预测的计算，让我们更仔细地看一下$k$步预测的困难。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">max_steps = <span class="number">64</span>  <span class="comment"># 定义最大预测步长</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化特征矩阵，每行包含过去观测值和预测值，用于后续的预测</span></span><br><span class="line">features = torch.zeros((T - tau - max_steps + <span class="number">1</span>, tau + max_steps))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 填充特征矩阵的前tau列，这些列包含过去的观测值</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(tau):</span><br><span class="line">    features[:, i] = x[i: i + T - tau - max_steps + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于特征矩阵的剩余列，使用模型进行预测并填充预测结果</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(tau, tau + max_steps):</span><br><span class="line">    <span class="comment"># 使用net对最近的tau个观测值或预测值进行预测，并将结果填充到特征矩阵中</span></span><br><span class="line">    features[:, i] = net(features[:, i - tau:i]).reshape(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义要展示的不同预测步长</span></span><br><span class="line">steps = (<span class="number">1</span>, <span class="number">4</span>, <span class="number">16</span>, <span class="number">64</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用d2l.plot进行绘图，展示不同预测步长的预测结果</span></span><br><span class="line">d2l.plot([time[tau + i - <span class="number">1</span>: T - max_steps + i] <span class="keyword">for</span> i <span class="keyword">in</span> steps],</span><br><span class="line">         [features[:, (tau + i - <span class="number">1</span>)].detach().numpy() <span class="keyword">for</span> i <span class="keyword">in</span> steps], <span class="string">&#x27;time&#x27;</span>, <span class="string">&#x27;x&#x27;</span>,</span><br><span class="line">         legend=[<span class="string">f&#x27;<span class="subst">&#123;i&#125;</span>-step preds&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> steps], xlim=[<span class="number">5</span>, <span class="number">1000</span>],</span><br><span class="line">         figsize=(<span class="number">6</span>, <span class="number">3</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraoutput_sequence_ce248f_96_0.svg" alt="../_images/output_sequence_ce248f_96_0.svg"></p><p>以上例子清楚地说明了当我们试图预测更远的未来时，预测的质量是如何变化的。 虽然“4步预测”看起来仍然不错，但超过这个跨度的任何预测几乎都是无用的。</p><hr><h2 id="文本预处理"><a href="#文本预处理" class="headerlink" title="文本预处理"></a>文本预处理</h2><p>本节中，我们将解析文本的常见预处理步骤。 这些步骤通常包括：</p><ol><li>将文本作为字符串加载到内存中。</li><li>将字符串拆分为词元（如单词和字符）。</li><li>建立一个词表，将拆分的词元映射到数字索引。</li><li>将文本转换为数字索引序列，方便模型操作。</li></ol><h3 id="读取数据集"><a href="#读取数据集" class="headerlink" title="读取数据集"></a>读取数据集</h3><p>首先，我们从H.G.Well的《时光机器》中加载文本。 这是一个相当小的语料库，只有30000多个单词，但足够我们小试牛刀， 而现实中的文档集合可能会包含数十亿个单词。 下面的函数将数据集读取到由多条文本行组成的列表中，其中每条文本行都是一个字符串。 为简单起见，我们在这里忽略了标点符号和字母大写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line">d2l.DATA_HUB[<span class="string">&#x27;time_machine&#x27;</span>] = (d2l.DATA_URL + <span class="string">&#x27;timemachine.txt&#x27;</span>,</span><br><span class="line">                                <span class="string">&#x27;090b5e7e70c295757f55df93cb0a180b9691891a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_time_machine</span>():</span>  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;将时间机器数据集加载到文本行的列表中&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(d2l.download(<span class="string">&#x27;time_machine&#x27;</span>), <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        lines = f.readlines()</span><br><span class="line">    <span class="keyword">return</span> [re.sub(<span class="string">&#x27;[^A-Za-z]+&#x27;</span>, <span class="string">&#x27; &#x27;</span>, line).strip().lower() <span class="keyword">for</span> line <span class="keyword">in</span> lines]</span><br><span class="line"></span><br><span class="line">lines = read_time_machine()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;# 文本总行数: <span class="subst">&#123;<span class="built_in">len</span>(lines)&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(lines[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(lines[<span class="number">10</span>])</span><br></pre></td></tr></table></figure><p><strong>文本预处理</strong>：</p><ul><li>对于 <code>lines</code> 列表中的每一行文本，函数使用正则表达式 <code>re.sub(&#39;[^A-Za-z]+&#39;, &#39; &#39;, line)</code> 来替换所有非字母字符为一个空格。这样做的目的是清理文本数据，保留文本中的字母字符，并去除数字、标点符号等非字母字符。</li><li><code>.strip()</code> 方法用于去除字符串首尾的空白字符。</li><li><code>.lower()</code> 方法将所有字母字符转换为小写。这是文本处理中常用的归一化步骤，旨在减少词汇的变体，使模型更容易处理文本数据。</li></ul><hr><h3 id="词元化"><a href="#词元化" class="headerlink" title="词元化"></a>词元化</h3><p>下面的<code>tokenize</code>函数将文本行列表（<code>lines</code>）作为输入， 列表中的每个元素是一个文本序列（如一条文本行）。 每个文本序列又被拆分成一个词元列表，<strong><em>词元</em></strong>（token）是文本的基本单位。 最后，返回一个由词元列表组成的列表，其中的每个词元都是一个字符串（string）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tokenize</span>(<span class="params">lines, token=<span class="string">&#x27;word&#x27;</span></span>):</span>  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    将文本行拆分为单词或字符词元。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    lines (list of str): 待处理的文本行列表。</span></span><br><span class="line"><span class="string">    token (str): 指定拆分类型，&#x27;word&#x27;表示按单词拆分，&#x27;char&#x27;表示按字符拆分。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">    list of list: 如果token=&#x27;word&#x27;，返回每行文本拆分成单词形成的列表的列表；</span></span><br><span class="line"><span class="string">                  如果token=&#x27;char&#x27;，返回每行文本拆分成字符形成的列表的列表。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> token == <span class="string">&#x27;word&#x27;</span>:</span><br><span class="line">        <span class="comment"># 按单词拆分：对于列表中的每一行文本，使用str.split()方法按空白字符（如空格、换行符等）拆分成单词。</span></span><br><span class="line">        <span class="keyword">return</span> [line.split() <span class="keyword">for</span> line <span class="keyword">in</span> lines]</span><br><span class="line">    <span class="keyword">elif</span> token == <span class="string">&#x27;char&#x27;</span>:</span><br><span class="line">        <span class="comment"># 按字符拆分：对于列表中的每一行文本，将其转换为一个字符列表。</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">list</span>(line) <span class="keyword">for</span> line <span class="keyword">in</span> lines]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 如果token参数不是&#x27;word&#x27;或&#x27;char&#x27;，则打印错误消息。</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;错误：未知词元类型：&#x27;</span> + token)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设`lines`是已经通过read_time_machine()函数预处理过的文本行列表。</span></span><br><span class="line">tokens = tokenize(lines)  <span class="comment"># 使用默认的按单词拆分对文本行进行词元化处理。</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>):</span><br><span class="line">    <span class="comment"># 打印前11行文本的词元化结果。这里假设tokens列表包含了所有行的词元化结果。</span></span><br><span class="line">    <span class="built_in">print</span>(tokens[i])</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="词表"><a href="#词表" class="headerlink" title="词表"></a>词表</h3><p>词元的类型是字符串，而模型需要的输入是数字，因此这种类型不方便模型使用。 现在，让我们构建一个字典，通常也叫做<strong><em>词表</em></strong>（vocabulary）， 用来将字符串类型的词元映射到从0开始的数字索引中。 我们先将训练集中的所有文档合并在一起，对它们的唯一词元进行统计， 得到的统计结果称之为<strong><em>语料</em></strong>（corpus）。 然后根据每个唯一词元的<strong>出现频率</strong>，为其分配一个<strong>数字索引</strong>。 很少出现的词元通常被移除，这可以降低复杂性。 另外，语料库中不存在或已删除的任何词元都将映射到一个特定的未知词元“<unk>”。 我们可以选择增加一个列表，用于保存那些被保留的词元， 例如：填充词元（<code>&lt;pad&gt;</code>）； 序列开始词元（<code>&lt;bos&gt;</code>）； 序列结束词元（<code>&lt;eos&gt;</code>）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vocab</span>:</span>  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;文本词表&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, tokens=<span class="literal">None</span>, min_freq=<span class="number">0</span>, reserved_tokens=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> tokens <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            tokens = []  <span class="comment"># 如果未提供tokens，则初始化为空列表</span></span><br><span class="line">        <span class="keyword">if</span> reserved_tokens <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            reserved_tokens = []  <span class="comment"># 如果未提供保留词元，则初始化为空列表</span></span><br><span class="line">        <span class="comment"># 统计tokens中每个词元的出现次数，并按频率降序排序</span></span><br><span class="line">        counter = count_corpus(tokens)</span><br><span class="line">        self._token_freqs = <span class="built_in">sorted</span>(counter.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># 初始化词表，未知词元的索引固定为0</span></span><br><span class="line">        self.idx_to_token = [<span class="string">&#x27;&lt;unk&gt;&#x27;</span>] + reserved_tokens</span><br><span class="line">        <span class="comment"># 创建词元到索引的映射字典</span></span><br><span class="line">        self.token_to_idx = &#123;token: idx <span class="keyword">for</span> idx, token <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.idx_to_token)&#125;</span><br><span class="line">        <span class="comment"># 根据出现频率和最小频率阈值添加词元到词表</span></span><br><span class="line">        <span class="keyword">for</span> token, freq <span class="keyword">in</span> self._token_freqs:</span><br><span class="line">            <span class="keyword">if</span> freq &lt; min_freq:  <span class="comment"># 如果词元频率小于最小频率阈值，则忽略</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> token <span class="keyword">not</span> <span class="keyword">in</span> self.token_to_idx:  <span class="comment"># 如果词元不在词表中，则添加进去</span></span><br><span class="line">                self.idx_to_token.append(token)</span><br><span class="line">                self.token_to_idx[token] = <span class="built_in">len</span>(self.idx_to_token) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 返回词表的大小</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.idx_to_token)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, tokens</span>):</span></span><br><span class="line">        <span class="comment"># 获取单个词元或词元列表的索引</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(tokens, (<span class="built_in">list</span>, <span class="built_in">tuple</span>)):</span><br><span class="line">            <span class="keyword">return</span> self.token_to_idx.get(tokens, self.unk)  <span class="comment"># 单个词元</span></span><br><span class="line">        <span class="keyword">return</span> [self.__getitem__(token) <span class="keyword">for</span> token <span class="keyword">in</span> tokens]  <span class="comment"># 词元列表</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_tokens</span>(<span class="params">self, indices</span>):</span></span><br><span class="line">        <span class="comment"># 将索引或索引列表转换回词元或词元列表</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(indices, (<span class="built_in">list</span>, <span class="built_in">tuple</span>)):</span><br><span class="line">            <span class="keyword">return</span> self.idx_to_token[indices]  <span class="comment"># 单个索引</span></span><br><span class="line">        <span class="keyword">return</span> [self.idx_to_token[index] <span class="keyword">for</span> index <span class="keyword">in</span> indices]  <span class="comment"># 索引列表</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">unk</span>(<span class="params">self</span>):</span>  <span class="comment"># 未知词元的索引为0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">token_freqs</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 返回词元及其频率的列表</span></span><br><span class="line">        <span class="keyword">return</span> self._token_freqs</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_corpus</span>(<span class="params">tokens</span>):</span>  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;统计词元的频率&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 如果tokens是二维列表，将其展平为一维列表</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(tokens) == <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">isinstance</span>(tokens[<span class="number">0</span>], <span class="built_in">list</span>):</span><br><span class="line">        tokens = [token <span class="keyword">for</span> line <span class="keyword">in</span> tokens <span class="keyword">for</span> token <span class="keyword">in</span> line]</span><br><span class="line">    <span class="comment"># 使用collections.Counter统计词元出现的次数</span></span><br><span class="line">    <span class="keyword">return</span> collections.Counter(tokens)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们首先使用《时间机器》数据集作为语料库来构建词表，然后打印前几个高频词元及其索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vocab = Vocab(tokens)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(vocab.token_to_idx.items())[:<span class="number">10</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#[(&#x27;&lt;unk&gt;&#x27;, 0), (&#x27;the&#x27;, 1), (&#x27;i&#x27;, 2), (&#x27;and&#x27;, 3), (&#x27;of&#x27;, 4), (&#x27;a&#x27;, 5), (&#x27;to&#x27;, 6), (&#x27;was&#x27;, 7), (&#x27;in&#x27;, 8), (&#x27;that&#x27;, 9)]</span></span><br></pre></td></tr></table></figure><p>现在，我们可以将每一条文本行转换成一个数字索引列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">10</span>]:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;文本:&#x27;</span>, tokens[i])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;索引:&#x27;</span>, vocab[tokens[i]])</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">文本: [&#x27;the&#x27;, &#x27;time&#x27;, &#x27;machine&#x27;, &#x27;by&#x27;, &#x27;h&#x27;, &#x27;g&#x27;, &#x27;wells&#x27;]</span></span><br><span class="line"><span class="string">索引: [1, 19, 50, 40, 2183, 2184, 400]</span></span><br><span class="line"><span class="string">文本: [&#x27;twinkled&#x27;, &#x27;and&#x27;, &#x27;his&#x27;, &#x27;usually&#x27;, &#x27;pale&#x27;, &#x27;face&#x27;, &#x27;was&#x27;, &#x27;flushed&#x27;, &#x27;and&#x27;, &#x27;animated&#x27;, &#x27;the&#x27;]</span></span><br><span class="line"><span class="string">索引: [2186, 3, 25, 1044, 362, 113, 7, 1421, 3, 1045, 1]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><hr><h3 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h3><p>在使用上述函数时，我们将所有功能打包到<code>load_corpus_time_machine</code>函数中， 该函数返回<code>corpus</code>（词元索引列表）和<code>vocab</code>（时光机器语料库的词表）。 我们在这里所做的改变是：</p><ol><li>为了简化后面章节中的训练，我们使用字符（而不是单词）实现文本词元化；</li><li>时光机器数据集中的每个文本行不一定是一个句子或一个段落，还可能是一个单词，因此返回的<code>corpus</code>仅处理为单个列表，而不是使用多词元列表构成的一个列表。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_corpus_time_machine</span>(<span class="params">max_tokens=-<span class="number">1</span></span>):</span>  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    读取《时间机器》数据集，进行字符级的词元化，然后将词元转换为词表中的索引。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    - max_tokens (int): 返回的最大词元数量。-1表示返回所有词元。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">    - corpus (list of int): 词元索引列表，每个词元对应词表中的一个索引。</span></span><br><span class="line"><span class="string">    - vocab (Vocab): 由数据集词元构成的词表。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 读取文本数据</span></span><br><span class="line">    lines = read_time_machine()</span><br><span class="line">    <span class="comment"># 使用字符级词元化处理文本行，得到词元列表</span></span><br><span class="line">    tokens = tokenize(lines, <span class="string">&#x27;char&#x27;</span>)</span><br><span class="line">    <span class="comment"># 根据词元列表创建词表</span></span><br><span class="line">    vocab = Vocab(tokens)</span><br><span class="line">    <span class="comment"># 将所有文本行的词元展平成一个长列表，并转换为词表中的索引</span></span><br><span class="line">    corpus = [vocab[token] <span class="keyword">for</span> line <span class="keyword">in</span> tokens <span class="keyword">for</span> token <span class="keyword">in</span> line]</span><br><span class="line">    <span class="comment"># 如果指定了max_tokens，就截取前max_tokens个词元</span></span><br><span class="line">    <span class="keyword">if</span> max_tokens &gt; <span class="number">0</span>:</span><br><span class="line">        corpus = corpus[:max_tokens]</span><br><span class="line">    <span class="comment"># 返回词元索引列表和词表</span></span><br><span class="line">    <span class="keyword">return</span> corpus, vocab</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用load_corpus_time_machine函数加载数据并创建词表</span></span><br><span class="line">corpus, vocab = load_corpus_time_machine()</span><br><span class="line"><span class="comment"># 输出词元索引列表的长度和词表的大小</span></span><br><span class="line"><span class="built_in">len</span>(corpus), <span class="built_in">len</span>(vocab)</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="语言模型和数据集"><a href="#语言模型和数据集" class="headerlink" title="语言模型和数据集"></a>语言模型和数据集</h2><p>我们了解了如何将文本数据映射为词元，以及将这些词元可以视为一系列离散的观测，例如单词或字符。</p><p>假设长度为$T$的文本序列中的词元依次为$x_1, x_2, \ldots, x_T$。于是，$x_t$（$1 \leq t \leq T$）可以被认为是文本序列在时间步$t$处的观测或标签。</p><p>在给定这样的文本序列时，<strong>语言模型</strong>的目标是估计序列的联合概率</p><script type="math/tex; mode=display">P(x_1, x_2, \ldots, x_T).</script><p>例如，只需要一次抽取一个词元$x_t \sim P(x_t \mid x_{t-1}, \ldots, x_1)$，一个理想的语言模型就能够基于模型本身生成自然文本。与猴子使用打字机完全不同的是，从这样的模型中提取的文本都将作为自然语言（例如，英语文本）来传递。只需要基于前面的对话片断中的文本，就足以生成一个有意义的对话。显然，我们离设计出这样的系统还很遥远，因为它需要“理解”文本，而不仅仅是生成语法合理的内容。</p><p>尽管如此，语言模型依然是非常有用的。例如，短语“to recognize speech”和“to wreck a nice beach”读音上听起来非常相似。这种相似性会导致语音识别中的歧义，但是这很容易通过语言模型来解决，因为第二句的语义很奇怪。同样，在文档摘要生成算法中，“狗咬人”比“人咬狗”出现的频率要高得多。</p><hr><h3 id="学习语言模型"><a href="#学习语言模型" class="headerlink" title="学习语言模型"></a>学习语言模型</h3><p>显而易见，我们面对的问题是如何对一个文档，甚至是一个词元序列进行建模。</p><p>假设在单词级别对文本数据进行词元化</p><p>让我们从基本概率规则开始：</p><script type="math/tex; mode=display">P(x_1, x_2, \ldots, x_T) = \prod_{t=1}^T P(x_t  \mid  x_1, \ldots, x_{t-1})</script><p>例如，包含了四个单词的一个文本序列的概率是：</p><script type="math/tex; mode=display">P(\text{deep}, \text{learning}, \text{is}, \text{fun}) =  P(\text{deep}) P(\text{learning}  \mid  \text{deep}) P(\text{is}  \mid  \text{deep}, \text{learning}) P(\text{fun}  \mid  \text{deep}, \text{learning}, \text{is}).</script><p>为了训练语言模型，我们需要计算单词的概率，以及给定前面几个单词后出现某个单词的条件概率。这些概率本质上就是语言模型的参数。</p><p>训练数据集中词的概率可以根据给定词的相对词频来计算。例如，可以将估计值$\hat{P}(\text{deep})$计算为任何以单词“deep”开头的句子的概率。一种（稍稍不太精确的）方法是统计单词“deep”在数据集中的出现次数，然后将其除以整个语料库中的单词总数。这种方法效果不错，特别是对于频繁出现的单词。接下来，我们可以尝试估计</p><script type="math/tex; mode=display">\hat{P}(\text{learning} \mid \text{deep}) = \frac{n(\text{deep, learning})}{n(\text{deep})},</script><p>其中$n(x)$和$n(x, x’)$分别是单个单词和连续单词对的出现次数。不幸的是，由于连续单词对“deep learning”的出现频率要低得多，所以估计这类单词正确的概率要困难得多。特别是对于一些不常见的单词组合，要想找到足够的出现次数来获得准确的估计可能都不容易。</p><p>而对于三个或者更多的单词组合，情况会变得更糟。许多合理的三个单词组合可能是存在的，但是在数据集中却找不到。除非我们提供某种解决方案，来将这些单词组合指定为非零计数，否则将无法在语言模型中使用它们。如果数据集很小，或者单词非常罕见，那么这类单词出现一次的机会可能都找不到。</p><hr><h3 id="马尔科夫模型与n元语法"><a href="#马尔科夫模型与n元语法" class="headerlink" title="马尔科夫模型与n元语法"></a>马尔科夫模型与n元语法</h3><p>如果$P(x_{t+1} \mid x_t, \ldots, x_1) = P(x_{t+1} \mid x_t)$，则序列上的分布满足一阶马尔可夫性质。阶数越高，对应的依赖关系就越长。这种性质推导出了许多可以应用于序列建模的近似公式：</p><script type="math/tex; mode=display">\begin{split}\begin{aligned}P(x_1, x_2, x_3, x_4) &=  P(x_1) P(x_2) P(x_3) P(x_4),\\P(x_1, x_2, x_3, x_4) &=  P(x_1) P(x_2  \mid  x_1) P(x_3  \mid  x_2) P(x_4  \mid  x_3),\\P(x_1, x_2, x_3, x_4) &=  P(x_1) P(x_2  \mid  x_1) P(x_3  \mid  x_1, x_2) P(x_4  \mid  x_2, x_3).\end{aligned}\end{split}</script><p>通常，涉及一个、两个和三个变量的概率公式分别被称为 <em>一元语法</em>（unigram）、<em>二元语法</em>（bigram）和<em>三元语法</em>（trigram）模型。 下面，我们将学习如何去设计更好的模型。</p><hr><h3 id="自然语言统计"><a href="#自然语言统计" class="headerlink" title="自然语言统计"></a>自然语言统计</h3><p>根据时光机器数据集构建词表， 并打印前10个最常用的（频率最高的）单词。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line">tokens = d2l.tokenize(d2l.read_time_machine())</span><br><span class="line"><span class="comment"># 因为每个文本行不一定是一个句子或一个段落，因此我们把所有文本行拼接到一起</span></span><br><span class="line">corpus = [token <span class="keyword">for</span> line <span class="keyword">in</span> tokens <span class="keyword">for</span> token <span class="keyword">in</span> line]</span><br><span class="line">vocab = d2l.Vocab(corpus)</span><br><span class="line">vocab.token_freqs[:<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[(&#x27;the&#x27;, 2261),</span></span><br><span class="line"><span class="string"> (&#x27;i&#x27;, 1267),</span></span><br><span class="line"><span class="string"> (&#x27;and&#x27;, 1245),</span></span><br><span class="line"><span class="string"> (&#x27;of&#x27;, 1155),</span></span><br><span class="line"><span class="string"> (&#x27;a&#x27;, 816),</span></span><br><span class="line"><span class="string"> (&#x27;to&#x27;, 695),</span></span><br><span class="line"><span class="string"> (&#x27;was&#x27;, 552),</span></span><br><span class="line"><span class="string"> (&#x27;in&#x27;, 541),</span></span><br><span class="line"><span class="string"> (&#x27;that&#x27;, 443),</span></span><br><span class="line"><span class="string"> (&#x27;my&#x27;, 440)]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>这些词通常被称为<em>停用词</em>（stop words），因此可以被过滤掉。 尽管如此，它们本身仍然是有意义的，我们仍然会在模型中使用它们。 此外，还有个明显的问题是词频衰减的速度相当地快。 例如，最常用单词的词频对比，第10个还不到第1个的1/5。 为了更好地理解，我们可以画出的词频图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">freqs = [freq <span class="keyword">for</span> token, freq <span class="keyword">in</span> vocab.token_freqs]</span><br><span class="line">d2l.plot(freqs, xlabel=<span class="string">&#x27;token: x&#x27;</span>, ylabel=<span class="string">&#x27;frequency: n(x)&#x27;</span>,</span><br><span class="line">         xscale=<span class="string">&#x27;log&#x27;</span>, yscale=<span class="string">&#x27;log&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraoutput_language-models-and-dataset_789d14_21_0.svg" alt="../_images/output_language-models-and-dataset_789d14_21_0.svg"></p><p>通过此图我们可以发现：词频以一种明确的方式迅速衰减。 将前几个单词作为例外消除后，剩余的所有单词大致遵循双对数坐标图上的一条直线。 这意味着单词的频率满足<em>齐普夫定律</em>（Zipf’s law）， 即第$i$个最常用单词的频率$n_i$为：</p><script type="math/tex; mode=display">n_i \propto \frac{1}{i^\alpha},</script><p>等价于</p><script type="math/tex; mode=display">\log n_i = -\alpha \log i + c</script><p>其中$\alpha$是刻画分布的指数，$c$是常数。 这告诉我们想要通过计数统计和平滑来建模单词是不可行的， 因为这样建模的结果会大大高估尾部单词的频率，也就是所谓的不常用单词。 </p><p>我们直观地对比三种模型中的词元频率：一元语法、二元语法和三元语法。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraoutput_language-models-and-dataset_789d14_66_0.svg" alt="../_images/output_language-models-and-dataset_789d14_66_0.svg"></p><p>除了一元语法词，单词序列似乎也遵循齐普夫定律， 尽管公式中的指数$\alpha$更小 （指数的大小受序列长度的影响）</p><hr><h3 id="读取长序列数据"><a href="#读取长序列数据" class="headerlink" title="读取长序列数据"></a>读取长序列数据</h3><p>假设我们将使用神经网络来训练语言模型， 模型中的网络一次处理具有预定义长度 （例如$n$个时间步）的一个小批量序列。 现在的问题是如何随机生成一个小批量数据的特征和标签以供读取。</p><p>首先，由于文本序列可以是任意长的， 例如整本《时光机器》（<em>The Time Machine</em>）， 于是任意长的序列可以被我们划分为具有相同时间步数的子序列。 当训练我们的神经网络时，这样的小批量子序列将被输入到模型中。 假设网络一次只处理具有n个时间步的子序列，图中画出了从原始文本序列获得子序列的所有不同的方式， 其中n=5，并且每个时间步的词元对应于一个字符。 请注意，因为我们可以选择任意偏移量来指示初始位置，所以我们有相当大的自由度。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoratimemachine-5gram.svg" alt="../_images/timemachine-5gram.svg"></p><p>因此，我们应该从图中选择哪一个呢？ 事实上，他们都一样的好。 然而，如果我们只选择一个偏移量， 那么用于训练网络的、所有可能的子序列的覆盖范围将是有限的。 因此，我们可以从随机偏移量开始划分序列， 以同时获得<strong><em>覆盖性</em></strong>（coverage）和<strong><em>随机性</em></strong>（randomness）。 下面，我们将描述如何实现<strong><em>随机采样</em></strong>（random sampling）和 <strong><em>顺序分区</em></strong>（sequential partitioning）策略。</p><p><strong>随机采样</strong></p><p>在随机采样中，<strong>每个样本都是在原始的长序列上任意捕获的子序列</strong>。 在迭代过程中，来自两个相邻的、随机的、小批量中的子序列不一定在原始序列上相邻。 对于语言建模，目标是基于到目前为止我们看到的词元来预测下一个词元， 因此<strong>标签是移位了一个词元的原始序列</strong>。</p><p>下面的代码每次可以从数据中随机生成一个小批量。 在这里，参数<code>batch_size</code>指定了每个小批量中子序列样本的数目， 参数<code>num_steps</code>是每个子序列中预定义的时间步数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">seq_data_iter_random</span>(<span class="params">corpus, batch_size, num_steps</span>):</span>  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用随机抽样生成一个小批量子序列&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 从随机偏移量开始对序列进行分区，随机范围包括num_steps-1</span></span><br><span class="line">    corpus = corpus[random.randint(<span class="number">0</span>, num_steps - <span class="number">1</span>):]</span><br><span class="line">    <span class="comment"># 减去1，是因为我们需要考虑标签</span></span><br><span class="line">    num_subseqs = (<span class="built_in">len</span>(corpus) - <span class="number">1</span>) // num_steps</span><br><span class="line">    <span class="comment"># 长度为num_steps的子序列的起始索引</span></span><br><span class="line">    initial_indices = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, num_subseqs * num_steps, num_steps))</span><br><span class="line">    <span class="comment"># 在随机抽样的迭代过程中，</span></span><br><span class="line">    <span class="comment"># 来自两个相邻的、随机的、小批量中的子序列不一定在原始序列上相邻</span></span><br><span class="line">    random.shuffle(initial_indices)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">data</span>(<span class="params">pos</span>):</span></span><br><span class="line">        <span class="comment"># 返回从pos位置开始的长度为num_steps的序列</span></span><br><span class="line">        <span class="keyword">return</span> corpus[pos: pos + num_steps]</span><br><span class="line"></span><br><span class="line">    num_batches = num_subseqs // batch_size</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, batch_size * num_batches, batch_size):</span><br><span class="line">        <span class="comment"># 在这里，initial_indices包含子序列的随机起始索引</span></span><br><span class="line">        initial_indices_per_batch = initial_indices[i: i + batch_size]</span><br><span class="line">        X = [data(j) <span class="keyword">for</span> j <span class="keyword">in</span> initial_indices_per_batch]</span><br><span class="line">        Y = [data(j + <span class="number">1</span>) <span class="keyword">for</span> j <span class="keyword">in</span> initial_indices_per_batch]</span><br><span class="line">        <span class="keyword">yield</span> torch.tensor(X), torch.tensor(Y)</span><br></pre></td></tr></table></figure><p>下面我们生成一个从0到34的序列。 假设批量大小为2，时间步数为5，这意味着可以生成 ⌊(35−1)/5⌋=6个“特征－标签”子序列对。 如果设置小批量大小为2，我们只能得到3个小批量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">my_seq = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">35</span>))</span><br><span class="line"><span class="keyword">for</span> X, Y <span class="keyword">in</span> seq_data_iter_random(my_seq, batch_size=<span class="number">2</span>, num_steps=<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;X: &#x27;</span>, X, <span class="string">&#x27;\nY:&#x27;</span>, Y)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">X:  tensor([[13, 14, 15, 16, 17],</span></span><br><span class="line"><span class="string">        [28, 29, 30, 31, 32]])</span></span><br><span class="line"><span class="string">Y: tensor([[14, 15, 16, 17, 18],</span></span><br><span class="line"><span class="string">        [29, 30, 31, 32, 33]])</span></span><br><span class="line"><span class="string">X:  tensor([[ 3,  4,  5,  6,  7],</span></span><br><span class="line"><span class="string">        [18, 19, 20, 21, 22]])</span></span><br><span class="line"><span class="string">Y: tensor([[ 4,  5,  6,  7,  8],</span></span><br><span class="line"><span class="string">        [19, 20, 21, 22, 23]])</span></span><br><span class="line"><span class="string">X:  tensor([[ 8,  9, 10, 11, 12],</span></span><br><span class="line"><span class="string">        [23, 24, 25, 26, 27]])</span></span><br><span class="line"><span class="string">Y: tensor([[ 9, 10, 11, 12, 13],</span></span><br><span class="line"><span class="string">        [24, 25, 26, 27, 28]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><hr><p><strong>顺序分区</strong></p><p>在迭代过程中，除了对原始序列可以随机抽样外， 我们还可以保证两个相邻的小批量中的子序列在原始序列上也是相邻的。 这种策略在基于小批量的迭代过程中保留了拆分的子序列的顺序，因此称为顺序分区。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">seq_data_iter_sequential</span>(<span class="params">corpus, batch_size, num_steps</span>):</span>  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用顺序分区生成一个小批量子序列&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 从一个小于num_steps的随机偏移量开始，以增加数据的多样性</span></span><br><span class="line">    offset = random.randint(<span class="number">0</span>, num_steps)</span><br><span class="line">    <span class="comment"># 调整corpus的长度以适应整数倍的batch_size</span></span><br><span class="line">    num_tokens = ((<span class="built_in">len</span>(corpus) - offset - <span class="number">1</span>) // batch_size) * batch_size</span><br><span class="line">    <span class="comment"># 生成输入序列Xs</span></span><br><span class="line">    Xs = torch.tensor(corpus[offset: offset + num_tokens])</span><br><span class="line">    <span class="comment"># 生成目标序列Ys，每个位置向后移动一位</span></span><br><span class="line">    Ys = torch.tensor(corpus[offset + <span class="number">1</span>: offset + <span class="number">1</span> + num_tokens])</span><br><span class="line">    <span class="comment"># 重塑Xs和Ys为batch_size行的矩阵形式，方便后续分批处理</span></span><br><span class="line">    Xs, Ys = Xs.reshape(batch_size, -<span class="number">1</span>), Ys.reshape(batch_size, -<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 计算每个epoch中的批次数量</span></span><br><span class="line">    num_batches = Xs.shape[<span class="number">1</span>] // num_steps</span><br><span class="line">    <span class="comment"># 按照num_steps的步长遍历整个数据集，生成每个小批量的数据</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, num_steps * num_batches, num_steps):</span><br><span class="line">        <span class="comment"># 提取当前批次的输入X</span></span><br><span class="line">        X = Xs[:, i: i + num_steps]</span><br><span class="line">        <span class="comment"># 提取与X对应的目标Y</span></span><br><span class="line">        Y = Ys[:, i: i + num_steps]</span><br><span class="line">        <span class="comment"># 以生成器的形式返回当前批次的数据</span></span><br><span class="line">        <span class="keyword">yield</span> X, Y</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>基于相同的设置，通过顺序分区读取每个小批量的子序列的特征<code>X</code>和标签<code>Y</code>。 通过将它们打印出来可以发现： 迭代期间来自两个相邻的小批量中的子序列在原始序列中确实是相邻的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> X, Y <span class="keyword">in</span> seq_data_iter_sequential(my_seq, batch_size=<span class="number">2</span>, num_steps=<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;X: &#x27;</span>, X, <span class="string">&#x27;\nY:&#x27;</span>, Y)</span><br><span class="line">   </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">X:  tensor([[ 0,  1,  2,  3,  4],</span></span><br><span class="line"><span class="string">        [17, 18, 19, 20, 21]])</span></span><br><span class="line"><span class="string">Y: tensor([[ 1,  2,  3,  4,  5],</span></span><br><span class="line"><span class="string">        [18, 19, 20, 21, 22]])</span></span><br><span class="line"><span class="string">X:  tensor([[ 5,  6,  7,  8,  9],</span></span><br><span class="line"><span class="string">        [22, 23, 24, 25, 26]])</span></span><br><span class="line"><span class="string">Y: tensor([[ 6,  7,  8,  9, 10],</span></span><br><span class="line"><span class="string">        [23, 24, 25, 26, 27]])</span></span><br><span class="line"><span class="string">X:  tensor([[10, 11, 12, 13, 14],</span></span><br><span class="line"><span class="string">        [27, 28, 29, 30, 31]])</span></span><br><span class="line"><span class="string">Y: tensor([[11, 12, 13, 14, 15],</span></span><br><span class="line"><span class="string">        [28, 29, 30, 31, 32]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>现在，我们将上面的两个采样函数包装到一个类中， 以便稍后可以将其用作数据迭代器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SeqDataLoader</span>:</span>  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;加载序列数据的迭代器&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, batch_size, num_steps, use_random_iter, max_tokens</span>):</span></span><br><span class="line">        <span class="comment"># 根据use_random_iter参数选择数据迭代器的类型</span></span><br><span class="line">        <span class="comment"># 如果use_random_iter为True, 使用随机抽样方法</span></span><br><span class="line">        <span class="comment"># 否则，使用顺序分区方法</span></span><br><span class="line">        <span class="keyword">if</span> use_random_iter:</span><br><span class="line">            self.data_iter_fn = d2l.seq_data_iter_random</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.data_iter_fn = d2l.seq_data_iter_sequential</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 加载语料库和词汇表，max_tokens限制了加载的最大词元数量</span></span><br><span class="line">        self.corpus, self.vocab = d2l.load_corpus_time_machine(max_tokens)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 设置批量大小和序列长度</span></span><br><span class="line">        self.batch_size, self.num_steps = batch_size, num_steps</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 当迭代这个类的实例时，使用选择的数据迭代函数</span></span><br><span class="line">        <span class="comment"># 生成并返回小批量数据</span></span><br><span class="line">        <span class="keyword">return</span> self.data_iter_fn(self.corpus, self.batch_size, self.num_steps)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后，我们定义了一个函数<code>load_data_time_machine</code>， 它同时返回数据迭代器和词表， 因此可以与其他带有<code>load_data</code>前缀的函数 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data_time_machine</span>(<span class="params">batch_size, num_steps,  <span class="comment">#@save</span></span></span></span><br><span class="line"><span class="params"><span class="function">                           use_random_iter=<span class="literal">False</span>, max_tokens=<span class="number">10000</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回时光机器数据集的迭代器和词表&quot;&quot;&quot;</span></span><br><span class="line">    data_iter = SeqDataLoader(</span><br><span class="line">        batch_size, num_steps, use_random_iter, max_tokens)</span><br><span class="line">    <span class="keyword">return</span> data_iter, data_iter.vocab</span><br></pre></td></tr></table></figure><hr><h2 id="循环神经网络-1"><a href="#循环神经网络-1" class="headerlink" title="循环神经网络"></a>循环神经网络</h2><p>之前我们介绍了$n$元语法模型，其中单词$x_t$在时间步$t$的条件概率仅取决于前面$n-1$个单词。对于时间步$t-(n-1)$之前的单词，如果我们想将其可能产生的影响合并到$x_t$上，需要增加$n$，然而模型参数的数量也会随之呈指数增长，因为词表$\mathcal{V}$需要存储$|\mathcal{V}|^n$个数字，因此与其将$P(x_t \mid x_{t-1}, \ldots, x_{t-n+1})$模型化，</p><p>不如使用隐变量模型：</p><script type="math/tex; mode=display">P(x_t \mid x_{t-1}, \ldots, x_1) \approx P(x_t \mid h_{t-1})</script><p>其中$h_{t-1}$是<strong>隐状态</strong>（hidden state），也称为<strong>隐藏变量</strong>（hidden variable），它存储了到时间步$t-1$的序列信息。通常，我们可以基于当前输入$x_{t}$和先前隐状态$h_{t-1}$来计算时间步$t$处的任何时间的隐状态：</p><script type="math/tex; mode=display">h_t = f(x_{t}, h_{t-1})</script><p>对于公式中的函数$f$，隐变量模型不是近似值。毕竟$h_t$是可以仅仅存储到目前为止观察到的所有数据，然而这样的操作可能会使计算和存储的代价都变得昂贵。</p><p>回想一下，我们在多层感知机中讨论过的具有隐藏单元的隐藏层。值得注意的是，隐藏层和隐状态指的是两个截然不同的概念。如上所述，隐藏层是在从输入到输出的路径上（以观测角度来理解）的隐藏的层，而隐状态则是在给定步骤所做的任何事情（以技术角度来定义）的<strong>输入</strong>，并且这些状态只能通过先前时间步的数据来计算。</p><hr><h3 id="无隐状态的神经网络"><a href="#无隐状态的神经网络" class="headerlink" title="无隐状态的神经网络"></a>无隐状态的神经网络</h3><p>让我们来看一看只有单隐藏层的多层感知机。设隐藏层的激活函数为$\phi$，给定一个小批量样本$\mathbf{X} \in \mathbb{R}^{n \times d}$，其中批量大小为$n$，输入维度为$d$，则隐藏层的输出$\mathbf{H} \in \mathbb{R}^{n \times h}$通过下式计算：</p><script type="math/tex; mode=display">\mathbf{H} = \phi(\mathbf{X} \mathbf{W}_{xh} + \mathbf{b}_h)</script><p>在公式中，我们拥有的隐藏层权重参数为$\mathbf{W}_{xh} \in \mathbb{R}^{d \times h}$，偏置参数为$\mathbf{b}_h \in \mathbb{R}^{1 \times h}$，以及隐藏单元的数目为$h$。因此求和时可以应用广播机制接下来，将隐藏变量$\mathbf{H}$用作输出层的输入。输出层由下式给出：</p><script type="math/tex; mode=display">\mathbf{O} = \mathbf{H} \mathbf{W}_{hq} + \mathbf{b}_q</script><p>其中，$\mathbf{O} \in \mathbb{R}^{n \times q}$是输出变量，</p><p>$\mathbf{W}_{hq} \in \mathbb{R}^{h \times q}$是权重参数，</p><p>$\mathbf{b}_q \in \mathbb{R}^{1 \times q}$是输出层的偏置参数。</p><p>如果是分类问题，我们可以用$\text{softmax}(\mathbf{O})$来计算输出类别的概率分布。这完全类似于之前在之前股票预测问题中解决的回归问题，因此我们省略了细节。无须多言，只要可以随机选择“特征-标签”对，并且通过自动微分和随机梯度下降能够学习网络参数就可以了。</p><hr><h3 id="有隐状态的神经网络"><a href="#有隐状态的神经网络" class="headerlink" title="有隐状态的神经网络"></a>有隐状态的神经网络</h3><p>有了隐状态后，情况就完全不同了。假设我们在时间步$t$有小批量输入$\mathbf{X}_t \in \mathbb{R}^{n \times d}$。换言之，对于$n$个序列样本的小批量，$\mathbf{X}_t$的每一行对应于来自该序列的时间步$t$处的一个样本。接下来，用$\mathbf{H}_t  \in \mathbb{R}^{n \times h}$表示时间步$t$的隐藏变量。</p><p>与多层感知机不同的是，我们在这里保存了前一个时间步的隐藏变量$\mathbf{H}_{t-1}$，并引入了一个新的权重参数$\mathbf{W}_{hh} \in \mathbb{R}^{h \times h}$，来描述如何在当前时间步中使用前一个时间步的隐藏变量。具体地说，当前时间步隐藏变量由当前时间步的输入与前一个时间步的隐藏变量一起计算得出：</p><script type="math/tex; mode=display">\mathbf{H}_t = \phi(\mathbf{X}_t \mathbf{W}_{xh} + \mathbf{H}_{t-1} \mathbf{W}_{hh}  + \mathbf{b}_h)</script><p>与原公式相比，有隐状态多添加了一项$\mathbf{H}_{t-1} \mathbf{W}_{hh}$，从而实例化了隐状态，从相邻时间步的隐藏变量$\mathbf{H}_t$和$\mathbf{H}_{t-1}$之间的关系可知，这些变量捕获并保留了序列直到其当前时间步的历史信息，就如当前时间步下神经网络的状态或记忆，因此这样的隐藏变量被称为<strong>隐状态</strong></p><p>由于在当前时间步中，隐状态使用的定义与前一个时间步中使用的定义<strong>相同</strong>，因此公式中的计算是<strong>循环的</strong>。于是基于循环计算的隐状态神经网络被命名为<strong>循环神经网络</strong>（recurrent neural network）。在循环神经网络中执行计算的层称为<strong>循环层</strong></p><hr><p>有许多不同的方法可以构建循环神经网络，公式中定义的隐状态的循环神经网络是非常常见的一种。对于时间步$t$，输出层的输出类似于多层感知机中的计算：</p><script type="math/tex; mode=display">\mathbf{O}_t = \mathbf{H}_t \mathbf{W}_{hq} + \mathbf{b}_q</script><p>循环神经网络的参数包括隐藏层的权重$\mathbf{W}_{xh} \in \mathbb{R}^{d \times h}, \mathbf{W}_{hh} \in \mathbb{R}^{h \times h}$和偏置$\mathbf{b}_h \in \mathbb{R}^{1 \times h}$，以及输出层的权重$\mathbf{W}_{hq} \in \mathbb{R}^{h \times q}$和偏置$\mathbf{b}_q \in \mathbb{R}^{1 \times q}$。值得一提的是，即使在不同的时间步，循环神经网络也总是使用这些模型参数。因此，循环神经网络的参数开销不会随着时间步的增加而增加。</p><p>循环神经网络（RNN）的参数包括以下几部分，这些参数共同定义了RNN的行为：</p><ol><li><p><strong>隐藏层的权重</strong> ($W_{xh} \in \mathbb{R}^{d \times h}$)：这是输入层到隐藏层的权重矩阵。其中(d)代表输入特征的维度，(h)代表隐藏层单元的数量。该矩阵负责将输入转换到隐藏状态空间。</p></li><li><p><strong>隐藏层自回归的权重</strong> ($W_{hh} \in \mathbb{R}^{h \times h}$)：这是从前一时间步的隐藏层到当前时间步的隐藏层的权重矩阵。它使网络能够学习时间序列数据中的序列依赖性。</p></li><li><p><strong>隐藏层的偏置</strong> ($b_h \in \mathbb{R}^{1 \times h}$)：这是隐藏层的偏置向量，用于添加到隐藏状态的线性转换中。</p></li><li><p><strong>输出层的权重</strong> ($W_{hq} \in \mathbb{R}^{h \times q}$)：这是从隐藏层到输出层的权重矩阵。(q)代表输出特征的维度。该矩阵负责将隐藏状态转换为最终的输出。</p></li><li><p><strong>输出层的偏置</strong> ($b_q \in \mathbb{R}^{1 \times q}$)：这是输出层的偏置向量，用于添加到输出层的线性转换中。</p></li></ol><p>RNN的特点是在所有时间步中重复使用这些参数。这种参数共享机制意味着，即使序列数据的长度变化，RNN模型的参数数量保持不变，从而使RNN能够处理不同长度的序列数据。这种设计不仅减少了模型的参数量，还帮助模型捕捉长期依赖，是RNN处理时间序列数据的关键特性。</p><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typorarnn.svg" alt="../_images/rnn.svg"></p><p>展示了循环神经网络在三个相邻时间步的计算逻辑。在任意时间步$t$，隐状态的计算可以被视为：</p><ul><li>拼接当前时间步$t$的输入$\mathbf{X}_t$和前一时间步$t-1$的隐状态$\mathbf{H}_{t-1}$</li><li>将拼接的结果送入带有激活函数$\phi$的全连接层。全连接层的输出是当前时间步$t$的隐状态$\mathbf{H}_t$。</li></ul><p>在本例中，模型参数是$\mathbf{W}_{xh}$和$\mathbf{W}_{hh}$的拼接，以及$\mathbf{b}_h$的偏置，所有这些参数都来自公式，当前时间步$t$的隐状态$\mathbf{H}_t$将参与计算下一时间步$t+1$的隐状态$\mathbf{H}_{t+1}$。而且$\mathbf{H}_t$还将送入全连接输出层，用于计算当前时间步$t$的输出$\mathbf{O}_t$。</p><hr><h3 id="基于循环神经网络的字符级语言模型"><a href="#基于循环神经网络的字符级语言模型" class="headerlink" title="基于循环神经网络的字符级语言模型"></a>基于循环神经网络的字符级语言模型</h3><p>回想一下之前的语言模型， 我们的目标是根据过去的和当前的词元预测下一个词元， 因此我们将原始序列移位一个词元作为标签。接下来，我们看一下如何使用循环神经网络来构建语言模型。 设小批量大小为1，批量中的文本序列为“machine”。 为了简化后续部分的训练，我们考虑使用 <strong><em>字符级语言模型</em></strong>， 将文本词元化为字符而不是单词。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typorarnn-train.svg" alt="../_images/rnn-train.svg"></p><p>图中演示了 如何通过基于字符级语言建模的循环神经网络， 使用当前的和先前的字符预测下一个字符。</p><p>在训练过程中，我们对每个时间步的输出层的输出进行$softmax$操作， 然后利用<strong>交叉熵损失</strong>计算模型输出和标签之间的误差。 由于隐藏层中隐状态的循环计算，图中的第3个时间步的输出$O_3$ 由文本序列“m”“a”和“c”确定。 由于训练数据中这个文本序列的下一个字符是“h”， 因此第3个时间步的损失将取决于下一个字符的概率分布， 而下一个字符是基于特征序列“m”“a”“c”和这个时间步的标签“h”生成的。</p><p>在实践中，我们使用的批量大小为$n&gt;1$，每个词元都由一个$d$维向量表示。因此，在时间步$t$输入$\mathbf X_t$将是一个$n\times d$矩阵，这与我们在上一小节中的讨论相同。</p><hr><h3 id="困惑度"><a href="#困惑度" class="headerlink" title="困惑度"></a>困惑度</h3><p>最后，让我们讨论如何度量语言模型的质量， 这将在后续部分中用于评估基于循环神经网络的模型。 一个好的语言模型能够用高度准确的词元来预测我们接下来会看到什么。</p><p>我们可以通过计算序列的似然概率来度量模型的质量。 然而这是一个难以理解、难以比较的数字。 毕竟，较短的序列比较长的序列更有可能出现， 因此评估模型产生托尔斯泰的巨著《战争与和平》的可能性 不可避免地会比产生圣埃克苏佩里的中篇小说《小王子》可能性要小得多。 而缺少的可能性值相当于平均数。</p><p>如果想要压缩文本，我们可以根据当前词元集预测的下一个词元。 一个更好的语言模型应该能让我们更准确地预测下一个词元。 因此，它应该允许我们在压缩序列时花费更少的比特。 所以我们可以通过一个序列中所有的$n$个词元的<strong>交叉熵损失</strong>的平均值来衡量：</p><script type="math/tex; mode=display">\frac{1}{n} \sum_{t=1}^n -\log P(x_t \mid x_{t-1}, \ldots, x_1)</script><p>其中$P$由语言模型给出，$x_t$是在时间步$t$从该序列中观察到的实际词元。这使得不同长度的文档的性能具有了可比性。由于历史原因，自然语言处理的科学家更喜欢使用一个叫做<strong>困惑度</strong>（perplexity）的量。简而言之，是交叉熵损失的平均值的指数</p><script type="math/tex; mode=display">\exp\left(-\frac{1}{n} \sum_{t=1}^n \log P(x_t \mid x_{t-1}, \ldots, x_1)\right)</script><p>困惑度的最好的理解是“下一个词元的实际选择数的调和平均数”。 我们看看一些案例。</p><ul><li>在最好的情况下，模型总是完美地估计标签词元的概率为1。 在这种情况下，模型的困惑度为1。</li><li>在最坏的情况下，模型总是预测标签词元的概率为0。 在这种情况下，困惑度是正无穷大。</li><li>在基线上，该模型的预测是词表的所有可用词元上的均匀分布。 在这种情况下，困惑度等于词表中唯一词元的数量。 事实上，如果我们在没有任何压缩的情况下存储序列， 这将是我们能做的最好的编码方式。 因此，这种方式提供了一个重要的上限， 而任何实际模型都必须超越这个上限。</li></ul><hr><h2 id="从零实现"><a href="#从零实现" class="headerlink" title="从零实现"></a>从零实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line">batch_size, num_steps = <span class="number">32</span>, <span class="number">35</span></span><br><span class="line">train_iter, vocab = d2l.load_data_time_machine(batch_size, num_steps)</span><br></pre></td></tr></table></figure><h3 id="独热编码"><a href="#独热编码" class="headerlink" title="独热编码"></a>独热编码</h3><p>回想一下，在<code>train_iter</code>中，每个词元都表示为一个数字索引， 将这些索引直接输入神经网络可能会使学习变得困难。 我们通常将每个词元表示为更具表现力的特征向量。 最简单的表示称为<strong><em>独热编码</em></strong></p><p>我们每次采样的小批量数据形状是二维张量： （批量大小，时间步数）。 <code>one_hot</code>函数将这样一个小批量数据转换成三维张量， 张量的最后一个维度等于词表大小（<code>len(vocab)</code>）。 我们经常转换输入的维度，以便获得形状为 （时间步数，批量大小，词表大小）的输出。 这将使我们能够更方便地通过最外层的维度， 一步一步地更新小批量数据的隐状态。</p><hr><h3 id="初始化模型参数"><a href="#初始化模型参数" class="headerlink" title="初始化模型参数"></a>初始化模型参数</h3><p>接下来，我们初始化循环神经网络模型的模型参数。 隐藏单元数<code>num_hiddens</code>是一个可调的超参数。 当训练语言模型时，输入和输出来自相同的词表。 因此，它们具有相同的维度，即词表的大小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_params</span>(<span class="params">vocab_size, num_hiddens, device</span>):</span></span><br><span class="line">    <span class="comment"># vocab_size是词汇表的大小，即输入和输出的维度大小</span></span><br><span class="line">    <span class="comment"># num_hiddens是隐藏层的维度大小</span></span><br><span class="line">    <span class="comment"># device是模型运行的设备（CPU或GPU）</span></span><br><span class="line">    num_inputs = num_outputs = vocab_size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">normal</span>(<span class="params">shape</span>):</span></span><br><span class="line">        <span class="comment"># 生成正态分布的随机数，用于初始化权重，乘以0.01使得权重较小</span></span><br><span class="line">        <span class="keyword">return</span> torch.randn(size=shape, device=device) * <span class="number">0.01</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 隐藏层参数</span></span><br><span class="line">    W_xh = normal((num_inputs, num_hiddens))  <span class="comment"># 输入到隐藏层的权重</span></span><br><span class="line">    W_hh = normal((num_hiddens, num_hiddens)) <span class="comment"># 隐藏层到隐藏层的权重</span></span><br><span class="line">    b_h = torch.zeros(num_hiddens, device=device) <span class="comment"># 隐藏层的偏置，初始化为0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出层参数</span></span><br><span class="line">    W_hq = normal((num_hiddens, num_outputs)) <span class="comment"># 隐藏层到输出层的权重</span></span><br><span class="line">    b_q = torch.zeros(num_outputs, device=device) <span class="comment"># 输出层的偏置，初始化为0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将所有参数合并到一个列表中，并设置它们为需要梯度的，以便在训练过程中对它们进行更新</span></span><br><span class="line">    params = [W_xh, W_hh, b_h, W_hq, b_q]</span><br><span class="line">    <span class="keyword">for</span> param <span class="keyword">in</span> params:</span><br><span class="line">        param.requires_grad_(<span class="literal">True</span>) <span class="comment"># 开启梯度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> params</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>为了定义循环神经网络模型， 我们首先需要一个<code>init_rnn_state</code>函数在初始化时返回隐状态。 这个函数的返回是一个张量，张量全用0填充， 形状为（批量大小，隐藏单元数）。 在后面的章节中我们将会遇到隐状态包含多个变量的情况， 而使用元组可以更容易地处理些。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_rnn_state</span>(<span class="params">batch_size, num_hiddens, device</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (torch.zeros((batch_size, num_hiddens), device=device), )</span><br></pre></td></tr></table></figure><p>下面的<code>rnn</code>函数定义了如何在一个时间步内计算隐状态和输出。 循环神经网络模型通过<code>inputs</code>最外层的维度实现循环， 以便逐时间步更新小批量数据的隐状态<code>H</code>。 这里使用$tanh$作为激活函数，当元素在实数上满足均匀分布时，$tanh$函数的平均值为0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rnn</span>(<span class="params">inputs, state, params</span>):</span></span><br><span class="line">    <span class="comment"># inputs的形状：(时间步数量，批量大小，词表大小)</span></span><br><span class="line">    W_xh, W_hh, b_h, W_hq, b_q = params</span><br><span class="line">    H, = state</span><br><span class="line">    outputs = []</span><br><span class="line">    <span class="comment"># X的形状：(批量大小，词表大小)</span></span><br><span class="line">    <span class="keyword">for</span> X <span class="keyword">in</span> inputs:</span><br><span class="line">        H = torch.tanh(torch.mm(X, W_xh) + torch.mm(H, W_hh) + b_h)</span><br><span class="line">        Y = torch.mm(H, W_hq) + b_q</span><br><span class="line">        outputs.append(Y)</span><br><span class="line">    <span class="keyword">return</span> torch.cat(outputs, dim=<span class="number">0</span>), (H,)</span><br></pre></td></tr></table></figure><p>定义了所有需要的函数之后，接下来我们创建一个类来包装这些函数， 并存储从零开始实现的循环神经网络模型的参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RNNModelScratch</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;从零开始实现的循环神经网络模型&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, vocab_size, num_hiddens, device,</span></span></span><br><span class="line"><span class="params"><span class="function">                 get_params, init_state, forward_fn</span>):</span></span><br><span class="line">        <span class="comment"># vocab_size: 词汇表的大小，即输入和输出的维度。</span></span><br><span class="line">        <span class="comment"># num_hiddens: 隐藏层的维度大小。</span></span><br><span class="line">        <span class="comment"># device: 模型运行的设备（CPU或GPU）。</span></span><br><span class="line">        <span class="comment"># get_params: 函数，用于初始化模型参数。</span></span><br><span class="line">        <span class="comment"># init_state: 函数，用于初始化隐藏状态。</span></span><br><span class="line">        <span class="comment"># forward_fn: 函数，定义了模型的前向传播。</span></span><br><span class="line">        self.vocab_size, self.num_hiddens = vocab_size, num_hiddens</span><br><span class="line">        self.params = get_params(vocab_size, num_hiddens, device)  <span class="comment"># 初始化模型参数</span></span><br><span class="line">        self.init_state, self.forward_fn = init_state, forward_fn  <span class="comment"># 初始化状态和前向函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, X, state</span>):</span></span><br><span class="line">        <span class="comment"># 将输入X通过one_hot编码，并转换数据类型为float32。</span></span><br><span class="line">        <span class="comment"># X.T使得批量大小维度和时间步维度交换，以满足one_hot函数的输入需求。</span></span><br><span class="line">        X = F.one_hot(X.T, self.vocab_size).<span class="built_in">type</span>(torch.float32)</span><br><span class="line">        <span class="comment"># 调用forward_fn函数执行模型的前向传播。</span></span><br><span class="line">        <span class="comment"># 返回计算得到的输出和新的隐藏状态。</span></span><br><span class="line">        <span class="keyword">return</span> self.forward_fn(X, state, self.params)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">begin_state</span>(<span class="params">self, batch_size, device</span>):</span></span><br><span class="line">        <span class="comment"># 调用init_state函数生成初始的隐藏状态。</span></span><br><span class="line">        <span class="comment"># batch_size: 指定批量的大小。</span></span><br><span class="line">        <span class="comment"># 返回初始化的隐藏状态。</span></span><br><span class="line">        <span class="keyword">return</span> self.init_state(batch_size, self.num_hiddens, device)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>让我们检查输出是否具有正确的形状。 例如，隐状态的维数是否保持不变。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">num_hiddens = <span class="number">512</span></span><br><span class="line">net = RNNModelScratch(<span class="built_in">len</span>(vocab), num_hiddens, d2l.try_gpu(), get_params,</span><br><span class="line">                      init_rnn_state, rnn)</span><br><span class="line">state = net.begin_state(X.shape[<span class="number">0</span>], d2l.try_gpu())</span><br><span class="line">Y, new_state = net(X.to(d2l.try_gpu()), state)</span><br><span class="line">Y.shape, <span class="built_in">len</span>(new_state), new_state[<span class="number">0</span>].shape</span><br><span class="line"><span class="comment">#(torch.Size([10, 28]), 1, torch.Size([2, 512]))</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们可以看到输出形状是（时间步数×批量大小，词表大小）， 而隐状态形状保持不变，即（批量大小，隐藏单元数）。</p><hr><h3 id="预测-1"><a href="#预测-1" class="headerlink" title="预测"></a>预测</h3><p>让我们首先定义预测函数来生成<code>prefix</code>之后的新字符， 其中的<code>prefix</code>是一个用户提供的包含多个字符的字符串。 在循环遍历<code>prefix</code>中的开始字符时， 我们不断地将隐状态传递到下一个时间步，但是不生成任何输出。 这被称为<em>预热</em>（warm-up）期， 因为在此期间模型会自我更新（例如，更新隐状态）， 但不会进行预测。 预热期结束后，隐状态的值通常比刚开始的初始值更适合预测， 从而预测字符并输出它们。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict_ch8</span>(<span class="params">prefix, num_preds, net, vocab, device</span>):</span>  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;在prefix后面生成新字符&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 初始化模型的隐藏状态，batch_size设为1，因为一次只生成一个字符。</span></span><br><span class="line">    state = net.begin_state(batch_size=<span class="number">1</span>, device=device)</span><br><span class="line">    <span class="comment"># outputs列表初始化为前缀的第一个字符的索引。</span></span><br><span class="line">    outputs = [vocab[prefix[<span class="number">0</span>]]]</span><br><span class="line">    <span class="comment"># 定义一个lambda函数，用于获取模型的当前输入。</span></span><br><span class="line">    <span class="comment"># 输入是outputs列表中的最后一个元素（即最新生成的字符索引）。</span></span><br><span class="line">    get_input = <span class="keyword">lambda</span>: torch.tensor([outputs[-<span class="number">1</span>]], device=device).reshape((<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 预热期：使用前缀中的字符（除了第一个）来更新模型的隐藏状态。</span></span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> prefix[<span class="number">1</span>:]:</span><br><span class="line">        <span class="comment"># 更新隐藏状态，但不收集这些字符的输出，因为这一阶段只是为了根据已知的前缀来设置隐藏状态。</span></span><br><span class="line">        _, state = net(get_input(), state)</span><br><span class="line">        <span class="comment"># 将前缀中当前字符的索引添加到输出列表中。</span></span><br><span class="line">        outputs.append(vocab[y])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 预测阶段：根据当前的隐藏状态和最后一个字符来生成新的字符。</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_preds):</span><br><span class="line">        <span class="comment"># 生成一个字符及更新隐藏状态。</span></span><br><span class="line">        y, state = net(get_input(), state)</span><br><span class="line">        <span class="comment"># 选择概率最高的字符索引作为输出，并添加到outputs列表中。</span></span><br><span class="line">        outputs.append(<span class="built_in">int</span>(y.argmax(dim=<span class="number">1</span>).reshape(<span class="number">1</span>)))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将生成的字符索引转换回字符，并拼接成字符串返回。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join([vocab.idx_to_token[i] <span class="keyword">for</span> i <span class="keyword">in</span> outputs])</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在我们可以测试<code>predict_ch8</code>函数。 我们将前缀指定为<code>time traveller</code>， 并基于这个前缀生成10个后续字符。 鉴于我们还没有训练网络，它会生成荒谬的预测结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">predict_ch8(<span class="string">&#x27;time traveller &#x27;</span>, <span class="number">10</span>, net, vocab, d2l.try_gpu())</span><br><span class="line"><span class="comment">#&#x27;time traveller aaaaaaaaaa&#x27;</span></span><br></pre></td></tr></table></figure><hr><h3 id="梯度剪裁"><a href="#梯度剪裁" class="headerlink" title="梯度剪裁"></a>梯度剪裁</h3><p>这个<code>grad_clipping</code>函数的目的是在训练神经网络时对梯度进行裁剪，以防止梯度爆炸问题，这是在训练循环神经网络（RNNs）时经常需要采取的一种措施。函数的工作原理如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grad_clipping</span>(<span class="params">net, theta</span>):</span>  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;裁剪梯度&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 如果net是一个nn.Module的实例，即PyTorch的模型，</span></span><br><span class="line">    <span class="comment"># 则从模型参数中选出需要梯度的参数。</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(net, nn.Module):</span><br><span class="line">        params = [p <span class="keyword">for</span> p <span class="keyword">in</span> net.parameters() <span class="keyword">if</span> p.requires_grad]</span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># 否则，假设net是一个自定义的模型，其参数存储在net.params中。</span></span><br><span class="line">        params = net.params</span><br><span class="line">    <span class="comment"># 计算所有参数的梯度的范数。</span></span><br><span class="line">    norm = torch.sqrt(<span class="built_in">sum</span>(torch.<span class="built_in">sum</span>((p.grad ** <span class="number">2</span>)) <span class="keyword">for</span> p <span class="keyword">in</span> params))</span><br><span class="line">    <span class="comment"># 如果范数超过了给定的阈值theta，</span></span><br><span class="line">    <span class="comment"># 则对所有参数的梯度进行等比缩放，使得范数降至theta。</span></span><br><span class="line">    <span class="keyword">if</span> norm &gt; theta:</span><br><span class="line">        <span class="keyword">for</span> param <span class="keyword">in</span> params:</span><br><span class="line">            param.grad[:] *= theta / norm</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>梯度裁剪通过限制梯度的范数，避免了在训练过程中由于梯度过大导致的参数更新过猛，从而引起的模型不稳定或梯度爆炸问题。</p><hr><h3 id="训练-1"><a href="#训练-1" class="headerlink" title="训练"></a>训练</h3><p>在训练模型之前，让我们定义一个函数在一个迭代周期内训练模型。 它与softmax训练模型的方式有三个不同之处。</p><ol><li>序列数据的不同采样方法（随机采样和顺序分区）将导致隐状态初始化的差异。</li><li>我们在更新模型参数之前裁剪梯度。 这样的操作的目的是，即使训练过程中某个点上发生了梯度爆炸，也能保证模型不会发散。</li><li>我们用<strong>困惑度</strong>来评价模型。 这样的度量确保了不同长度的序列具有可比性。</li></ol><p><strong>顺序分区</strong>：我们只在每个迭代周期的开始位置初始化隐状态。 由于下一个小批量数据中的第$i$个子序列样本 与当前第$i$个子序列样本相邻， 因此当前小批量数据最后一个样本的隐状态， 将用于初始化下一个小批量数据第一个样本的隐状态。 这样，存储在隐状态中的序列的历史信息 可以在一个迭代周期内流经相邻的子序列。 然而，在任何一点隐状态的计算， 都依赖于同一迭代周期中前面所有的小批量数据， 这使得梯度计算变得复杂。 为了降低计算量，在处理任何一个小批量数据之前， 我们先分离梯度，使得隐状态的梯度计算总是限制在一个小批量数据的时间步内。</p><p><strong>随机抽样</strong>：因为每个样本都是在一个随机位置抽样的， 因此需要为每个迭代周期重新初始化隐状态。 与softmax中的 <code>train_epoch_ch3</code>函数相同， <code>updater</code>是更新模型参数的常用函数。 它既可以是从头开始实现的<code>d2l.sgd</code>函数， 也可以是深度学习框架中内置的优化函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_epoch_ch8</span>(<span class="params">net, train_iter, loss, updater, device, use_random_iter</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;训练网络一个迭代周期&quot;&quot;&quot;</span></span><br><span class="line">    state, timer = <span class="literal">None</span>, d2l.Timer()  <span class="comment"># 初始化状态和计时器</span></span><br><span class="line">    metric = d2l.Accumulator(<span class="number">2</span>)  <span class="comment"># 初始化累加器，用于累计训练损失和处理的词元数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> X, Y <span class="keyword">in</span> train_iter:  <span class="comment"># 遍历数据集</span></span><br><span class="line">        <span class="comment"># 根据use_random_iter决定是否在每次迭代时重新初始化状态</span></span><br><span class="line">        <span class="keyword">if</span> state <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> use_random_iter:</span><br><span class="line">            state = net.begin_state(batch_size=X.shape[<span class="number">0</span>], device=device) </span><br><span class="line">            <span class="comment"># 初始化或重置状态</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果状态不需要重置，且是可分离的，对其进行分离操作</span></span><br><span class="line">            <span class="comment"># 这样做是为了截断反向传播时的梯度流</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(net, nn.Module) <span class="keyword">and</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(state, <span class="built_in">tuple</span>):</span><br><span class="line">                state.detach_()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> s <span class="keyword">in</span> state:</span><br><span class="line">                    s.detach_()</span><br><span class="line">        y = Y.T.reshape(-<span class="number">1</span>)  <span class="comment"># 将标签Y转换为适合损失函数的形式</span></span><br><span class="line">        X, y = X.to(device), y.to(device)  <span class="comment"># 将数据和标签移至指定的设备</span></span><br><span class="line"></span><br><span class="line">        y_hat, state = net(X, state)  <span class="comment"># 前向传播</span></span><br><span class="line">        l = loss(y_hat, y.long()).mean()  <span class="comment"># 计算损失并取均值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 根据updater的类型进行梯度清零、反向传播、梯度裁剪和参数更新</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(updater, torch.optim.Optimizer):</span><br><span class="line">            updater.zero_grad()  <span class="comment"># 梯度清零</span></span><br><span class="line">            l.backward()  <span class="comment"># 反向传播</span></span><br><span class="line">            grad_clipping(net, <span class="number">1</span>)  <span class="comment"># 梯度裁剪</span></span><br><span class="line">            updater.step()  <span class="comment"># 参数更新</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l.backward()</span><br><span class="line">            grad_clipping(net, <span class="number">1</span>)  <span class="comment"># 梯度裁剪</span></span><br><span class="line">            updater(batch_size=<span class="number">1</span>)  <span class="comment"># 手动更新参数</span></span><br><span class="line"></span><br><span class="line">        metric.add(l * y.numel(), y.numel())  <span class="comment"># 更新累加器的统计</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算本迭代周期的困惑度和吞吐量（每秒处理的词元数量）</span></span><br><span class="line">    <span class="keyword">return</span> math.exp(metric[<span class="number">0</span>] / metric[<span class="number">1</span>]), metric[<span class="number">1</span>] / timer.stop()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在训练循环神经网络（RNN）时，<code>detach_()</code>方法的调用是为了截断反向传播时的梯度流。这是因为在RNN中，通过时间反向传播（Backpropagation Through Time, BPTT）是用来计算梯度的。BPTT会追溯每一步的计算，这可能会导致两个主要问题：</p><ol><li><strong>梯度消失或梯度爆炸</strong>：当梯度通过很长的序列传播时，它们可能会变得非常小（消失）或非常大（爆炸），这使得网络难以学习。</li><li><strong>计算成本高</strong>：随着序列长度的增加，存储过去所有状态的梯度所需的计算资源（如内存）会显著增加。</li></ol><p>为了缓解这些问题，<code>detach_()</code>方法被用于将状态变量（<code>state</code>）从前一时间步的计算历史中分离出来。这样做的结果是，在当前时间步计算梯度时，梯度不会被反向传播到这个状态变量之前的任何时间步。换句话说，这限制了梯度反向传播的深度，从而减少了梯度消失或爆炸的风险，并减少了每次迭代的计算负担。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_ch8</span>(<span class="params">net, train_iter, vocab, lr, num_epochs, device, use_random_iter=<span class="literal">False</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;训练模型（定义见第8章）&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 使用交叉熵损失函数</span></span><br><span class="line">    loss = nn.CrossEntropyLoss()</span><br><span class="line">    <span class="comment"># 初始化动画制作工具，用于可视化训练进度</span></span><br><span class="line">    animator = d2l.Animator(xlabel=<span class="string">&#x27;epoch&#x27;</span>, ylabel=<span class="string">&#x27;perplexity&#x27;</span>,</span><br><span class="line">                            legend=[<span class="string">&#x27;train&#x27;</span>], xlim=[<span class="number">10</span>, num_epochs])</span><br><span class="line">    <span class="comment"># 根据网络类型初始化优化器</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(net, nn.Module):</span><br><span class="line">        updater = torch.optim.SGD(net.parameters(), lr)  <span class="comment"># 对于PyTorch模型</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        updater = <span class="keyword">lambda</span> batch_size: d2l.sgd(net.params, lr, batch_size) </span><br><span class="line">        <span class="comment"># 对于从零开始的实现</span></span><br><span class="line">    <span class="comment"># 定义预测函数，用于在训练过程中生成文本</span></span><br><span class="line">    predict = <span class="keyword">lambda</span> prefix: predict_ch8(prefix, <span class="number">50</span>, net, vocab, device)</span><br><span class="line">    <span class="comment"># 训练模型</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        <span class="comment"># 训练一个迭代周期，并返回困惑度和处理速度</span></span><br><span class="line">        ppl, speed = train_epoch_ch8(</span><br><span class="line">            net, train_iter, loss, updater, device, use_random_iter)</span><br><span class="line">        <span class="comment"># 每10个周期打印一次生成的文本并更新动画</span></span><br><span class="line">        <span class="keyword">if</span> (epoch + <span class="number">1</span>) % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(predict(<span class="string">&#x27;time traveller&#x27;</span>))  <span class="comment"># 生成文本</span></span><br><span class="line">            animator.add(epoch + <span class="number">1</span>, [ppl])  <span class="comment"># 更新动画数据</span></span><br><span class="line">    <span class="comment"># 打印最终的困惑度和速度，以及最后的文本生成示例</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;困惑度 <span class="subst">&#123;ppl:<span class="number">.1</span>f&#125;</span>, <span class="subst">&#123;speed:<span class="number">.1</span>f&#125;</span> 词元/秒 <span class="subst">&#123;<span class="built_in">str</span>(device)&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(predict(<span class="string">&#x27;time traveller&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(predict(<span class="string">&#x27;traveller&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在，我们训练循环神经网络模型。 因为我们在数据集中只使用了10000个词元， 所以模型需要更多的迭代周期来更好地收敛。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">num_epochs, lr = <span class="number">500</span>, <span class="number">1</span></span><br><span class="line">train_ch8(net, train_iter, vocab, lr, num_epochs, d2l.try_gpu())</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">困惑度 1.0, 67212.6 词元/秒 cuda:0</span></span><br><span class="line"><span class="string">time traveller for so it will be convenient to speak of himwas e</span></span><br><span class="line"><span class="string">travelleryou can show black is white by argument said filby</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraoutput_rnn-scratch_546c4d_202_1.svg" alt="../_images/output_rnn-scratch_546c4d_202_1.svg"></p><p>最后，让我们检查一下使用随机抽样方法的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">net = RNNModelScratch(<span class="built_in">len</span>(vocab), num_hiddens, d2l.try_gpu(), get_params,</span><br><span class="line">                      init_rnn_state, rnn)</span><br><span class="line">train_ch8(net, train_iter, vocab, lr, num_epochs, d2l.try_gpu(),</span><br><span class="line">          use_random_iter=<span class="literal">True</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">困惑度 1.5, 65222.3 词元/秒 cuda:0</span></span><br><span class="line"><span class="string">time traveller held in his hand was a glitteringmetallic framewo</span></span><br><span class="line"><span class="string">traveller but now you begin to seethe object of my investig</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraoutput_rnn-scratch_546c4d_217_1.svg" alt="../_images/output_rnn-scratch_546c4d_217_1.svg"></p><hr><h3 id="简洁实现"><a href="#简洁实现" class="headerlink" title="简洁实现"></a>简洁实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置批量大小和时间步长</span></span><br><span class="line">batch_size, num_steps = <span class="number">32</span>, <span class="number">35</span></span><br><span class="line"><span class="comment"># 加载时间机器数据集</span></span><br><span class="line">train_iter, vocab = d2l.load_data_time_machine(batch_size, num_steps)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置隐藏单元的数量</span></span><br><span class="line">num_hiddens = <span class="number">256</span></span><br><span class="line"><span class="comment"># 初始化一个RNN层</span></span><br><span class="line">rnn_layer = nn.RNN(<span class="built_in">len</span>(vocab), num_hiddens)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化隐状态</span></span><br><span class="line">state = torch.zeros((<span class="number">1</span>, batch_size, num_hiddens))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成一个随机的输入数据</span></span><br><span class="line">X = torch.rand(size=(num_steps, batch_size, <span class="built_in">len</span>(vocab)))</span><br><span class="line"><span class="comment"># 通过RNN层处理输入，获得输出和新的隐状态</span></span><br><span class="line">Y, state_new = rnn_layer(X, state)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义RNN模型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RNNModel</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;循环神经网络模型&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, rnn_layer, vocab_size, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(RNNModel, self).__init__(**kwargs)</span><br><span class="line">        self.rnn = rnn_layer</span><br><span class="line">        self.vocab_size = vocab_size</span><br><span class="line">        self.num_hiddens = self.rnn.hidden_size</span><br><span class="line">        <span class="comment"># 根据RNN是否双向来设置num_directions，并定义线性层</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.rnn.bidirectional:</span><br><span class="line">            self.num_directions = <span class="number">1</span></span><br><span class="line">            self.linear = nn.Linear(self.num_hiddens, self.vocab_size)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.num_directions = <span class="number">2</span></span><br><span class="line">            self.linear = nn.Linear(self.num_hiddens * <span class="number">2</span>, self.vocab_size)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, inputs, state</span>):</span></span><br><span class="line">        <span class="comment"># 将输入转换为one-hot编码，并传递给RNN层</span></span><br><span class="line">        X = F.one_hot(inputs.T.long(), self.vocab_size).to(torch.float32)</span><br><span class="line">        Y, state = self.rnn(X, state)</span><br><span class="line">        <span class="comment"># 将RNN层的输出通过全连接层，改变形状为(时间步数*批量大小, 词表大小)</span></span><br><span class="line">        output = self.linear(Y.reshape((-<span class="number">1</span>, Y.shape[-<span class="number">1</span>])))</span><br><span class="line">        <span class="keyword">return</span> output, state</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">begin_state</span>(<span class="params">self, device, batch_size=<span class="number">1</span></span>):</span></span><br><span class="line">        <span class="comment"># 根据RNN类型返回相应的初始隐状态</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(self.rnn, nn.LSTM):</span><br><span class="line">            <span class="comment"># 对于非LSTM的RNN，返回一个全0的张量</span></span><br><span class="line">            <span class="keyword">return</span> torch.zeros((self.num_directions * self.rnn.num_layers,</span><br><span class="line">                                 batch_size, self.num_hiddens), device=device)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 对于LSTM，返回两个全0的张量组成的元组</span></span><br><span class="line">            <span class="keyword">return</span> (torch.zeros((self.num_directions * self.rnn.num_layers,</span><br><span class="line">                                 batch_size, self.num_hiddens), device=device),</span><br><span class="line">                    torch.zeros((self.num_directions * self.rnn.num_layers,</span><br><span class="line">                                 batch_size, self.num_hiddens), device=device))</span><br><span class="line">            </span><br><span class="line"><span class="comment"># 设置设备，将模型移到相应的设备上</span></span><br><span class="line">device = d2l.try_gpu()</span><br><span class="line">net = RNNModel(rnn_layer, vocab_size=<span class="built_in">len</span>(vocab))</span><br><span class="line">net = net.to(device)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置训练的轮数和学习率</span></span><br><span class="line">num_epochs, lr = <span class="number">500</span>, <span class="number">1</span></span><br><span class="line"><span class="comment"># 调用d2l库的train_ch8函数进行模型训练</span></span><br><span class="line">d2l.train_ch8(net, train_iter, vocab, lr, num_epochs, device)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10.0 注意力机制</title>
      <link href="/post/55896.html"/>
      <url>/post/55896.html</url>
      
        <content type="html"><![CDATA[<h1 id="注意力机制"><a href="#注意力机制" class="headerlink" title="注意力机制"></a>注意力机制</h1><h2 id="注意力提示"><a href="#注意力提示" class="headerlink" title="注意力提示"></a>注意力提示</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>首先，考虑一个相对简单的状况， 即只使用非自主性提示。 要想将选择偏向于感官输入， 则可以简单地使用参数化的全连接层， 甚至是非参数化的最大汇聚层或平均汇聚层。</p><p>因此，“是否包含自主性提示”将注意力机制与全连接层或汇聚层区别开来。 在注意力机制的背景下，自主性提示被称为<strong><em>查询</em></strong>（query）。 给定任何查询，注意力机制通过<strong><em>注意力汇聚</em></strong>（attention pooling） 将选择引导至<em>感官输入</em>（sensory inputs，例如中间特征表示）。 在注意力机制中，这些感官输入被称为<strong><em>值</em></strong>（value）。 更通俗的解释，每个值都与一个<strong><em>键</em></strong>（key）配对， 这可以想象为感官输入的非自主提示。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraqkv.svg" alt="../_images/qkv.svg"></p><p> 如图所示，可以通过设计注意力汇聚的方式， 便于给定的查询（自主性提示）与键（非自主性提示）进行匹配， 这将引导得出最匹配的值（感官输入）。</p><p>注意力机制通过注意力汇聚将<strong><em>查询</em></strong>（自主性提示）和<strong><em>键</em></strong>（非自主性提示）结合在一起，实现对<strong><em>值</em></strong>（感官输入）的选择倾向</p><p>假设我们有一个简单的英文句子：“The cat sat on the mat.”（猫坐在垫子上。），我们希望将其翻译为中文。在翻译过程中，我们当前的任务是生成“猫”这个词的中文翻译。在这个过程中，我们将使用注意力机制来决定源句子中的哪些词对于当前的翻译任务最为重要。</p><ul><li><strong>查询（Query）</strong>：假设在我们的模型中，当前的查询是由翻译模型的状态表示的，这个状态试图找到“cat”这个词的最佳中文对应。在这个例子中，查询是对“猫”这个概念的内部表示。</li><li><strong>键（Key）</strong>：每个英文单词都会有一个与之对应的键。这些键代表了模型对每个单词的内部表示，用于帮助模型理解每个词与当前查询的相关性。例如，”cat”, “sat”, “on”, “the”, “mat”每个词都有一个键。</li><li><strong>值（Value）</strong>：与键相对应，每个单词也都有一个值，这些值是实际用于计算输出的数据。在我们的翻译任务中，这些值可能包含了每个英文单词的含义、用法和上下文信息，这些信息将用于生成翻译。</li></ul><hr><h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h3><p>平均汇聚层可以被视为输入的加权平均值， 其中各输入的权重是一样的。 实际上，注意力汇聚得到的是加权平均的总和值， 其中权重是在给定的查询和不同的键之间计算得出的。</p><p>为了可视化注意力权重，需要定义一个<code>show_heatmaps</code>函数。 其输入<code>matrices</code>的形状是 （要显示的行数，要显示的列数，查询的数目，键的数目）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line"><span class="comment"># #@save 注释用于标记这个函数可能会被保存或导入到其他脚本中使用</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_heatmaps</span>(<span class="params">matrices, xlabel, ylabel, titles=<span class="literal">None</span>, figsize=(<span class="params"><span class="number">2.5</span>, <span class="number">2.5</span></span>),</span></span></span><br><span class="line"><span class="params"><span class="function">                  cmap=<span class="string">&#x27;Reds&#x27;</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;显示矩阵热图&quot;&quot;&quot;</span></span><br><span class="line">    d2l.use_svg_display()  <span class="comment"># 使用SVG格式显示图像，以获得更清晰的图像质量</span></span><br><span class="line">    num_rows, num_cols = matrices.shape[<span class="number">0</span>], matrices.shape[<span class="number">1</span>]  <span class="comment"># 获取矩阵数组的行数和列数</span></span><br><span class="line">    fig, axes = d2l.plt.subplots(num_rows, num_cols, figsize=figsize,</span><br><span class="line">                                 sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>, squeeze=<span class="literal">False</span>)</span><br><span class="line">    <span class="comment"># 创建一个图形和一组子图，每个矩阵都会在子图中显示</span></span><br><span class="line">    <span class="keyword">for</span> i, (row_axes, row_matrices) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(axes, matrices)):</span><br><span class="line">        <span class="keyword">for</span> j, (ax, matrix) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(row_axes, row_matrices)):</span><br><span class="line">            pcm = ax.imshow(matrix.detach().numpy(), cmap=cmap)</span><br><span class="line">            <span class="comment"># 使用imshow函数绘制矩阵的热图，detach().numpy()将矩阵从PyTorch张量转换为NumPy数组</span></span><br><span class="line">            <span class="keyword">if</span> i == num_rows - <span class="number">1</span>:</span><br><span class="line">                ax.set_xlabel(xlabel)  <span class="comment"># 在最下方的子图设置x轴标签</span></span><br><span class="line">            <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">                ax.set_ylabel(ylabel)  <span class="comment"># 在最左侧的子图设置y轴标签</span></span><br><span class="line">            <span class="keyword">if</span> titles:</span><br><span class="line">                ax.set_title(titles[j])  <span class="comment"># 如果提供了标题，为每个子图设置标题</span></span><br><span class="line">    fig.colorbar(pcm, ax=axes, shrink=<span class="number">0.6</span>)  <span class="comment"># 为子图集添加一个颜色条，显示颜色映射的数值范围</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面使用一个简单的例子进行演示。 在本例子中，仅当查询和键相同时，注意力权重为1，否则为0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">attention_weights = torch.eye(<span class="number">10</span>).reshape((<span class="number">1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">10</span>))</span><br><span class="line">show_heatmaps(attention_weights, xlabel=<span class="string">&#x27;Keys&#x27;</span>, ylabel=<span class="string">&#x27;Queries&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraoutput_attention-cues_054b1a_36_0.svg" alt="../_images/output_attention-cues_054b1a_36_0.svg"></p><hr><h2 id="Nadaraya-Watson-核回归"><a href="#Nadaraya-Watson-核回归" class="headerlink" title="Nadaraya-Watson 核回归"></a>Nadaraya-Watson 核回归</h2><h3 id="生成数据集"><a href="#生成数据集" class="headerlink" title="生成数据集"></a>生成数据集</h3><p>简单起见，考虑下面这个回归问题：给定的成对的“输入－输出”数据集$\{(x_1, y_1), \ldots, (x_n, y_n)\}$，如何学习$f$来预测任意新输入$x$的输出$\hat{y} = f(x)$？</p><p>根据下面的非线性函数生成一个人工数据集，其中加入的噪声项为$\epsilon$：</p><script type="math/tex; mode=display">y_i = 2\sin(x_i) + x_i^{0.8} + \epsilon</script><p>其中$\epsilon$服从均值为$0$和标准差为$0.5$的正态分布。在这里生成了$50$个训练样本和$50$个测试样本。为了更好地可视化之后的注意力模式，需要将训练样本进行<strong>排序</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">n_train = <span class="number">50</span>  <span class="comment"># 训练样本数</span></span><br><span class="line">x_train, _ = torch.sort(torch.rand(n_train) * <span class="number">5</span>)   <span class="comment"># 排序后的训练样本</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * torch.sin(x) + x**<span class="number">0.8</span></span><br><span class="line"></span><br><span class="line">y_train = f(x_train) + torch.normal(<span class="number">0.0</span>, <span class="number">0.5</span>, (n_train,))  <span class="comment"># 训练样本的输出</span></span><br><span class="line">x_test = torch.arange(<span class="number">0</span>, <span class="number">5</span>, <span class="number">0.1</span>)  <span class="comment"># 测试样本</span></span><br><span class="line">y_truth = f(x_test)  <span class="comment"># 测试样本的真实输出</span></span><br><span class="line">n_test = <span class="built_in">len</span>(x_test)  <span class="comment"># 测试样本数</span></span><br></pre></td></tr></table></figure><p>下面的函数将绘制所有的训练样本（样本由圆圈表示）， 不带噪声项的真实数据生成函数$f$（标记为“Truth”）， 以及学习得到的预测函数（标记为“Pred”）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_kernel_reg</span>(<span class="params">y_hat</span>):</span></span><br><span class="line">    d2l.plot(x_test, [y_truth, y_hat], <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, legend=[<span class="string">&#x27;Truth&#x27;</span>, <span class="string">&#x27;Pred&#x27;</span>],</span><br><span class="line">             xlim=[<span class="number">0</span>, <span class="number">5</span>], ylim=[-<span class="number">1</span>, <span class="number">5</span>])</span><br><span class="line">    d2l.plt.plot(x_train, y_train, <span class="string">&#x27;o&#x27;</span>, alpha=<span class="number">0.5</span>);</span><br></pre></td></tr></table></figure><hr><h3 id="平均汇聚"><a href="#平均汇聚" class="headerlink" title="平均汇聚"></a>平均汇聚</h3><p>先使用最简单的估计器来解决回归问题。基于平均汇聚来计算所有训练样本输出值的平均值：</p><script type="math/tex; mode=display">f(x) = \frac{1}{n}\sum_{i=1}^n y_i</script><p>如图所示，这个估计器确实不够聪明。真实函数$f$（“Truth”）和预测函数（“Pred”）相差很大。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#torch.repeat_interleave 是一个PyTorch函数，用于沿指定维度重复张量中的元素。</span></span><br><span class="line">y_hat = torch.repeat_interleave(y_train.mean(), n_test)</span><br><span class="line">plot_kernel_reg(y_hat)</span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraoutput_nadaraya-waston_736177_39_0.svg" alt="../_images/output_nadaraya-waston_736177_39_0.svg"></p><hr><h3 id="非参数注意力汇聚"><a href="#非参数注意力汇聚" class="headerlink" title="非参数注意力汇聚"></a>非参数注意力汇聚</h3><p>显然，平均汇聚忽略了输入$x_i$。于是Nadaraya和Watson提出了一个更好的想法，根据输入的位置对输出$y_i$进行加权：</p><script type="math/tex; mode=display">f(x) = \sum_{i=1}^n \frac{K(x - x_i)}{\sum_{j=1}^n K(x - x_j)} y_i</script><p>其中$K$是<strong>核</strong>（kernel）。公式所描述的估计器被称为<strong>Nadaraya-Watson核回归</strong></p><p>这里不会深入讨论核函数的细节，但受此启发，我们可以从注意力机制框架的角度重写成为一个更加通用的<strong>注意力汇聚</strong>（attention pooling）公式：</p><script type="math/tex; mode=display">f(x) = \sum_{i=1}^n \alpha(x, x_i) y_i,</script><p>其中$x$是查询，$(x_i, y_i)$是键值对。注意力汇聚是$y_i$的加权平均。将查询$x$和键$x_i$之间的关系建模为<strong>注意力权重</strong>$\alpha(x, x_i)$，这个权重将被分配给每一个对应值$y_i$。对于任何查询，模型在所有键值对注意力权重都是一个有效的概率分布：它们是非负的，并且总和为1。</p><p>为了更好地理解注意力汇聚，下面考虑一个<strong>高斯核</strong>（Gaussian kernel），其定义为：</p><script type="math/tex; mode=display">K(u) = \frac{1}{\sqrt{2\pi}} \exp(-\frac{u^2}{2}).</script><p>将高斯核代入可以得到：</p><script type="math/tex; mode=display">\begin{aligned} f(x) &=\sum_{i=1}^n \alpha(x, x_i) y_i\\ &= \sum_{i=1}^n \frac{\exp\left(-\frac{1}{2}(x - x_i)^2\right)}{\sum_{j=1}^n \exp\left(-\frac{1}{2}(x - x_j)^2\right)} y_i \\&= \sum_{i=1}^n \mathrm{softmax}\left(-\frac{1}{2}(x - x_i)^2\right) y_i. \end{aligned}</script><p>在公式中，如果一个键$x_i$越是接近给定的查询$x$，那么分配给这个键对应值$y_i$的注意力权重就会越大，也就“获得了更多的注意力”。</p><p>值得注意的是，Nadaraya-Watson核回归是一个非参数模型。因此，公式是<strong>非参数的注意力汇聚</strong>模型。接下来，我们将基于这个非参数的注意力汇聚模型来绘制预测结果。绘制的结果会发现新的模型预测线是平滑的，并且比平均汇聚的预测更接近真实。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># X_repeat的形状:(n_test,n_train),</span></span><br><span class="line"><span class="comment"># 每一行都包含着相同的测试输入（例如：同样的查询）</span></span><br><span class="line">X_repeat = x_test.repeat_interleave(n_train).reshape((-<span class="number">1</span>, n_train))</span><br><span class="line"><span class="comment"># x_train包含着键。attention_weights的形状：(n_test,n_train),</span></span><br><span class="line"><span class="comment"># 每一行都包含着要在给定的每个查询的值（y_train）之间分配的注意力权重</span></span><br><span class="line">attention_weights = nn.functional.softmax(-(X_repeat - x_train)**<span class="number">2</span> / <span class="number">2</span>, dim=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># y_hat的每个元素都是值的加权平均值，其中的权重是注意力权重</span></span><br><span class="line">y_hat = torch.matmul(attention_weights, y_train)</span><br><span class="line">plot_kernel_reg(y_hat)</span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraoutput_nadaraya-waston_736177_54_0.svg" alt="../_images/output_nadaraya-waston_736177_54_0.svg"></p><p>现在来观察注意力的权重。 这里测试数据的输入相当于查询，而训练数据的输入相当于键。 因为两个输入都是经过排序的，因此由观察可知“查询-键”对越接近， 注意力汇聚的注意力权重就越高。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d2l.show_heatmaps(attention_weights.unsqueeze(<span class="number">0</span>).unsqueeze(<span class="number">0</span>),</span><br><span class="line">                  xlabel=<span class="string">&#x27;Sorted training inputs&#x27;</span>,</span><br><span class="line">                  ylabel=<span class="string">&#x27;Sorted testing inputs&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraoutput_nadaraya-waston_736177_69_0.svg" alt="../_images/output_nadaraya-waston_736177_69_0.svg"></p><hr><h3 id="带参数注意力汇聚"><a href="#带参数注意力汇聚" class="headerlink" title="带参数注意力汇聚"></a>带参数注意力汇聚</h3><p>非参数的Nadaraya-Watson核回归具有<strong><em>一致性</em></strong>（consistency）的优点： 如果有足够的数据，此模型会收敛到最优结果。 尽管如此，我们还是可以轻松地将可学习的参数集成到注意力汇聚中。</p><p>在下面的查询$x$和键$x_i$之间的距离乘以可学习参数$w$：</p><script type="math/tex; mode=display">\begin{aligned}f(x) &= \sum_{i=1}^n \alpha(x, x_i) y_i \\&= \sum_{i=1}^n \frac{\exp\left(-\frac{1}{2}((x - x_i)w)^2\right)}{\sum_{j=1}^n \exp\left(-\frac{1}{2}((x - x_j)w)^2\right)} y_i \\&= \sum_{i=1}^n \mathrm{softmax}\left(-\frac{1}{2}((x - x_i)w)^2\right) y_i.\end{aligned}</script><p>本节的余下部分将通过训练这个模型来学习注意力汇聚的参数。</p><p><strong>批量矩阵乘法</strong></p><p>在注意力机制的背景中，我们可以使用小批量矩阵乘法来计算小批量数据中的加权平均值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">weights = torch.ones((<span class="number">2</span>, <span class="number">10</span>)) * <span class="number">0.1</span></span><br><span class="line">values = torch.arange(<span class="number">20.0</span>).reshape((<span class="number">2</span>, <span class="number">10</span>))</span><br><span class="line">torch.bmm(weights.unsqueeze(<span class="number">1</span>), values.unsqueeze(-<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p><code>torch.bmm</code></p><ul><li><strong>功能</strong>：<code>torch.bmm</code> 是批量矩阵乘法（Batch Matrix Multiplication）的缩写。这个函数用于计算两个张量中包含的多组矩阵的乘积。具体来说，如果你有两个三维张量，每个张量中包含了多个二维矩阵，<code>torch.bmm</code> 可以一次性计算这些矩阵的乘积。</li><li><strong>输入</strong>：两个形状为 <code>(b, n, m)</code> 和 <code>(b, m, p)</code> 的张量，其中 <code>b</code> 是批次大小，表示有多少组矩阵需要相乘，<code>n</code>, <code>m</code>, <code>p</code> 分别是这些矩阵的维度。</li><li><strong>输出</strong>：一个形状为 <code>(b, n, p)</code> 的张量，包含了每一组输入矩阵乘积的结果。</li></ul><p><code>torch.unsqueeze</code></p><ul><li><strong>功能</strong>：<code>torch.unsqueeze</code> 用于在指定位置增加一个维度（即增加一个轴）。这个操作不会改变张量的数据，但会改变张量的形状</li><li><strong>输入</strong>：一个张量和一个指定的维度（位置）。</li><li><p><strong>输出</strong>：形状改变后的张量，其在指定位置上增加了一个大小为1的维度。</p></li><li><p><code>weights.unsqueeze(1)</code> 将 <code>weights</code> 张量从形状 <code>(2, 10)</code> 改变为 <code>(2, 1, 10)</code>。这里，<code>1</code> 表示在原有的行和列之间增加了一个新的维度。</p></li><li><code>values.unsqueeze(-1)</code> 将 <code>values</code> 张量从形状 <code>(2, 10)</code> 改变为 <code>(2, 10, 1)</code>。这里，<code>-1</code> 表示在张量的最后增加了一个新的维度。</li></ul><hr><p>接下来，将训练数据集变换为键和值用于训练注意力模型。 在带参数的注意力汇聚模型中， 任何一个训练样本的输入都会和除自己以外的所有训练样本的“键－值”对进行计算， 从而得到其对应的预测输出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># X_tile的形状:(n_train，n_train)，每一行都包含着相同的训练输入</span></span><br><span class="line">X_tile = x_train.repeat((n_train, <span class="number">1</span>))</span><br><span class="line"><span class="comment"># Y_tile的形状:(n_train，n_train)，每一行都包含着相同的训练输出</span></span><br><span class="line">Y_tile = y_train.repeat((n_train, <span class="number">1</span>))</span><br><span class="line"><span class="comment"># keys的形状:(&#x27;n_train&#x27;，&#x27;n_train&#x27;-1)</span></span><br><span class="line">keys = X_tile[(<span class="number">1</span> - torch.eye(n_train)).<span class="built_in">type</span>(torch.<span class="built_in">bool</span>)].reshape((n_train, -<span class="number">1</span>))</span><br><span class="line"><span class="comment"># values的形状:(&#x27;n_train&#x27;，&#x27;n_train&#x27;-1)</span></span><br><span class="line">values = Y_tile[(<span class="number">1</span> - torch.eye(n_train)).<span class="built_in">type</span>(torch.<span class="built_in">bool</span>)].reshape((n_train, -<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>训练带参数的注意力汇聚模型时，使用平方损失函数和随机梯度下降。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">net = NWKernelRegression()</span><br><span class="line">loss = nn.MSELoss(reduction=<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">trainer = torch.optim.SGD(net.parameters(), lr=<span class="number">0.5</span>)</span><br><span class="line">animator = d2l.Animator(xlabel=<span class="string">&#x27;epoch&#x27;</span>, ylabel=<span class="string">&#x27;loss&#x27;</span>, xlim=[<span class="number">1</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    trainer.zero_grad()</span><br><span class="line">    l = loss(net(x_train, keys, values), y_train)</span><br><span class="line">    l.<span class="built_in">sum</span>().backward()</span><br><span class="line">    trainer.step()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;epoch <span class="subst">&#123;epoch + <span class="number">1</span>&#125;</span>, loss <span class="subst">&#123;<span class="built_in">float</span>(l.<span class="built_in">sum</span>()):<span class="number">.6</span>f&#125;</span>&#x27;</span>)</span><br><span class="line">    animator.add(epoch + <span class="number">1</span>, <span class="built_in">float</span>(l.<span class="built_in">sum</span>()))</span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraoutput_nadaraya-waston_736177_144_0.svg" alt="../_images/output_nadaraya-waston_736177_144_0.svg"></p><p>如下所示，训练完带参数的注意力汇聚模型后可以发现： 在尝试拟合带噪声的训练数据时， 预测结果绘制的线不如之前非参数模型的平滑。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d2l.show_heatmaps(net.attention_weights.unsqueeze(<span class="number">0</span>).unsqueeze(<span class="number">0</span>),</span><br><span class="line">                  xlabel=<span class="string">&#x27;Sorted training inputs&#x27;</span>,</span><br><span class="line">                  ylabel=<span class="string">&#x27;Sorted testing inputs&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraoutput_nadaraya-waston_736177_174_0.svg" alt="../_images/output_nadaraya-waston_736177_174_0.svg"></p><hr><h2 id="注意力评分函数"><a href="#注意力评分函数" class="headerlink" title="注意力评分函数"></a>注意力评分函数</h2><p>高斯核指数部分可以视为<strong><em>注意力评分函数</em></strong>（attention scoring function）， 简称<strong><em>评分函数</em></strong>（scoring function）， 然后把这个函数的输出结果输入到softmax函数中进行运算。 通过上述步骤，将得到与键对应的值的概率分布（即注意力权重）。 最后，注意力汇聚的输出就是基于这些注意力权重的值的加权和。</p><p>从宏观来看，上述算法可以用来实现注意力机制框架。图中说明了如何将注意力汇聚的输出计算成为值的加权和，其中$a$表示注意力评分函数。由于注意力权重是概率分布，因此加权和其本质上是加权平均值。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraattention-output.svg" alt="../_images/attention-output.svg"></p><p>用数学语言描述，假设有一个查询$\mathbf{q} \in \mathbb{R}^q$和$m$个“键－值”对$(\mathbf{k}_1, \mathbf{v}_1), \ldots, (\mathbf{k}_m, \mathbf{v}_m)$，其中$\mathbf{k}_i \in \mathbb{R}^k$，$\mathbf{v}_i \in \mathbb{R}^v$。</p><p>注意力汇聚函数$f$就被表示成值的加权和：</p><script type="math/tex; mode=display">f(\mathbf{q}, (\mathbf{k}_1, \mathbf{v}_1), \ldots, (\mathbf{k}_m, \mathbf{v}_m)) = \sum_{i=1}^m \alpha(\mathbf{q}, \mathbf{k}_i) \mathbf{v}_i \in \mathbb{R}^v</script><p>其中查询$\mathbf{q}$和键$\mathbf{k}_i$的注意力权重（标量）是通过注意力评分函数$a$将两个向量映射成标量，再经过softmax运算得到的：</p><script type="math/tex; mode=display">\alpha(\mathbf{q}, \mathbf{k}_i) = \mathrm{softmax}(a(\mathbf{q}, \mathbf{k}_i)) = \frac{\exp(a(\mathbf{q}, \mathbf{k}_i))}{\sum_{j=1}^m \exp(a(\mathbf{q}, \mathbf{k}_j))} \in \mathbb{R}</script><p>正如上图所示，选择不同的注意力评分函数$a$会导致不同的注意力汇聚操作。本节将介绍两个流行的评分函数，稍后将用他们来实现更复杂的注意力机制。</p><hr><h3 id="掩蔽softmax"><a href="#掩蔽softmax" class="headerlink" title="掩蔽softmax"></a>掩蔽softmax</h3><p>正如上面提到的，softmax操作用于输出一个概率分布作为注意力权重。 在某些情况下，并非所有的值都应该被纳入到注意力汇聚中。 例如，为了在机器翻译中高效处理小批量数据集， 某些文本序列被填充了没有意义的特殊词元。 </p><p>为了仅将有意义的词元作为值来获取注意力汇聚， 可以指定一个有效序列长度（即词元的个数）， 以便在计算softmax时过滤掉超出指定范围的位置。 下面的<code>masked_softmax</code>函数 实现了这样的<strong><em>掩蔽softmax操作</em></strong>， 其中任何超出有效长度的位置都被掩蔽并置为0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">masked_softmax</span>(<span class="params">X, valid_lens</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;通过在最后一个轴上掩蔽元素来执行softmax操作&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># X:3D张量，valid_lens:1D或2D张量</span></span><br><span class="line">    <span class="keyword">if</span> valid_lens <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> nn.functional.softmax(X, dim=-<span class="number">1</span>)  <span class="comment"># 如果没有提供有效长度，直接在最后一个轴上应用softmax</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        shape = X.shape  <span class="comment"># 保存X的原始形状</span></span><br><span class="line">        <span class="keyword">if</span> valid_lens.dim() == <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># 如果valid_lens是1D张量，则对每个样本的所有序列重复相同的长度</span></span><br><span class="line">            valid_lens = torch.repeat_interleave(valid_lens, shape[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果valid_lens是2D张量，则将其展平</span></span><br><span class="line">            valid_lens = valid_lens.reshape(-<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 对序列进行掩蔽操作，有效长度之外的位置被置为一个非常大的负数(-1e6)</span></span><br><span class="line">        X = d2l.sequence_mask(X.reshape(-<span class="number">1</span>, shape[-<span class="number">1</span>]), valid_lens,</span><br><span class="line">                              value=-<span class="number">1e6</span>)</span><br><span class="line">        <span class="comment"># 将掩蔽后的X重新塑形为原始形状，并在最后一个轴上应用softmax</span></span><br><span class="line">        <span class="keyword">return</span> nn.functional.softmax(X.reshape(shape), dim=-<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为了演示此函数是如何工作的， 考虑由两个$2×4$矩阵表示的样本， 这两个样本的有效长度分别为2和3。 经过掩蔽softmax操作，超出有效长度的值都被掩蔽为0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">masked_softmax(torch.rand(<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>), torch.tensor([<span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[[0.5980, 0.4020, 0.0000, 0.0000],</span></span><br><span class="line"><span class="string">         [0.5548, 0.4452, 0.0000, 0.0000]],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        [[0.3716, 0.3926, 0.2358, 0.0000],</span></span><br><span class="line"><span class="string">         [0.3455, 0.3337, 0.3208, 0.0000]]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><hr><h3 id="加性注意力"><a href="#加性注意力" class="headerlink" title="加性注意力"></a>加性注意力</h3><p>一般来说，当查询和键是不同长度的矢量时，可以使用加性注意力作为评分函数。</p><p>给定查询$\mathbf{q} \in \mathbb{R}^q$和键$\mathbf{k} \in \mathbb{R}^k$，<strong>加性注意力</strong>（additive attention）的评分函数为</p><script type="math/tex; mode=display">a(\mathbf q, \mathbf k) = \mathbf w_v^\top \text{tanh}(\mathbf W_q\mathbf q + \mathbf W_k \mathbf k) \in \mathbb{R}</script><p>其中可学习的参数是$\mathbf W_q\in\mathbb R^{h\times q}$、$\mathbf W_k\in\mathbb R^{h\times k}$和$\mathbf w_v\in\mathbb R^{h}$。</p><p>将查询和键连结起来后输入到一个多层感知机（MLP）中，感知机包含一个隐藏层，其隐藏单元数是一个超参数$h$。通过使用$\tanh$作为激活函数，并且禁用偏置项。</p><p>下面来实现加性注意力。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AdditiveAttention</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;加性注意力&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, key_size, query_size, num_hiddens, dropout, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(AdditiveAttention, self).__init__(**kwargs)</span><br><span class="line">        <span class="comment"># 使用线性层将键和查询转换到相同的隐藏维度</span></span><br><span class="line">        self.W_k = nn.Linear(key_size, num_hiddens, bias=<span class="literal">False</span>)</span><br><span class="line">        self.W_q = nn.Linear(query_size, num_hiddens, bias=<span class="literal">False</span>)</span><br><span class="line">        <span class="comment"># 线性层用于计算加性注意力的分数</span></span><br><span class="line">        self.w_v = nn.Linear(num_hiddens, <span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">        <span class="comment"># Dropout层用于正则化</span></span><br><span class="line">        self.dropout = nn.Dropout(dropout)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, queries, keys, values, valid_lens</span>):</span></span><br><span class="line">        <span class="comment"># 首先，通过W_k和W_q将键和查询映射到隐藏空间</span></span><br><span class="line">        queries, keys = self.W_q(queries), self.W_k(keys)</span><br><span class="line">        <span class="comment"># 扩展维度，使得queries和keys能够进行广播相加</span></span><br><span class="line">        <span class="comment"># queries形状变为(batch_size, 查询的个数, 1, num_hiddens)</span></span><br><span class="line">        <span class="comment"># keys形状变为(batch_size, 1, 键-值对的个数, num_hiddens)</span></span><br><span class="line">        features = queries.unsqueeze(<span class="number">2</span>) + keys.unsqueeze(<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 应用tanh激活函数</span></span><br><span class="line">        features = torch.tanh(features)</span><br><span class="line">        <span class="comment"># 计算加性注意力分数</span></span><br><span class="line">        scores = self.w_v(features).squeeze(-<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 应用掩蔽softmax函数，考虑到有效长度</span></span><br><span class="line">        self.attention_weights = masked_softmax(scores, valid_lens)</span><br><span class="line">        <span class="comment"># 应用注意力权重到值上，进行加权求和</span></span><br><span class="line">        <span class="comment"># values形状：(batch_size, 键-值对的个数, 值的维度)</span></span><br><span class="line">        <span class="keyword">return</span> torch.bmm(self.dropout(self.attention_weights), values)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过广播，<code>1</code>这个维度会被自动扩展以匹配另一个张量的相应维度（查询的<code>1</code>扩展以匹配键的“键-值对的个数”，键的<code>1</code>扩展以匹配查询的“查询的个数”），从而两者可以在每个维度上相加。</p><p>这个广播相加的结果是一个形状为<code>(batch_size, 查询的个数, 键-值对的个数, num_hiddens)</code>的张量。这个张量的每个元素代表了一个查询与一个键在映射到共同隐藏空间后的加性组合。这个加性组合随后通过激活函数和进一步的处理来计算注意力分数。</p><p>用一个小例子来演示上面的<code>AdditiveAttention</code>类， 其中查询、键和值的形状为（批量大小，步数或词元序列长度，特征大小）， 实际输出为$(2,1,20)$、$(2,10,2)$和$(2,10,4)$。 注意力汇聚输出的形状为（批量大小，查询的步数，值的维度）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化输入数据</span></span><br><span class="line">queries, keys = torch.normal(<span class="number">0</span>, <span class="number">1</span>, (<span class="number">2</span>, <span class="number">1</span>, <span class="number">20</span>)), torch.ones((<span class="number">2</span>, <span class="number">10</span>, <span class="number">2</span>))</span><br><span class="line">values = torch.arange(<span class="number">40</span>, dtype=torch.float32).reshape(<span class="number">1</span>, <span class="number">10</span>, <span class="number">4</span>).repeat(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">valid_lens = torch.tensor([<span class="number">2</span>, <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化加性注意力模型，设置为评估模式</span></span><br><span class="line">attention = AdditiveAttention(key_size=<span class="number">2</span>, query_size=<span class="number">20</span>, num_hiddens=<span class="number">8</span>, dropout=<span class="number">0.1</span>)</span><br><span class="line">attention.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过加性注意力模型计算输出</span></span><br><span class="line">output = attention(queries, keys, values, valid_lens)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[[ 2.0000,  3.0000,  4.0000,  5.0000]],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        [[10.0000, 11.0000, 12.0000, 13.0000]]], grad_fn=&lt;BmmBackward0&gt;)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><ol><li><strong>输入维度</strong>：<ul><li><strong>查询（Queries）</strong>：初始维度为<code>(batch_size, 查询的个数, query_size)</code>。在示例中，这个维度是<code>(2, 1, 20)</code>。</li><li><strong>键（Keys）和值（Values）</strong>：键的初始维度为<code>(batch_size, 键-值对的个数, key_size)</code>，值的维度为<code>(batch_size, 键-值对的个数, value_size)</code>。在示例中，键的维度是<code>(2, 10, 2)</code>，值的维度是<code>(2, 10, 4)</code>。</li></ul></li><li><strong>线性变换后的维度</strong>：<ul><li>经过<code>self.W_q(queries)</code>和<code>self.W_k(keys)</code>的线性变换后，查询和键都被映射到了<code>num_hiddens</code>维度的空间。这里<code>num_hiddens=8</code>。因此，变换后查询和键的维度分别变为<code>(batch_size, 查询的个数, num_hiddens)</code>和<code>(batch_size, 键-值对的个数, num_hiddens)</code>。在示例中，这意味着它们都变为<code>(2, 1, 8)</code>和<code>(2, 10, 8)</code>。</li></ul></li><li><strong><code>unsqueeze</code>操作后的维度</strong>：<ul><li>执行<code>queries.unsqueeze(2)</code>后，查询的维度变为<code>(batch_size, 查询的个数, 1, num_hiddens)</code>，在示例中为<code>(2, 1, 1, 8)</code>。</li><li>执行<code>keys.unsqueeze(1)</code>后，键的维度变为<code>(batch_size, 1, 键-值对的个数, num_hiddens)</code>，在示例中为<code>(2, 1, 10, 8)</code>。</li></ul></li><li><strong>广播相加后的维度</strong>：<ul><li>在执行加法操作后，由于广播机制，最终的<code>features</code>维度为<code>(batch_size, 查询的个数, 键-值对的个数, num_hiddens)</code>。在示例中，这个维度是<code>(2, 1, 10, 8)</code>。</li></ul></li><li><strong>通过<code>self.w_v</code>后维度变化</strong>：<ul><li>经过<code>self.w_v(features)</code>计算得到的分数在最后一个维度为1，因此维度是<code>(batch_size, 查询的个数, 键-值对的个数, 1)</code>。在示例中，维度变为<code>(2, 1, 10, 1)</code>。</li></ul></li><li><strong><code>squeeze</code>操作后的维度</strong>：<ul><li>执行<code>scores.squeeze(-1)</code>后，去除了最后一个维度，所以<code>scores</code>的维度变为<code>(batch_size, 查询的个数, 键-值对的个数)</code>。在示例中，这变为<code>(2, 1, 10)</code>。</li></ul></li><li><strong>输出维度</strong>：<ul><li>最终的输出是通过对<code>values</code>进行加权求和得到的，其维度为<code>(batch_size, 查询的个数, value_size)</code>。在示例中，输出维度是<code>(2, 1, 4)</code>，这表示每个查询对应的加权值维度。</li></ul></li></ol><p>尽管加性注意力包含了可学习的参数，但由于本例子中每个键都是相同的， 所以注意力权重是均匀的，由指定的有效长度决定。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d2l.show_heatmaps(attention.attention_weights.reshape((1, 1, 2, 10)),</span><br><span class="line">                  xlabel=&#x27;Keys&#x27;, ylabel=&#x27;Queries&#x27;)</span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoratyporaoutput_attention-scoring-functions_2a8fdc_96_0.svg" alt="../_images/output_attention-scoring-functions_2a8fdc_96_0.svg"></p><hr><h3 id="缩放点积注意力"><a href="#缩放点积注意力" class="headerlink" title="缩放点积注意力"></a>缩放点积注意力</h3><p>使用点积可以得到计算效率更高的评分函数，但是点积操作要求查询和键具有相同的长度$d$。</p><p>假设查询和键的所有元素都是独立的随机变量，并且都满足零均值和单位方差，那么两个向量的点积的均值为$0$，方差为$d$。为确保无论向量长度如何，点积的方差在不考虑向量长度的情况下仍然是$1$，我们再将点积除以$\sqrt{d}$，则<strong>缩放点积注意力</strong>（scaled dot-product attention）评分函数为：</p><script type="math/tex; mode=display">a(\mathbf q, \mathbf k) = \frac{\mathbf{q}^\top \mathbf{k}}{\sqrt{d}}</script><p>在实践中，我们通常从小批量的角度来考虑提高效率，例如基于$n$个查询和$m$个键－值对计算注意力，其中查询和键的长度为$d$，值的长度为$v$。</p><p>查询$\mathbf Q\in\mathbb R^{n\times d}$、</p><p>键$\mathbf K\in\mathbb R^{m\times d}$和</p><p>值$\mathbf V\in\mathbb R^{m\times v}$的缩放点积注意力是：</p><script type="math/tex; mode=display">\mathrm{softmax}\left(\frac{\mathbf Q \mathbf K^\top }{\sqrt{d}}\right) \mathbf V \in \mathbb{R}^{n\times v}.</script><p>下面的缩放点积注意力的实现使用了暂退法进行模型正则化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DotProductAttention</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;缩放点积注意力&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, dropout, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(DotProductAttention, self).__init__(**kwargs)</span><br><span class="line">        self.dropout = nn.Dropout(dropout)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># queries的形状：(batch_size，查询的个数，d)</span></span><br><span class="line">    <span class="comment"># keys的形状：(batch_size，“键－值”对的个数，d)</span></span><br><span class="line">    <span class="comment"># values的形状：(batch_size，“键－值”对的个数，值的维度)</span></span><br><span class="line">    <span class="comment"># valid_lens的形状:(batch_size，)或者(batch_size，查询的个数)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, queries, keys, values, valid_lens=<span class="literal">None</span></span>):</span></span><br><span class="line">        d = queries.shape[-<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 设置transpose_b=True为了交换keys的最后两个维度</span></span><br><span class="line">        scores = torch.bmm(queries, keys.transpose(<span class="number">1</span>,<span class="number">2</span>)) / math.sqrt(d)</span><br><span class="line">        self.attention_weights = masked_softmax(scores, valid_lens)</span><br><span class="line">        <span class="keyword">return</span> torch.bmm(self.dropout(self.attention_weights), values)</span><br></pre></td></tr></table></figure><p>为了演示上述的<code>DotProductAttention</code>类， 我们使用与先前加性注意力例子中相同的键、值和有效长度。 对于点积操作，我们令查询的特征维度与键的特征维度大小相同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">queries = torch.normal(<span class="number">0</span>, <span class="number">1</span>, (<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">attention = DotProductAttention(dropout=<span class="number">0.5</span>)</span><br><span class="line">attention.<span class="built_in">eval</span>()</span><br><span class="line">attention(queries, keys, values, valid_lens)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[[ 2.0000,  3.0000,  4.0000,  5.0000]],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        [[10.0000, 11.0000, 12.0000, 13.0000]]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>与加性注意力演示相同，由于键包含的是相同的元素， 而这些元素无法通过任何查询进行区分，因此获得了均匀的注意力权重。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d2l.show_heatmaps(attention.attention_weights.reshape((<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>)),</span><br><span class="line">                  xlabel=<span class="string">&#x27;Keys&#x27;</span>, ylabel=<span class="string">&#x27;Queries&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraoutput_attention-scoring-functions_2a8fdc_141_0.svg" alt="../_images/output_attention-scoring-functions_2a8fdc_141_0.svg"></p><p>当查询和键是不同长度的矢量时，可以使用可加性注意力评分函数。当它们的长度相同时，使用缩放的“点－积”注意力评分函数的计算效率更高。</p><hr><h2 id="多头注意力"><a href="#多头注意力" class="headerlink" title="多头注意力"></a>多头注意力</h2><p>在实践中，当给定相同的查询、键和值的集合时， 我们希望模型可以基于相同的注意力机制学习到不同的行为， 然后将不同的行为作为知识组合起来， 捕获序列内各种范围的依赖关系 （例如，短距离依赖和长距离依赖关系）。 因此，允许注意力机制组合使用查询、键和值的不同 <strong><em>子空间表示</em></strong> 可能是有益的。</p><p>为此，与其只使用单独一个注意力汇聚， 我们可以用独立学习得到的ℎ组不同的 <strong><em>线性投影</em></strong>来变换查询、键和值。 然后，这ℎ组变换后的查询、键和值将并行地送到注意力汇聚中。 最后，将这ℎ个注意力汇聚的输出拼接在一起， 并且通过另一个可以学习的线性投影进行变换， 以产生最终输出。 这种设计被称为<strong><em>多头注意力</em></strong>， 对于ℎ个注意力汇聚输出，每一个注意力汇聚都被称作一个<em>头</em>（head）。 图中展示了使用全连接层来实现可学习的线性变换的多头注意力</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoramulti-head-attention.svg" alt="../_images/multi-head-attention.svg"></p><hr><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>在实现多头注意力之前，让我们用数学语言将这个模型形式化地描述出来。</p><p>给定查询$\mathbf{q} \in \mathbb{R}^{d_q}$、键$\mathbf{k} \in \mathbb{R}^{d_k}$和值$\mathbf{v} \in \mathbb{R}^{d_v}$，每个注意力头$\mathbf{h}_i$（$i = 1, \ldots, h$）的计算方法为：</p><script type="math/tex; mode=display">\mathbf{h}_i = f(\mathbf W_i^{(q)}\mathbf q, \mathbf W_i^{(k)}\mathbf k,\mathbf W_i^{(v)}\mathbf v) \in \mathbb R^{p_v}</script><p>其中，可学习的参数包括$\mathbf W_i^{(q)}\in\mathbb R^{p_q\times d_q}$、$\mathbf W_i^{(k)}\in\mathbb R^{p_k\times d_k}$$\mathbf W_i^{(v)}\in\mathbb R^{p_v\times d_v}$，以及代表注意力汇聚的函数$f$。$f$可以是上一节中的<strong>加性注意力</strong>和<strong>缩放点积注意力</strong></p><p>多头注意力的输出需要经过另一个线性转换，它对应着$h$个头连结后的结果，因此其可学习参数是$\mathbf W_o\in\mathbb R^{p_o\times h p_v}$：</p><script type="math/tex; mode=display">\mathbf W_o \begin{bmatrix}\mathbf h_1\\\vdots\\\mathbf h_h\end{bmatrix} \in \mathbb{R}^{p_o}</script><p>基于这种设计，每个头都可能会关注输入的不同部分，可以表示比简单加权平均值更复杂的函数。</p><hr><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>在实现过程中通常选择<strong>缩放点积注意力</strong>作为每一个注意力头。为了避免计算代价和参数代价的大幅增长，</p><p>我们设定$p_q = p_k = p_v = p_o / h$。 $p_q,p_k,p_v$分别代表单个注意力头的查询、键和值的维度，而 $p_o$ 是所有头合并后的输出维度。通过这种方式，每个头处理的维度更小，但总的来看，模型能够并行处理，并学习到不同子空间的表示。ℎ 是头的数量，$p_o$ 通过模型的参数（如<code>num_hiddens</code>）指定。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiHeadAttention</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;多头注意力&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, key_size, query_size, value_size, num_hiddens,</span></span></span><br><span class="line"><span class="params"><span class="function">                 num_heads, dropout, bias=<span class="literal">False</span>, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(MultiHeadAttention, self).__init__(**kwargs)</span><br><span class="line">        self.num_heads = num_heads  <span class="comment"># 定义头的数量</span></span><br><span class="line">        <span class="comment"># 初始化点积注意力机制，其中包含dropout</span></span><br><span class="line">        self.attention = d2l.DotProductAttention(dropout)</span><br><span class="line">        <span class="comment"># 为查询、键、值分别初始化线性变换层</span></span><br><span class="line">        self.W_q = nn.Linear(query_size, num_hiddens, bias=bias)</span><br><span class="line">        self.W_k = nn.Linear(key_size, num_hiddens, bias=bias)</span><br><span class="line">        self.W_v = nn.Linear(value_size, num_hiddens, bias=bias)</span><br><span class="line">        <span class="comment"># 最后的线性变换层，用于合并多头注意力的输出</span></span><br><span class="line">        self.W_o = nn.Linear(num_hiddens, num_hiddens, bias=bias)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, queries, keys, values, valid_lens</span>):</span></span><br><span class="line">        <span class="comment"># 对输入的查询、键、值进行线性变换</span></span><br><span class="line">        queries = transpose_qkv(self.W_q(queries), self.num_heads)</span><br><span class="line">        keys = transpose_qkv(self.W_k(keys), self.num_heads)</span><br><span class="line">        values = transpose_qkv(self.W_v(values), self.num_heads)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> valid_lens <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 如果提供了有效长度，则对其进行处理以匹配扩展后的批次大小</span></span><br><span class="line">            valid_lens = torch.repeat_interleave(</span><br><span class="line">                valid_lens, repeats=self.num_heads, dim=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 调用点积注意力机制，计算多头注意力的输出</span></span><br><span class="line">        output = self.attention(queries, keys, values, valid_lens)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 合并多头注意力的输出</span></span><br><span class="line">        output_concat = transpose_output(output, self.num_heads)</span><br><span class="line">        <span class="comment"># 通过最后的线性变换层</span></span><br><span class="line">        <span class="keyword">return</span> self.W_o(output_concat)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为了能够使多个头并行计算， 上面的<code>MultiHeadAttention</code>类将使用下面定义的两个转置函数。 具体来说，<code>transpose_output</code>函数反转了<code>transpose_qkv</code>函数的操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transpose_qkv</span>(<span class="params">X, num_heads</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;为了多注意力头的并行计算而变换形状&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 输入X的形状:(batch_size，查询或者“键－值”对的个数，num_hiddens)</span></span><br><span class="line">    <span class="comment"># 输出X的形状:(batch_size，查询或者“键－值”对的个数，num_heads，</span></span><br><span class="line">    <span class="comment"># num_hiddens/num_heads)</span></span><br><span class="line">    X = X.reshape(X.shape[<span class="number">0</span>], X.shape[<span class="number">1</span>], num_heads, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出X的形状:(batch_size，num_heads，查询或者“键－值”对的个数,</span></span><br><span class="line">    <span class="comment"># num_hiddens/num_heads)</span></span><br><span class="line">    X = X.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 最终输出的形状:(batch_size*num_heads,查询或者“键－值”对的个数,</span></span><br><span class="line">    <span class="comment"># num_hiddens/num_heads)</span></span><br><span class="line">    <span class="keyword">return</span> X.reshape(-<span class="number">1</span>, X.shape[<span class="number">2</span>], X.shape[<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transpose_output</span>(<span class="params">X, num_heads</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;逆转transpose_qkv函数的操作&quot;&quot;&quot;</span></span><br><span class="line">    X = X.reshape(-<span class="number">1</span>, num_heads, X.shape[<span class="number">1</span>], X.shape[<span class="number">2</span>])</span><br><span class="line">    X = X.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> X.reshape(X.shape[<span class="number">0</span>], X.shape[<span class="number">1</span>], -<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>下面使用键和值相同的小例子来测试我们编写的<code>MultiHeadAttention</code>类。 多头注意力输出的形状是（<code>batch_size</code>，<code>num_queries</code>，<code>num_hiddens</code>）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">num_hiddens, num_heads = <span class="number">100</span>, <span class="number">5</span></span><br><span class="line">attention = MultiHeadAttention(num_hiddens, num_hiddens, num_hiddens,</span><br><span class="line">                               num_hiddens, num_heads, <span class="number">0.5</span>)</span><br><span class="line">attention.<span class="built_in">eval</span>()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">MultiHeadAttention(</span></span><br><span class="line"><span class="string">  (attention): DotProductAttention(</span></span><br><span class="line"><span class="string">    (dropout): Dropout(p=0.5, inplace=False)</span></span><br><span class="line"><span class="string">  )</span></span><br><span class="line"><span class="string">  (W_q): Linear(in_features=100, out_features=100, bias=False)</span></span><br><span class="line"><span class="string">  (W_k): Linear(in_features=100, out_features=100, bias=False)</span></span><br><span class="line"><span class="string">  (W_v): Linear(in_features=100, out_features=100, bias=False)</span></span><br><span class="line"><span class="string">  (W_o): Linear(in_features=100, out_features=100, bias=False)</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">batch_size, num_queries = <span class="number">2</span>, <span class="number">4</span></span><br><span class="line">num_kvpairs, valid_lens =  <span class="number">6</span>, torch.tensor([<span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line">X = torch.ones((batch_size, num_queries, num_hiddens))</span><br><span class="line">Y = torch.ones((batch_size, num_kvpairs, num_hiddens))</span><br><span class="line">attention(X, Y, Y, valid_lens).shape</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">torch.Size([2, 4, 100])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><hr><h2 id="自注意力"><a href="#自注意力" class="headerlink" title="自注意力"></a>自注意力</h2><p>在深度学习中，经常使用卷积神经网络（CNN）或循环神经网络（RNN）对序列进行编码。 想象一下，有了注意力机制之后，我们将词元序列输入注意力池化中， 以便<strong>同一组词元同时充当查询、键和值</strong>。 具体来说，<strong>每个查询都会关注所有的键－值对并生成一个注意力输出</strong>。 由于查询、键和值来自同一组输入，因此被称为 <strong><em>自注意力</em></strong></p><p>给定一个由词元组成的输入序列$\mathbf{x}_1, \ldots, \mathbf{x}_n$，其中任意$\mathbf{x}_i \in \mathbb{R}^d$（$1 \leq i \leq n$）。该序列的自注意力输出为一个长度相同的序列$\mathbf{y}_1, \ldots, \mathbf{y}_n$，其中：</p><script type="math/tex; mode=display">\mathbf{y}_i = f(\mathbf{x}_i, (\mathbf{x}_1, \mathbf{x}_1), \ldots, (\mathbf{x}_n, \mathbf{x}_n)) \in \mathbb{R}^d</script><p>根据中之前定义的注意力汇聚函数$f(x) = \sum_{i=1}^n \alpha(x, x_i) y_i,$下面的代码片段是基于多头注意力对一个张量完成自注意力的计算，张量的形状为（批量大小，时间步的数目或词元序列的长度，$d$）。输出与输入的张量形状相同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">num_hiddens, num_heads = <span class="number">100</span>, <span class="number">5</span></span><br><span class="line">attention = d2l.MultiHeadAttention(num_hiddens, num_hiddens, num_hiddens,</span><br><span class="line">                                   num_hiddens, num_heads, <span class="number">0.5</span>)</span><br><span class="line">attention.<span class="built_in">eval</span>()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">MultiHeadAttention(</span></span><br><span class="line"><span class="string">  (attention): DotProductAttention(</span></span><br><span class="line"><span class="string">    (dropout): Dropout(p=0.5, inplace=False)</span></span><br><span class="line"><span class="string">  )</span></span><br><span class="line"><span class="string">  (W_q): Linear(in_features=100, out_features=100, bias=False)</span></span><br><span class="line"><span class="string">  (W_k): Linear(in_features=100, out_features=100, bias=False)</span></span><br><span class="line"><span class="string">  (W_v): Linear(in_features=100, out_features=100, bias=False)</span></span><br><span class="line"><span class="string">  (W_o): Linear(in_features=100, out_features=100, bias=False)</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><ul><li><code>num_hiddens</code>: 这个参数指定了查询（Query）、键（Key）、值（Value）以及最终输出向量的维度。在这个例子中，所有这些维度都被设置为100。</li><li><code>num_heads</code>: 多头注意力中头的数量。在这里，设置为5，意味着注意力机制会被分成5个头进行并行计算，每个头处理的是输入数据的不同子空间。</li><li>第三个参数<code>0.5</code>是<code>dropout</code>的比率，用于防止模型过拟合，通过随机丢弃一部分注意力权重来增加模型的泛化能力。</li></ul><p>综上所述，这段代码创建了一个具有100维隐藏层和5个注意力头的<code>MultiHeadAttention</code>模型实例，并通过设置<code>dropout</code>比率为0.5来帮助防止过拟合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">batch_size, num_queries, valid_lens = <span class="number">2</span>, <span class="number">4</span>, torch.tensor([<span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line">X = torch.ones((batch_size, num_queries, num_hiddens))</span><br><span class="line">attention(X, X, X, valid_lens).shape</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">torch.Size([2, 4, 100])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><hr><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>接下来比较下面几个架构，目标都是将由$n$个词元组成的序列映射到另一个长度相等的序列，其中的每个输入词元或输出词元都由$d$维向量表示。具体来说，将比较的是卷积神经网络、循环神经网络和自注意力这几个架构的计算复杂性、顺序操作和最大路径长度。</p><p>请注意，顺序操作会妨碍并行计算，而任意的序列位置组合之间的路径越短，则能更轻松地学习序列中的远距离<strong>依赖关系</strong> </p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoracnn-rnn-self-attention.svg" alt="../_images/cnn-rnn-self-attention.svg"></p><p>考虑一个卷积核大小为$k$的卷积层。</p><p>目前只需要知道的是，由于序列长度是$n$，输入和输出的通道数量都是$d$，所以卷积层的计算复杂度为$\mathcal{O}(knd^2)$。如图所示，卷积神经网络是分层的，因此为有$\mathcal{O}(1)$个顺序操作，最大路径长度为$\mathcal{O}(n/k)$。例如，$\mathbf{x}_1$和$\mathbf{x}_5$处于图中卷积核大小为3的双层卷积神经网络的感受野内。</p><p>当更新循环神经网络的隐状态时，$d \times d$权重矩阵和$d$维隐状态的乘法计算复杂度为$\mathcal{O}(d^2)$。由于序列长度为$n$，因此循环神经网络层的计算复杂度为$\mathcal{O}(nd^2)$。有$\mathcal{O}(n)$个顺序操作无法并行化，最大路径长度也是$\mathcal{O}(n)$。</p><p>在自注意力中，查询、键和值都是$n \times d$矩阵。考虑到缩放的”点－积“注意力，其中$n \times d$矩阵乘以$d \times n$矩阵。之后输出的$n \times n$矩阵乘以$n \times d$矩阵。因此，自注意力具有$\mathcal{O}(n^2d)$计算复杂性。每个词元都通过自注意力直接连接到任何其他词元。因此，有$\mathcal{O}(1)$个顺序操作可以并行计算，最大路径长度也是$\mathcal{O}(1)$。</p><p>总而言之，卷积神经网络和自注意力都拥有并行计算的优势，而且自注意力的<strong>最大路径长度最短</strong>。但是因为其计算复杂度是关于序列长度的二次方，所以在很长的序列中计算会非常慢。</p><hr><h3 id="位置编码"><a href="#位置编码" class="headerlink" title="位置编码"></a>位置编码</h3><p>在处理词元序列时，循环神经网络是逐个的重复地处理词元的， 而自注意力则因为并行计算而放弃了顺序操作。 为了使用序列的顺序信息，通过在输入表示中添加 <strong><em>位置编码</em></strong>（positional encoding）来注入绝对的或相对的位置信息。 位置编码可以通过学习得到也可以直接固定得到。 接下来描述的是基于正弦函数和余弦函数的固定位置编码</p><p>假设输入表示$\mathbf{X} \in \mathbb{R}^{n \times d}$包含一个序列中$n$个词元的$d$维嵌入表示。位置编码使用相同形状的位置嵌入矩阵$\mathbf{P} \in \mathbb{R}^{n \times d}$输出$\mathbf{X} + \mathbf{P}$，矩阵第$i$行、第$2j$列和$2j+1$列上的元素为：</p><script type="math/tex; mode=display">\begin{aligned} p_{i, 2j} &= \sin\left(\frac{i}{10000^{2j/d}}\right)\\p_{i, 2j+1} &= \cos\left(\frac{i}{10000^{2j/d}}\right)\end{aligned}</script><p>乍一看，这种基于三角函数的设计看起来很奇怪。在解释这个设计之前，让我们先在下面的<code>PositionalEncoding</code>类中实现它。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PositionalEncoding</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;位置编码&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, num_hiddens, dropout, max_len=<span class="number">1000</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>(PositionalEncoding, self).__init__()</span><br><span class="line">        <span class="comment"># 初始化一个Dropout层，用于在位置编码后对输出进行dropout操作以防止过拟合</span></span><br><span class="line">        self.dropout = nn.Dropout(dropout)</span><br><span class="line">        <span class="comment"># 初始化一个位置编码矩阵P，它有max_len行和num_hiddens列</span></span><br><span class="line">        <span class="comment"># 这里max_len是序列的最大长度，num_hiddens是每个词元的隐藏向量维度</span></span><br><span class="line">        self.P = torch.zeros((<span class="number">1</span>, max_len, num_hiddens))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算位置编码的公式部分</span></span><br><span class="line">        X = torch.arange(max_len, dtype=torch.float32).reshape(-<span class="number">1</span>, <span class="number">1</span>) / torch.<span class="built_in">pow</span>(<span class="number">10000</span>, torch.arange(<span class="number">0</span>, num_hiddens, <span class="number">2</span>, dtype=torch.float32) / num_hiddens)</span><br><span class="line">        <span class="comment"># 对偶数位置使用正弦函数进行编码</span></span><br><span class="line">        self.P[:, :, <span class="number">0</span>::<span class="number">2</span>] = torch.sin(X)</span><br><span class="line">        <span class="comment"># 对奇数位置使用余弦函数进行编码</span></span><br><span class="line">        self.P[:, :, <span class="number">1</span>::<span class="number">2</span>] = torch.cos(X)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, X</span>):</span></span><br><span class="line">        <span class="comment"># 将位置编码添加到输入X上</span></span><br><span class="line">        <span class="comment"># 这里X是一个三维张量，形状为(batch_size, sequence_length, num_hiddens)</span></span><br><span class="line">        X = X + self.P[:, :X.shape[<span class="number">1</span>], :].to(X.device)</span><br><span class="line">        <span class="comment"># 对结果应用dropout并返回</span></span><br><span class="line">        <span class="keyword">return</span> self.dropout(X)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在位置嵌入矩阵$P$中， 行代表词元在序列中的位置，列代表位置编码的不同维度。 从下面的例子中可以看到位置嵌入矩阵的第6列和第7列的频率高于第8列和第9列。 第6列和第7列之间的偏移量（第8列和第9列相同）是由于正弦函数和余弦函数的交替。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">encoding_dim, num_steps = <span class="number">32</span>, <span class="number">60</span></span><br><span class="line">pos_encoding = PositionalEncoding(encoding_dim, <span class="number">0</span>)</span><br><span class="line">pos_encoding.<span class="built_in">eval</span>()</span><br><span class="line">X = pos_encoding(torch.zeros((<span class="number">1</span>, num_steps, encoding_dim)))</span><br><span class="line">P = pos_encoding.P[:, :X.shape[<span class="number">1</span>], :]</span><br><span class="line">d2l.plot(torch.arange(num_steps), P[<span class="number">0</span>, :, <span class="number">6</span>:<span class="number">10</span>].T, xlabel=<span class="string">&#x27;Row (position)&#x27;</span>,</span><br><span class="line">         figsize=(<span class="number">6</span>, <span class="number">2.5</span>), legend=[<span class="string">&quot;Col %d&quot;</span> % d <span class="keyword">for</span> d <span class="keyword">in</span> torch.arange(<span class="number">6</span>, <span class="number">10</span>)])</span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraoutput_self-attention-and-positional-encoding_d76d5a_52_0.svg" alt="../_images/output_self-attention-and-positional-encoding_d76d5a_52_0.svg"></p><hr><p><strong>绝对位置信息</strong></p><p>为了明白沿着编码维度单调降低的频率与绝对位置信息的关系， 让我们打印出0,1,…,7的二进制表示形式。 正如所看到的，每个数字、每两个数字和每四个数字上的比特值 在第一个最低位、第二个最低位和第三个最低位上<strong>分别交替</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;i&#125;</span>的二进制是：<span class="subst">&#123;i:&gt;03b&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">0的二进制是：000</span></span><br><span class="line"><span class="string">1的二进制是：001</span></span><br><span class="line"><span class="string">2的二进制是：010</span></span><br><span class="line"><span class="string">3的二进制是：011</span></span><br><span class="line"><span class="string">4的二进制是：100</span></span><br><span class="line"><span class="string">5的二进制是：101</span></span><br><span class="line"><span class="string">6的二进制是：110</span></span><br><span class="line"><span class="string">7的二进制是：111</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>在二进制表示中，较高比特位的交替频率低于较低比特位， 与下面的热图所示相似，只是位置编码通过使用三角函数在编码维度上降低频率。 由于输出是浮点数，因此此类连续表示比二进制表示法更节省空间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P = P[<span class="number">0</span>, :, :].unsqueeze(<span class="number">0</span>).unsqueeze(<span class="number">0</span>)</span><br><span class="line">d2l.show_heatmaps(P, xlabel=<span class="string">&#x27;Column (encoding dimension)&#x27;</span>,</span><br><span class="line">                  ylabel=<span class="string">&#x27;Row (position)&#x27;</span>, figsize=(<span class="number">3.5</span>, <span class="number">4</span>), cmap=<span class="string">&#x27;Blues&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraoutput_self-attention-and-positional-encoding_d76d5a_82_0.svg" alt="../_images/output_self-attention-and-positional-encoding_d76d5a_82_0.svg"></p><hr><h2 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h2><p>自注意力同时具有并行计算和最短的最大路径长度这两个优势。因此，使用自注意力来设计深度架构是很有吸引力的。对比之前仍然依赖循环神经网络实现输入表示的自注意力模型，Transformer模型完全基于注意力机制，没有任何卷积层或循环神经网络层。尽管Transformer最初是应用于在文本数据上的序列到序列学习，但现在已经推广到各种现代的深度学习中，例如语言、视觉、语音和强化学习领域。</p><h3 id="模型-1"><a href="#模型-1" class="headerlink" title="模型"></a>模型</h3><p>Transformer作为编码器－解码器架构的一个实例，其整体架构图在图中展示。正如所见到的，Transformer是由编码器和解码器组成的。Transformer的编码器和解码器是基于自注意力的模块叠加而成的，源（输入）序列和目标（输出）序列的<strong><em>嵌入</em></strong>（embedding）表示将加上<strong><em>位置编码</em></strong>（positional encoding），再分别输入到<strong>编码器</strong>和<strong>解码器</strong>中。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoratransformer.svg" alt="../_images/transformer.svg"></p><p>从宏观角度来看，Transformer的编码器是由多个相同的层叠加而成的，每个层都有两个子层（子层表示为$\mathrm{sublayer}$）。第一个子层是 <strong><em>多头自注意力</em></strong> 汇聚；第二个子层是<strong><em>基于位置的前馈网络</em></strong>。具体来说，在计算编码器的自注意力时，查询、键和值都来自前一个编码器层的输出。</p><p>受ResNet中残差网络的启发，每个子层都采用了<strong><em>残差连接</em></strong>。在Transformer中，对于序列中任何位置的任何输入$\mathbf{x} \in \mathbb{R}^d$，都要求满足$\mathrm{sublayer}(\mathbf{x}) \in \mathbb{R}^d$，以便残差连接满足$\mathbf{x} + \mathrm{sublayer}(\mathbf{x}) \in \mathbb{R}^d$。在残差连接的加法计算之后，紧接着应用<strong>层规范化</strong>，因此，输入序列对应的每个位置，Transformer编码器都将输出一个$d$维表示向量。</p><p>Transformer解码器也是由多个相同的层叠加而成的，并且层中使用了残差连接和层规范化。除了编码器中描述的两个子层之外，解码器还在这两个子层之间插入了第三个子层，称为<strong>编码器－解码器注意力</strong>层。在编码器－解码器注意力中，查询来自前一个解码器层的输出，而键和值来自整个编码器的输出。在解码器自注意力中，查询、键和值都来自上一个解码器层的输出。但是，解码器中的每个位置只能考虑该位置之前的所有位置。这种<strong>掩蔽</strong>注意力保留了<strong>自回归</strong>属性，确保预测仅依赖于已生成的输出词元。</p><p>接下来将实现Transformer模型的剩余部分。</p><hr><h3 id="基于位置的前馈神经"><a href="#基于位置的前馈神经" class="headerlink" title="基于位置的前馈神经"></a>基于位置的前馈神经</h3><p>基于位置的前馈网络对序列中的所有位置的表示进行变换时使用的是同一个多层感知机（MLP），这就是称前馈网络是<strong><em>基于位置的</em></strong>的原因。在下面的实现中，输入<code>X</code>的形状（批量大小，时间步数或序列长度，隐单元数或特征维度）将被一个两层的感知机转换成形状为（批量大小，时间步数，<code>ffn_num_outputs</code>）的输出张量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PositionWiseFFN</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;基于位置的前馈网络&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, ffn_num_input, ffn_num_hiddens, ffn_num_outputs, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(PositionWiseFFN, self).__init__(**kwargs)</span><br><span class="line">        <span class="comment"># 第一个全连接层，将输入维度从ffn_num_input变换到ffn_num_hiddens</span></span><br><span class="line">        self.dense1 = nn.Linear(ffn_num_input, ffn_num_hiddens)</span><br><span class="line">        <span class="comment"># ReLU激活函数</span></span><br><span class="line">        self.relu = nn.ReLU()</span><br><span class="line">        <span class="comment"># 第二个全连接层，将隐藏层维度从ffn_num_hiddens变换到ffn_num_outputs</span></span><br><span class="line">        self.dense2 = nn.Linear(ffn_num_hiddens, ffn_num_outputs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, X</span>):</span></span><br><span class="line">        <span class="comment"># X是输入的张量，形状为(batch_size, sequence_length, ffn_num_input)</span></span><br><span class="line">        <span class="comment"># 先通过第一个全连接层和ReLU激活函数</span></span><br><span class="line">        <span class="comment"># 然后通过第二个全连接层</span></span><br><span class="line">        <span class="comment"># 输出张量的形状为(batch_size, sequence_length, ffn_num_outputs)</span></span><br><span class="line">        <span class="keyword">return</span> self.dense2(self.relu(self.dense1(X)))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面的例子显示，改变张量的最里层维度的尺寸，会改变成基于位置的前馈网络的输出尺寸。因为用同一个多层感知机对所有位置上的输入进行变换，所以当所有这些位置的输入相同时，它们的输出也是相同的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ffn = PositionWiseFFN(<span class="number">4</span>, <span class="number">4</span>, <span class="number">8</span>)</span><br><span class="line">ffn.<span class="built_in">eval</span>()</span><br><span class="line">ffn(torch.ones((<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)))</span><br></pre></td></tr></table></figure><p>最后会输出(2,3,8)的张量，前馈神经网络只会把输入的最后一个维度改变成指定的输出维度</p><hr><h3 id="残差连接和层规范化"><a href="#残差连接和层规范化" class="headerlink" title="残差连接和层规范化"></a>残差连接和层规范化</h3><p>现在让我们关注图中的<strong><em>加法和规范化</em></strong>（add&amp;norm）组件。正如在本节开头所述，这是由残差连接和紧随其后的层规范化组成的。两者都是构建有效的深度架构的关键。</p><p>批量规范化<code>batchnorm</code>中解释了在一个小批量的样本内基于批量规范化对数据进行重新中心化和重新缩放的调整。层规范化和批量规范化的目标相同，但层规范化是基于特征维度进行规范化。尽管批量规范化在计算机视觉中被广泛应用，但在自然语言处理任务中（输入通常是变长序列）批量规范化通常不如层规范化的效果好。</p><p>现在可以使用残差连接和层规范化来实现<code>AddNorm</code>类。暂退法也被作为正则化方法使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddNorm</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;残差连接后进行层规范化&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, normalized_shape, dropout, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(AddNorm, self).__init__(**kwargs)</span><br><span class="line">        <span class="comment"># 初始化一个Dropout层，用于在加法操作之前对Y进行随机丢弃，以减少过拟合</span></span><br><span class="line">        self.dropout = nn.Dropout(dropout)</span><br><span class="line">        <span class="comment"># 初始化一个LayerNorm层，用于在加法操作之后对结果进行规范化</span></span><br><span class="line">        self.ln = nn.LayerNorm(normalized_shape)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, X, Y</span>):</span></span><br><span class="line">        <span class="comment"># 首先对Y应用dropout，然后与X进行加法操作（残差连接）</span></span><br><span class="line">        <span class="comment"># 最后，对加法操作的结果进行层规范化</span></span><br><span class="line">        <span class="comment"># X是来自前一个层的输入，Y是当前层的输出</span></span><br><span class="line">        <span class="keyword">return</span> self.ln(self.dropout(Y) + X)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>比较层规范化和批量规范化</p><div class="table-container"><table><thead><tr><th>特性/应用</th><th>层规范化 (LN)</th><th>批量规范化 (BN)</th></tr></thead><tbody><tr><td><strong>规范化维度</strong></td><td>对单个样本内的所有特征进行规范化</td><td>对批次内的同一特征进行规范化</td></tr><tr><td><strong>计算统计量</strong></td><td>每个样本独立计算均值和方差</td><td>跨整个批次的样本计算均值和方差</td></tr><tr><td><strong>适用场景</strong></td><td>循环神经网络（RNN）、Transformer</td><td>卷积神经网络（CNN）</td></tr><tr><td><strong>优点</strong></td><td>适用于变长输入，不依赖于批次大小</td><td>可以加速训练过程，有助于稳定训练</td></tr><tr><td><strong>缺点</strong></td><td>可能不如BN在某些卷积网络中有效</td><td>对小批量大小敏感，可能影响模型在小批量数据上的表现</td></tr><tr><td><strong>自回归任务</strong></td><td>适合，因为不泄露未来信息</td><td>需要特别设计以避免未来信息泄露</td></tr><tr><td><strong>并行计算</strong></td><td>容易实现，因为计算独立于其他样本</td><td>需要整个批次的数据进行计算</td></tr></tbody></table></div><hr><h3 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20240229204921088.png" alt="image-20240229204921088"></p><p>有了组成Transformer编码器的基础组件，现在可以先实现编码器中的一个层。下面的<code>EncoderBlock</code>类包含两个子层：<strong>多头自注意力和基于位置的前馈网络</strong>，这两个子层都使用了<strong>残差连接和紧随的层规范化</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EncoderBlock</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Transformer编码器块&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, key_size, query_size, value_size, num_hiddens,</span></span></span><br><span class="line"><span class="params"><span class="function">                 norm_shape, ffn_num_input, ffn_num_hiddens, num_heads,</span></span></span><br><span class="line"><span class="params"><span class="function">                 dropout, use_bias=<span class="literal">False</span>, **kwargs</span>):</span></span><br><span class="line"> <span class="string">&quot;&quot;&quot; </span></span><br><span class="line"><span class="string">      参数:</span></span><br><span class="line"><span class="string">    - key_size: 键向量的维度大小。</span></span><br><span class="line"><span class="string">    - query_size: 查询向量的维度大小。</span></span><br><span class="line"><span class="string">    - value_size: 值向量的维度大小。</span></span><br><span class="line"><span class="string">    - num_hiddens: 自注意力层和前馈网络输出的隐藏单元数量，也是模型中间层的维度。</span></span><br><span class="line"><span class="string">    - norm_shape: 层规范化应用的维度。这通常是输入特征的维度。</span></span><br><span class="line"><span class="string">    - ffn_num_input: 前馈网络的输入维度。</span></span><br><span class="line"><span class="string">    - ffn_num_hiddens: 前馈网络中间层的维度。</span></span><br><span class="line"><span class="string">    - num_heads: 多头注意力机制中头的数量。</span></span><br><span class="line"><span class="string">    - dropout: Dropout层的丢弃比例。</span></span><br><span class="line"><span class="string">    - use_bias: 是否在多头自注意力机制和前馈网络中使用偏置项。默认为False。</span></span><br><span class="line"><span class="string"> &quot;&quot;&quot;</span>  </span><br><span class="line">        <span class="built_in">super</span>(EncoderBlock, self).__init__(**kwargs)</span><br><span class="line">        <span class="comment"># 初始化多头自注意力机制，其中包括指定的头数和大小参数</span></span><br><span class="line">        self.attention = d2l.MultiHeadAttention(</span><br><span class="line">            key_size, query_size, value_size, num_hiddens, num_heads, dropout,</span><br><span class="line">            use_bias)</span><br><span class="line">        <span class="comment"># 第一个残差连接和层规范化模块</span></span><br><span class="line">        self.addnorm1 = AddNorm(norm_shape, dropout)</span><br><span class="line">        <span class="comment"># 初始化基于位置的前馈网络</span></span><br><span class="line">        self.ffn = PositionWiseFFN(</span><br><span class="line">            ffn_num_input, ffn_num_hiddens, num_hiddens)</span><br><span class="line">        <span class="comment"># 第二个残差连接和层规范化模块</span></span><br><span class="line">        self.addnorm2 = AddNorm(norm_shape, dropout)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, X, valid_lens</span>):</span></span><br><span class="line">        <span class="comment"># 先通过多头自注意力机制，然后应用残差连接和层规范化</span></span><br><span class="line">        Y = self.addnorm1(X, self.attention(X, X, X, valid_lens))</span><br><span class="line">        <span class="comment"># 接着通过基于位置的前馈网络，再次应用残差连接和层规范化</span></span><br><span class="line">        <span class="keyword">return</span> self.addnorm2(Y, self.ffn(Y))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>正如从代码中所看到的，Transformer编码器中的任何层都不会改变其输入的形状</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">X = torch.ones((<span class="number">2</span>, <span class="number">100</span>, <span class="number">24</span>))</span><br><span class="line">valid_lens = torch.tensor([<span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line">encoder_blk = EncoderBlock(<span class="number">24</span>, <span class="number">24</span>, <span class="number">24</span>, <span class="number">24</span>, [<span class="number">100</span>, <span class="number">24</span>], <span class="number">24</span>, <span class="number">48</span>, <span class="number">8</span>, <span class="number">0.5</span>)</span><br><span class="line">encoder_blk.<span class="built_in">eval</span>()</span><br><span class="line">encoder_blk(X, valid_lens).shape</span><br><span class="line"><span class="comment"># 输出依然是：torch.Size([2, 100, 24])</span></span><br></pre></td></tr></table></figure><p>下面实现的Transformer编码器的代码中，堆叠了<code>num_layers</code>个<code>EncoderBlock</code>类的实例。由于这里使用的是值范围在−1和1之间的固定位置编码，因此通过学习得到的输入的嵌入表示的值需要先乘以嵌入维度的平方根进行重新缩放，然后再与位置编码相加。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TransformerEncoder</span>(<span class="params">d2l.Encoder</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Transformer编码器&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, vocab_size, key_size, query_size, value_size,</span></span></span><br><span class="line"><span class="params"><span class="function">                 num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens,</span></span></span><br><span class="line"><span class="params"><span class="function">                 num_heads, num_layers, dropout, use_bias=<span class="literal">False</span>, **kwargs</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        初始化Transformer编码器。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        参数:</span></span><br><span class="line"><span class="string">        - vocab_size: 词汇表大小，用于嵌入层。</span></span><br><span class="line"><span class="string">        - key_size: 键向量的维度。</span></span><br><span class="line"><span class="string">        - query_size: 查询向量的维度。</span></span><br><span class="line"><span class="string">        - value_size: 值向量的维度。</span></span><br><span class="line"><span class="string">        - num_hiddens: 自注意力层和前馈网络的输出维度，即模型的隐藏单元数。</span></span><br><span class="line"><span class="string">        - norm_shape: 层规范化应用的维度，通常是模型的隐藏层维度。</span></span><br><span class="line"><span class="string">        - ffn_num_input: 前馈网络的输入维度。</span></span><br><span class="line"><span class="string">        - ffn_num_hiddens: 前馈网络的隐藏层维度。</span></span><br><span class="line"><span class="string">        - num_heads: 多头自注意力机制中的头数。</span></span><br><span class="line"><span class="string">        - num_layers: 编码器中的层数。</span></span><br><span class="line"><span class="string">        - dropout: Dropout比例。</span></span><br><span class="line"><span class="string">        - use_bias: 是否在自注意力和前馈网络中使用偏置项，默认为False。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        其他参数:</span></span><br><span class="line"><span class="string">        - **kwargs: 捕获未明确列出的关键字参数。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>(TransformerEncoder, self).__init__(**kwargs)</span><br><span class="line">        self.num_hiddens = num_hiddens  <span class="comment"># 存储隐藏单元数</span></span><br><span class="line">        <span class="comment"># 初始化嵌入层，将词汇表索引转换为固定大小的密集向量</span></span><br><span class="line">        self.embedding = nn.Embedding(vocab_size, num_hiddens)</span><br><span class="line">        <span class="comment"># 初始化位置编码，为每个位置的词元添加位置信息</span></span><br><span class="line">        self.pos_encoding = d2l.PositionalEncoding(num_hiddens, dropout)</span><br><span class="line">        <span class="comment"># 创建编码器层的堆叠</span></span><br><span class="line">        self.blks = nn.Sequential()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_layers):</span><br><span class="line">            <span class="comment"># 逐层添加编码器块</span></span><br><span class="line">            self.blks.add_module(<span class="string">&quot;block&quot;</span>+<span class="built_in">str</span>(i),</span><br><span class="line">                EncoderBlock(key_size, query_size, value_size, num_hiddens,</span><br><span class="line">                             norm_shape, ffn_num_input, ffn_num_hiddens,</span><br><span class="line">                             num_heads, dropout, use_bias))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, X, valid_lens, *args</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        前向传播函数。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        参数:</span></span><br><span class="line"><span class="string">        - X: 输入序列的张量。</span></span><br><span class="line"><span class="string">        - valid_lens: 输入序列中每个元素的有效长度。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        返回:</span></span><br><span class="line"><span class="string">        - 经过Transformer编码器处理的序列张量。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 对嵌入向量进行缩放并添加位置编码</span></span><br><span class="line">        X = self.pos_encoding(self.embedding(X) * math.sqrt(self.num_hiddens))</span><br><span class="line">        self.attention_weights = [<span class="literal">None</span>] * <span class="built_in">len</span>(self.blks)</span><br><span class="line">        <span class="keyword">for</span> i, blk <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.blks):</span><br><span class="line">            <span class="comment"># 逐个编码器块处理</span></span><br><span class="line">            X = blk(X, valid_lens)</span><br><span class="line">            <span class="comment"># 存储每个编码器块的注意力权重</span></span><br><span class="line">            self.attention_weights[i] = blk.attention.attention.attention_weights</span><br><span class="line">        <span class="keyword">return</span> X</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面我们指定了超参数来创建一个两层的Transformer编码器。 Transformer编码器输出的形状是（批量大小，时间步数目，<code>num_hiddens</code>）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">encoder = TransformerEncoder(</span><br><span class="line">    <span class="number">200</span>, <span class="number">24</span>, <span class="number">24</span>, <span class="number">24</span>, <span class="number">24</span>, [<span class="number">100</span>, <span class="number">24</span>], <span class="number">24</span>, <span class="number">48</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">0.5</span>)</span><br><span class="line">encoder.<span class="built_in">eval</span>()</span><br><span class="line">encoder(torch.ones((<span class="number">2</span>, <span class="number">100</span>), dtype=torch.long), valid_lens).shape</span><br></pre></td></tr></table></figure><hr><h3 id="解码器"><a href="#解码器" class="headerlink" title="解码器"></a>解码器</h3><p>Transformer解码器也是由多个相同的层组成。在<code>DecoderBlock</code>类中实现的每个层包含了三个子层：解码器自注意力、“编码器-解码器”注意力和基于位置的前馈网络。这些子层也都被残差连接和紧随的层规范化围绕。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20240229212551267.png" alt="image-20240229212551267"></p><p>正如在本节前面所述，在掩蔽多头解码器自注意力层（第一个子层）中，查询、键和值都来自上一个解码器层的输出。关于<strong><em>序列到序列模型</em></strong>，在训练阶段，其输出序列的所有位置（时间步）的词元都是已知的；然而，在预测阶段，其输出序列的词元是逐个生成的。因此，在任何解码器时间步中，只有生成的词元才能用于解码器的自注意力计算中。为了在解码器中保留自回归的属性，其掩蔽自注意力设定了参数<code>dec_valid_lens</code>，以便任何查询都只会与解码器中所有已经生成词元的位置（即直到该查询位置为止）进行注意力计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecoderBlock</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;解码器中第i个块&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, key_size, query_size, value_size, num_hiddens,</span></span></span><br><span class="line"><span class="params"><span class="function">                 norm_shape, ffn_num_input, ffn_num_hiddens, num_heads,</span></span></span><br><span class="line"><span class="params"><span class="function">                 dropout, i, **kwargs</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        初始化解码器块。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        参数:</span></span><br><span class="line"><span class="string">        - key_size, query_size, value_size: 键、查询、值向量的维度。</span></span><br><span class="line"><span class="string">        - num_hiddens: 多头注意力机制和前馈网络的隐藏层维度。</span></span><br><span class="line"><span class="string">        - norm_shape: 层规范化的维度。</span></span><br><span class="line"><span class="string">        - ffn_num_input, ffn_num_hiddens: 前馈网络的输入和隐藏层维度。</span></span><br><span class="line"><span class="string">        - num_heads: 多头自注意力的头数。</span></span><br><span class="line"><span class="string">        - dropout: Dropout层的丢弃比例。</span></span><br><span class="line"><span class="string">        - i: 解码器块的索引，用于在解码过程中跟踪状态。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>(DecoderBlock, self).__init__(**kwargs)</span><br><span class="line">        self.i = i</span><br><span class="line">        <span class="comment"># 第一个多头自注意力层，用于处理目标序列自身的依赖关系。</span></span><br><span class="line">        self.attention1 = d2l.MultiHeadAttention(</span><br><span class="line">            key_size, query_size, value_size, num_hiddens, num_heads, dropout)</span><br><span class="line">        <span class="comment"># 第一个残差连接和层规范化。</span></span><br><span class="line">        self.addnorm1 = AddNorm(norm_shape, dropout)</span><br><span class="line">        <span class="comment"># 第二个多头自注意力层，用于处理编码器的输出和当前目标序列的依赖关系。</span></span><br><span class="line">        self.attention2 = d2l.MultiHeadAttention(</span><br><span class="line">            key_size, query_size, value_size, num_hiddens, num_heads, dropout)</span><br><span class="line">        <span class="comment"># 第二个残差连接和层规范化。</span></span><br><span class="line">        self.addnorm2 = AddNorm(norm_shape, dropout)</span><br><span class="line">        <span class="comment"># 基于位置的前馈网络。</span></span><br><span class="line">        self.ffn = PositionWiseFFN(ffn_num_input, ffn_num_hiddens, num_hiddens)</span><br><span class="line">        <span class="comment"># 第三个残差连接和层规范化。</span></span><br><span class="line">        self.addnorm3 = AddNorm(norm_shape, dropout)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, X, state</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        前向传播函数。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        参数:</span></span><br><span class="line"><span class="string">        - X: 输入序列的张量。</span></span><br><span class="line"><span class="string">        - state: 包含编码器输出和其他信息的状态，用于解码器的计算。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        返回:</span></span><br><span class="line"><span class="string">        - 解码器块的输出和更新后的状态。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        enc_outputs, enc_valid_lens = state[<span class="number">0</span>], state[<span class="number">1</span>]  <span class="comment"># 编码器的输出和有效长度。</span></span><br><span class="line">        <span class="comment"># 处理解码器的自注意力状态更新，区分训练和预测模式。</span></span><br><span class="line">        <span class="keyword">if</span> state[<span class="number">2</span>][self.i] <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            key_values = X</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            key_values = torch.cat((state[<span class="number">2</span>][self.i], X), axis=<span class="number">1</span>)</span><br><span class="line">        state[<span class="number">2</span>][self.i] = key_values</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 自注意力机制。</span></span><br><span class="line">        X2 = self.attention1(X, key_values, key_values, dec_valid_lens)</span><br><span class="line">        Y = self.addnorm1(X, X2)</span><br><span class="line">        <span class="comment"># 编码器-解码器注意力机制。</span></span><br><span class="line">        Y2 = self.attention2(Y, enc_outputs, enc_outputs, enc_valid_lens)</span><br><span class="line">        Z = self.addnorm2(Y, Y2)</span><br><span class="line">        <span class="comment"># 前馈网络。</span></span><br><span class="line">        <span class="keyword">return</span> self.addnorm3(Z, self.ffn(Z)), state</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为了便于在“编码器－解码器”注意力中进行缩放点积计算和残差连接中进行加法计算，编码器和解码器的特征维度都是<code>num_hiddens</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">decoder_blk = DecoderBlock(<span class="number">24</span>, <span class="number">24</span>, <span class="number">24</span>, <span class="number">24</span>, [<span class="number">100</span>, <span class="number">24</span>], <span class="number">24</span>, <span class="number">48</span>, <span class="number">8</span>, <span class="number">0.5</span>, <span class="number">0</span>)</span><br><span class="line">decoder_blk.<span class="built_in">eval</span>()</span><br><span class="line">X = torch.ones((<span class="number">2</span>, <span class="number">100</span>, <span class="number">24</span>))</span><br><span class="line">state = [encoder_blk(X, valid_lens), valid_lens, [<span class="literal">None</span>]]</span><br><span class="line">decoder_blk(X, state)[<span class="number">0</span>].shape</span><br></pre></td></tr></table></figure><p>现在我们构建了由<code>num_layers</code>个<code>DecoderBlock</code>实例组成的完整的Transformer解码器。最后，通过一个全连接层计算所有<code>vocab_size</code>个可能的输出词元的预测值。解码器的自注意力权重和编码器解码器注意力权重都被存储下来，方便日后可视化的需要。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TransformerDecoder</span>(<span class="params">d2l.AttentionDecoder</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, vocab_size, key_size, query_size, value_size,</span></span></span><br><span class="line"><span class="params"><span class="function">                 num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens,</span></span></span><br><span class="line"><span class="params"><span class="function">                 num_heads, num_layers, dropout, **kwargs</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        初始化Transformer解码器。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        参数:</span></span><br><span class="line"><span class="string">        - vocab_size: 词汇表的大小，用于嵌入层和最终的输出层。</span></span><br><span class="line"><span class="string">        - key_size, query_size, value_size: 在多头自注意力机制中，键、查询和值的维度。</span></span><br><span class="line"><span class="string">        - num_hiddens: 内部嵌入的维度，也是多头自注意力和前馈网络的输出维度。</span></span><br><span class="line"><span class="string">        - norm_shape: 层规范化应用的维度，通常是模型的隐藏层维度。</span></span><br><span class="line"><span class="string">        - ffn_num_input, ffn_num_hiddens: 前馈网络的输入和隐藏层的维度。</span></span><br><span class="line"><span class="string">        - num_heads: 多头自注意力中的头数。</span></span><br><span class="line"><span class="string">        - num_layers: 解码器中的层数。</span></span><br><span class="line"><span class="string">        - dropout: Dropout层的丢弃率。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>(TransformerDecoder, self).__init__(**kwargs)</span><br><span class="line">        self.num_hiddens = num_hiddens</span><br><span class="line">        self.num_layers = num_layers</span><br><span class="line">        <span class="comment"># 词嵌入层，将输入的词汇索引转换为密集的向量表示。</span></span><br><span class="line">        self.embedding = nn.Embedding(vocab_size, num_hiddens)</span><br><span class="line">        <span class="comment"># 位置编码层，为每个元素的嵌入添加位置信息。</span></span><br><span class="line">        self.pos_encoding = d2l.PositionalEncoding(num_hiddens, dropout)</span><br><span class="line">        <span class="comment"># 解码器块的堆叠，每个块包括两个多头自注意力层和一个前馈网络。</span></span><br><span class="line">        self.blks = nn.Sequential()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_layers):</span><br><span class="line">            self.blks.add_module(<span class="string">&quot;block&quot;</span>+<span class="built_in">str</span>(i),</span><br><span class="line">                DecoderBlock(key_size, query_size, value_size, num_hiddens,</span><br><span class="line">                             norm_shape, ffn_num_input, ffn_num_hiddens,</span><br><span class="line">                             num_heads, dropout, i))</span><br><span class="line">        <span class="comment"># 最终的线性层，将解码器的输出转换为词汇表大小的向量，用于预测下一个词元。</span></span><br><span class="line">        self.dense = nn.Linear(num_hiddens, vocab_size)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init_state</span>(<span class="params">self, enc_outputs, enc_valid_lens, *args</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        初始化解码器的状态，包括编码器的输出和有效长度。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> [enc_outputs, enc_valid_lens, [<span class="literal">None</span>] * self.num_layers]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, X, state</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        前向传播函数。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        参数:</span></span><br><span class="line"><span class="string">        - X: 输入序列的张量。</span></span><br><span class="line"><span class="string">        - state: 包含编码器输出和其他信息的状态。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        返回:</span></span><br><span class="line"><span class="string">        - 解码器的输出和更新后的状态。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        X = self.pos_encoding(self.embedding(X) * math.sqrt(self.num_hiddens))</span><br><span class="line">        self._attention_weights = [[<span class="literal">None</span>] * <span class="built_in">len</span>(self.blks) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)]</span><br><span class="line">        <span class="keyword">for</span> i, blk <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.blks):</span><br><span class="line">            X, state = blk(X, state)</span><br><span class="line">            <span class="comment"># 存储当前块的解码器自注意力权重和编码器-解码器注意力权重。</span></span><br><span class="line">            self._attention_weights[<span class="number">0</span>][i] = blk.attention1.attention.attention_weights</span><br><span class="line">            self._attention_weights[<span class="number">1</span>][i] = blk.attention2.attention.attention_weights</span><br><span class="line">        <span class="comment"># 将解码器的输出通过一个线性层转换为预测下一个词元的概率分布。</span></span><br><span class="line">        <span class="keyword">return</span> self.dense(X), state</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">attention_weights</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        返回解码器内部的注意力权重。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self._attention_weights</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p>依照Transformer架构来实例化编码器－解码器模型。在这里，指定Transformer的编码器和解码器都是2层，都使用4头注意力</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置模型参数</span></span><br><span class="line">num_hiddens, num_layers, dropout = <span class="number">32</span>, <span class="number">2</span>, <span class="number">0.1</span>  <span class="comment"># 模型隐藏单元数，层数，以及dropout比率</span></span><br><span class="line">batch_size, num_steps = <span class="number">64</span>, <span class="number">10</span>  <span class="comment"># 批量大小和序列长度（步数）</span></span><br><span class="line">lr, num_epochs = <span class="number">0.005</span>, <span class="number">200</span>  <span class="comment"># 学习率和训练周期</span></span><br><span class="line">device = d2l.try_gpu()  <span class="comment"># 训练使用的设备，尽量使用GPU</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置前馈网络和多头注意力的参数</span></span><br><span class="line">ffn_num_input, ffn_num_hiddens, num_heads = <span class="number">32</span>, <span class="number">64</span>, <span class="number">4</span>  <span class="comment"># 前馈网络输入和隐藏层维度，注意力头数</span></span><br><span class="line">key_size, query_size, value_size = <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>  <span class="comment"># 设置键、查询、值的维度（对于Transformer通常相等）</span></span><br><span class="line">norm_shape = [<span class="number">32</span>]  <span class="comment"># 层规范化应用的维度</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载机器翻译数据集</span></span><br><span class="line">train_iter, src_vocab, tgt_vocab = d2l.load_data_nmt(batch_size, num_steps)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化编码器</span></span><br><span class="line">encoder = TransformerEncoder(</span><br><span class="line">    <span class="built_in">len</span>(src_vocab),  <span class="comment"># 源语言词汇表大小</span></span><br><span class="line">    key_size, query_size, value_size,</span><br><span class="line">    num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens,</span><br><span class="line">    num_heads, num_layers, dropout)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化解码器</span></span><br><span class="line">decoder = TransformerDecoder(</span><br><span class="line">    <span class="built_in">len</span>(tgt_vocab),  <span class="comment"># 目标语言词汇表大小</span></span><br><span class="line">    key_size, query_size, value_size,</span><br><span class="line">    num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens,</span><br><span class="line">    num_heads, num_layers, dropout)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 组合编码器和解码器为一个完整的模型</span></span><br><span class="line">net = d2l.EncoderDecoder(encoder, decoder)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">d2l.train_seq2seq(net, train_iter, lr, num_epochs, tgt_vocab, device)</span><br><span class="line"><span class="comment">#loss 0.030, 5202.9 tokens/sec on cuda:0</span></span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraoutput_transformer_5722f1_201_1.svg" alt="../_images/output_transformer_5722f1_201_1.svg"></p><p>训练结束后，使用Transformer模型将一些英语句子翻译成法语，并且计算它们的BLEU分数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">engs = [<span class="string">&#x27;go .&#x27;</span>, <span class="string">&quot;i lost .&quot;</span>, <span class="string">&#x27;he\&#x27;s calm .&#x27;</span>, <span class="string">&#x27;i\&#x27;m home .&#x27;</span>]</span><br><span class="line">fras = [<span class="string">&#x27;va !&#x27;</span>, <span class="string">&#x27;j\&#x27;ai perdu .&#x27;</span>, <span class="string">&#x27;il est calme .&#x27;</span>, <span class="string">&#x27;je suis chez moi .&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> eng, fra <span class="keyword">in</span> <span class="built_in">zip</span>(engs, fras):</span><br><span class="line">    translation, dec_attention_weight_seq = d2l.predict_seq2seq(</span><br><span class="line">        net, eng, src_vocab, tgt_vocab, num_steps, device, <span class="literal">True</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;eng&#125;</span> =&gt; <span class="subst">&#123;translation&#125;</span>, &#x27;</span>,</span><br><span class="line">          <span class="string">f&#x27;bleu <span class="subst">&#123;d2l.bleu(translation, fra, k=<span class="number">2</span>):<span class="number">.3</span>f&#125;</span>&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">go . =&gt; va !,  bleu 1.000</span></span><br><span class="line"><span class="string">i lost . =&gt; j&#x27;ai perdu .,  bleu 1.000</span></span><br><span class="line"><span class="string">he&#x27;s calm . =&gt; il est calme .,  bleu 1.000</span></span><br><span class="line"><span class="string">i&#x27;m home . =&gt; je suis chez moi .,  bleu 1.000</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>当进行最后一个英语到法语的句子翻译工作时，让我们可视化Transformer的注意力权重。编码器自注意力权重的形状为（编码器层数，注意力头数，<code>num_steps</code>或查询的数目，<code>num_steps</code>或“键－值”对的数目）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enc_attention_weights = torch.cat(net.encoder.attention_weights, <span class="number">0</span>).reshape((num_layers, num_heads,</span><br><span class="line">    -<span class="number">1</span>, num_steps))</span><br><span class="line">enc_attention_weights.shape</span><br><span class="line"></span><br><span class="line"><span class="comment"># torch.Size([2, 4, 10, 10])</span></span><br></pre></td></tr></table></figure><p>在编码器的自注意力中，查询和键都来自相同的输入序列。因为填充词元是不携带信息的，因此通过指定输入序列的有效长度可以避免查询与使用填充词元的位置计算注意力。接下来，将逐行呈现两层多头注意力的权重。每个注意力头都根据查询、键和值的不同的表示子空间来表示不同的注意力。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d2l.show_heatmaps(</span><br><span class="line">    enc_attention_weights.cpu(), xlabel=&#x27;Key positions&#x27;,</span><br><span class="line">    ylabel=&#x27;Query positions&#x27;, titles=[&#x27;Head %d&#x27; % i for i in range(1, 5)],</span><br><span class="line">    figsize=(7, 3.5))</span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraoutput_transformer_5722f1_246_0.svg" alt="../_images/output_transformer_5722f1_246_0.svg"></p><p>为了可视化解码器的自注意力权重和“编码器－解码器”的注意力权重，我们需要完成更多的数据操作工作。例如用零填充被掩蔽住的注意力权重。值得注意的是，解码器的自注意力权重和“编码器－解码器”的注意力权重都有相同的查询：即以<strong><em>序列开始词元</em></strong>（beginning-of-sequence,BOS）打头，再与后续输出的词元共同组成序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dec_attention_weights_2d = [head[<span class="number">0</span>].tolist()</span><br><span class="line">                            <span class="keyword">for</span> step <span class="keyword">in</span> dec_attention_weight_seq</span><br><span class="line">                            <span class="keyword">for</span> attn <span class="keyword">in</span> step <span class="keyword">for</span> blk <span class="keyword">in</span> attn <span class="keyword">for</span> head <span class="keyword">in</span> blk]</span><br><span class="line">dec_attention_weights_filled = torch.tensor(</span><br><span class="line">    pd.DataFrame(dec_attention_weights_2d).fillna(<span class="number">0.0</span>).values)</span><br><span class="line">dec_attention_weights = dec_attention_weights_filled.reshape((-<span class="number">1</span>, <span class="number">2</span>, num_layers, num_heads, num_steps))</span><br><span class="line">dec_self_attention_weights, dec_inter_attention_weights = \</span><br><span class="line">    dec_attention_weights.permute(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>)</span><br><span class="line">dec_self_attention_weights.shape, dec_inter_attention_weights.shape</span><br></pre></td></tr></table></figure><p>由于解码器自注意力的自回归属性，查询不会对当前位置之后的“键－值”对进行注意力计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Plusonetoincludethebeginning-of-sequencetoken</span></span><br><span class="line">d2l.show_heatmaps(</span><br><span class="line">    dec_self_attention_weights[:, :, :, :<span class="built_in">len</span>(translation.split()) + <span class="number">1</span>],</span><br><span class="line">    xlabel=<span class="string">&#x27;Key positions&#x27;</span>, ylabel=<span class="string">&#x27;Query positions&#x27;</span>,</span><br><span class="line">    titles=[<span class="string">&#x27;Head %d&#x27;</span> % i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>)], figsize=(<span class="number">7</span>, <span class="number">3.5</span>))</span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraoutput_transformer_5722f1_276_0.svg" alt="../_images/output_transformer_5722f1_276_0.svg"></p><p>与编码器的自注意力的情况类似，通过指定输入序列的有效长度，输出序列的查询不会与输入序列中填充位置的词元进行注意力计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d2l.show_heatmaps(</span><br><span class="line">    dec_inter_attention_weights, xlabel=<span class="string">&#x27;Key positions&#x27;</span>,</span><br><span class="line">    ylabel=<span class="string">&#x27;Query positions&#x27;</span>, titles=[<span class="string">&#x27;Head %d&#x27;</span> % i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>)],</span><br><span class="line">    figsize=(<span class="number">7</span>, <span class="number">3.5</span>))</span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraoutput_transformer_5722f1_291_0.svg" alt="../_images/output_transformer_5722f1_291_0.svg"></p><p>尽管Transformer架构是为了<strong><em>序列到序列</em></strong>的学习而提出的，但正如本书后面将提及的那样，Transformer编码器或Transformer解码器通常被单独用于不同的深度学习任务中。</p><ul><li>Transformer是编码器－解码器架构的一个实践，尽管在实际情况中编码器或解码器可以单独使用。</li><li>在Transformer中，多头自注意力用于表示输入序列和输出序列，不过解码器必须通过掩蔽机制来保留自回归属性。</li><li>Transformer中的残差连接和层规范化是训练非常深度模型的重要工具。</li><li>Transformer模型中基于位置的前馈网络使用同一个多层感知机，作用是对所有序列位置的表示进行转换。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.0 现代卷积神经网络</title>
      <link href="/post/54714.html"/>
      <url>/post/54714.html</url>
      
        <content type="html"><![CDATA[<h1 id="现代卷积神经网络"><a href="#现代卷积神经网络" class="headerlink" title="现代卷积神经网络"></a>现代卷积神经网络</h1><h2 id="深度卷积神经网络-AlexNet"><a href="#深度卷积神经网络-AlexNet" class="headerlink" title="深度卷积神经网络(AlexNet)"></a>深度卷积神经网络(AlexNet)</h2><p>首次证明了学习到的特征可以超越手工设计的特征，AlexNet和LeNet的架构非常相似，但也存在显著差异。</p><ol><li>AlexNet比相对较小的LeNet5要深得多。AlexNet由八层组成：五个卷积层、两个全连接隐藏层和一个全连接输出层。</li><li>AlexNet使用ReLU而不是sigmoid作为其激活函数。</li></ol><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraalexnet.svg" alt="../_images/alexnet.svg"></p><hr><h3 id="模型设计"><a href="#模型设计" class="headerlink" title="模型设计"></a>模型设计</h3><p>在<code>AlexNet</code>的第一层，卷积窗口的形状是$11×11$。 由于<code>ImageNet</code>中大多数图像的宽和高比<code>MNIST</code>图像的多10倍以上，因此，需要一个更大的卷积窗口来捕获目标。 第二层中的卷积窗口形状被缩减为$5×5$，然后是$3×3$。 此外，在第一层、第二层和第五层卷积层之后，加入窗口形状为$3×3$、步幅为2的最大汇聚层。 而且，<code>AlexNet</code>的卷积通道数目是<code>LeNet</code>的10倍。</p><p>在最后一个卷积层后有两个全连接层，分别有4096个输出。 这两个巨大的全连接层拥有将近1GB的模型参数。 </p><p>此外，<code>AlexNet</code>将<code>sigmoid</code>激活函数改为更简单的<code>ReLU</code>激活函数。 一方面，<code>ReLU</code>激活函数的计算更简单，它不需要如<code>sigmoid</code>激活函数那般复杂的求幂运算。 另一方面，当使用不同的参数初始化方法时，<code>ReLU</code>激活函数使训练模型更加容易。 当<code>sigmoid</code>激活函数的输出非常接近于0或1时，这些区域的梯度几乎为0，因此反向传播无法继续更新一些模型参数。 相反，<code>ReLU</code>激活函数在正区间的梯度总是1。 因此，如果模型参数没有正确初始化，<code>sigmoid</code>函数可能在正区间内得到几乎为0的梯度，从而使模型无法得到有效的训练。</p><hr><h3 id="容量控制和预处理"><a href="#容量控制和预处理" class="headerlink" title="容量控制和预处理"></a>容量控制和预处理</h3><p><code>AlexNet</code>通过暂退法(dropout)控制全连接层的模型复杂度，而<code>LeNet</code>只使用了权重衰减。 为了进一步扩充数据，<code>AlexNet</code>在训练时增加了大量的图像增强数据，如翻转、裁切和变色。 这使得模型更健壮，更大的样本量有效地减少了过拟合。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line">net = nn.Sequential(</span><br><span class="line">    <span class="comment"># 这里使用一个11*11的更大窗口来捕捉对象。</span></span><br><span class="line">    <span class="comment"># 同时，步幅为4，以减少输出的高度和宽度。</span></span><br><span class="line">    <span class="comment"># 另外，输出通道的数目远大于LeNet</span></span><br><span class="line">    nn.Conv2d(<span class="number">1</span>, <span class="number">96</span>, kernel_size=<span class="number">11</span>, stride=<span class="number">4</span>, padding=<span class="number">1</span>), nn.ReLU(),</span><br><span class="line">    nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>),</span><br><span class="line">    <span class="comment"># 减小卷积窗口，使用填充为2来使得输入与输出的高和宽一致，且增大输出通道数</span></span><br><span class="line">    nn.Conv2d(<span class="number">96</span>, <span class="number">256</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>), nn.ReLU(),</span><br><span class="line">    nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>),</span><br><span class="line">    <span class="comment"># 使用三个连续的卷积层和较小的卷积窗口。</span></span><br><span class="line">    <span class="comment"># 除了最后的卷积层，输出通道的数量进一步增加。</span></span><br><span class="line">    <span class="comment"># 在前两个卷积层之后，汇聚层不用于减少输入的高度和宽度</span></span><br><span class="line">    nn.Conv2d(<span class="number">256</span>, <span class="number">384</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>), nn.ReLU(),</span><br><span class="line">    nn.Conv2d(<span class="number">384</span>, <span class="number">384</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>), nn.ReLU(),</span><br><span class="line">    nn.Conv2d(<span class="number">384</span>, <span class="number">256</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>), nn.ReLU(),</span><br><span class="line">    nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>),</span><br><span class="line">    nn.Flatten(),</span><br><span class="line">    <span class="comment"># 这里，全连接层的输出数量是LeNet中的好几倍。使用dropout层来减轻过拟合</span></span><br><span class="line">    nn.Linear(<span class="number">6400</span>, <span class="number">4096</span>), nn.ReLU(),</span><br><span class="line">    nn.Dropout(p=<span class="number">0.5</span>),</span><br><span class="line">    nn.Linear(<span class="number">4096</span>, <span class="number">4096</span>), nn.ReLU(),</span><br><span class="line">    nn.Dropout(p=<span class="number">0.5</span>),</span><br><span class="line">    <span class="comment"># 最后是输出层。由于这里使用Fashion-MNIST，所以用类别数为10，而非论文中的1000</span></span><br><span class="line">    nn.Linear(<span class="number">4096</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure><p>我们构造一个高度和宽度都为224的单通道数据，来观察每一层输出的形状。 它与图中的AlexNet架构相匹配。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X = torch.randn(<span class="number">1</span>, <span class="number">1</span>, <span class="number">224</span>, <span class="number">224</span>)</span><br><span class="line"><span class="keyword">for</span> layer <span class="keyword">in</span> net:</span><br><span class="line">    X=layer(X)</span><br><span class="line">    <span class="built_in">print</span>(layer.__class__.__name__,<span class="string">&#x27;output shape:\t&#x27;</span>,X.shape)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Conv2d output shape:         torch.Size([<span class="number">1</span>, <span class="number">96</span>, <span class="number">54</span>, <span class="number">54</span>])</span><br><span class="line">ReLU output shape:   torch.Size([<span class="number">1</span>, <span class="number">96</span>, <span class="number">54</span>, <span class="number">54</span>])</span><br><span class="line">MaxPool2d output shape:      torch.Size([<span class="number">1</span>, <span class="number">96</span>, <span class="number">26</span>, <span class="number">26</span>])</span><br><span class="line">Conv2d output shape:         torch.Size([<span class="number">1</span>, <span class="number">256</span>, <span class="number">26</span>, <span class="number">26</span>])</span><br><span class="line">ReLU output shape:   torch.Size([<span class="number">1</span>, <span class="number">256</span>, <span class="number">26</span>, <span class="number">26</span>])</span><br><span class="line">MaxPool2d output shape:      torch.Size([<span class="number">1</span>, <span class="number">256</span>, <span class="number">12</span>, <span class="number">12</span>])</span><br><span class="line">Conv2d output shape:         torch.Size([<span class="number">1</span>, <span class="number">384</span>, <span class="number">12</span>, <span class="number">12</span>])</span><br><span class="line">ReLU output shape:   torch.Size([<span class="number">1</span>, <span class="number">384</span>, <span class="number">12</span>, <span class="number">12</span>])</span><br><span class="line">Conv2d output shape:         torch.Size([<span class="number">1</span>, <span class="number">384</span>, <span class="number">12</span>, <span class="number">12</span>])</span><br><span class="line">ReLU output shape:   torch.Size([<span class="number">1</span>, <span class="number">384</span>, <span class="number">12</span>, <span class="number">12</span>])</span><br><span class="line">Conv2d output shape:         torch.Size([<span class="number">1</span>, <span class="number">256</span>, <span class="number">12</span>, <span class="number">12</span>])</span><br><span class="line">ReLU output shape:   torch.Size([<span class="number">1</span>, <span class="number">256</span>, <span class="number">12</span>, <span class="number">12</span>])</span><br><span class="line">MaxPool2d output shape:      torch.Size([<span class="number">1</span>, <span class="number">256</span>, <span class="number">5</span>, <span class="number">5</span>])</span><br><span class="line">Flatten output shape:        torch.Size([<span class="number">1</span>, <span class="number">6400</span>])</span><br><span class="line">Linear output shape:         torch.Size([<span class="number">1</span>, <span class="number">4096</span>])</span><br><span class="line">ReLU output shape:   torch.Size([<span class="number">1</span>, <span class="number">4096</span>])</span><br><span class="line">Dropout output shape:        torch.Size([<span class="number">1</span>, <span class="number">4096</span>])</span><br><span class="line">Linear output shape:         torch.Size([<span class="number">1</span>, <span class="number">4096</span>])</span><br><span class="line">ReLU output shape:   torch.Size([<span class="number">1</span>, <span class="number">4096</span>])</span><br><span class="line">Dropout output shape:        torch.Size([<span class="number">1</span>, <span class="number">4096</span>])</span><br><span class="line">Linear output shape:         torch.Size([<span class="number">1</span>, <span class="number">10</span>])</span><br></pre></td></tr></table></figure><hr><h3 id="训练AlexNet"><a href="#训练AlexNet" class="headerlink" title="训练AlexNet"></a>训练AlexNet</h3><p>与LeNet相比，这里的主要变化是使用更小的学习速率训练，这是因为网络更深更广、图像分辨率更高，训练卷积神经网络就更昂贵。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">batch_size = <span class="number">128</span></span><br><span class="line">train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size, resize=<span class="number">224</span>)</span><br><span class="line">lr, num_epochs = <span class="number">0.01</span>, <span class="number">10</span></span><br><span class="line">d2l.train_ch6(net, train_iter, test_iter, num_epochs, lr, d2l.try_gpu())</span><br><span class="line"><span class="comment">#loss 0.328, train acc 0.882, test acc 0.881 </span></span><br><span class="line"><span class="comment">#3205.9 examples/sec on cuda:0</span></span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraoutput_alexnet_180871_38_1.svg" alt="../_images/output_alexnet_180871_38_1.svg"></p><ul><li>AlexNet的架构与LeNet相似，但使用了更多的卷积层和更多的参数来拟合大规模的ImageNet数据集。</li><li>今天，AlexNet已经被更有效的架构所超越，但它是从浅层网络到深层网络的关键一步。</li><li>尽管AlexNet的代码只比LeNet多出几行，但学术界花了很多年才接受深度学习这一概念，并应用其出色的实验结果。这也是由于缺乏有效的计算工具。</li></ul><hr><h2 id="使用块的网络-VGG"><a href="#使用块的网络-VGG" class="headerlink" title="使用块的网络(VGG)"></a>使用块的网络(VGG)</h2><h3 id="VGG块"><a href="#VGG块" class="headerlink" title="VGG块"></a>VGG块</h3><p>经典卷积神经网络的基本组成部分是下面的这个序列：</p><ol><li>带填充以保持分辨率的卷积层；</li><li>非线性激活函数，如ReLU；</li><li>汇聚层，如最大汇聚层。</li></ol><p>而一个VGG块与之类似，由一系列卷积层组成，后面再加上用于空间下采样的最大汇聚层</p><p>作者使用了带有$3×3$卷积核、填充为1（保持高度和宽度）的卷积层，和带有2×2汇聚窗口、步幅为2（每个块后的分辨率减半）的最大汇聚层。在下面的代码中，我们定义了一个名为<code>vgg_block</code>的函数来实现一个VGG块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch  </span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn  </span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义vgg_block函数，接受三个参数：卷积层数量(num_convs)、输入通道数(in_channels)和输出通道数(out_channels)。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vgg_block</span>(<span class="params">num_convs, in_channels, out_channels</span>):</span>  </span><br><span class="line"><span class="comment"># 初始化一个空列表，用于存放卷积块中的层。</span></span><br><span class="line">    layers = []  </span><br><span class="line"><span class="comment"># 开始一个循环，根据num_convs的值重复添加卷积层和ReLU激活层。</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_convs):  </span><br><span class="line"><span class="comment"># 向layers列表中添加一个2D卷积层。这个卷积层将具有指定的输入和输出通道数，核大小为3，并使用padding使得输入和输出的空间维度不变。</span></span><br><span class="line">        layers.append(nn.Conv2d(in_channels, out_channels, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)) </span><br><span class="line"><span class="comment"># 在每个卷积层后面添加一个ReLU激活函数层。</span></span><br><span class="line">        layers.append(nn.ReLU()) </span><br><span class="line"><span class="comment"># 将输入通道数更新为输出通道数，以便下一个卷积层可以接受当前卷积层的输出作为其输入。</span></span><br><span class="line">        in_channels = out_channels  </span><br><span class="line"><span class="comment"># 在卷积层后面添加一个最大池化层，其核大小为2，步长也为2，用于减少特征图的空间维度。</span></span><br><span class="line">    layers.append(nn.MaxPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>)) </span><br><span class="line"><span class="comment"># 使用nn.Sequential将所有层组合成一个连续的模块，并返回这个模块。这样，vgg_block就可以作为一个整体在VGG网络中被重复使用。</span></span><br><span class="line">    <span class="keyword">return</span> nn.Sequential(*layers)  </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="VGG网络"><a href="#VGG网络" class="headerlink" title="VGG网络"></a>VGG网络</h3><p>与AlexNet、LeNet一样，VGG网络可以分为两部分：第一部分主要由卷积层和汇聚层组成，第二部分由全连接层组成</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoravgg.svg" alt="../_images/vgg.svg"></p><p><code>VGG</code>神经网络连接图中的几个<code>VGG</code>块（在<code>vgg_block</code>函数中定义）。其中有超参数变量<code>conv_arch</code>。该变量指定了每个<code>VGG</code>块里卷积层个数和输出通道数。全连接模块则与AlexNet中的相同。</p><p>原始<code>VGG</code>网络有5个卷积块，其中前两个块各有一个卷积层，后三个块各包含两个卷积层。 第一个模块有64个输出通道，每个后续模块将输出通道数量翻倍，直到该数字达到512。由于该网络使用8个卷积层和3个全连接层，因此它通常被称为<code>VGG-11</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conv_arch = ((<span class="number">1</span>, <span class="number">64</span>), (<span class="number">1</span>, <span class="number">128</span>), (<span class="number">2</span>, <span class="number">256</span>), (<span class="number">2</span>, <span class="number">512</span>), (<span class="number">2</span>, <span class="number">512</span>))</span><br></pre></td></tr></table></figure><p>下面的代码实现了VGG-11。可以通过在<code>conv_arch</code>上执行for循环来简单实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vgg</span>(<span class="params">conv_arch</span>):</span>  <span class="comment"># 定义vgg函数，接受一个卷积架构参数conv_arch。</span></span><br><span class="line">    conv_blks = []  <span class="comment"># 初始化一个空列表，用于存储网络中的所有卷积块。</span></span><br><span class="line">    in_channels = <span class="number">1</span>  <span class="comment"># 初始的输入通道数设为1，假设输入图像是灰度图。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 卷积层部分</span></span><br><span class="line">    <span class="keyword">for</span> (num_convs, out_channels) <span class="keyword">in</span> conv_arch: </span><br><span class="line">    <span class="comment"># 遍历conv_arch列表，每个元素包含卷积层数和该块的输出通道数。</span></span><br><span class="line">        conv_blks.append(vgg_block(num_convs, in_channels, out_channels))</span><br><span class="line">    <span class="comment"># 使用vgg_block函数构建卷积块，并将其添加到conv_blks列表中。</span></span><br><span class="line">        in_channels = out_channels  </span><br><span class="line">    <span class="comment"># 更新in_channels为当前卷积块的输出通道数，以供下一个卷积块使用。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nn.Sequential(</span><br><span class="line">        *conv_blks,  </span><br><span class="line">        <span class="comment"># 将所有卷积块添加到Sequential模型中。</span></span><br><span class="line">        nn.Flatten(),  </span><br><span class="line">        <span class="comment"># 添加一个Flatten层，将卷积层的多维输出扁平化为一维，以便全连接层处理。</span></span><br><span class="line">        <span class="comment"># 全连接层部分</span></span><br><span class="line">        nn.Linear(out_channels * <span class="number">7</span> * <span class="number">7</span>, <span class="number">4096</span>),  </span><br><span class="line">        <span class="comment"># 第一个全连接层，输入节点数依赖于最后一个卷积块的输出通道数和假设的特征图大小（7*7）。</span></span><br><span class="line">        nn.ReLU(),  <span class="comment"># ReLU激活函数。</span></span><br><span class="line">        nn.Dropout(<span class="number">0.5</span>),  <span class="comment"># Dropout层，以0.5的概率丢弃节点，防止过拟合。</span></span><br><span class="line">        nn.Linear(<span class="number">4096</span>, <span class="number">4096</span>),  <span class="comment"># 第二个全连接层，节点数保持为4096。</span></span><br><span class="line">        nn.ReLU(),  <span class="comment"># 又一个ReLU激活函数。</span></span><br><span class="line">        nn.Dropout(<span class="number">0.5</span>),  <span class="comment"># 又一个Dropout层。</span></span><br><span class="line">        nn.Linear(<span class="number">4096</span>, <span class="number">10</span>)  <span class="comment"># 最后一个全连接层，输出节点数为10，对应于分类任务的类别数。</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设conv_arch是已定义的卷积架构参数</span></span><br><span class="line">net = vgg(conv_arch)  <span class="comment"># 使用vgg函数和conv_arch参数创建VGG网络模型。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p>由于VGG-11比AlexNet计算量更大，因此我们构建了一个通道数较少的网络，足够用于训练Fashion-MNIST数据集。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ratio = <span class="number">4</span></span><br><span class="line">small_conv_arch = [(pair[<span class="number">0</span>], pair[<span class="number">1</span>] // ratio) <span class="keyword">for</span> pair <span class="keyword">in</span> conv_arch]</span><br><span class="line">net = vgg(small_conv_arch)</span><br><span class="line"></span><br><span class="line">lr, num_epochs, batch_size = <span class="number">0.05</span>, <span class="number">10</span>, <span class="number">128</span></span><br><span class="line">train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size, resize=<span class="number">224</span>)</span><br><span class="line">d2l.train_ch6(net, train_iter, test_iter, num_epochs, lr, d2l.try_gpu())</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">loss 0.172, train acc 0.936, test acc 0.913</span><br><span class="line">1680.2 examples/sec on cuda:0</span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraoutput_vgg_4a7574_71_1.svg" alt="../_images/output_vgg_4a7574_71_1.svg"></p><ul><li>VGG-11使用可复用的卷积块构造网络。不同的VGG模型可通过每个块中卷积层数量和输出通道数量的差异来定义。</li><li>块的使用导致网络定义的非常简洁。使用块可以有效地设计复杂的网络。</li><li>在VGG论文中，Simonyan和Ziserman尝试了各种架构。特别是他们发现深层且窄的卷积（即3×3）比较浅层且宽的卷积更有效。</li></ul><hr><h2 id="网络中的网络-NiN"><a href="#网络中的网络-NiN" class="headerlink" title="网络中的网络(NiN)"></a>网络中的网络(NiN)</h2><p><code>LeNet</code>、<code>AlexNet</code>和<code>VGG</code>都有一个共同的设计模式：通过一系列的卷积层与汇聚层来提取空间结构特征；然后通过全连接层对特征的表征进行处理。 <code>AlexNet</code>和<code>VGG</code>对<code>LeNet</code>的改进主要在于如何扩大和加深这两个模块。</p><p>然而，如果使用了全连接层，可能会完全放弃表征的空间结构。 <strong><em>网络中的网络</em></strong>（<em>NiN</em>）提供了一个非常简单的解决方案：在每个像素的通道上分别使用<strong>多层感知机</strong></p><h3 id="NiN块"><a href="#NiN块" class="headerlink" title="NiN块"></a>NiN块</h3><p>卷积层的输入和输出由四维张量组成，张量的每个轴分别对应样本、通道、高度和宽度。 另外，全连接层的输入和输出通常是分别对应于样本和特征的二维张量。 NiN的想法是在每个像素位置（针对每个高度和宽度）应用一个全连接层。 如果我们将权重连接到每个空间位置，我们可以将其视为1×1卷积层，或作为在每个像素位置上独立作用的全连接层。 从另一个角度看，即将空间维度中的每个像素视为单个样本，将通道维度视为不同特征（feature）。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoranin.svg" alt="../_images/nin.svg"></p><p>图中说明了VGG和NiN及它们的块之间主要架构差异。 NiN块以一个普通卷积层开始，后面是两个1×1的卷积层。这两个$1×1$卷积层充当带有ReLU激活函数的逐像素全连接层。 第一层的卷积窗口形状通常由用户设置。 随后的卷积窗口形状固定为$1×1$。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nin_block</span>(<span class="params">in_channels, out_channels, kernel_size, strides, padding</span>):</span></span><br><span class="line">    <span class="comment"># 定义一个NiN块，该块接收五个参数：</span></span><br><span class="line">    <span class="comment"># in_channels：输入通道数。</span></span><br><span class="line">    <span class="comment"># out_channels：输出通道数。</span></span><br><span class="line">    <span class="comment"># kernel_size：卷积核的大小。</span></span><br><span class="line">    <span class="comment"># strides：卷积的步长。</span></span><br><span class="line">    <span class="comment"># padding：卷积的填充量。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> nn.Sequential(</span><br><span class="line">        nn.Conv2d(in_channels, out_channels, kernel_size, strides, padding),</span><br><span class="line">        <span class="comment"># 第一个卷积层，它将接收指定的输入通道数和输出通道数，并使用指定的卷积核大小、步长和填充进行卷积操作。</span></span><br><span class="line">        nn.ReLU(),</span><br><span class="line">        <span class="comment"># ReLU激活函数，用于引入非线性，提高模型的表达能力。</span></span><br><span class="line"></span><br><span class="line">        nn.Conv2d(out_channels, out_channels, kernel_size=<span class="number">1</span>), nn.ReLU(),</span><br><span class="line">        <span class="comment"># 第二个卷积层，这是一个1x1卷积，用于在每个像素位置上应用一个全连接层的效果。</span></span><br><span class="line">        <span class="comment"># 它的输入和输出通道数相同，都是out_channels。这样做可以在不改变特征图深度的情况下，增加网络的深度和复杂度。</span></span><br><span class="line"></span><br><span class="line">        nn.Conv2d(out_channels, out_channels, kernel_size=<span class="number">1</span>), nn.ReLU())</span><br><span class="line">        <span class="comment"># 第三个卷积层，同样是一个1x1卷积，后面也跟着一个ReLU激活函数。</span></span><br><span class="line">        <span class="comment"># 这个连续使用1x1卷积的设计有助于进一步增加网络对于空间信息的学习能力，同时控制参数数量和计算复杂度。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="NiN网络"><a href="#NiN网络" class="headerlink" title="NiN网络"></a>NiN网络</h3><p>最初的NiN网络是在AlexNet后不久提出的，显然从中得到了一些启示。 NiN使用窗口形状为$11×11$、$5×5$和$3×3$的卷积层，输出通道数量与AlexNet中的相同。 每个NiN块后有一个最大汇聚层，汇聚窗口形状为$3×3$，步幅为2。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">net = nn.Sequential(</span><br><span class="line">    <span class="comment"># 输入层</span></span><br><span class="line">    nin_block(<span class="number">1</span>, <span class="number">96</span>, kernel_size=<span class="number">11</span>, strides=<span class="number">4</span>, padding=<span class="number">0</span>),</span><br><span class="line">    <span class="comment"># 使用nin_block定义第一个NiN块。这里处理的是单通道输入（例如灰度图），使用96个输出通道。</span></span><br><span class="line">    <span class="comment"># 卷积核大小为11，步长为4，无填充。这种设置用于在输入层上捕获更大范围的特征。</span></span><br><span class="line"></span><br><span class="line">    nn.MaxPool2d(<span class="number">3</span>, stride=<span class="number">2</span>),</span><br><span class="line">    <span class="comment"># 紧接着一个最大池化层，核大小为3，步长为2。池化层用于减少特征图的尺寸，提高模型的空间不变性。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第二层</span></span><br><span class="line">    nin_block(<span class="number">96</span>, <span class="number">256</span>, kernel_size=<span class="number">5</span>, strides=<span class="number">1</span>, padding=<span class="number">2</span>),</span><br><span class="line">    <span class="comment"># 第二个NiN块，输入通道数从96变为256，卷积核大小减小到5，步长为1，填充为2。</span></span><br><span class="line">    <span class="comment"># 通过增加输出通道数，网络能够学习更多的特征表示。</span></span><br><span class="line"></span><br><span class="line">    nn.MaxPool2d(<span class="number">3</span>, stride=<span class="number">2</span>),</span><br><span class="line">    <span class="comment"># 又一个最大池化层。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第三层</span></span><br><span class="line">    nin_block(<span class="number">256</span>, <span class="number">384</span>, kernel_size=<span class="number">3</span>, strides=<span class="number">1</span>, padding=<span class="number">1</span>),</span><br><span class="line">    <span class="comment"># 第三个NiN块，进一步增加模型的深度，此处输入通道数为256，输出通道数为384。</span></span><br><span class="line">    <span class="comment"># 卷积核大小为3，这是一个比较常见的选择，能够有效捕捉局部特征。</span></span><br><span class="line"></span><br><span class="line">    nn.MaxPool2d(<span class="number">3</span>, stride=<span class="number">2</span>),</span><br><span class="line">    <span class="comment"># 第三个最大池化层。</span></span><br><span class="line"></span><br><span class="line">    nn.Dropout(<span class="number">0.5</span>),</span><br><span class="line">    <span class="comment"># Dropout层，随机丢弃一部分神经元（这里是50%的比例），用于减少过拟合。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出层</span></span><br><span class="line">    nin_block(<span class="number">384</span>, <span class="number">10</span>, kernel_size=<span class="number">3</span>, strides=<span class="number">1</span>, padding=<span class="number">1</span>),</span><br><span class="line">    <span class="comment"># 最后一个NiN块，将输出通道数调整为10，对应于10个分类标签。</span></span><br><span class="line">    </span><br><span class="line">    nn.AdaptiveAvgPool2d((<span class="number">1</span>, <span class="number">1</span>)),</span><br><span class="line">    <span class="comment"># 适应性平均池化层，将特征图的大小调整为1x1，这样做的目的是为了将空间维度的特征压缩成单个数值，</span></span><br><span class="line">    <span class="comment"># 这相当于对每个通道进行全局平均池化，确保输出大小与分类标签数相匹配。</span></span><br><span class="line"></span><br><span class="line">    nn.Flatten())</span><br><span class="line">    <span class="comment"># 将四维的输出（批量大小, 通道数, 高度, 宽度）扁平化为二维的输出（批量大小, 通道数），</span></span><br><span class="line">    <span class="comment"># 这是因为最终的分类器期望的输入是一维向量形式。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们创建一个数据样本来查看每个块的输出形状。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X = torch.rand(size=(<span class="number">1</span>, <span class="number">1</span>, <span class="number">224</span>, <span class="number">224</span>))</span><br><span class="line"><span class="keyword">for</span> layer <span class="keyword">in</span> net:</span><br><span class="line">    X = layer(X)</span><br><span class="line">    <span class="built_in">print</span>(layer.__class__.__name__,<span class="string">&#x27;output shape:\t&#x27;</span>, X.shape)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Sequential output shape:     torch.Size([<span class="number">1</span>, <span class="number">96</span>, <span class="number">54</span>, <span class="number">54</span>])</span><br><span class="line">MaxPool2d output shape:      torch.Size([<span class="number">1</span>, <span class="number">96</span>, <span class="number">26</span>, <span class="number">26</span>])</span><br><span class="line">Sequential output shape:     torch.Size([<span class="number">1</span>, <span class="number">256</span>, <span class="number">26</span>, <span class="number">26</span>])</span><br><span class="line">MaxPool2d output shape:      torch.Size([<span class="number">1</span>, <span class="number">256</span>, <span class="number">12</span>, <span class="number">12</span>])</span><br><span class="line">Sequential output shape:     torch.Size([<span class="number">1</span>, <span class="number">384</span>, <span class="number">12</span>, <span class="number">12</span>])</span><br><span class="line">MaxPool2d output shape:      torch.Size([<span class="number">1</span>, <span class="number">384</span>, <span class="number">5</span>, <span class="number">5</span>])</span><br><span class="line">Dropout output shape:        torch.Size([<span class="number">1</span>, <span class="number">384</span>, <span class="number">5</span>, <span class="number">5</span>])</span><br><span class="line">Sequential output shape:     torch.Size([<span class="number">1</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">5</span>])</span><br><span class="line">AdaptiveAvgPool2d output shape:      torch.Size([<span class="number">1</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">Flatten output shape:        torch.Size([<span class="number">1</span>, <span class="number">10</span>])</span><br></pre></td></tr></table></figure><hr><h3 id="训练-1"><a href="#训练-1" class="headerlink" title="训练"></a>训练</h3><p>和以前一样，我们使用Fashion-MNIST来训练模型。训练NiN与训练AlexNet、VGG时相似。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lr, num_epochs, batch_size = <span class="number">0.1</span>, <span class="number">10</span>, <span class="number">128</span></span><br><span class="line">train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size, resize=<span class="number">224</span>)</span><br><span class="line">d2l.train_ch6(net, train_iter, test_iter, num_epochs, lr, d2l.try_gpu())</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">loss <span class="number">0.348</span>, train acc <span class="number">0.871</span>, test acc <span class="number">0.848</span></span><br><span class="line"><span class="number">2385.0</span> examples/sec on cuda:<span class="number">0</span></span><br></pre></td></tr></table></figure><p><img src="https://zh-v2.d2l.ai/_images/output_nin_8ad4f3_48_1.svg" alt="../_images/output_nin_8ad4f3_48_1.svg"></p><ul><li>NiN使用由一个卷积层和多个1×1卷积层组成的块。该块可以在卷积神经网络中使用，以允许更多的每像素非线性。</li><li>NiN去除了容易造成过拟合的全连接层，将它们替换为全局平均汇聚层（即在所有位置上进行求和）。该汇聚层通道数量为所需的输出数量（例如，Fashion-MNIST的输出为10）。</li><li>移除全连接层可减少过拟合，同时显著减少NiN的参数。</li><li>NiN的设计影响了许多后续卷积神经网络的设计。</li></ul><hr><h2 id="含并行连结的网络-GoogleNet"><a href="#含并行连结的网络-GoogleNet" class="headerlink" title="含并行连结的网络(GoogleNet)"></a>含并行连结的网络(GoogleNet)</h2><p> GoogLeNet吸收了NiN中串联网络的思想，并在此基础上做了改进。 这篇论文的一个重点是解决了什么样大小的卷积核最合适的问题。 毕竟，以前流行的网络使用小到$1×1$，大到$11×11$的卷积核。 本文的一个观点是，有时使用不同大小的卷积核组合是有利的</p><h3 id="Inception块"><a href="#Inception块" class="headerlink" title="Inception块"></a>Inception块</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typorainception.svg" alt="../_images/inception.svg"></p><p>如图所示，Inception块由四条并行路径组成。 前三条路径使用窗口大小为1×1、3×3和5×5的卷积层，从不同空间大小中提取信息。 中间的两条路径在输入上执行1×1卷积，以减少通道数，从而降低模型的复杂性。 第四条路径使用3×3最大汇聚层，然后使用1×1卷积层来改变通道数。 这四条路径都使用合适的填充来使输入与输出的高和宽一致，最后我们将每条线路的输出在通道维度上连结，并构成Inception块的输出。在Inception块中，通常调整的超参数是每层输出通道数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inception</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="comment"># c1--c4是每条路径的输出通道数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, in_channels, c1, c2, c3, c4, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Inception, self).__init__(**kwargs)</span><br><span class="line">        <span class="comment"># 初始化Inception模块的构造函数。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 线路1，单1x1卷积层</span></span><br><span class="line">        self.p1_1 = nn.Conv2d(in_channels, c1, kernel_size=<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 对输入进行1x1卷积操作，主要用于降维，减少计算量。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 线路2，1x1卷积层后接3x3卷积层</span></span><br><span class="line">        self.p2_1 = nn.Conv2d(in_channels, c2[<span class="number">0</span>], kernel_size=<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 第一部分是1x1卷积，用于降维。</span></span><br><span class="line">        self.p2_2 = nn.Conv2d(c2[<span class="number">0</span>], c2[<span class="number">1</span>], kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 第二部分是3x3卷积，能够捕捉到更广阔的空间特征。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 线路3，1x1卷积层后接5x5卷积层</span></span><br><span class="line">        self.p3_1 = nn.Conv2d(in_channels, c3[<span class="number">0</span>], kernel_size=<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 同样，先进行1x1卷积进行降维。</span></span><br><span class="line">        self.p3_2 = nn.Conv2d(c3[<span class="number">0</span>], c3[<span class="number">1</span>], kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>)</span><br><span class="line">        <span class="comment"># 然后使用5x5卷积捕捉更大范围的特征，padding=2保证输出特征图大小不变。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 线路4，3x3最大汇聚层后接1x1卷积层</span></span><br><span class="line">        self.p4_1 = nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 首先使用3x3的最大汇聚层，增强模型的空间不变性。</span></span><br><span class="line">        self.p4_2 = nn.Conv2d(in_channels, c4, kernel_size=<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 然后通过1x1卷积进行处理，主要用于降维。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        p1 = F.relu(self.p1_1(x))</span><br><span class="line">        <span class="comment"># 通过线路1的处理，并应用ReLU激活函数。</span></span><br><span class="line">        p2 = F.relu(self.p2_2(F.relu(self.p2_1(x))))</span><br><span class="line">        <span class="comment"># 先通过线路2的1x1卷积，应用ReLU，然后通过3x3卷积，再次应用ReLU。</span></span><br><span class="line">        p3 = F.relu(self.p3_2(F.relu(self.p3_1(x))))</span><br><span class="line">        <span class="comment"># 先通过线路3的1x1卷积，应用ReLU，然后通过5x5卷积，再次应用ReLU。</span></span><br><span class="line">        p4 = F.relu(self.p4_2(self.p4_1(x)))</span><br><span class="line">        <span class="comment"># 先通过线路4的最大汇聚层，然后通过1x1卷积，应用ReLU。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 在通道维度上连结输出</span></span><br><span class="line">        <span class="keyword">return</span> torch.cat((p1, p2, p3, p4), dim=<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 将四个线路的输出在通道维度（dim=1）上拼接起来，使模型能同时学习到不同尺度的特征。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 首先我们考虑一下滤波器（filter）的组合，它们可以用各种滤波器尺寸探索图像，这意味着不同大小的滤波器可以有效地识别不同范围的图像细节。 同时，我们可以为不同的滤波器分配不同数量的参数。</p><hr><h3 id="GoogleNet模型"><a href="#GoogleNet模型" class="headerlink" title="GoogleNet模型"></a>GoogleNet模型</h3><p>GoogLeNet一共使用9个Inception块和全局平均汇聚层的堆叠来生成其估计值。Inception块之间的最大汇聚层可降低维度。 第一个模块类似于AlexNet和LeNet，Inception块的组合从VGG继承，全局平均汇聚层避免了在最后使用全连接层。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typorainception-full.svg" alt="../_images/inception-full.svg"></p><p>现在，我们逐一实现GoogLeNet的每个模块。第一个模块使用64个通道、$7×7$卷积层。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b1 = nn.Sequential(nn.Conv2d(<span class="number">1</span>, <span class="number">64</span>, kernel_size=<span class="number">7</span>, stride=<span class="number">2</span>, padding=<span class="number">3</span>),</span><br><span class="line">                   nn.ReLU(),</span><br><span class="line">                   nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>第二个模块使用两个卷积层：第一个卷积层是64个通道、1×1卷积层；第二个卷积层使用将通道数量增加三倍的3×3卷积层。 这对应于Inception块中的第二条路径。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b2 = nn.Sequential(nn.Conv2d(<span class="number">64</span>, <span class="number">64</span>, kernel_size=<span class="number">1</span>),</span><br><span class="line">                   nn.ReLU(),</span><br><span class="line">                   nn.Conv2d(<span class="number">64</span>, <span class="number">192</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>),</span><br><span class="line">                   nn.ReLU(),</span><br><span class="line">                   nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>第三个模块串联两个完整的Inception块。 第一个Inception块的输出通道数为64+128+32+32=256，四个路径之间的输出通道数量比为64:128:32:32=2:4:1:1。 第二个和第三个路径首先将输入通道的数量分别减少到96/192=1/2和16/192=1/12，然后连接第二个卷积层。第二个Inception块的输出通道数增加到128+192+96+64=480，四个路径之间的输出通道数量比为128:192:96:64=4:6:3:2。 第二条和第三条路径首先将输入通道的数量分别减少到128/256=1/2和32/256=1/8。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b3 = nn.Sequential(Inception(<span class="number">192</span>, <span class="number">64</span>, (<span class="number">96</span>, <span class="number">128</span>), (<span class="number">16</span>, <span class="number">32</span>), <span class="number">32</span>),</span><br><span class="line">                   Inception(<span class="number">256</span>, <span class="number">128</span>, (<span class="number">128</span>, <span class="number">192</span>), (<span class="number">32</span>, <span class="number">96</span>), <span class="number">64</span>),</span><br><span class="line">                   nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>第四模块更加复杂， 它串联了5个Inception块，其输出通道数分别是192+208+48+64=512、160+224+64+64=512、128+256+64+64=512、112+288+64+64=528和256+320+128+128=832。 这些路径的通道数分配和第三模块中的类似，首先是含3×3卷积层的第二条路径输出最多通道，其次是仅含1×1卷积层的第一条路径，之后是含5×5卷积层的第三条路径和含3×3最大汇聚层的第四条路径。 其中第二、第三条路径都会先按比例减小通道数。 这些比例在各个Inception块中都略有不同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">b4 = nn.Sequential(Inception(<span class="number">480</span>, <span class="number">192</span>, (<span class="number">96</span>, <span class="number">208</span>), (<span class="number">16</span>, <span class="number">48</span>), <span class="number">64</span>),</span><br><span class="line">                   Inception(<span class="number">512</span>, <span class="number">160</span>, (<span class="number">112</span>, <span class="number">224</span>), (<span class="number">24</span>, <span class="number">64</span>), <span class="number">64</span>),</span><br><span class="line">                   Inception(<span class="number">512</span>, <span class="number">128</span>, (<span class="number">128</span>, <span class="number">256</span>), (<span class="number">24</span>, <span class="number">64</span>), <span class="number">64</span>),</span><br><span class="line">                   Inception(<span class="number">512</span>, <span class="number">112</span>, (<span class="number">144</span>, <span class="number">288</span>), (<span class="number">32</span>, <span class="number">64</span>), <span class="number">64</span>),</span><br><span class="line">                   Inception(<span class="number">528</span>, <span class="number">256</span>, (<span class="number">160</span>, <span class="number">320</span>), (<span class="number">32</span>, <span class="number">128</span>), <span class="number">128</span>),</span><br><span class="line">                   nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>第五模块包含输出通道数为256+320+128+128=832和384+384+128+128=1024的两个Inception块。 其中每条路径通道数的分配思路和第三、第四模块中的一致，只是在具体数值上有所不同。 需要注意的是，第五模块的后面紧跟输出层，该模块同NiN一样使用全局平均汇聚层，将每个通道的高和宽变成1。 最后我们将输出变成二维数组，再接上一个输出个数为标签类别数的全连接层。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">b5 = nn.Sequential(Inception(<span class="number">832</span>, <span class="number">256</span>, (<span class="number">160</span>, <span class="number">320</span>), (<span class="number">32</span>, <span class="number">128</span>), <span class="number">128</span>),</span><br><span class="line">                   Inception(<span class="number">832</span>, <span class="number">384</span>, (<span class="number">192</span>, <span class="number">384</span>), (<span class="number">48</span>, <span class="number">128</span>), <span class="number">128</span>),</span><br><span class="line">                   nn.AdaptiveAvgPool2d((<span class="number">1</span>,<span class="number">1</span>)),</span><br><span class="line">                   nn.Flatten())</span><br><span class="line"></span><br><span class="line">net = nn.Sequential(b1, b2, b3, b4, b5, nn.Linear(<span class="number">1024</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure><p>GoogLeNet模型的计算复杂，而且不如VGG那样便于修改通道数。 为了使Fashion-MNIST上的训练短小精悍，我们将输入的高和宽从224降到96，这简化了计算。下面演示各个模块输出的形状变化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X = torch.rand(size=(<span class="number">1</span>, <span class="number">1</span>, <span class="number">96</span>, <span class="number">96</span>))</span><br><span class="line"><span class="keyword">for</span> layer <span class="keyword">in</span> net:</span><br><span class="line">    X = layer(X)</span><br><span class="line">    <span class="built_in">print</span>(layer.__class__.__name__,<span class="string">&#x27;output shape:\t&#x27;</span>, X.shape)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Sequential output shape:     torch.Size([<span class="number">1</span>, <span class="number">64</span>, <span class="number">24</span>, <span class="number">24</span>])</span><br><span class="line">Sequential output shape:     torch.Size([<span class="number">1</span>, <span class="number">192</span>, <span class="number">12</span>, <span class="number">12</span>])</span><br><span class="line">Sequential output shape:     torch.Size([<span class="number">1</span>, <span class="number">480</span>, <span class="number">6</span>, <span class="number">6</span>])</span><br><span class="line">Sequential output shape:     torch.Size([<span class="number">1</span>, <span class="number">832</span>, <span class="number">3</span>, <span class="number">3</span>])</span><br><span class="line">Sequential output shape:     torch.Size([<span class="number">1</span>, <span class="number">1024</span>])</span><br><span class="line">Linear output shape:         torch.Size([<span class="number">1</span>, <span class="number">10</span>])</span><br></pre></td></tr></table></figure><hr><h3 id="训练-2"><a href="#训练-2" class="headerlink" title="训练"></a>训练</h3><p>在训练之前，我们将图片转换为96×96分辨率。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lr, num_epochs, batch_size = <span class="number">0.1</span>, <span class="number">10</span>, <span class="number">128</span></span><br><span class="line">train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size, resize=<span class="number">96</span>)</span><br><span class="line">d2l.train_ch6(net, train_iter, test_iter, num_epochs, lr, d2l.try_gpu())</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loss 0.243, train acc 0.908, test acc 0.888 2567.8 examples/sec on cuda:0</span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraoutput_googlenet_83a8b4_111_1.svg" alt="../_images/output_googlenet_83a8b4_111_1.svg"></p><ul><li>Inception块相当于一个有4条路径的子网络。它通过不同窗口形状的卷积层和最大汇聚层来并行抽取信息，并使用1×1卷积层减少每像素级别上的通道维数从而降低模型复杂度。</li><li>GoogLeNet将多个设计精细的Inception块与其他层（卷积层、全连接层）串联起来。其中Inception块的通道数分配之比是在ImageNet数据集上通过大量的实验得来的。</li><li>GoogLeNet和它的后继者们一度是ImageNet上最有效的模型之一：它以较低的计算复杂度提供了类似的测试精度。</li></ul><hr><h2 id="批量规范化"><a href="#批量规范化" class="headerlink" title="批量规范化"></a>批量规范化</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>训练深层神经网络是十分困难的，特别是在较短的时间内使他们收敛更加棘手。 本节将介绍<strong><em>批量规范化</em></strong>（batch normalization），这是一种流行且有效的技术，可持续加速深层网络的收敛速度</p><p>对于典型的多层感知机或卷积神经网络。当我们训练时，中间层中的变量（例如，多层感知机中的仿射变换输出）可能具有更广的变化范围：不论是沿着从输入到输出的层，跨同一层中的单元，或是随着时间的推移，模型参数的随着训练更新变幻莫测。 批量规范化的发明者非正式地假设，这些变量分布中的这种偏移可能会阻碍网络的收敛。 直观地说，我们可能会猜想，如果一个层的可变值是另一层的100倍，这可能需要对学习率进行补偿调整。</p><p>批量规范化应用于单个可选层（也可以应用到所有层），其原理如下：在每次训练迭代中，我们首先<strong>规范化输入</strong>，即通过减去其均值并除以其标准差，其中两者均基于当前小批量处理。 接下来，我们应用<strong>比例系数</strong>和<strong>比例偏移</strong>。 正是由于这个基于<strong><em>批量</em>统计</strong>的<em>标准化</em>，才有了<strong><em>批量规范化</em></strong>的名称。</p><p>从形式上来说，用$\mathbf{x} \in \mathcal{B}$表示一个来自小批量$\mathcal{B}$的输入，批量规范化$\mathrm{BN}$根据以下表达式转换$\mathbf{x}$：</p><script type="math/tex; mode=display">\mathrm{BN}(\mathbf{x}) = \boldsymbol{\gamma} \odot \frac{\mathbf{x} - \hat{\boldsymbol{\mu}}_\mathcal{B}}{\hat{\boldsymbol{\sigma}}_\mathcal{B}} + \boldsymbol{\beta}</script><p>$\hat{\boldsymbol{\mu}}_\mathcal{B}$是小批量$\mathcal{B}$的样本均值，$\hat{\boldsymbol{\sigma}}_\mathcal{B}$是小批量$\mathcal{B}$的样本标准差。</p><p>由于单位方差是一个主观的选择，因此我们通常包含<strong>拉伸参数</strong>$\boldsymbol{\gamma}$和<strong>偏移参数</strong>$\boldsymbol{\beta}$，它们的形状与$\mathbf{x}$相同。请注意，$\boldsymbol{\gamma}$和$\boldsymbol{\beta}$是需要与其他模型参数一起学习的参数。</p><p>由于在训练过程中，中间层的变化幅度不能过于剧烈，而批量规范化将每一层主动居中，并将它们重新调整为给定的平均值和大小</p><script type="math/tex; mode=display">\begin{aligned} \hat{\boldsymbol{\mu}}_\mathcal{B} &= \frac{1}{|\mathcal{B}|} \sum_{\mathbf{x} \in \mathcal{B}} \mathbf{x}\\\hat{\boldsymbol{\sigma}}_\mathcal{B}^2 &= \frac{1}{|\mathcal{B}|} \sum_{\mathbf{x} \in \mathcal{B}} (\mathbf{x} - \hat{\boldsymbol{\mu}}_{\mathcal{B}})^2 + \epsilon.\end{aligned}</script><p>请注意，我们在方差估计值中添加一个小的常量$\epsilon &gt; 0$，以确保我们永远不会尝试除以零，即使在经验方差估计值可能消失的情况下也是如此。估计值$\hat{\boldsymbol{\mu}}_\mathcal{B}$<strong>和</strong>${\hat{\boldsymbol{\sigma}}_\mathcal{B}}$通过使用平均值和方差的噪声（noise）估计来抵消缩放问题。</p><hr><h3 id="批量规范化层"><a href="#批量规范化层" class="headerlink" title="批量规范化层"></a>批量规范化层</h3><p><strong>全连接层的规范化</strong></p><p>通常，我们将批量规范化层置于全连接层中的仿射变换和激活函数之间。设全连接层的输入为$x$，权重参数和偏置参数分别为$\mathbf{W}$和$\mathbf{b}$，激活函数为$\phi$，批量规范化的运算符为$\mathrm{BN}$。</p><p>那么，使用批量规范化的全连接层的输出的计算详情如下：</p><script type="math/tex; mode=display">\mathbf{h} = \phi(\mathrm{BN}(\mathbf{W}\mathbf{x} + \mathbf{b}) )</script><p>回想一下，均值和方差是在应用变换的”相同”小批量上计算的。</p><p><strong>卷积层的规范化</strong></p><p>同样，对于卷积层，我们可以在卷积层之后和非线性激活函数之前应用批量规范化。当卷积有多个输出通道时，我们需要对这些通道的“每个”输出执行批量规范化，每个通道都有自己的<strong>拉伸和偏移参数</strong>，这两个参数都是标量。</p><p>假设我们的小批量包含$m$个样本，并且对于每个通道，卷积的输出具有高度$p$和宽度$q$。那么对于卷积层，我们在每个输出通道的$m \cdot p \cdot q$个元素上同时执行每个批量规范化。因此，在计算平均值和方差时，我们会收集所有空间位置的值，然后在给定通道内应用相同的均值和方差，以便在每个空间位置对值进行规范化。</p><hr><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>根据pytorch的模式进行划分：</p><ol><li><strong>训练模式（Training Mode）</strong>：<ul><li>在训练模式下，所有的层都在正常状态下工作，即按照定义执行前向和后向传播。</li><li>对于某些层，比如Dropout和BatchNorm，它们在训练时的行为与预测时不同。例如，Dropout层会随机丢弃一些神经元，以防止过拟合；BatchNorm层会使用当前批次的均值和方差进行归一化，并更新移动平均的均值和方差。</li><li>在PyTorch中，可以使用 <code>model.train()</code> 将模型设置为训练模式。</li></ul></li><li><strong>评估（预测）模式</strong>：<ul><li>在评估模式下，模型的行为会有所不同，以适应评估或预测的需求。</li><li>对于BatchNorm和Dropout层，它们在评估模式下的行为会发生改变。Dropout层会停止工作，即不再丢弃任何神经元；BatchNorm层会停止更新移动平均的均值和方差，而是使用之前训练阶段累积的均值和方差。</li><li>在PyTorch中，可以使用 <code>model.eval()</code> 将模型设置为评估模式。</li></ul></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">batch_norm</span>(<span class="params">X, gamma, beta, moving_mean, moving_var, eps, momentum</span>):</span></span><br><span class="line">    <span class="comment"># 定义批量归一化操作的函数。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 通过is_grad_enabled来判断当前模式是训练模式还是预测模式</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> torch.is_grad_enabled():</span><br><span class="line">        <span class="comment"># 如果是在预测模式下，直接使用传入的移动平均所得的均值和方差进行归一化</span></span><br><span class="line">        X_hat = (X - moving_mean) / torch.sqrt(moving_var + eps)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 在训练模式下，需要根据当前批次的数据来计算均值和方差</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(X.shape) <span class="keyword">in</span> (<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">        <span class="comment"># 确保输入X是二维（全连接层）或四维（卷积层）的张量。</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(X.shape) == <span class="number">2</span>:</span><br><span class="line">            <span class="comment"># 对于全连接层的情况，按照特征维（每一列）计算均值和方差</span></span><br><span class="line">            mean = X.mean(dim=<span class="number">0</span>)</span><br><span class="line">            var = ((X - mean) ** <span class="number">2</span>).mean(dim=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 对于二维卷积层的情况，按照通道维（第一个维度，即C）计算均值和方差，</span></span><br><span class="line">            <span class="comment"># 并保持维度不变，以便进行后续的广播运算。</span></span><br><span class="line">            mean = X.mean(dim=(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>), keepdim=<span class="literal">True</span>)</span><br><span class="line">            var = ((X - mean) ** <span class="number">2</span>).mean(dim=(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>), keepdim=<span class="literal">True</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 用当前批次的均值和方差对输入进行标准化</span></span><br><span class="line">        X_hat = (X - mean) / torch.sqrt(var + eps)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 更新移动平均的均值和方差，用于预测模式</span></span><br><span class="line">        moving_mean = momentum * moving_mean + (<span class="number">1.0</span> - momentum) * mean</span><br><span class="line">        moving_var = momentum * moving_var + (<span class="number">1.0</span> - momentum) * var</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将归一化后的数据进行缩放和平移变换</span></span><br><span class="line">    Y = gamma * X_hat + beta</span><br><span class="line">    <span class="keyword">return</span> Y, moving_mean.data, moving_var.data</span><br><span class="line">    <span class="comment"># 返回批量归一化后的结果，以及更新后的移动平均均值和方差。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们现在可以创建一个正确的<code>BatchNorm</code>层。 这个层将保持适当的参数：拉伸<code>gamma</code>和偏移<code>beta</code>,这两个参数将在训练过程中更新。 此外，我们的层将保存均值和方差的移动平均值，以便在模型预测期间随后使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BatchNorm</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="comment"># num_features：完全连接层的输出数量或卷积层的输出通道数。</span></span><br><span class="line">    <span class="comment"># num_dims：2表示完全连接层，4表示卷积层</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, num_features, num_dims</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()  <span class="comment"># 调用父类nn.Module的构造函数。</span></span><br><span class="line">        <span class="keyword">if</span> num_dims == <span class="number">2</span>:</span><br><span class="line">            shape = (<span class="number">1</span>, num_features)  <span class="comment"># 对于全连接层，形状是(1, num_features)。</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            shape = (<span class="number">1</span>, num_features, <span class="number">1</span>, <span class="number">1</span>)  <span class="comment"># 对于卷积层，形状是(1, num_features, 1, 1)。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 参与求梯度和迭代的拉伸（gamma）和偏移（beta）参数，分别初始化成1和0。</span></span><br><span class="line">        self.gamma = nn.Parameter(torch.ones(shape))</span><br><span class="line">        self.beta = nn.Parameter(torch.zeros(shape))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 非模型参数的变量初始化为0和1。这些是用于在训练过程中计算移动平均的变量，不直接参与梯度计算。</span></span><br><span class="line">        self.moving_mean = torch.zeros(shape)</span><br><span class="line">        self.moving_var = torch.ones(shape)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, X</span>):</span></span><br><span class="line">        <span class="comment"># 定义前向传播过程。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果X不在内存上，将moving_mean和moving_var复制到X所在显存上。</span></span><br><span class="line">        <span class="comment"># 这是为了支持模型在不同的设备上运行，比如CPU和GPU。</span></span><br><span class="line">        <span class="keyword">if</span> self.moving_mean.device != X.device:</span><br><span class="line">            self.moving_mean = self.moving_mean.to(X.device)</span><br><span class="line">            self.moving_var = self.moving_var.to(X.device)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 调用batch_norm函数进行批量归一化处理，返回归一化后的数据Y，</span></span><br><span class="line">        <span class="comment"># 以及更新过的移动平均的均值和方差。</span></span><br><span class="line">        Y, self.moving_mean, self.moving_var = batch_norm(</span><br><span class="line">            X, self.gamma, self.beta, self.moving_mean,</span><br><span class="line">            self.moving_var, eps=<span class="number">1e-5</span>, momentum=<span class="number">0.9</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Y</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通常情况下，我们用一个单独的函数定义其数学原理，比如说<code>batch_norm</code>。 然后，我们将此功能集成到一个自定义层中，其代码主要处理数据移动到训练设备（如GPU）、分配和初始化任何必需的变量、跟踪移动平均线（此处为均值和方差）等问题</p><hr><h3 id="应用到LeNet网络"><a href="#应用到LeNet网络" class="headerlink" title="应用到LeNet网络"></a>应用到LeNet网络</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">net = nn.Sequential(</span><br><span class="line">    nn.Conv2d(<span class="number">1</span>, <span class="number">6</span>, kernel_size=<span class="number">5</span>), BatchNorm(<span class="number">6</span>, num_dims=<span class="number">4</span>), nn.Sigmoid(),</span><br><span class="line">    nn.AvgPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>),</span><br><span class="line">    nn.Conv2d(<span class="number">6</span>, <span class="number">16</span>, kernel_size=<span class="number">5</span>), BatchNorm(<span class="number">16</span>, num_dims=<span class="number">4</span>), nn.Sigmoid(),</span><br><span class="line">    nn.AvgPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>), nn.Flatten(),</span><br><span class="line">    nn.Linear(<span class="number">16</span>*<span class="number">4</span>*<span class="number">4</span>, <span class="number">120</span>), BatchNorm(<span class="number">120</span>, num_dims=<span class="number">2</span>), nn.Sigmoid(),</span><br><span class="line">    nn.Linear(<span class="number">120</span>, <span class="number">84</span>), BatchNorm(<span class="number">84</span>, num_dims=<span class="number">2</span>), nn.Sigmoid(),</span><br><span class="line">    nn.Linear(<span class="number">84</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure><p>和以前一样，我们将在Fashion-MNIST数据集上训练网络。 这个代码与我们第一次训练LeNet时几乎完全相同，主要区别在于学习率大得多。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lr, num_epochs, batch_size = <span class="number">1.0</span>, <span class="number">10</span>, <span class="number">256</span></span><br><span class="line">train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size)</span><br><span class="line">d2l.train_ch6(net, train_iter, test_iter, num_epochs, lr, d2l.try_gpu())</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">loss <span class="number">0.273</span>, train acc <span class="number">0.899</span>, test acc <span class="number">0.807</span></span><br><span class="line"><span class="number">32293.9</span> examples/sec on cuda:<span class="number">0</span></span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraoutput_batch-norm_cf033c_51_1.svg" alt="../_images/output_batch-norm_cf033c_51_1.svg"></p><p>让我们来看看从第一个批量规范化层中学到的拉伸参数<code>gamma</code>和偏移参数<code>beta</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(tensor([<span class="number">0.4863</span>, <span class="number">2.8573</span>, <span class="number">2.3190</span>, <span class="number">4.3188</span>, <span class="number">3.8588</span>, <span class="number">1.7942</span>], device=<span class="string">&#x27;cuda:0&#x27;</span>,</span><br><span class="line">        grad_fn=&lt;ReshapeAliasBackward0&gt;),</span><br><span class="line"> tensor([-<span class="number">0.0124</span>,  <span class="number">1.4839</span>, -<span class="number">1.7753</span>,  <span class="number">2.3564</span>, -<span class="number">3.8801</span>, -<span class="number">2.1589</span>], device=<span class="string">&#x27;cuda:0&#x27;</span>,</span><br><span class="line">        grad_fn=&lt;ReshapeAliasBackward0&gt;))</span><br></pre></td></tr></table></figure><hr><h2 id="残差网络-ResNet"><a href="#残差网络-ResNet" class="headerlink" title="残差网络(ResNet)"></a>残差网络(ResNet)</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>首先，假设有一类特定的神经网络架构$\mathcal{F}$，它包括学习速率和其他超参数设置。对于所有$f \in \mathcal{F}$，存在一些参数集（例如权重和偏置），这些参数可以通过在合适的数据集上进行训练而获得。</p><p>现在假设$f^<em>$是我们真正想要找到的函数，如果是$f^</em> \in\mathcal{F}$*，那我们可以轻而易举的训练得到它，但通常我们不会那么幸运。</p><p>相反，我们将尝试找到一个函数$f^*_{\mathcal{F}}$，这是我们在$\mathcal{F}$中的最佳选择。例如，给定一个具有$\mathbf{X}$特性和$\mathbf{y}$标签的数据集，我们可以尝试通过解决以下优化问题来找到它：</p><script type="math/tex; mode=display">f^*_\mathcal{F} := \mathop{\mathrm{argmin}}_f L(\mathbf{X}, \mathbf{y}, f) \text{ subject to } f \in \mathcal{F}</script><p>那么，怎样得到更近似真正$f^*$的函数呢？</p><p>唯一合理的可能性是，我们需要设计一个更强大的架构$\mathcal{F}’$。换句话说，我们预计$f^<em>_{\mathcal{F}’}$比$f^</em>_{\mathcal{F}}$“更近似”。然而，如果$\mathcal{F} \not\subseteq \mathcal{F}’$，则无法保证新的体系“更近似”。</p><p>事实上，$f^*_{\mathcal{F}’}$可能更糟：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typorafunctionclasses.svg" alt="../_images/functionclasses.svg"></p><p>因此，只有当较复杂的函数类包含较小的函数类时，我们才能确保提高它们的性能。</p><p>对于深度神经网络，如果我们能将新添加的层训练成<strong>恒等映射</strong>（identity function）$f(\mathbf{x}) = \mathbf{x}$，新模型和原模型将同样有效。同时，由于新模型可能得出更优的解来拟合训练数据集，因此添加层似乎更容易降低训练误差。</p><p>残差网络的核心思想是：<strong>每个附加层都应该更容易地包含原始函数作为其元素之一</strong>。于是，<strong>残差块</strong>（residual blocks）便诞生了，这个设计对如何建立深层神经网络产生了深远的影响。</p><hr><h3 id="残差块"><a href="#残差块" class="headerlink" title="残差块"></a>残差块</h3><p>让我们聚焦于神经网络局部：如图所示，假设我们的原始输入为$x$，而希望学出的理想映射为$f(\mathbf{x})$（作为上方激活函数的输入）。</p><p>左图虚线框中的部分需要直接拟合出该映射$f(\mathbf{x})$，而右图虚线框中的部分则需要拟合出残差映射$f(\mathbf{x}) - \mathbf{x}$。残差映射在现实中往往更容易优化。</p><p>以本节开头提到的恒等映射作为我们希望学出的理想映射$f(\mathbf{x})$，我们只需将右图虚线框内上方的加权运算（如仿射）的权重和偏置参数设成0，那么$f(\mathbf{x})$即为恒等映射。</p><p>实际中，当理想映射$f(\mathbf{x})$极接近于恒等映射时，残差映射也易于捕捉恒等映射的细微波动。在残差块中，输入可通过跨层数据线路更快地向前传播。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraresidual-block.svg" alt="../_images/residual-block.svg"></p><p>ResNet沿用了VGG完整的$3×3$卷积层设计。 残差块里首先有2个有相同输出通道数的$3×3$卷积层。 每个卷积层后接一个批量规范化层和ReLU激活函数。 然后我们通过跨层数据通路，跳过这2个卷积运算，将输入直接加在最后的ReLU激活函数前。 这样的设计要求2个卷积层的输出与输入形状一样，从而使它们可以相加。 如果想改变通道数，就需要引入一个额外的1×1卷积层来将输入变换成需要的形状后再做相加运算。 残差块的实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Residual</span>(<span class="params">nn.Module</span>):</span>  <span class="comment"># 继承自nn.Module，表示自定义的模块</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, input_channels, num_channels,</span></span></span><br><span class="line"><span class="params"><span class="function">                 use_1x1conv=<span class="literal">False</span>, strides=<span class="number">1</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()  <span class="comment"># 调用父类的构造函数</span></span><br><span class="line">        <span class="comment"># 第一个卷积层，使用3x3卷积核，保持输出尺寸不变，步长由strides参数控制。</span></span><br><span class="line">        self.conv1 = nn.Conv2d(input_channels, num_channels,</span><br><span class="line">                               kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>, stride=strides)</span><br><span class="line">        <span class="comment"># 第二个卷积层，使用3x3卷积核，保持输出尺寸不变。</span></span><br><span class="line">        self.conv2 = nn.Conv2d(num_channels, num_channels,</span><br><span class="line">                               kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 可选的第三个卷积层，使用1x1卷积核调整输入的通道数，仅当use_1x1conv=True时使用。</span></span><br><span class="line">        <span class="keyword">if</span> use_1x1conv:</span><br><span class="line">            self.conv3 = nn.Conv2d(input_channels, num_channels,</span><br><span class="line">                                   kernel_size=<span class="number">1</span>, stride=strides)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.conv3 = <span class="literal">None</span>  <span class="comment"># 如果不需要调整通道数，则不使用这个层</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 两个批量归一化层，分别应用于conv1和conv2的输出上。</span></span><br><span class="line">        self.bn1 = nn.BatchNorm2d(num_channels)</span><br><span class="line">        self.bn2 = nn.BatchNorm2d(num_channels)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, X</span>):</span></span><br><span class="line">        <span class="comment"># 通过第一个卷积层后，应用批量归一化和ReLU激活函数。</span></span><br><span class="line">        Y = F.relu(self.bn1(self.conv1(X)))</span><br><span class="line">        <span class="comment"># 通过第二个卷积层后，应用批量归一化，注意这里没有立即应用ReLU。</span></span><br><span class="line">        Y = self.bn2(self.conv2(Y))</span><br><span class="line">        <span class="comment"># 如果存在第三个卷积层（conv3），则通过它调整输入X的维度。</span></span><br><span class="line">        <span class="keyword">if</span> self.conv3:</span><br><span class="line">            X = self.conv3(X)</span><br><span class="line">        <span class="comment"># 将调整后的输入X加到第二个卷积层的输出上，实现跳跃连接。</span></span><br><span class="line">        Y += X</span><br><span class="line">        <span class="comment"># 最后，应用ReLU激活函数并返回结果。</span></span><br><span class="line">        <span class="keyword">return</span> F.relu(Y)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此代码生成两种类型的网络： 一种是当<code>use_1x1conv=False</code>时，应用ReLU非线性函数之前，将输入添加到输出。 另一种是当<code>use_1x1conv=True</code>时，添加通过1×1卷积调整通道和分辨率。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraresnet-block.svg" alt="../_images/resnet-block.svg"></p><hr><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>ResNet的前两层跟之前介绍的GoogLeNet中的一样： 在输出通道数为64、步幅为2的7×7卷积层后，接步幅为2的3×3的最大汇聚层。 不同之处在于ResNet每个卷积层后增加了批量规范化层。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b1 = nn.Sequential(nn.Conv2d(<span class="number">1</span>, <span class="number">64</span>, kernel_size=<span class="number">7</span>, stride=<span class="number">2</span>, padding=<span class="number">3</span>),</span><br><span class="line">                   nn.BatchNorm2d(<span class="number">64</span>), nn.ReLU(),</span><br><span class="line">                   nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>GoogLeNet在后面接了4个由Inception块组成的模块。 ResNet则使用4个由残差块组成的模块，每个模块使用若干个同样输出通道数的残差块。 第一个模块的通道数同输入通道数一致。 由于之前已经使用了步幅为2的最大汇聚层，所以无须减小高和宽。 之后的每个模块在第一个残差块里将上一个模块的通道数翻倍，并将高和宽减半。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resnet_block</span>(<span class="params">input_channels, num_channels, num_residuals, first_block=<span class="literal">False</span></span>):</span></span><br><span class="line">    blk = []  <span class="comment"># 初始化一个空列表，用于存放残差块</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_residuals):  <span class="comment"># 遍历，创建指定数量的残差块</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> first_block:</span><br><span class="line">            <span class="comment"># 对于非第一个ResNet块的第一个残差块，使用步长为2的1x1卷积，</span></span><br><span class="line">            <span class="comment"># 这是为了减半高度和宽度，同时增加通道数。</span></span><br><span class="line">            <span class="comment"># 这个操作通常用于ResNet中的过渡层，以逐渐减小特征图的空间维度，</span></span><br><span class="line">            <span class="comment"># 同时增加通道维度，使网络能够学习更高层次的特征表示。</span></span><br><span class="line">            blk.append(Residual(input_channels, num_channels,</span><br><span class="line">                                use_1x1conv=<span class="literal">True</span>, strides=<span class="number">2</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 对于块中的其他残差块，或者是第一个ResNet块的残差块，</span></span><br><span class="line">            <span class="comment"># 使用标准的残差块结构，不改变特征图的大小，也不使用1x1卷积调整通道数。</span></span><br><span class="line">            blk.append(Residual(num_channels, num_channels))</span><br><span class="line">    <span class="keyword">return</span> blk  <span class="comment"># 返回包含所有残差块的列表</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接着在ResNet加入所有残差块，这里每个模块使用2个残差块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b2 = nn.Sequential(*resnet_block(<span class="number">64</span>, <span class="number">64</span>, <span class="number">2</span>, first_block=<span class="literal">True</span>))</span><br><span class="line">b3 = nn.Sequential(*resnet_block(<span class="number">64</span>, <span class="number">128</span>, <span class="number">2</span>))</span><br><span class="line">b4 = nn.Sequential(*resnet_block(<span class="number">128</span>, <span class="number">256</span>, <span class="number">2</span>))</span><br><span class="line">b5 = nn.Sequential(*resnet_block(<span class="number">256</span>, <span class="number">512</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>最后，与GoogLeNet一样，在ResNet中加入全局平均汇聚层，以及全连接层输出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net = nn.Sequential(b1, b2, b3, b4, b5,</span><br><span class="line">                    nn.AdaptiveAvgPool2d((1,1)),</span><br><span class="line">                    nn.Flatten(), nn.Linear(512, 10))</span><br></pre></td></tr></table></figure><p>每个模块有4个卷积层（不包括恒等映射的1×1卷积层）。 加上第一个7×7卷积层和最后一个全连接层，共有18层。 因此，这种模型通常被称为ResNet-18。 通过配置不同的通道数和模块里的残差块数可以得到不同的ResNet模型，例如更深的含152层的ResNet-152。 虽然ResNet的主体架构跟GoogLeNet类似，但ResNet架构更简单，修改也更方便。这些因素都导致了ResNet迅速被广泛使用</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraresnet18.svg" alt="../_images/resnet18.svg"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X = torch.rand(size=(<span class="number">1</span>, <span class="number">1</span>, <span class="number">224</span>, <span class="number">224</span>))</span><br><span class="line"><span class="keyword">for</span> layer <span class="keyword">in</span> net:</span><br><span class="line">    X = layer(X)</span><br><span class="line">    <span class="built_in">print</span>(layer.__class__.__name__,<span class="string">&#x27;output shape:\t&#x27;</span>, X.shape)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Sequential output shape:     torch.Size([1, 64, 56, 56])</span><br><span class="line">Sequential output shape:     torch.Size([1, 64, 56, 56])</span><br><span class="line">Sequential output shape:     torch.Size([1, 128, 28, 28])</span><br><span class="line">Sequential output shape:     torch.Size([1, 256, 14, 14])</span><br><span class="line">Sequential output shape:     torch.Size([1, 512, 7, 7])</span><br><span class="line">AdaptiveAvgPool2d output shape:      torch.Size([1, 512, 1, 1])</span><br><span class="line">Flatten output shape:        torch.Size([1, 512])</span><br><span class="line">Linear output shape:         torch.Size([1, 10])</span><br></pre></td></tr></table></figure><hr><h3 id="训练-3"><a href="#训练-3" class="headerlink" title="训练"></a>训练</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lr, num_epochs, batch_size = <span class="number">0.05</span>, <span class="number">10</span>, <span class="number">256</span></span><br><span class="line">train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size, resize=<span class="number">96</span>)</span><br><span class="line">d2l.train_ch6(net, train_iter, test_iter, num_epochs, lr, d2l.try_gpu())</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">loss 0.014, train acc 0.996, test acc 0.915</span><br><span class="line">3856.5 examples/sec on cuda:0</span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraoutput_resnet_46beba_126_1.svg" alt="../_images/output_resnet_46beba_126_1.svg"></p><ul><li>学习嵌套函数（nested function）是训练神经网络的理想情况。在深层神经网络中，学习另一层作为恒等映射（identity function）较容易（尽管这是一个极端情况）。</li><li>残差映射可以更容易地学习同一函数，例如将权重层中的参数近似为零。</li><li>利用残差块（residual blocks）可以训练出一个有效的深层神经网络：输入可以通过层间的残余连接更快地向前传播。</li></ul><hr><h2 id="稠密连接网络-DenseNet"><a href="#稠密连接网络-DenseNet" class="headerlink" title="稠密连接网络(DenseNet)"></a>稠密连接网络(DenseNet)</h2><p>ResNet极大地改变了如何参数化深层网络中函数的观点。 <strong><em>稠密连接网络</em></strong>（DenseNet） 在某种程度上是ResNet的逻辑扩展。</p><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>回想一下任意函数的泰勒展开式（Taylor expansion），它把这个函数分解成越来越高阶的项。在$x$接近0时，</p><script type="math/tex; mode=display">f(x) = f(0) + f'(0) x + \frac{f''(0)}{2!}  x^2 + \frac{f'''(0)}{3!}  x^3 + \ldots</script><p>同样，ResNet将函数展开为</p><script type="math/tex; mode=display">f(\mathbf{x}) = \mathbf{x} + g(\mathbf{x})</script><p>也就是说，ResNet将$f$分解为两部分：一个简单的线性项和一个复杂的非线性项。 那么再向前拓展一步，</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoradensenet-block.svg" alt="../_images/densenet-block.svg"></p><p>ResNet和DenseNet的关键区别在于，DenseNet输出是<strong><em>连接</em></strong>（用图中的[,]表示）而不是如ResNet的简单相加。 因此，在应用越来越复杂的函数序列后，我们执行从$x$到其展开式的映射：</p><script type="math/tex; mode=display">\mathbf{x} \to \left[\mathbf{x},f_1(\mathbf{x}),f_2([\mathbf{x}, f_1(\mathbf{x})]), f_3([\mathbf{x}, f_1(\mathbf{x}), f_2([\mathbf{x}, f_1(\mathbf{x})])]), \ldots\right]</script><p>最后，将这些展开式结合到多层感知机中，再次减少特征的数量。 实现起来非常简单：我们不需要添加术语，而是将它们连接起来。 DenseNet这个名字由变量之间的“稠密连接”而得来，最后一层与之前的所有层紧密相连。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoradensenet.svg" alt="../_images/densenet.svg"></p><p>稠密网络主要由2部分构成：<em>稠密块</em>（dense block）和<em>过渡层</em>（transition layer）。 前者定义如何连接输入和输出，而后者则控制通道数量，使其不会太复杂。</p><hr><h3 id="稠密块体"><a href="#稠密块体" class="headerlink" title="稠密块体"></a>稠密块体</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv_block</span>(<span class="params">input_channels, num_channels</span>):</span></span><br><span class="line">    <span class="keyword">return</span> nn.Sequential(</span><br><span class="line">        nn.BatchNorm2d(input_channels), nn.ReLU(),</span><br><span class="line">        nn.Conv2d(input_channels, num_channels, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>一个<strong><em>稠密块</em></strong>由多个卷积块组成，每个卷积块使用相同数量的输出通道。 然而，在前向传播中，我们将每个卷积块的输入和输出在通道维上<strong>连结</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DenseBlock</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, num_convs, input_channels, num_channels</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(DenseBlock, self).__init__()</span><br><span class="line">        layer = []  <span class="comment"># 初始化一个空列表，用来存储卷积块</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_convs):</span><br><span class="line">            <span class="comment"># 对于每一个卷积层，输入通道数是前面所有层的输出通道数之和加上原始输入通道数</span></span><br><span class="line">            <span class="comment"># 这是因为DenseBlock中的特点是将每一层的输出与原始输入在通道维度上进行拼接</span></span><br><span class="line">            layer.append(conv_block(</span><br><span class="line">                num_channels * i + input_channels, num_channels))</span><br><span class="line">            <span class="comment"># 这里的conv_block是一个卷积块，它接受当前的输入通道数和输出通道数为参数</span></span><br><span class="line">            <span class="comment"># 注意，这里假设conv_block已经在其他地方定义</span></span><br><span class="line">        self.net = nn.Sequential(*layer)  <span class="comment"># 使用nn.Sequential将所有卷积块组合成一个顺序模型</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, X</span>):</span></span><br><span class="line">        <span class="keyword">for</span> blk <span class="keyword">in</span> self.net:</span><br><span class="line">            Y = blk(X)  <span class="comment"># 获取当前块的输出</span></span><br><span class="line">            <span class="comment"># 在通道维度(dim=1)上将当前块的输出Y与原始输入X拼接</span></span><br><span class="line">            <span class="comment"># 这样做的目的是为了实现特征重用，并增加网络的深度而不会导致梯度消失或爆炸</span></span><br><span class="line">            X = torch.cat((X, Y), dim=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> X  <span class="comment"># 返回最终的输出</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><strong>初始输入 <code>X</code> 的形状</strong>：<code>(4, 3, 8, 8)</code> 表示批量大小为4，通道数为3，高度和宽度都是8。</li><li><strong>通过 <code>DenseBlock</code> 后的变化</strong>：<ul><li><code>DenseBlock</code> 中有2个卷积层，每个卷积层输出的通道数为10。</li><li>在 <code>DenseBlock</code> 中，每个卷积层的输出都会与它的输入在通道维度上进行拼接，因此输出通道数会逐层累加。</li></ul></li><li><strong>输出 <code>Y</code> 的形状计算</strong>：<ul><li>第一个卷积层接收3个通道的输入，输出10个通道，然后将这10个通道与原始的3个通道拼接，得到13个通道。</li><li>第二个卷积层接收13个通道的输入（因为它接收了第一个卷积层的输出和原始输入的拼接），输出10个通道，然后将这10个通道与前面的13个通道拼接，得到23个通道。</li><li>因此，最终输出 <code>Y</code> 的形状为 <code>(4, 23, 8, 8)</code>，批量大小保持不变，高度和宽度由于卷积层使用了padding=1（假设conv_block内部这样设置），也保持不变，通道数增加到了23。</li></ul></li></ol><p>卷积块的通道数控制了输出通道数相对于输入通道数的增长，因此也被称为<strong><em>增长率</em></strong>（growth rate）。</p><hr><h3 id="过渡层"><a href="#过渡层" class="headerlink" title="过渡层"></a>过渡层</h3><p>由于每个稠密块都会带来通道数的增加，使用过多则会过于复杂化模型。 而过渡层可以用来控制模型复杂度。 它通过1×1卷积层来减小通道数，并使用步幅为2的平均汇聚层减半高和宽，从而进一步降低模型复杂度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transition_block</span>(<span class="params">input_channels, num_channels</span>):</span></span><br><span class="line">    <span class="keyword">return</span> nn.Sequential(</span><br><span class="line">        nn.BatchNorm2d(input_channels), nn.ReLU(),</span><br><span class="line">        nn.Conv2d(input_channels, num_channels, kernel_size=<span class="number">1</span>),</span><br><span class="line">        nn.AvgPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>对上一个例子中稠密块的输出使用通道数为10的过渡层。 此时输出的通道数减为10，高和宽均减半。</p><hr><h3 id="模型-1"><a href="#模型-1" class="headerlink" title="模型"></a>模型</h3><p>DenseNet首先使用同ResNet一样的单卷积层和最大汇聚层。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b1 = nn.Sequential(</span><br><span class="line">    nn.Conv2d(<span class="number">1</span>, <span class="number">64</span>, kernel_size=<span class="number">7</span>, stride=<span class="number">2</span>, padding=<span class="number">3</span>),</span><br><span class="line">    nn.BatchNorm2d(<span class="number">64</span>), nn.ReLU(),</span><br><span class="line">    nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>接下来，类似于ResNet使用的4个残差块，DenseNet使用的是4个稠密块。 与ResNet类似，我们可以设置每个稠密块使用多少个卷积层。 这里我们设成4，稠密块里的卷积层通道数（即增长率）设为32，所以每个稠密块将增加128个通道。</p><p>在每个模块之间，ResNet通过步幅为2的残差块减小高和宽，DenseNet则使用过渡层来减半高和宽，并减半通道数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始通道数和每个DenseBlock的增长率（每个卷积层增加的通道数）</span></span><br><span class="line">num_channels, growth_rate = <span class="number">64</span>, <span class="number">32</span></span><br><span class="line"><span class="comment"># 每个DenseBlock中包含的卷积层数量</span></span><br><span class="line">num_convs_in_dense_blocks = [<span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">blks = []  <span class="comment"># 初始化一个空列表，用于存储DenseBlock和转换层</span></span><br><span class="line"><span class="keyword">for</span> i, num_convs <span class="keyword">in</span> <span class="built_in">enumerate</span>(num_convs_in_dense_blocks):</span><br><span class="line">    <span class="comment"># 为每个num_convs添加一个DenseBlock到blks列表中</span></span><br><span class="line">    <span class="comment"># DenseBlock的输入通道数为num_channels，每个卷积层增加的通道数为growth_rate</span></span><br><span class="line">    blks.append(DenseBlock(num_convs, num_channels, growth_rate))</span><br><span class="line">    <span class="comment"># 更新num_channels为DenseBlock之后的输出通道数</span></span><br><span class="line">    num_channels += num_convs * growth_rate</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 除了最后一个DenseBlock外，在每个DenseBlock之后添加一个转换层</span></span><br><span class="line">    <span class="comment"># 转换层的作用是减半通道数，从而控制模型大小和计算量</span></span><br><span class="line">    <span class="keyword">if</span> i != <span class="built_in">len</span>(num_convs_in_dense_blocks) - <span class="number">1</span>:</span><br><span class="line">        blks.append(transition_block(num_channels, num_channels // <span class="number">2</span>))</span><br><span class="line">        <span class="comment"># 更新num_channels为转换层之后的输出通道数，即减半</span></span><br><span class="line">        num_channels = num_channels // <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>与ResNet类似，最后接上全局汇聚层和全连接层来输出结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">net = nn.Sequential(</span><br><span class="line">    b1, *blks,</span><br><span class="line">    nn.BatchNorm2d(num_channels), nn.ReLU(),</span><br><span class="line">    nn.AdaptiveAvgPool2d((<span class="number">1</span>, <span class="number">1</span>)),</span><br><span class="line">    nn.Flatten(),</span><br><span class="line">    nn.Linear(num_channels, <span class="number">10</span>))</span><br></pre></td></tr></table></figure><hr><h3 id="训练-4"><a href="#训练-4" class="headerlink" title="训练"></a>训练</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lr, num_epochs, batch_size = <span class="number">0.1</span>, <span class="number">10</span>, <span class="number">256</span></span><br><span class="line">train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size, resize=<span class="number">96</span>)</span><br><span class="line">d2l.train_ch6(net, train_iter, test_iter, num_epochs, lr, d2l.try_gpu())</span><br><span class="line"></span><br><span class="line"><span class="comment">#loss 0.140, train acc 0.948, test acc 0.881 3685.0 examples/sec on cuda:0</span></span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraoutput_densenet_e82156_126_1.svg" alt="../_images/output_densenet_e82156_126_1.svg"></p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="table-container"><table><thead><tr><th>架构</th><th>发布年份</th><th>特点</th></tr></thead><tbody><tr><td>AlexNet</td><td>2012</td><td>- 使用ReLU激活函数<br>- 局部响应归一化（LRN）<br>- 丢弃法（Dropout）<br>- 多GPU训练</td></tr><tr><td>VGG</td><td>2014</td><td>- 重复使用小卷积核（3x3）<br>- 堆叠卷积层以增加深度</td></tr><tr><td>NIN</td><td>2013</td><td>- 引入“网络中的网络”（mlpconv层）<br>- 1x1卷积核用于替代全连接层<br>- 强调了卷积层中的感受野对性能的影响</td></tr><tr><td>GoogLeNet (Inception)</td><td>2014</td><td>- 引入Inception模块，实现多尺度处理<br>- 使用1x1卷积核进行降维<br>- 辅助分类器减轻梯度消失问题<br>- 不使用全连接层，减少参数</td></tr><tr><td>ResNet</td><td>2015</td><td>- 引入残差学习单元，简化了深度网络的训练<br>- 支持构建极深的网络结构<br>- 恒等映射通过跳跃连接实现</td></tr><tr><td>DenseNet</td><td>2017</td><td>- 每层与前面所有层连接<br>- 极大地增强了特征的传递和复用<br>- 有效减少了参数数量<br>- 通过特征拼接而不是相加，保留了特征信息</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.0 卷积神经网络</title>
      <link href="/post/4590.html"/>
      <url>/post/4590.html</url>
      
        <content type="html"><![CDATA[<h1 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>我们之前讨论的多层感知机十分适合处理表格数据，其中行对应样本，列对应特征。 对于表格数据，我们寻找的模式可能涉及特征之间的交互，但是我们不能预先假设任何与特征交互相关的先验结构。 此时，多层感知机可能是最好的选择，然而对于高维感知数据，这种缺少结构的网络可能会变得不实用</p><p>而图像中本就拥有丰富的结构，而这些结构可以被人类和机器学习模型使用。 <strong><em>卷积神经网络</em></strong>（convolutional neural networks，CNN）是机器学习利用自然图像中一些已知结构的创造性方法。</p><hr><h3 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h3><ol><li><strong><em>平移不变性</em></strong>（translation invariance）：不管检测对象出现在图像中的哪个位置，神经网络的前面几层应该对相同的图像区域具有相似的反应，即为“平移不变性”。</li><li><strong><em>局部性</em></strong>（locality）：神经网络的前面几层应该只探索输入图像中的局部区域，而不过度在意图像中相隔较远区域的关系，这就是“局部性”原则。最终，可以聚合这些局部特征，以在整个图像级别进行预测。</li></ol><hr><h3 id="多层感知机的限制"><a href="#多层感知机的限制" class="headerlink" title="多层感知机的限制"></a>多层感知机的限制</h3><p>首先，多层感知机的输入是二维图像$\mathbf{X}$，其隐藏表示$\mathbf{H}$在数学上是一个矩阵，在代码中表示为二维张量。</p><p>其中$\mathbf{X}$和$\mathbf{H}$具有相同的形状。</p><p>为了方便理解，我们可以认为，无论是输入还是隐藏表示都拥有空间结构。</p><p>使用$[\mathbf{X}]_{i, j}$<strong>和</strong>$[\mathbf{H}]_{i, j}$分别表示输入图像和隐藏表示中位置（$i$,$j$）处的像素。</p><p>为了使每个隐藏神经元都能接收到每个输入像素的信息，我们将参数从权重矩阵（如同我们先前在多层感知机中所做的那样）替换为四阶权重张量$\mathsf{W}$。假设$\mathbf{U}$包含偏置参数，我们可以将全连接层形式化地表示为</p><script type="math/tex; mode=display">\begin{split}\begin{aligned} \left[\mathbf{H}\right]_{i, j} &= [\mathbf{U}]_{i, j} + \sum_k \sum_l[\mathsf{W}]_{i, j, k, l}  [\mathbf{X}]_{k, l}\\ &=  [\mathbf{U}]_{i, j} +\sum_a \sum_b [\mathsf{V}]_{i, j, a, b}  [\mathbf{X}]_{i+a, j+b}.\end{aligned}\end{split}</script><ul><li><code>(i, j)</code> 想象为这个小方块的中心点在图像上的位置。</li><li><code>U[i,j]</code> 是这个小方块在没有任何额外上下文信息时的特征（就像是你只看这个小方块，不考虑周围的情况）。</li><li><code>W[i,j,k,l]</code> 是一个滤波器，它告诉我们应该如何考虑 <code>(i, j)</code> 周围的像素来增强我们对这个点的理解。比如，它可以是一个高斯滤波器，用于平滑图像并消除噪声。</li><li><code>(k, l)</code> 是滤波器在图像上移动的位置，你可以想象为你手中有一个放大镜，你在图像上移动它，看不同部分的细节。</li></ul><hr><p><strong>平移不变性</strong></p><p>举个例子：</p><ol><li>假设我们的特征检测器在位置$(i,j)$识别出一只小狗，并计算得到特征 $H[i,j]$</li><li>现在，如果我们将图像向右平移一个像素，那么小狗现在在位置 $(i,j+1)$</li><li>应用同样的特征检测器，如果我们计算得到的特征  $H[i,j+1]$与  $H[i,j]$相同，那么我们的检测器就具有<strong>平移不变性</strong>。</li><li>在图像处理中，如果我们使用一种算法来识别图像中的物体，比如小狗，我们希望无论小狗出现在图像的哪个位置，算法都能准确识别它。如果一个算法具有平移不变性，那么即使小狗在图像的左上角或者右下角，或者任何位置，这个算法都能告诉我们”这是一只小狗”。换句话说，<strong>这个算法对于小狗的位置不敏感</strong>。</li></ol><p>这意味着检测对象在输入$\mathbf{X}$中的平移，应该仅导致隐藏表示$\mathbf{H}$中的平移。也就是说，$\mathsf{V}$和$\mathbf{U}$实际上不依赖于$(i, j)$的值，即$[\mathsf{V}]_{i, j, a, b} = [\mathbf{V}]_{a, b}$。并且$\mathbf{U}$是一个常数，比如$u$。因此，我们可以简化$\mathbf{H}$定义为：</p><script type="math/tex; mode=display">[\mathbf{H}]_{i, j} = u + \sum_a\sum_b [\mathbf{V}]_{a, b} [\mathbf{X}]_{i+a, j+b}</script><p>这就是<strong>卷积</strong>（convolution）。我们是在使用系数$[\mathbf{V}]_{a, b}$<strong>对位置</strong>$(i, j)$<strong>附近的像素</strong>$(i+a, j+b)$进行加权得到$[\mathbf{H}]_{i, j}$。</p><p>注意，$[\mathbf{V}]_{a, b}$的系数比$[\mathsf{V}]_{i, j, a, b}$少很多，因为前者不再依赖于图像中的位置。这就是显著的进步！</p><hr><p><strong>局部性</strong></p><p>如上所述，为了收集用来训练参数$[\mathbf{H}]_{i, j}$的相关信息，我们不应偏离到距$(i, j)$很远的地方。这意味着在$|a|&gt; \Delta$或$|b| &gt; \Delta$的范围之外，我们可以设置$[\mathbf{V}]_{a, b} = 0$。因此，我们可以将$[\mathbf{H}]_{i, j}$重写为</p><script type="math/tex; mode=display">[\mathbf{H}]_{i, j} = u + \sum_{a = -\Delta}^{\Delta} \sum_{b = -\Delta}^{\Delta} [\mathbf{V}]_{a, b}  [\mathbf{X}]_{i+a, j+b}.</script><p>简而言之， 上述公式是一个<strong>卷积层</strong>（convolutional layer），而卷积神经网络是包含卷积层的一类特殊的神经网络。</p><p>在深度学习研究社区中，$\mathbf{V}$被称为<strong>卷积核</strong>（convolution kernel）或者<strong>滤波器</strong>（filter），亦或简单地称之为该卷积层的<strong>权重</strong>，通常该权重是可学习的参数。</p><p>当图像处理的局部区域很小时，卷积神经网络与多层感知机的训练差异可能是巨大的：以前，多层感知机可能需要数十亿个参数来表示网络中的一层，而现在卷积神经网络通常只需要几百个参数，而且不需要改变输入或隐藏表示的维数。</p><p>参数大幅减少的代价是，我们的特征现在是平移不变的，并且当确定每个隐藏活性值时，每一层只包含<strong>局部的信息</strong>。</p><hr><h3 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h3><p>在进一步讨论之前，我们先简要回顾一下为什么上面的操作被称为卷积。在数学中，两个函数（比如$f, g: \mathbb{R}^d \to \mathbb{R}$）之间的“卷积”被定义为</p><script type="math/tex; mode=display">(f * g)(\mathbf{x}) = \int f(\mathbf{z}) g(\mathbf{x}-\mathbf{z}) d\mathbf{z}</script><p>也就是说，卷积是当把一个函数“翻转”并移位$\mathbf{x}$时，测量$f$和$g$之间的重叠。</p><ul><li>函数 $g$ 是<strong>放大镜</strong>，定义了您关注的特定图形或模式。在图像处理中，这可以是一个卷积核，它突出或检测特定的特征，比如边缘或纹理。</li><li><strong>移动放大镜</strong> 对应于卷积操作中的“翻转并移位”步骤。您通过移动 $g$ 相对于$f$的位置（即改变 $x$），来检查 $f$ 在不同位置上如何与 $g$ 重叠。</li><li><strong>寻找特定图形</strong> 的过程就是计算卷积值的过程。在每个位置 $x$，通过对所有可能的$z$ 值进行积分（或在离散情况下求和），实际上是在测量$f$ 和 $g$ 在该位置的匹配程度。这个匹配程度表达为一个数值，即卷积结果$(f*g)(x)$</li></ul><p>当为离散对象时，积分就变成求和。例如，对于由索引为$\mathbb{Z}$的、平方可和的、无限维向量集合中抽取的向量，我们得到以下定义：</p><script type="math/tex; mode=display">(f * g)(i) = \sum_a f(a) g(i-a)</script><p>对于二维张量，则为$f$的索引$(a, b)$和$g$的索引$(i-a, j-b)$上的对应加和：</p><script type="math/tex; mode=display">(f * g)(i, j) = \sum_a\sum_b f(a, b) g(i-a, j-b)</script><hr><h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><p>然而这种方法有一个问题：我们忽略了图像一般包含三个通道/三种原色（红色、绿色和蓝色）。</p><p>实际上，图像不是二维张量，而是一个由高度、宽度和颜色组成的三维张量，比如包含$1024 \times 1024 \times 3$个像素。前两个轴与像素的空间位置有关，而第三个轴可以看作每个像素的多维表示。</p><p>因此，我们将$\mathsf{X}$索引为$[\mathsf{X}]_{i, j, k}$。由此卷积相应地调整为$[\mathsf{V}]_{a,b,c}$，而不是$[\mathbf{V}]_{a,b}$。</p><p>此外，由于输入图像是三维的，我们的隐藏表示$\mathsf{H}$也最好采用三维张量。换句话说，对于每一个空间位置，我们想要采用一组而不是一个隐藏表示。这样一组隐藏表示可以想象成一些互相堆叠的二维网格。</p><p>因此，我们可以把隐藏表示想象为一系列具有二维张量的<strong>通道</strong>（channel）。这些通道有时也被称为<strong>特征映射</strong>（feature maps），因为每个通道都向后续层提供一组空间化的学习特征。直观上可以想象在靠近输入的底层，一些通道专门识别边缘，而一些通道专门识别纹理。</p><p>为了支持输入$\mathsf{X}$和隐藏表示$\mathsf{H}$中的多个通道，我们可以在$\mathsf{V}$中添加第四个坐标，即$[\mathsf{V}]_{a, b, c, d}$。综上所述，</p><script type="math/tex; mode=display">[\mathsf{H}]_{i,j,d} = \sum_{a = -\Delta}^{\Delta} \sum_{b = -\Delta}^{\Delta} \sum_c [\mathsf{V}]_{a, b, c, d} [\mathsf{X}]_{i+a, j+b, c}</script><p>其中隐藏表示$\mathsf{H}$中的索引$d$表示输出通道，而随后的输出将继续以三维张量$\mathsf{H}$作为输入进入下一个卷积层。所以，公式可以定义具有多个通道的卷积层，而其中$\mathsf{V}$是该卷积层的权重。</p><p>具体来说，如果我们有一个输入数据张量和一个卷积层，其输入数据张量具有 $C_{in}$ 个通道（例如，彩色图像的3个通道），而卷积层要产生 $C_{out}$ 个输出特征映射（或通道），那么每个卷积核实际上需要是一个四维数组</p><ol><li><strong>输出通道数$C_{out}$</strong>：卷积层产生的特征映射数。</li><li><strong>输入通道数 $C_{in}$</strong>：输入数据的通道数。</li><li><strong>高度 H</strong>：卷积核在空间高度维度上的大小。</li><li><strong>宽度 W</strong>：卷积核在空间宽度维度上的大小。</li></ol><hr><h2 id="图像卷积"><a href="#图像卷积" class="headerlink" title="图像卷积"></a>图像卷积</h2><h3 id="互相关运算"><a href="#互相关运算" class="headerlink" title="互相关运算"></a>互相关运算</h3><p>我们暂时忽略通道（第三维）这一情况，看看如何处理二维图像数据和隐藏表示。在图中，输入是高度为3、宽度为3的二维张量（即形状为3×3）。卷积核的高度和宽度都是2，而卷积核窗口（或卷积窗口）的形状由内核的高度和宽度决定（即2×2）</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoracorrelation.svg" alt="../_images/correlation.svg"></p><script type="math/tex; mode=display">0\times0+1\times1+3\times2+4\times3=19</script><p>二维互相关运算中，卷积窗口从输入张量的左上角开始，从左到右、从上到下滑动。 当卷积窗口滑动到新一个位置时，包含在该窗口中的部分张量与卷积核张量进行按元素相乘，得到的张量再求和得到一个单一的标量值，由此我们得出了这一位置的输出张量值。</p><p>注意，输出大小略小于输入大小。这是因为卷积核的宽度和高度大于1， 而卷积核只与图像中每个大小完全适合的位置进行互相关运算，稍后，我们将看到如何通过在图像边界周围填充零来保证有足够的空间移动卷积核，从而保持输出大小不变</p><p>在<code>corr2d</code>函数中实现如上过程，该函数接受输入张量<code>X</code>和卷积核张量<code>K</code>，并返回输出张量<code>Y</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">corr2d</span>(<span class="params">X, K</span>):</span>  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算二维互相关运算&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 获取卷积核K的高度和宽度</span></span><br><span class="line">    h, w = K.shape</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 初始化输出特征图Y，其尺寸根据输入X的尺寸和卷积核K的尺寸计算得出</span></span><br><span class="line">    <span class="comment"># 输出特征图的每个维度都比输入X对应维度小卷积核尺寸加一</span></span><br><span class="line">    Y = torch.zeros((X.shape[<span class="number">0</span>] - h + <span class="number">1</span>, X.shape[<span class="number">1</span>] - w + <span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 遍历输出特征图的每个位置</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Y.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(Y.shape[<span class="number">1</span>]):</span><br><span class="line">            <span class="comment"># 在输入X上对应位置切片，与卷积核K进行元素乘法后求和</span></span><br><span class="line">            <span class="comment"># 这一步实际上是在计算卷积核K与输入X在(i, j)位置的互相关</span></span><br><span class="line">            Y[i, j] = (X[i:i + h, j:j + w] * K).<span class="built_in">sum</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 返回计算得到的输出特征图Y</span></span><br><span class="line">    <span class="keyword">return</span> Y</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h3><p>卷积层对输入和卷积核权重进行互相关运算，并在添加标量偏置之后产生输出。 所以，卷积层中的两个被训练的参数是<strong>卷积核权重V和标量偏置U</strong>。 就像我们之前随机初始化全连接层一样，在训练基于卷积层的模型时，我们也随机初始化卷积核权重。</p><p>基于上面定义的<code>corr2d</code>函数实现二维卷积层。在<code>__init__</code>构造函数中，将<code>weight</code>和<code>bias</code>声明为两个模型参数。前向传播函数调用<code>corr2d</code>函数并添加偏置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Conv2D</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, kernel_size</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="comment"># 初始化卷积核权重为随机值，大小由kernel_size参数指定</span></span><br><span class="line">        self.weight = nn.Parameter(torch.rand(kernel_size))</span><br><span class="line">        <span class="comment"># 初始化偏置为0，大小为1</span></span><br><span class="line">        self.bias = nn.Parameter(torch.zeros(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="comment"># 在前向传播时，使用corr2d函数进行互相关运算</span></span><br><span class="line">        <span class="comment"># 将输入x和权重self.weight作为参数传递给corr2d</span></span><br><span class="line">        <span class="comment"># 然后将结果加上偏置self.bias</span></span><br><span class="line">        <span class="keyword">return</span> corr2d(x, self.weight) + self.bias</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h3><p>如下是卷积层的一个简单应用：通过找到像素变化的位置，来检测图像中不同颜色的边缘。 首先，我们构造一个$6×8$像素的黑白图像。中间四列为黑色（$0$），其余像素为白色（$1$）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">X = torch.ones((<span class="number">6</span>, <span class="number">8</span>))</span><br><span class="line">X[:, <span class="number">2</span>:<span class="number">6</span>] = <span class="number">0</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">输出结果：</span></span><br><span class="line"><span class="string">tensor([[1., 1., 0., 0., 0., 0., 1., 1.],</span></span><br><span class="line"><span class="string">        [1., 1., 0., 0., 0., 0., 1., 1.],</span></span><br><span class="line"><span class="string">        [1., 1., 0., 0., 0., 0., 1., 1.],</span></span><br><span class="line"><span class="string">        [1., 1., 0., 0., 0., 0., 1., 1.],</span></span><br><span class="line"><span class="string">        [1., 1., 0., 0., 0., 0., 1., 1.],</span></span><br><span class="line"><span class="string">        [1., 1., 0., 0., 0., 0., 1., 1.]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>接下来，我们构造一个高度为1、宽度为2的卷积核<code>K</code>。当进行互相关运算时，如果水平相邻的两元素相同，则输出为零，否则输出为非零。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">K = torch.tensor([[<span class="number">1.0</span>, -<span class="number">1.0</span>]])</span><br></pre></td></tr></table></figure><p>现在，我们对参数<code>X</code>（输入）和<code>K</code>（卷积核）执行互相关运算。 如下所示，输出<code>Y</code>中的1代表从白色到黑色的边缘，-1代表从黑色到白色的边缘，其他情况的输出为0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Y = corr2d(X, K)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[ 0.,  1.,  0.,  0.,  0., -1.,  0.],</span></span><br><span class="line"><span class="string">        [ 0.,  1.,  0.,  0.,  0., -1.,  0.],</span></span><br><span class="line"><span class="string">        [ 0.,  1.,  0.,  0.,  0., -1.,  0.],</span></span><br><span class="line"><span class="string">        [ 0.,  1.,  0.,  0.,  0., -1.,  0.],</span></span><br><span class="line"><span class="string">        [ 0.,  1.,  0.,  0.,  0., -1.,  0.],</span></span><br><span class="line"><span class="string">        [ 0.,  1.,  0.,  0.,  0., -1.,  0.]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>现在我们将输入的二维图像转置，再进行如上的互相关运算。 其输出如下，之前检测到的垂直边缘消失了。 不出所料，这个卷积核<code>K</code>只可以检测垂直边缘，无法检测水平边缘</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">corr2d(X.t(), K)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[0., 0., 0., 0., 0.],</span></span><br><span class="line"><span class="string">        [0., 0., 0., 0., 0.],</span></span><br><span class="line"><span class="string">        [0., 0., 0., 0., 0.],</span></span><br><span class="line"><span class="string">        [0., 0., 0., 0., 0.],</span></span><br><span class="line"><span class="string">        [0., 0., 0., 0., 0.],</span></span><br><span class="line"><span class="string">        [0., 0., 0., 0., 0.],</span></span><br><span class="line"><span class="string">        [0., 0., 0., 0., 0.],</span></span><br><span class="line"><span class="string">        [0., 0., 0., 0., 0.]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><hr><h3 id="学习卷积核"><a href="#学习卷积核" class="headerlink" title="学习卷积核"></a>学习卷积核</h3><p>如果我们只需寻找黑白边缘，那么以上<code>[1, -1]</code>的边缘检测器足以。然而，当有了更复杂数值的卷积核，或者连续的卷积层时，我们不可能手动设计滤波器。那么我们是否可以<strong>学习</strong>由<code>X</code>生成<code>Y</code>的卷积核呢？</p><p>现在让我们看看是否可以通过仅查看“输入-输出”对来学习由<code>X</code>生成<code>Y</code>的卷积核。 我们先构造一个卷积层，并将其卷积核初始化为随机张量。接下来，在每次迭代中，我们比较<code>Y</code>与卷积层输出的平方误差，然后计算梯度来更新卷积核。为了简单起见，我们在此使用内置的二维卷积层，并忽略偏置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构造一个二维卷积层，它具有1个输出通道和形状为（1，2）的卷积核</span></span><br><span class="line">conv2d = nn.Conv2d(<span class="number">1</span>,<span class="number">1</span>, kernel_size=(<span class="number">1</span>, <span class="number">2</span>), bias=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个二维卷积层使用四维输入和输出格式（批量大小、通道、高度、宽度），</span></span><br><span class="line"><span class="comment"># 其中批量大小和通道数都为1</span></span><br><span class="line">X = X.reshape((<span class="number">1</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">8</span>))</span><br><span class="line">Y = Y.reshape((<span class="number">1</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">7</span>))</span><br><span class="line">lr = <span class="number">3e-2</span>  <span class="comment"># 学习率</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    Y_hat = conv2d(X)</span><br><span class="line">    l = (Y_hat - Y) ** <span class="number">2</span></span><br><span class="line">    conv2d.zero_grad()</span><br><span class="line">    l.<span class="built_in">sum</span>().backward()</span><br><span class="line">    <span class="comment"># 迭代卷积核</span></span><br><span class="line">    conv2d.weight.data[:] -= lr * conv2d.weight.grad</span><br><span class="line">    <span class="keyword">if</span> (i + <span class="number">1</span>) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;epoch <span class="subst">&#123;i+<span class="number">1</span>&#125;</span>, loss <span class="subst">&#123;l.<span class="built_in">sum</span>():<span class="number">.3</span>f&#125;</span>&#x27;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">epoch 2, loss 6.422</span></span><br><span class="line"><span class="string">epoch 4, loss 1.225</span></span><br><span class="line"><span class="string">epoch 6, loss 0.266</span></span><br><span class="line"><span class="string">epoch 8, loss 0.070</span></span><br><span class="line"><span class="string">epoch 10, loss 0.022</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>在10次迭代之后，误差已经降到足够低。现在我们来看看我们所学的卷积核的权重张量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conv2d.weight.data.reshape((<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"><span class="comment">#tensor([[ 1.0010, -0.9739]])</span></span><br></pre></td></tr></table></figure><p>和之前设置的卷积核权重非常接近</p><hr><h2 id="填充与步幅"><a href="#填充与步幅" class="headerlink" title="填充与步幅"></a>填充与步幅</h2><h3 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h3><p>假设以下情景： 有时，在应用了连续的卷积之后，我们最终得到的输出远小于输入大小。这是由于卷积核的宽度和高度通常大于1所导致的。比如，一个240×240像素的图像，经过10层5×5的卷积后，将减少到200×200像素。如此一来，原始图像的边界丢失了许多有用信息。而<strong><em>填充</em></strong>是解决此问题最有效的方法</p><p>在应用多层卷积时，我们常常丢失边缘像素。 由于我们通常使用小卷积核，因此对于任何单个卷积，我们可能只会丢失几个像素。 但随着我们应用许多连续卷积层，累积丢失的像素数就多了。 解决这个问题的简单方法即为<strong><em>填充</em></strong>（padding）：在输入图像的边界填充元素（通常填充元素是0）</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraconv-pad.svg" alt="../_images/conv-pad.svg"></p><p>通常，如果我们添加$p_ℎ$行填充（大约一半在顶部，一半在底部）和$p_w$列填充（左侧大约一半，右侧一半），则输出形状将为</p><script type="math/tex; mode=display">(n_h-k_h+p_h+1)\times(n_w-k_w+p_w+1)</script><p>许多情况下，我们需要设置$p_ℎ=k_ℎ−1$和$p_w=k_w−1$，使输入和输出具有相同的高度和宽度。 这样可以在构建网络时更容易地预测每个图层的输出形状</p><p>卷积神经网络中卷积核的高度和宽度通常为奇数，例如1、3、5或7。 选择奇数的好处是，保持空间维度的同时，我们可以在顶部和底部填充相同数量的行，在左侧和右侧填充相同数量的列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了方便起见，我们定义了一个计算卷积层的函数。</span></span><br><span class="line"><span class="comment"># 此函数初始化卷积层权重，并对输入和输出提高和缩减相应的维数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">comp_conv2d</span>(<span class="params">conv2d, X</span>):</span></span><br><span class="line">    <span class="comment"># 这里的（1，1）表示批量大小和通道数都是1</span></span><br><span class="line">    X = X.reshape((<span class="number">1</span>, <span class="number">1</span>) + X.shape)</span><br><span class="line">    Y = conv2d(X)</span><br><span class="line">    <span class="comment"># 省略前两个维度：批量大小和通道</span></span><br><span class="line">    <span class="keyword">return</span> Y.reshape(Y.shape[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 请注意，这里每边都填充了1行或1列，因此总共添加了2行或2列</span></span><br><span class="line">conv2d = nn.Conv2d(<span class="number">1</span>, <span class="number">1</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line">X = torch.rand(size=(<span class="number">8</span>, <span class="number">8</span>))</span><br><span class="line">comp_conv2d(conv2d, X).shape</span><br></pre></td></tr></table></figure><p>当卷积核的高度和宽度不同时，我们可以填充不同的高度和宽度，使输出和输入具有相同的高度和宽度</p><hr><h3 id="步幅"><a href="#步幅" class="headerlink" title="步幅"></a>步幅</h3><p>在计算互相关时，卷积窗口从输入张量的左上角开始，向下、向右滑动。 在前面的例子中，我们默认每次滑动一个元素。 但是，有时候为了高效计算或是缩减采样次数，卷积窗口可以跳过中间位置，每次滑动多个元素,每次滑动元素的数量称为<strong><em>步幅</em></strong>（stride）</p><p>图中是垂直步幅为3，水平步幅为2的二维互相关运算。 着色部分是输出元素以及用于输出计算的输入和内核张量元素</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraconv-stride.svg" alt="../_images/conv-stride.svg"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conv2d = nn.Conv2d(<span class="number">1</span>, <span class="number">1</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>, stride=(<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">comp_conv2d(conv2d, X).shape</span><br></pre></td></tr></table></figure><hr><h2 id="多输入多输出通道"><a href="#多输入多输出通道" class="headerlink" title="多输入多输出通道"></a>多输入多输出通道</h2><p>当我们添加通道时，我们的输入和隐藏的表示都变成了三维张量。例如，每个RGB输入图像具有$3×ℎ×w$的形状。我们将这个大小为3的轴称为<strong><em>通道</em></strong>（channel）维度。本节将更深入地研究具有多输入和多输出通道的卷积核</p><h3 id="多输入通道"><a href="#多输入通道" class="headerlink" title="多输入通道"></a>多输入通道</h3><p>当输入包含多个通道时，需要构造一个与输入数据具有相同输入通道数的卷积核，以便与输入数据进行互相关运算。假设输入的通道数为$c_i$，那么卷积核的输入通道数也需要为$c_i$。</p><p>然而，当$c_i&gt;1$时，我们卷积核的每个输入通道将包含形状为$k_h\times k_w$的张量。将这些张量$c_i$连结在一起可以得到形状为$c_i\times k_h\times k_w$的卷积核。由于输入和卷积核都有$c_i$个通道，我们可以对每个通道输入的二维张量和卷积核的二维张量进行互相关运算，再对通道求和（将$c_i$的结果相加）得到二维张量。这是多通道输入和多输入通道卷积核之间进行二维互相关运算的结果。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraconv-multi-in.svg" alt="../_images/conv-multi-in.svg"></p><p>在上图，我们演示了一个具有两个输入通道的二维互相关运算的示例。阴影部第一个输出元素以及用于计算这个输出的输入和核张量元素：$(1\times1+2\times2+4\times3+5\times4)+(0\times0+1\times1+3\times2+4\times3)=56$。</p><p>为了加深理解，我们实现一下多输入通道互相关运算。 简而言之，我们所做的就是对每个通道执行互相关操作，然后将结果相加。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">corr2d_multi_in</span>(<span class="params">X, K</span>):</span></span><br><span class="line">    <span class="comment"># 先遍历“X”和“K”的第0个维度（通道维度），再把它们加在一起</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(d2l.corr2d(x, k) <span class="keyword">for</span> x, k <span class="keyword">in</span> <span class="built_in">zip</span>(X, K))</span><br></pre></td></tr></table></figure><p>可以构造与图中的值相对应的输入张量X和核张量K，以验证互相关运算的输出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">X = torch.tensor([[[<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>], [<span class="number">6.0</span>, <span class="number">7.0</span>, <span class="number">8.0</span>]],</span><br><span class="line">               [[<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>], [<span class="number">4.0</span>, <span class="number">5.0</span>, <span class="number">6.0</span>], [<span class="number">7.0</span>, <span class="number">8.0</span>, <span class="number">9.0</span>]]])</span><br><span class="line">K = torch.tensor([[[<span class="number">0.0</span>, <span class="number">1.0</span>], [<span class="number">2.0</span>, <span class="number">3.0</span>]], [[<span class="number">1.0</span>, <span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>]]])</span><br><span class="line"></span><br><span class="line">corr2d_multi_in(X, K)</span><br></pre></td></tr></table></figure><hr><h3 id="多输出通道"><a href="#多输出通道" class="headerlink" title="多输出通道"></a>多输出通道</h3><p>在最流行的神经网络架构中，随着神经网络层数的加深，我们常会增加输出通道的维数，通过减少空间分辨率以获得更大的通道深度。直观地说，我们可以将每个通道看作对不同特征的响应。而现实可能更为复杂一些，因为每个通道不是独立学习的，而是为了共同使用而优化的。因此，多输出通道并不仅是学习多个单通道的检测器。</p><p>用$c_i$和$c_o$分别表示输入和输出通道的数目，并让$k_h$和$k_w$为卷积核的高度和宽度。为了获得多个通道的输出，我们可以为每个输出通道创建一个形状为$c_i\times k_h\times k_w$的卷积核张量，这样卷积核的形状是$c_o\times c_i\times k_h\times k_w$。在互相关运算中，每个输出通道先获取所有输入通道，再以对应该输出通道的卷积核计算出结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">corr2d_multi_in_out</span>(<span class="params">X, K</span>):</span></span><br><span class="line">    <span class="comment"># 迭代“K”的第0个维度，每次都对输入“X”执行互相关运算。</span></span><br><span class="line">    <span class="comment"># 最后将所有结果都叠加在一起</span></span><br><span class="line">    <span class="keyword">return</span> torch.stack([corr2d_multi_in(X, k) <span class="keyword">for</span> k <span class="keyword">in</span> K], <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>通过将核张量<code>K</code>与<code>K+1</code>（<code>K</code>中每个元素加$1$）和<code>K+2</code>连接起来，构造了一个具有$3$个输出通道的卷积核。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">K = np.stack((K, K + <span class="number">1</span>, K + <span class="number">2</span>), <span class="number">0</span>)</span><br><span class="line">K.shape</span><br></pre></td></tr></table></figure><p>下面，我们对输入张量<code>X</code>与卷积核张量<code>K</code>执行互相关运算。现在的输出包含3个通道，第一个通道的结果与先前输入张量<code>X</code>和多输入单输出通道的结果一致。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">corr2d_multi_in_out(X, K)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[[ 56.,  72.],</span></span><br><span class="line"><span class="string">         [104., 120.]],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        [[ 76., 100.],</span></span><br><span class="line"><span class="string">         [148., 172.]],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        [[ 96., 128.],</span></span><br><span class="line"><span class="string">         [192., 224.]]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><hr><h3 id="1X1卷积层"><a href="#1X1卷积层" class="headerlink" title="1X1卷积层"></a>1X1卷积层</h3><p>$1 \times 1$卷积，即$k_h = k_w = 1$，看起来似乎没有多大意义。</p><p>毕竟，卷积的本质是有效提取相邻像素间的相关特征，而$1 \times 1$卷积显然没有此作用。尽管如此，$1 \times 1$仍然十分流行，经常包含在复杂深层网络的设计中。下面，让我们详细地解读一下它的实际作用。</p><p>因为使用了最小窗口，$1\times 1$卷积失去了卷积层的特有能力——在高度和宽度维度上，识别相邻元素间相互作用的能力。其实$1\times 1$卷积的唯一计算发生在通道上。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraconv-1x1.svg" alt="../_images/conv-1x1.svg"></p><p>图中展示了使用$1\times 1$卷积核与$3$个输入通道和$2$个输出通道的互相关计算。</p><p>这里输入和输出具有相同的高度和宽度，输出中的每个元素都是从输入图像中同一位置的元素的线性组合。</p><p>我们可以将$1\times 1$卷积层看作在每个像素位置应用的全连接层，以$c_i$个输入值转换为$c_o$个输出值。因为这仍然是一个卷积层，所以跨像素的权重是一致的。同时，$1\times 1$卷积层需要的权重维度为$c_o\times c_i$，再额外加上一个偏置。</p><p>下面，我们使用全连接层实现1×1卷积。 请注意，我们需要对输入和输出的数据形状进行调整。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">corr2d_multi_in_out_1x1</span>(<span class="params">X, K</span>):</span></span><br><span class="line">    c_i, h, w = X.shape</span><br><span class="line">    c_o = K.shape[<span class="number">0</span>]</span><br><span class="line">    X = X.reshape((c_i, h * w))</span><br><span class="line">    K = K.reshape((c_o, c_i))</span><br><span class="line">    <span class="comment"># 全连接层中的矩阵乘法</span></span><br><span class="line">    Y = torch.matmul(K, X)</span><br><span class="line">    <span class="keyword">return</span> Y.reshape((c_o, h, w))</span><br></pre></td></tr></table></figure><hr><h2 id="汇聚层"><a href="#汇聚层" class="headerlink" title="汇聚层"></a>汇聚层</h2><p>本节将介绍<strong><em>汇聚</em></strong>（pooling）层，它具有双重目的：降低卷积层对位置的敏感性，同时降低对空间降采样表示的敏感性。</p><h3 id="最大汇聚层和平均汇聚层"><a href="#最大汇聚层和平均汇聚层" class="headerlink" title="最大汇聚层和平均汇聚层"></a>最大汇聚层和平均汇聚层</h3><p>与卷积层类似，汇聚层运算符由一个固定形状的窗口组成，该窗口根据其步幅大小在输入的所有区域上滑动，为固定形状窗口（有时称为<em>汇聚窗口</em>）遍历的每个位置计算一个输出。 然而，不同于卷积层中的输入与卷积核之间的互相关计算，汇聚层不包含参数。 相反，池运算是确定性的，我们通常计算汇聚窗口中所有元素的<strong>最大值或平均值</strong>。这些操作分别称为<strong><em>最大汇聚层</em></strong>（maximum pooling）和<strong><em>平均汇聚层</em></strong>（average pooling）。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typorapooling.svg" alt="../_images/pooling.svg"></p><p>在这两种情况下，与互相关运算符一样，汇聚窗口从输入张量的左上角开始，从左往右、从上往下的在输入张量内滑动。在汇聚窗口到达的每个位置，它计算该窗口中输入子张量的最大值或平均值。计算最大值或平均值是取决于使用了最大汇聚层还是平均汇聚层</p><p>汇聚窗口形状为$p \times q$的汇聚层称为$p \times q$汇聚层，汇聚操作称为$p \times q$汇聚。</p><p>回到本节开头提到的对象边缘检测示例，现在我们将使用卷积层的输出作为$2\times 2$最大汇聚的输入。</p><p>设置卷积层输入为<code>X</code>，汇聚层输出为<code>Y</code>。</p><p>无论<code>X[i, j]</code>和<code>X[i, j + 1]</code>的值相同与否，或<code>X[i, j + 1]</code>和<code>X[i, j + 2]</code>的值相同与否，汇聚层始终输出<code>Y[i, j] = 1</code>。</p><p>也就是说，使用$2\times 2$最大汇聚层，即使在高度或宽度上移动一个元素，卷积层仍然可以识别到模式。</p><p>在下面的代码中的<code>pool2d</code>函数，我们实现汇聚层的前向传播。这类似于中的<code>corr2d</code>函数。然而，这里我们没有卷积核，输出为输入中每个区域的最大值或平均值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch  </span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn  </span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义pool2d函数，它执行池化操作。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pool2d</span>(<span class="params">X, pool_size, mode=<span class="string">&#x27;max&#x27;</span></span>):</span> </span><br><span class="line">    <span class="comment"># X是输入的特征图，pool_size是池化窗口的大小，mode决定池化的类型（最大或平均）。</span></span><br><span class="line">    p_h, p_w = pool_size </span><br><span class="line">    <span class="comment"># 将pool_size元组解包到p_h和p_w，分别代表池化窗口的高度和宽度。</span></span><br><span class="line">    <span class="comment"># 初始化输出特征图Y，其大小根据输入X的尺寸和池化窗口的大小计算得出。</span></span><br><span class="line">    Y = torch.zeros((X.shape[<span class="number">0</span>] - p_h + <span class="number">1</span>, X.shape[<span class="number">1</span>] - p_w + <span class="number">1</span>))</span><br><span class="line">    <span class="comment"># 通过两层循环遍历输出特征图Y的每一个元素。</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Y.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(Y.shape[<span class="number">1</span>]):</span><br><span class="line">            <span class="keyword">if</span> mode == <span class="string">&#x27;max&#x27;</span>:  <span class="comment"># 如果池化模式为最大池化，</span></span><br><span class="line">                <span class="comment"># 则将输入特征图X的对应窗口区域内的最大值赋给Y的当前位置。</span></span><br><span class="line">                Y[i, j] = X[i: i + p_h, j: j + p_w].<span class="built_in">max</span>()</span><br><span class="line">            <span class="keyword">elif</span> mode == <span class="string">&#x27;avg&#x27;</span>:  <span class="comment"># 如果池化模式为平均池化，</span></span><br><span class="line">                <span class="comment"># 则将输入特征图X的对应窗口区域内的平均值赋给Y的当前位置。</span></span><br><span class="line">                Y[i, j] = X[i: i + p_h, j: j + p_w].mean()</span><br><span class="line">    <span class="keyword">return</span> Y  <span class="comment"># 返回最终经过池化操作的输出特征图Y。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在处理多通道输入数据时，汇聚层在每个输入通道上单独运算，而不是像卷积层一样在通道上对输入进行汇总。 这意味着汇聚层的输出通道数与输入通道数相同</p><hr><h2 id="神经网络-LeNet"><a href="#神经网络-LeNet" class="headerlink" title="神经网络(LeNet)"></a>神经网络(LeNet)</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>总体来看，LeNet（LeNet-5）由两个部分组成：</p><ul><li>卷积编码器：由两个卷积层组成;</li><li>全连接层密集块：由三个全连接层组成</li></ul><p>如图所示：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoralenet.svg" alt="../_images/lenet.svg"></p><p>每个卷积块中的基本单元是一个卷积层、一个sigmoid激活函数和平均汇聚层。请注意，虽然ReLU和最大汇聚层更有效，但它们在20世纪90年代还没有出现。每个卷积层使用$5×5$卷积核和一个sigmoid激活函数。这些层将输入映射到多个二维特征输出，通常同时增加通道的数量。第一卷积层有6个输出通道，而第二个卷积层有16个输出通道。每个$2×2$池操作（步幅2）通过空间下采样将维数减少4倍。卷积的输出形状由批量大小、通道数、高度、宽度决定。</p><p>为了将卷积块的输出传递给稠密块，我们必须在小批量中展平每个样本。换言之，我们将这个四维输入转换成全连接层所期望的二维输入。这里的二维表示的第一个维度索引小批量中的样本，第二个维度给出每个样本的平面向量表示。LeNet的稠密块有三个全连接层，分别有120、84和10个输出。因为我们在执行分类任务，所以输出层的10维对应于最后输出结果的数量。</p><p>通过下面的LeNet代码，可以看出用深度学习框架实现此类模型非常简单。我们只需要实例化一个<code>Sequential</code>块并将需要的层连接在一起。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch  </span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn  </span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l </span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个序贯模型，即各个层按顺序执行</span></span><br><span class="line">net = nn.Sequential(</span><br><span class="line">    <span class="comment"># 第一层是二维卷积层，输入通道为1，输出通道为6，卷积核为5x5，边缘填充为2</span></span><br><span class="line">    nn.Conv2d(<span class="number">1</span>, <span class="number">6</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>), nn.Sigmoid(),</span><br><span class="line">    <span class="comment"># 第二层是平均池化层，卷积核为2x2，步幅为2</span></span><br><span class="line">    nn.AvgPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>),</span><br><span class="line">    <span class="comment"># 第三层是二维卷积层，输入通道为6，输出通道为16，卷积核为5x5（无填充，默认为0）</span></span><br><span class="line">    nn.Conv2d(<span class="number">6</span>, <span class="number">16</span>, kernel_size=<span class="number">5</span>), nn.Sigmoid(),</span><br><span class="line">    <span class="comment"># 第四层是平均池化层，卷积核为2x2，步幅为2</span></span><br><span class="line">    nn.AvgPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>),</span><br><span class="line">    <span class="comment"># 扁平化层，将多维输入一维化，用于从卷积层到全连接层的过渡</span></span><br><span class="line">    nn.Flatten(),</span><br><span class="line">    <span class="comment"># 全连接层，输入特征数为16*5*5，输出特征数为120</span></span><br><span class="line">    nn.Linear(<span class="number">16</span> * <span class="number">5</span> * <span class="number">5</span>, <span class="number">120</span>), nn.Sigmoid(),</span><br><span class="line">    <span class="comment"># 另一个全连接层，输入特征数为120，输出特征数为84</span></span><br><span class="line">    nn.Linear(<span class="number">120</span>, <span class="number">84</span>), nn.Sigmoid(),</span><br><span class="line">    <span class="comment"># 最后一个全连接层，输入特征数为84，输出特征数为10（通常对应于分类任务的类别数）</span></span><br><span class="line">    nn.Linear(<span class="number">84</span>, <span class="number">10</span>)</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们对原始模型做了一点小改动，去掉了最后一层的高斯激活。除此之外，这个网络与最初的LeNet-5一致。</p><p>下面，我们将一个大小为28×28的单通道（黑白）图像通过LeNet。通过在每一层打印输出的形状，我们可以检查模型，以确保其操作与我们期望的一致。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoralenet-vert.svg" alt="../_images/lenet-vert.svg"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X = torch.rand(size=(<span class="number">1</span>, <span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>), dtype=torch.float32)</span><br><span class="line"><span class="keyword">for</span> layer <span class="keyword">in</span> net:</span><br><span class="line">    X = layer(X)</span><br><span class="line">    <span class="built_in">print</span>(layer.__class__.__name__,<span class="string">&#x27;output shape: \t&#x27;</span>,X.shape)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Conv2d output shape:         torch.Size([<span class="number">1</span>, <span class="number">6</span>, <span class="number">28</span>, <span class="number">28</span>])</span><br><span class="line">Sigmoid output shape:        torch.Size([<span class="number">1</span>, <span class="number">6</span>, <span class="number">28</span>, <span class="number">28</span>])</span><br><span class="line">AvgPool2d output shape:      torch.Size([<span class="number">1</span>, <span class="number">6</span>, <span class="number">14</span>, <span class="number">14</span>])</span><br><span class="line">Conv2d output shape:         torch.Size([<span class="number">1</span>, <span class="number">16</span>, <span class="number">10</span>, <span class="number">10</span>])</span><br><span class="line">Sigmoid output shape:        torch.Size([<span class="number">1</span>, <span class="number">16</span>, <span class="number">10</span>, <span class="number">10</span>])</span><br><span class="line">AvgPool2d output shape:      torch.Size([<span class="number">1</span>, <span class="number">16</span>, <span class="number">5</span>, <span class="number">5</span>])</span><br><span class="line">Flatten output shape:        torch.Size([<span class="number">1</span>, <span class="number">400</span>])</span><br><span class="line">Linear output shape:         torch.Size([<span class="number">1</span>, <span class="number">120</span>])</span><br><span class="line">Sigmoid output shape:        torch.Size([<span class="number">1</span>, <span class="number">120</span>])</span><br><span class="line">Linear output shape:         torch.Size([<span class="number">1</span>, <span class="number">84</span>])</span><br><span class="line">Sigmoid output shape:        torch.Size([<span class="number">1</span>, <span class="number">84</span>])</span><br><span class="line">Linear output shape:         torch.Size([<span class="number">1</span>, <span class="number">10</span>])</span><br></pre></td></tr></table></figure><p>请注意，在整个卷积块中，与上一层相比，每一层特征的高度和宽度都减小了。 第一个卷积层使用2个像素的填充，来补偿$5×5$卷积核导致的特征减少。 相反，第二个卷积层没有填充，因此高度和宽度都减少了4个像素。 随着层叠的上升，通道的数量从输入时的1个，增加到第一个卷积层之后的6个，再到第二个卷积层之后的16个。 同时，每个汇聚层的高度和宽度都减半。最后，每个全连接层减少维数，最终输出一个维数与结果分类数相匹配的输出。</p><hr><h3 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">batch_size = <span class="number">256</span></span><br><span class="line">train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size=batch_size)</span><br></pre></td></tr></table></figure><p>虽然卷积神经网络的参数较少，但与深度的多层感知机相比，它们的计算成本仍然很高，因为每个参数都参与更多的乘法。 通过使用GPU，可以用它加快训练。</p><p>为了进行评估，我们需要对<code>evaluate_accuracy</code>函数进行轻微的修改。 由于完整的数据集位于内存中，因此在模型使用GPU计算数据集之前，我们需要将其复制到显存中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluate_accuracy_gpu</span>(<span class="params">net, data_iter, device=<span class="literal">None</span></span>):</span> <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用GPU计算模型在数据集上的精度&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(net, nn.Module):</span><br><span class="line">        net.<span class="built_in">eval</span>()  <span class="comment"># 设置为评估模式</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> device:</span><br><span class="line">            device = <span class="built_in">next</span>(<span class="built_in">iter</span>(net.parameters())).device</span><br><span class="line">    <span class="comment"># 正确预测的数量，总预测的数量</span></span><br><span class="line">    metric = d2l.Accumulator(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(X, <span class="built_in">list</span>):</span><br><span class="line">                <span class="comment"># BERT微调所需的（之后将介绍）</span></span><br><span class="line">                X = [x.to(device) <span class="keyword">for</span> x <span class="keyword">in</span> X]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                X = X.to(device)</span><br><span class="line">            y = y.to(device)</span><br><span class="line">            metric.add(d2l.accuracy(net(X), y), y.numel())</span><br><span class="line">    <span class="keyword">return</span> metric[<span class="number">0</span>] / metric[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>如下所示，训练函数<code>train_ch6</code>也类似于中定义的<code>train_ch3</code>。 由于我们将实现多层神经网络，因此我们将主要使用高级API。 以下训练函数假定从高级API创建的模型作为输入，并进行相应的优化。 我们使用之前介绍的<code>Xavier</code>随机初始化模型参数。 与全连接层一样，我们使用交叉熵损失函数和小批量随机梯度下降。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_ch6</span>(<span class="params">net, train_iter, test_iter, num_epochs, lr, device</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;用GPU训练模型(在第六章定义)&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init_weights</span>(<span class="params">m</span>):</span></span><br><span class="line">        <span class="comment"># 初始化模型的权重，使用Xavier初始化方法，适用于线性层和卷积层</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(m) == nn.Linear <span class="keyword">or</span> <span class="built_in">type</span>(m) == nn.Conv2d:</span><br><span class="line">            nn.init.xavier_uniform_(m.weight)</span><br><span class="line">            </span><br><span class="line">    net.apply(init_weights)  <span class="comment"># 将权重初始化应用到网络的每个模块</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;training on&#x27;</span>, device)  <span class="comment"># 打印正在使用的设备，GPU或CPU</span></span><br><span class="line">    net.to(device)  <span class="comment"># 将模型转移到指定的设备上</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 定义优化器，这里使用SGD（随机梯度下降）</span></span><br><span class="line">    optimizer = torch.optim.SGD(net.parameters(), lr=lr)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 定义损失函数，这里使用交叉熵损失，适合多分类问题</span></span><br><span class="line">    loss = nn.CrossEntropyLoss()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 使用d2l库的Animator绘制训练过程中的损失和准确率</span></span><br><span class="line">    animator = d2l.Animator(xlabel=<span class="string">&#x27;epoch&#x27;</span>, xlim=[<span class="number">1</span>, num_epochs],</span><br><span class="line">                            legend=[<span class="string">&#x27;train loss&#x27;</span>, <span class="string">&#x27;train acc&#x27;</span>, <span class="string">&#x27;test acc&#x27;</span>])</span><br><span class="line">    </span><br><span class="line">    timer, num_batches = d2l.Timer(), <span class="built_in">len</span>(train_iter)  <span class="comment"># 初始化计时器和计算批次数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):  <span class="comment"># 训练过程中遍历每一个epoch</span></span><br><span class="line">        <span class="comment"># 初始化累加器，用于记录损失和准确率</span></span><br><span class="line">        metric = d2l.Accumulator(<span class="number">3</span>)  <span class="comment"># 训练损失之和，训练准确率之和，样本数</span></span><br><span class="line">        </span><br><span class="line">        net.train()  <span class="comment"># 将网络设置为训练模式</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i, (X, y) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_iter):  <span class="comment"># 遍历训练数据集</span></span><br><span class="line">            timer.start()  <span class="comment"># 开始计时</span></span><br><span class="line">            </span><br><span class="line">            optimizer.zero_grad()  <span class="comment"># 清空梯度</span></span><br><span class="line">            X, y = X.to(device), y.to(device)  <span class="comment"># 将数据转移到指定的设备</span></span><br><span class="line">            y_hat = net(X)  <span class="comment"># 前向传播，计算预测值</span></span><br><span class="line">            l = loss(y_hat, y)  <span class="comment"># 计算损失</span></span><br><span class="line">            l.backward()  <span class="comment"># 反向传播，计算梯度</span></span><br><span class="line">            optimizer.step()  <span class="comment"># 更新权重</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">with</span> torch.no_grad():  <span class="comment"># 不计算梯度，节省计算资源</span></span><br><span class="line">                <span class="comment"># 更新累加器中的损失和准确率</span></span><br><span class="line">                metric.add(l * X.shape[<span class="number">0</span>], d2l.accuracy(y_hat, y), X.shape[<span class="number">0</span>])</span><br><span class="line">            timer.stop()  <span class="comment"># 停止计时</span></span><br><span class="line">            </span><br><span class="line">            train_l = metric[<span class="number">0</span>] / metric[<span class="number">2</span>]  <span class="comment"># 计算平均训练损失</span></span><br><span class="line">            train_acc = metric[<span class="number">1</span>] / metric[<span class="number">2</span>]  <span class="comment"># 计算平均训练准确率</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 定期更新动画中的训练损失和训练准确率</span></span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span>) % (num_batches // <span class="number">5</span>) == <span class="number">0</span> <span class="keyword">or</span> i == num_batches - <span class="number">1</span>:</span><br><span class="line">                animator.add(epoch + (i + <span class="number">1</span>) / num_batches,</span><br><span class="line">                             (train_l, train_acc, <span class="literal">None</span>))</span><br><span class="line">                </span><br><span class="line">        test_acc = evaluate_accuracy_gpu(net, test_iter)  <span class="comment"># 在测试集上评估模型的准确率</span></span><br><span class="line">        animator.add(epoch + <span class="number">1</span>, (<span class="literal">None</span>, <span class="literal">None</span>, test_acc))  <span class="comment"># 更新动画中的测试准确率</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 打印训练损失、训练准确率和测试准确率</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;loss <span class="subst">&#123;train_l:<span class="number">.3</span>f&#125;</span>, train acc <span class="subst">&#123;train_acc:<span class="number">.3</span>f&#125;</span>, &#x27;</span></span><br><span class="line">          <span class="string">f&#x27;test acc <span class="subst">&#123;test_acc:<span class="number">.3</span>f&#125;</span>&#x27;</span>)</span><br><span class="line">          </span><br><span class="line">    <span class="comment"># 打印每秒可以处理的样本数，表示训练效率</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;metric[<span class="number">2</span>] * num_epochs / timer.<span class="built_in">sum</span>():<span class="number">.1</span>f&#125;</span> examples</span></span><br></pre></td></tr></table></figure><p>现在，我们训练和评估LeNet-5模型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lr, num_epochs = <span class="number">0.9</span>, <span class="number">10</span></span><br><span class="line">train_ch6(net, train_iter, test_iter, num_epochs, lr, d2l.try_gpu())</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">loss 0.464, train acc 0.827, test acc 0.782</span></span><br><span class="line"><span class="string">57969.2 examples/sec on cuda:0</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraoutput_lenet_4a2e9e_64_1.svg" alt="../_images/output_lenet_4a2e9e_64_1.svg"></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.0 pytorch基础</title>
      <link href="/post/21849.html"/>
      <url>/post/21849.html</url>
      
        <content type="html"><![CDATA[<h1 id="pytorch基础"><a href="#pytorch基础" class="headerlink" title="pytorch基础"></a>pytorch基础</h1><h2 id="块"><a href="#块" class="headerlink" title="块"></a>块</h2><h3 id="块的定义"><a href="#块的定义" class="headerlink" title="块的定义"></a>块的定义</h3><p><em>块</em>（block）可以描述单个层、由多个层组成的组件或整个模型本身。</p><p>使用块进行抽象的一个好处是可以将一些块组合成更大的组件， 这一过程通常是递归的，如所示。 通过定义代码来按需生成任意复杂度的块， 我们可以通过简洁的代码实现复杂的神经网络。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typorablocks.svg" alt="../_images/blocks.svg"></p><p>从编程的角度来看，块由<em>类</em>（class）表示。 它的任何子类都必须定义一个将其输入转换为输出的前向传播函数， 并且必须存储任何必需的参数。 注意，有些块不需要任何参数。 最后，为了计算梯度，块必须具有反向传播函数。 在定义我们自己的块时，由于<strong>自动微分</strong>提供了一些后端实现，我们只需要考虑前向传播函数和必需的参数。</p><p>比如多层感知机的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line">net = nn.Sequential(nn.Linear(<span class="number">20</span>, <span class="number">256</span>), nn.ReLU(), nn.Linear(<span class="number">256</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">X = torch.rand(<span class="number">2</span>, <span class="number">20</span>)</span><br><span class="line">net(X)</span><br></pre></td></tr></table></figure><p>上面的代码生成一个网络，其中包含一个具有256个单元和ReLU激活函数的全连接隐藏层， 然后是一个具有10个隐藏单元且不带激活函数的全连接输出层。</p><p>在这个例子中，我们通过实例化<code>nn.Sequential</code>来构建我们的模型， 层的执行顺序是作为参数传递的。 简而言之，<code>nn.Sequential</code>定义了一种特殊的<code>Module</code>， 即在PyTorch中表示一个块的类， 它维护了一个由<code>Module</code>组成的有序列表。 注意，两个全连接层都是<code>Linear</code>类的实例， <code>Linear</code>类本身就是<code>Module</code>的子类。 </p><p>另外，到目前为止，我们一直在通过<code>net(X)</code>调用我们的模型来获得模型的输出。 这实际上是<code>net.__call__(X)</code>的简写。 这个前向传播函数非常简单： 它将列表中的每个块连接在一起，将每个块的输出作为下一个块的输入。</p><hr><h3 id="自定义块"><a href="#自定义块" class="headerlink" title="自定义块"></a>自定义块</h3><p> 每个块必须提供的基本功能如下：</p><ol><li>将输入数据作为其前向传播函数的参数。</li><li>通过前向传播函数来生成输出。请注意，输出的形状可能与输入的形状不同。例如，我们上面模型中的第一个全连接的层接收一个20维的输入，但是返回一个维度为256的输出。</li><li>计算其输出关于输入的梯度，可通过其反向传播函数进行访问。通常这是自动发生的。</li><li>存储和访问前向传播计算所需的参数。</li><li>根据需要初始化模型参数。</li></ol><p>我们从零开始编写一个块。 它包含一个多层感知机，其具有256个隐藏单元的隐藏层和一个10维输出层</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MLP</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="comment"># 用模型参数声明层。这里，我们声明两个全连接的层</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 调用MLP的父类Module的构造函数来执行必要的初始化。</span></span><br><span class="line">        <span class="comment"># 这样，在类实例化时也可以指定其他函数参数，例如模型参数params（稍后将介绍）</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.hidden = nn.Linear(<span class="number">20</span>, <span class="number">256</span>)  <span class="comment"># 隐藏层</span></span><br><span class="line">        self.out = nn.Linear(<span class="number">256</span>, <span class="number">10</span>)  <span class="comment"># 输出层</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义模型的前向传播，即如何根据输入X返回所需的模型输出</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, X</span>):</span></span><br><span class="line">        <span class="comment"># 注意，这里我们使用ReLU的函数版本，其在nn.functional模块中定义。</span></span><br><span class="line">        <span class="keyword">return</span> self.out(F.relu(self.hidden(X)))</span><br></pre></td></tr></table></figure><p>首先看一下前向传播函数，它以<code>X</code>作为输入， 计算带有激活函数的隐藏表示，并输出其未规范化的输出值。 在这个<code>MLP</code>实现中，两个层都是实例变量</p><p>接着我们实例化多层感知机的层，然后在每次调用前向传播函数时调用这些层。 注意一些关键细节： 首先，我们定制的<code>__init__</code>函数通过<code>super().__init__()</code> 调用父类的<code>__init__</code>函数， 省去了重复编写模版代码的痛苦</p><p>然后，我们实例化两个全连接层， 分别为<code>self.hidden</code>和<code>self.out</code>。 注意，除非我们实现一个新的运算符， 否则我们不必担心反向传播函数或参数初始化， 系统将自动生成这些</p><hr><h3 id="顺序块"><a href="#顺序块" class="headerlink" title="顺序块"></a>顺序块</h3><p>为了构建我们自己的简化的<code>MySequential</code>， 我们只需要定义两个关键函数：</p><ol><li>一种将块逐个追加到列表中的函数；</li><li>一种前向传播函数，用于将输入按追加块的顺序传递给块组成的“链条”。</li></ol><p>下面的<code>MySequential</code>类提供了与默认<code>Sequential</code>类相同的功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySequential</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, *args</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="keyword">for</span> idx, module <span class="keyword">in</span> <span class="built_in">enumerate</span>(args):</span><br><span class="line">            <span class="comment"># 这里，module是Module子类的一个实例。我们把它保存在&#x27;Module&#x27;类的成员</span></span><br><span class="line">            <span class="comment"># 变量_modules中。_module的类型是OrderedDict</span></span><br><span class="line">            self._modules[<span class="built_in">str</span>(idx)] = module</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, X</span>):</span></span><br><span class="line">        <span class="comment"># OrderedDict保证了按照成员添加的顺序遍历它们</span></span><br><span class="line">        <span class="keyword">for</span> block <span class="keyword">in</span> self._modules.values():</span><br><span class="line">            X = block(X)</span><br><span class="line">        <span class="keyword">return</span> X</span><br></pre></td></tr></table></figure><p><code>_modules</code>的主要优点是： 在模块的参数初始化过程中， 系统知道在<code>_modules</code>字典中查找需要初始化参数的子块</p><p><code>OrderedDict</code>是Python标准库<code>collections</code>模块中的一个类，它是字典（<code>dict</code>）的一个子类，提供了所有常规字典的方法。与普通的字典不同，<code>OrderedDict</code>记住了元素添加的顺序。这意味着当你对<code>OrderedDict</code>进行迭代或序列化操作时，元素的顺序会按照它们被添加的顺序来进行，这是<code>OrderedDict</code>的主要特性。</p><hr><h3 id="在前向传播函数中执行代码"><a href="#在前向传播函数中执行代码" class="headerlink" title="在前向传播函数中执行代码"></a>在前向传播函数中执行代码</h3><p><code>Sequential</code>类使模型构造变得简单， 允许我们组合新的架构，而不必定义自己的类。 然而，并不是所有的架构都是简单的顺序架构，当需要更强的灵活性时，我们需要定义自己的块</p><p>到目前为止， 我们网络中的所有操作都对网络的激活值及网络的参数起作用。 然而，有时我们可能希望合并既不是上一层的结果也不是可更新参数的项， 我们称之为<strong><em>常数参数</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义FixedHiddenMLP类，它继承自nn.Module</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FixedHiddenMLP</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()  <span class="comment"># 调用父类的构造函数进行初始化</span></span><br><span class="line">        <span class="comment"># 初始化一个固定的随机权重矩阵，这个权重在训练过程中不会被更新</span></span><br><span class="line">        <span class="comment"># requires_grad=False意味着不需要计算梯度，即这个权重不会在反向传播中更新</span></span><br><span class="line">        self.rand_weight = torch.rand((<span class="number">20</span>, <span class="number">20</span>), requires_grad=<span class="literal">False</span>)</span><br><span class="line">        <span class="comment"># 定义一个线性层（全连接层），输入和输出维度都是20</span></span><br><span class="line">        self.linear = nn.Linear(<span class="number">20</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, X</span>):</span></span><br><span class="line">        <span class="comment"># 将输入X通过一个线性层</span></span><br><span class="line">        X = self.linear(X)</span><br><span class="line">        <span class="comment"># 应用ReLU激活函数，并通过固定的随机权重矩阵进行矩阵乘法运算</span></span><br><span class="line">        <span class="comment"># torch.mm用于矩阵乘法，加上1是对结果的一个简单偏置调整</span></span><br><span class="line">        X = F.relu(torch.mm(X, self.rand_weight) + <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 再次将X通过相同的线性层（全连接层），这相当于两个全连接层共享了相同的参数</span></span><br><span class="line">        <span class="comment"># 参数共享意味着在两次不同的操作中，使用了相同的权重和偏置，而不是输入数据相同。</span></span><br><span class="line">        X = self.linear(X)</span><br><span class="line">        <span class="comment"># 使用控制流（一个while循环），不断地将X除以2，直到X的绝对值之和小于等于1</span></span><br><span class="line">        <span class="keyword">while</span> X.<span class="built_in">abs</span>().<span class="built_in">sum</span>() &gt; <span class="number">1</span>:</span><br><span class="line">            X /= <span class="number">2</span></span><br><span class="line">        <span class="comment"># 返回X的元素和，这是这个网络的最终输出</span></span><br><span class="line">        <span class="keyword">return</span> X.<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure><p>注意，在返回输出之前，模型做了一些不寻常的事情： 它运行了一个<code>while</code>循环，在$L_1$范数大于1的条件下， 将输出向量除以2，直到它满足条件为止。 最后，模型返回了<code>X</code>中所有项的和。 注意，此操作可能不会常用于在任何实际任务中， 我们只展示如何将任意代码集成到神经网络计算的流程中。</p><hr><h2 id="参数管理"><a href="#参数管理" class="headerlink" title="参数管理"></a>参数管理</h2><p>选择了架构并设置了超参数后，我们就进入了训练阶段。 此时，我们的目标是找到使损失函数最小化的模型参数值。 经过训练后，我们将需要使用这些参数来做出未来的预测。 此外，有时我们希望提取参数，以便在其他环境中复用它们， 将模型保存下来，以便它可以在其他软件中执行， 或者为了获得科学的理解而进行检查。</p><p>本节，我们将介绍以下内容：</p><ul><li>访问参数，用于调试、诊断和可视化；</li><li>参数初始化；</li><li>在不同模型组件间共享参数。</li></ul><p>先创建一个单隐藏层的多层感知机</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个顺序模型</span></span><br><span class="line">net = nn.Sequential(</span><br><span class="line">    nn.Linear(<span class="number">4</span>, <span class="number">8</span>),  <span class="comment"># 第一个全连接层，接受4个特征的输入，输出8个特征</span></span><br><span class="line">    nn.ReLU(),        <span class="comment"># ReLU激活函数，引入非线性，增强模型的表达能力</span></span><br><span class="line">    nn.Linear(<span class="number">8</span>, <span class="number">1</span>)   <span class="comment"># 第二个全连接层，将8个特征转换为1个输出特征</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个形状为(2, 4)的随机张量，模拟两个具有4个特征的样本</span></span><br><span class="line">X = torch.rand(size=(<span class="number">2</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将X作为输入传递给顺序模型，执行前向传播计算</span></span><br><span class="line"><span class="comment"># 输出为模型根据输入特征对每个样本做出的预测结果</span></span><br><span class="line">output = net(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印模型的输出</span></span><br><span class="line"><span class="built_in">print</span>(output)</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="参数访问"><a href="#参数访问" class="headerlink" title="参数访问"></a>参数访问</h3><p>我们从已有模型中访问参数。 当通过<code>Sequential</code>类定义模型时， 我们可以通过索引来访问模型的任意层。 这就像模型是一个列表一样，每层的参数都在其属性中。 如下所示，我们可以检查第二个全连接层的参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(net[<span class="number">2</span>].state_dict())</span><br><span class="line"><span class="comment">#输出：OrderedDict([(&#x27;weight&#x27;, tensor([[-0.0427, -0.2939, -0.1894,  0.0220, -0.1709, -0.1522, -0.0334, -0.2263]])), (&#x27;bias&#x27;, tensor([0.0887]))])</span></span><br></pre></td></tr></table></figure><p><code>state_dict()</code>方法返回一个包含该层参数的Python字典，其中键是参数名称，值是参数值（权重和偏置）。</p><p>输出的结果告诉我们一些重要的事情： 首先，这个全连接层包含两个参数，分别是该层的权重和偏置。 两者都存储为单精度浮点数（float32）。 注意，参数名称允许唯一标识每个参数，即使在包含数百个层的网络中也是如此。</p><hr><p>注意，每个参数都表示为参数类的一个实例。 要对参数执行任何操作，首先我们需要访问底层的数值。 有几种方法可以做到这一点。有些比较简单，而另一些则比较通用。 </p><p>下面的代码从第二个全连接层（即第三个神经网络层）提取偏置， 提取后返回的是一个参数类实例，并进一步访问该参数的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(net[<span class="number">2</span>].bias))</span><br><span class="line"><span class="built_in">print</span>(net[<span class="number">2</span>].bias)</span><br><span class="line"><span class="built_in">print</span>(net[<span class="number">2</span>].bias.data)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string">&lt;class &#x27;torch.nn.parameter.Parameter&#x27;&gt;</span></span><br><span class="line"><span class="string">Parameter containing:</span></span><br><span class="line"><span class="string">tensor([0.0887], requires_grad=True)</span></span><br><span class="line"><span class="string">tensor([0.0887])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>参数是复合的对象，包含值、梯度和额外信息。 这就是我们需要显式参数值的原因。 除了值之外，我们还可以访问每个参数的梯度</p><hr><p><strong>访问单层</strong></p><p>当我们需要对所有参数执行操作时，逐个访问它们可能会很麻烦。 当我们处理更复杂的块（例如，嵌套块）时，情况可能会变得特别复杂， 因为我们需要递归整个树来提取每个子块的参数。 下面，我们将通过演示来比较访问第一个全连接层的参数和访问所有层。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(*[(name, param.shape) <span class="keyword">for</span> name, param <span class="keyword">in</span> net[<span class="number">0</span>].named_parameters()])</span><br><span class="line"><span class="comment">#输出结果：(&#x27;weight&#x27;, torch.Size([8, 4])) (&#x27;bias&#x27;, torch.Size([8]))</span></span><br></pre></td></tr></table></figure><ul><li><p><code>[(name, param.shape) for name, param in net[0].named_parameters()]</code>是一个<strong>列表推导式</strong>，用于创建一个列表。列表中的每个元素都是由<code>name</code>和<code>param.shape</code>组成的元组，其中<code>name</code>是参数的名称（如<code>&#39;weight&#39;</code>或<code>&#39;bias&#39;</code>），<code>param.shape</code>是对应参数的形状（即它的尺寸）。</p></li><li><p><code>net[0]</code>访问<code>net</code>这个<code>nn.Sequential</code>模型的第一个模块（层）。<code>named_parameters()</code>是一个方法，返回模块中所有参数的迭代器，其中每个参数由其名称和参数本身组成。这意味着你会遍历第一个层中的所有参数，例如全连接层的权重和偏置。</p></li><li>在<code>print</code>函数调用中，<code>*</code>操作符用于解包列表，这意味着列表中的每个元素都将作为独立的参数传递给<code>print</code>函数。这样，列表中的每个元组都将单独打印，而不是打印整个列表。</li></ul><p><strong>访问所有层</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(*[(name, param.shape) <span class="keyword">for</span> name, param <span class="keyword">in</span> net.named_parameters()])</span><br><span class="line"><span class="comment">#输出结果：(&#x27;0.weight&#x27;, torch.Size([8, 4])) (&#x27;0.bias&#x27;, torch.Size([8])) </span></span><br><span class="line"><span class="comment">#(&#x27;2.weight&#x27;, torch.Size([1, 8])) (&#x27;2.bias&#x27;, torch.Size([1]))</span></span><br></pre></td></tr></table></figure><ul><li><p>列表推导式仍然用于创建一个列表，列表中的每个元素是由参数的名称和形状组成的元组。</p></li><li><p><strong><code>net.named_parameters()</code>方法</strong>：</p><p>与<code>net[0].named_parameters()</code>不同，<code>net.named_parameters()</code>遍历整个<code>nn.Sequential</code>模型的所有参数。这意味着它不仅包括第一个层的参数，而且包括模型中所有层的参数。</p><p><code>weight</code>和<code>bias</code>前面的编号表示在<code>Sequential</code>中的位置</p></li></ul><p>这为我们提供了另一种访问网络参数的方式，如下所示，访问第三层的偏置参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.state_dict()[<span class="string">&#x27;2.bias&#x27;</span>].data</span><br></pre></td></tr></table></figure><hr><p><strong>嵌套块</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个简单的模块，该模块包含两个全连接层和两个ReLU激活函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">block1</span>():</span></span><br><span class="line">    <span class="comment"># 第一个全连接层将输入特征从4维扩展到8维</span></span><br><span class="line">    <span class="comment"># 第二个全连接层将特征从8维缩减回4维</span></span><br><span class="line">    <span class="comment"># 每个全连接层后面跟着一个ReLU激活函数，以引入非线性</span></span><br><span class="line">    <span class="keyword">return</span> nn.Sequential(nn.Linear(<span class="number">4</span>, <span class="number">8</span>), nn.ReLU(),</span><br><span class="line">                         nn.Linear(<span class="number">8</span>, <span class="number">4</span>), nn.ReLU())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义另一个模块，该模块通过循环创建4个block1模块并将它们添加到一个Sequential模型中</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">block2</span>():</span></span><br><span class="line">    net = nn.Sequential()  <span class="comment"># 创建一个空的Sequential模型</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        <span class="comment"># 循环中，为Sequential模型动态添加block1模块</span></span><br><span class="line">        <span class="comment"># 使用格式化字符串为每个嵌套的block1提供唯一的名称</span></span><br><span class="line">        net.add_module(<span class="string">f&#x27;block <span class="subst">&#123;i&#125;</span>&#x27;</span>, block1())</span><br><span class="line">    <span class="keyword">return</span> net</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建最终的神经网络rgnet</span></span><br><span class="line"><span class="comment"># 首先使用block2函数得到的模块，它包含了4个嵌套的block1模块</span></span><br><span class="line"><span class="comment"># 然后添加一个全连接层，将特征从4维缩减为1维，可能用于回归任务的输出层</span></span><br><span class="line">rgnet = nn.Sequential(block2(), nn.Linear(<span class="number">4</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个随机输入张量X，用于演示模型的前向传播</span></span><br><span class="line">X = torch.rand(size=(<span class="number">2</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将输入X传递给模型rgnet进行前向传播，打印输出结果</span></span><br><span class="line"><span class="built_in">print</span>(rgnet(X))</span><br></pre></td></tr></table></figure><p>设计了网络后，我们看看它是如何工作的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(rgnet)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Sequential(</span><br><span class="line">  (<span class="number">0</span>): Sequential(</span><br><span class="line">    (block <span class="number">0</span>): Sequential(</span><br><span class="line">      (<span class="number">0</span>): Linear(in_features=<span class="number">4</span>, out_features=<span class="number">8</span>, bias=<span class="literal">True</span>)</span><br><span class="line">      (<span class="number">1</span>): ReLU()</span><br><span class="line">      (<span class="number">2</span>): Linear(in_features=<span class="number">8</span>, out_features=<span class="number">4</span>, bias=<span class="literal">True</span>)</span><br><span class="line">      (<span class="number">3</span>): ReLU()</span><br><span class="line">    )</span><br><span class="line">    (block <span class="number">1</span>): Sequential(</span><br><span class="line">      (<span class="number">0</span>): Linear(in_features=<span class="number">4</span>, out_features=<span class="number">8</span>, bias=<span class="literal">True</span>)</span><br><span class="line">      (<span class="number">1</span>): ReLU()</span><br><span class="line">      (<span class="number">2</span>): Linear(in_features=<span class="number">8</span>, out_features=<span class="number">4</span>, bias=<span class="literal">True</span>)</span><br><span class="line">      (<span class="number">3</span>): ReLU()</span><br><span class="line">    )</span><br><span class="line">    (block <span class="number">2</span>): Sequential(</span><br><span class="line">      (<span class="number">0</span>): Linear(in_features=<span class="number">4</span>, out_features=<span class="number">8</span>, bias=<span class="literal">True</span>)</span><br><span class="line">      (<span class="number">1</span>): ReLU()</span><br><span class="line">      (<span class="number">2</span>): Linear(in_features=<span class="number">8</span>, out_features=<span class="number">4</span>, bias=<span class="literal">True</span>)</span><br><span class="line">      (<span class="number">3</span>): ReLU()</span><br><span class="line">    )</span><br><span class="line">    (block <span class="number">3</span>): Sequential(</span><br><span class="line">      (<span class="number">0</span>): Linear(in_features=<span class="number">4</span>, out_features=<span class="number">8</span>, bias=<span class="literal">True</span>)</span><br><span class="line">      (<span class="number">1</span>): ReLU()</span><br><span class="line">      (<span class="number">2</span>): Linear(in_features=<span class="number">8</span>, out_features=<span class="number">4</span>, bias=<span class="literal">True</span>)</span><br><span class="line">      (<span class="number">3</span>): ReLU()</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">  (<span class="number">1</span>): Linear(in_features=<span class="number">4</span>, out_features=<span class="number">1</span>, bias=<span class="literal">True</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>因为层是分层嵌套的，所以我们也可以像通过嵌套列表索引一样访问它们。 下面，我们访问第一个主要的块中、第二个子块的第一层的偏置项。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rgnet[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>].bias.data</span><br><span class="line"><span class="comment">#输出：tensor([ 0.1999, -0.4073, -0.1200, -0.2033, -0.1573,  0.3546, -0.2141, -0.2483])</span></span><br></pre></td></tr></table></figure><hr><h3 id="参数初始化"><a href="#参数初始化" class="headerlink" title="参数初始化"></a>参数初始化</h3><p> 深度学习框架提供默认随机初始化， 也允许我们创建自定义初始化方法， 满足我们通过其他规则实现初始化权重。</p><p>默认情况下，PyTorch会根据一个范围均匀地初始化权重和偏置矩阵， 这个范围是根据输入和输出维度计算出的。 PyTorch的<code>nn.init</code>模块提供了多种预置初始化方法。</p><p><strong>内置初始化</strong></p><p>下面的代码将所有权重参数初始化为标准差为0.01的高斯随机变量， 且将偏置参数设置为0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_normal</span>(<span class="params">m</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(m) == nn.Linear:</span><br><span class="line">        nn.init.normal_(m.weight, mean=<span class="number">0</span>, std=<span class="number">0.01</span>)</span><br><span class="line">        nn.init.zeros_(m.bias)</span><br><span class="line">net.apply(init_normal)</span><br><span class="line">net[<span class="number">0</span>].weight.data[<span class="number">0</span>], net[<span class="number">0</span>].bias.data[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>我们还可以对某些块应用不同的初始化方法。 例如，下面我们使用Xavier初始化方法初始化第一个神经网络层， 然后将第三个神经网络层初始化为常量值42。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_xavier</span>(<span class="params">m</span>):</span></span><br><span class="line">    <span class="comment"># 检查m是否为线性层 (nn.Linear)</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(m) == nn.Linear:</span><br><span class="line">        <span class="comment"># 使用Xavier均匀初始化方法初始化权重</span></span><br><span class="line">        nn.init.xavier_uniform_(m.weight)</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_42</span>(<span class="params">m</span>):</span></span><br><span class="line">    <span class="comment"># 检查m是否为线性层 (nn.Linear)</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(m) == nn.Linear:</span><br><span class="line">        <span class="comment"># 将权重初始化为常数42</span></span><br><span class="line">        nn.init.constant_(m.weight, <span class="number">42</span>)</span><br><span class="line">  </span><br><span class="line">net[<span class="number">0</span>].apply(init_xavier)</span><br><span class="line">net[<span class="number">2</span>].apply(init_42)       </span><br></pre></td></tr></table></figure><hr><p><strong>自定义初始化</strong></p><p> 在下面的例子中，我们使用以下的分布为任意权重参数$w$定义初始化方法：</p><script type="math/tex; mode=display">\begin{split}\begin{aligned}    w \sim \begin{cases}        U(5, 10) & \text{ 可能性 } \frac{1}{4} \\            0    & \text{ 可能性 } \frac{1}{2} \\        U(-10, -5) & \text{ 可能性 } \frac{1}{4}    \end{cases}\end{aligned}\end{split}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_init</span>(<span class="params">m</span>):</span></span><br><span class="line">    <span class="comment"># 检查传入的模块 m 是否是线性层 (nn.Linear)</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(m) == nn.Linear:</span><br><span class="line">        <span class="comment"># 打印出线性层的参数名称和形状。这里使用了列表解析和 named_parameters 方法来获取参数，</span></span><br><span class="line">        <span class="comment"># 并且仅展示了第一个参数（通常是权重）的名称和形状。</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Init&quot;</span>, *[(name, param.shape)</span><br><span class="line">                        <span class="keyword">for</span> name, param <span class="keyword">in</span> m.named_parameters()][<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 使用均匀分布初始化权重，范围是 [-10, 10]。</span></span><br><span class="line">        nn.init.uniform_(m.weight, -<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 修改权重，只保留绝对值大于等于5的权重，其他的权重被设置为0。</span></span><br><span class="line">        <span class="comment"># 这是通过先计算 m.weight.data.abs() &gt;= 5 得到一个布尔型张量，</span></span><br><span class="line">        <span class="comment"># 然后用这个张量乘以 m.weight.data 实现的。</span></span><br><span class="line">        m.weight.data *= m.weight.data.<span class="built_in">abs</span>() &gt;= <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将自定义初始化函数 my_init 应用到网络的所有层上。</span></span><br><span class="line"><span class="comment"># apply 方法会递归地遍历所有子模块，并对每个子模块调用 my_init 函数。</span></span><br><span class="line">net.apply(my_init)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印出第一个线性层的前两个权重数据。</span></span><br><span class="line"><span class="comment"># 这里假设 net[0] 是一个 nn.Linear 层，并且我们感兴趣的是查看经过自定义初始化后的前两行权重值。</span></span><br><span class="line">net[<span class="number">0</span>].weight[:<span class="number">2</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h3><p>有时我们希望在多个层间共享参数： 我们可以定义一个<strong>全连接层</strong>，然后使用它的参数来设置另一个层的参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我们需要给共享层一个名称，以便可以引用它的参数</span></span><br><span class="line">shared = nn.Linear(<span class="number">8</span>, <span class="number">8</span>)  <span class="comment"># 定义一个共享的全连接层（稠密层），输入和输出特征数量都是8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个神经网络，其中包含了一个输入层，两个激活层，两次使用共享层，和一个输出层</span></span><br><span class="line">net = nn.Sequential(</span><br><span class="line">    nn.Linear(<span class="number">4</span>, <span class="number">8</span>),  <span class="comment"># 第一个全连接层，将输入特征从4维映射到8维</span></span><br><span class="line">    nn.ReLU(),  <span class="comment"># 第一个ReLU激活函数，引入非线性</span></span><br><span class="line">    shared,  <span class="comment"># 第一次使用共享层</span></span><br><span class="line">    nn.ReLU(),  <span class="comment"># 第二个ReLU激活函数</span></span><br><span class="line">    shared,  <span class="comment"># 第二次使用相同的共享层</span></span><br><span class="line">    nn.ReLU(),  <span class="comment"># 第三个ReLU激活函数</span></span><br><span class="line">    nn.Linear(<span class="number">8</span>, <span class="number">1</span>)  <span class="comment"># 输出层，将特征从8维映射到1维</span></span><br><span class="line">)</span><br><span class="line">net(X)  <span class="comment"># 将输入数据X通过网络进行前向传播</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查共享层的两个实例是否有相同的权重数据</span></span><br><span class="line"><span class="built_in">print</span>(net[<span class="number">2</span>].weight.data[<span class="number">0</span>] == net[<span class="number">4</span>].weight.data[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改共享层中的权重参数</span></span><br><span class="line">net[<span class="number">2</span>].weight.data[<span class="number">0</span>, <span class="number">0</span>] = <span class="number">100</span>  <span class="comment"># 将共享层的第一个权重修改为100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 确保共享层的修改影响到了所有引用该层的地方，证明它们实际上是同一个对象</span></span><br><span class="line"><span class="built_in">print</span>(net[<span class="number">2</span>].weight.data[<span class="number">0</span>] == net[<span class="number">4</span>].weight.data[<span class="number">0</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tensor([<span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>])</span><br><span class="line">tensor([<span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>])</span><br></pre></td></tr></table></figure><p>这个例子表明第三个和第五个神经网络层的参数是绑定的。 它们不仅值相等，而且由相同的张量表示。 因此，如果我们改变其中一个参数，另一个参数也会改变</p><hr><h2 id="延后初始化"><a href="#延后初始化" class="headerlink" title="延后初始化"></a>延后初始化</h2><p>深度学习框架无法判断网络的输入维度是什么。 这里的诀窍是框架的<strong><em>延后初始化</em></strong>（defers initialization）， 即直到数据第一次通过模型传递时，框架才会动态地推断出每个层的大小。</p><p>在以后，当使用卷积神经网络时， 由于输入维度（即图像的分辨率）将影响每个后续层的维数， 有了该技术将更加方便。 现在我们在编写代码时无须知道维度是什么就可以设置参数， 这种能力可以大大简化定义和修改模型的任务。 接下来，我们将更深入地研究初始化机制。</p><p><strong>实例化网络</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;延后初始化&quot;&quot;&quot;</span></span><br><span class="line">net = nn.Sequential(nn.LazyLinear(<span class="number">256</span>), nn.ReLU(), nn.LazyLinear(<span class="number">10</span>))</span><br><span class="line"><span class="comment"># print(net[0].weight)  # 尚未初始化</span></span><br><span class="line"><span class="built_in">print</span>(net)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时，因为输入维数是未知的，所以网络不可能知道输入层权重的维数。 因此，框架尚未初始化任何参数，我们通过尝试访问以下参数进行确认。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[net[i].state_dict() <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(net))]</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[OrderedDict([(<span class="string">&#x27;weight&#x27;</span>, &lt;UninitializedParameter&gt;),</span><br><span class="line">              (<span class="string">&#x27;bias&#x27;</span>, &lt;UninitializedParameter&gt;)]),</span><br><span class="line"> OrderedDict(),</span><br><span class="line"> OrderedDict([(<span class="string">&#x27;weight&#x27;</span>, &lt;UninitializedParameter&gt;),</span><br><span class="line">              (<span class="string">&#x27;bias&#x27;</span>, &lt;UninitializedParameter&gt;)])]</span><br></pre></td></tr></table></figure><p>请注意，每个层对象都存在，但权重为空。 使用<code>net.get_weights()</code>将抛出一个错误，因为权重尚未初始化。</p><p>接下来让我们将数据通过网络，最终使框架初始化参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X = torch.rand(<span class="number">2</span>, <span class="number">20</span>)</span><br><span class="line">net(X)</span><br><span class="line"><span class="built_in">print</span>(net)</span><br></pre></td></tr></table></figure><p>一旦我们知道输入维数是20，框架可以通过代入值20来识别第一层权重矩阵的形状。 识别出第一层的形状后，框架处理第二层，依此类推，直到所有形状都已知为止。 注意，在这种情况下，只有第一层需要延迟初始化，但是框架仍是按顺序初始化的。 等到知道了所有的参数形状，框架就可以初始化参数。</p><hr><h2 id="自定义层"><a href="#自定义层" class="headerlink" title="自定义层"></a>自定义层</h2><h3 id="不带参数的层"><a href="#不带参数的层" class="headerlink" title="不带参数的层"></a>不带参数的层</h3><p>下面的<code>CenteredLayer</code>类要从其输入中减去均值。 要构建它，我们只需继承基础层类并实现前向传播功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CenteredLayer</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, X</span>):</span></span><br><span class="line">        <span class="keyword">return</span> X - X.mean()</span><br></pre></td></tr></table></figure><p>现在，我们可以将层作为组件合并到更复杂的模型中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net = nn.Sequential(nn.Linear(<span class="number">8</span>, <span class="number">128</span>), CenteredLayer())</span><br></pre></td></tr></table></figure><hr><h3 id="带参数的层"><a href="#带参数的层" class="headerlink" title="带参数的层"></a>带参数的层</h3><p>我们继续定义具有参数的层， 这些参数可以通过训练进行调整。 我们可以使用内置函数来创建参数，这些函数提供一些基本的管理功能。 比如管理访问、初始化、共享、保存和加载模型参数。 这样做的好处之一是：我们不需要为每个自定义层编写自定义的序列化程序。</p><p>现在，让我们实现自定义版本的全连接层。 回想一下，该层需要两个参数，一个用于表示权重，另一个用于表示偏置项。 在此实现中，我们使用修正线性单元作为激活函数。 该层需要输入参数：<code>in_units</code>和<code>units</code>，分别表示输入数和输出数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个继承自nn.Module的自定义层，这样它就可以利用PyTorch的自动求导等功能</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinear</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="comment"># 类的初始化函数，接收输入特征数量（in_units）和输出特征数量（units）作为参数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, in_units, units</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()  <span class="comment"># 调用父类的初始化函数，进行必要的初始化操作</span></span><br><span class="line">        <span class="comment"># 创建一个参数，表示权重，使用正态分布随机初始化。权重的形状是[in_units, units]，</span></span><br><span class="line">        <span class="comment"># 这样它就可以和输入数据进行矩阵乘法操作</span></span><br><span class="line">        self.weight = nn.Parameter(torch.randn(in_units, units))</span><br><span class="line">        <span class="comment"># 创建一个参数，表示偏置，也使用正态分布随机初始化。偏置的形状是[units,]，</span></span><br><span class="line">        <span class="comment"># 每个输出特征都有一个对应的偏置</span></span><br><span class="line">        self.bias = nn.Parameter(torch.randn(units,))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义前向传播函数，接收输入X</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, X</span>):</span></span><br><span class="line">        <span class="comment"># 计算输入X和权重的矩阵乘法，然后加上偏置。注意这里直接使用了`.data`，</span></span><br><span class="line">        <span class="comment"># 通常不推荐这样做，因为这样会绕过PyTorch的自动求导，不会计算梯度</span></span><br><span class="line">        linear = torch.matmul(X, self.weight.data) + self.bias.data</span><br><span class="line">        <span class="comment"># 应用ReLU激活函数，将所有负值设为0，返回激活后的结果</span></span><br><span class="line">        <span class="keyword">return</span> F.relu(linear)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来，我们实例化<code>MyLinear</code>类并访问其模型参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">linear = MyLinear(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">linear.weight</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Parameter containing:</span><br><span class="line">tensor([[ <span class="number">0.1775</span>, -<span class="number">1.4539</span>,  <span class="number">0.3972</span>],</span><br><span class="line">        [-<span class="number">0.1339</span>,  <span class="number">0.5273</span>,  <span class="number">1.3041</span>],</span><br><span class="line">        [-<span class="number">0.3327</span>, -<span class="number">0.2337</span>, -<span class="number">0.6334</span>],</span><br><span class="line">        [ <span class="number">1.2076</span>, -<span class="number">0.3937</span>,  <span class="number">0.6851</span>],</span><br><span class="line">        [-<span class="number">0.4716</span>,  <span class="number">0.0894</span>, -<span class="number">0.9195</span>]], requires_grad=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>我们可以使用自定义层直接执行前向传播计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linear(torch.rand(<span class="number">2</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tensor([[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">        [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>]])</span><br></pre></td></tr></table></figure><p>我们还可以使用自定义层构建模型，就像使用内置的全连接层一样使用自定义层。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net = nn.Sequential(MyLinear(<span class="number">64</span>, <span class="number">8</span>), MyLinear(<span class="number">8</span>, <span class="number">1</span>))</span><br><span class="line">net(torch.rand(<span class="number">2</span>, <span class="number">64</span>))</span><br></pre></td></tr></table></figure><hr><h2 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h2><h3 id="加载和保存张量"><a href="#加载和保存张量" class="headerlink" title="加载和保存张量"></a>加载和保存张量</h3><p>对于单个张量，我们可以直接调用<code>load</code>和<code>save</code>函数分别读写它们。 这两个函数都要求我们提供一个名称，<code>save</code>要求将要保存的变量作为输入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line">x = torch.arange(<span class="number">4</span>)</span><br><span class="line">torch.save(x, <span class="string">&#x27;x-file&#x27;</span>)</span><br></pre></td></tr></table></figure><p>我们现在可以将存储在文件中的数据读回内存。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x2 = torch.load(<span class="string">&#x27;x-file&#x27;</span>)</span><br><span class="line">x2</span><br><span class="line"><span class="comment">#输出结果:tensor([0, 1, 2, 3])</span></span><br></pre></td></tr></table></figure><p>我们甚至可以写入或读取从字符串映射到张量的字典。 当我们要读取或写入模型中的所有权重时，这很方便。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mydict = &#123;<span class="string">&#x27;x&#x27;</span>: x, <span class="string">&#x27;y&#x27;</span>: y&#125;</span><br><span class="line">torch.save(mydict, <span class="string">&#x27;mydict&#x27;</span>)</span><br><span class="line">mydict2 = torch.load(<span class="string">&#x27;mydict&#x27;</span>)</span><br><span class="line">mydict2</span><br></pre></td></tr></table></figure><hr><h3 id="加载和保存模型参数"><a href="#加载和保存模型参数" class="headerlink" title="加载和保存模型参数"></a>加载和保存模型参数</h3><p>保存单个权重向量（或其他张量）确实有用， 但是如果我们想保存整个模型，并在以后加载它们， 单独保存每个向量则会变得很麻烦。 毕竟，我们可能有数百个参数散布在各处。 因此，深度学习框架提供了内置函数来保存和加载整个网络。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MLP</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.hidden = nn.Linear(<span class="number">20</span>, <span class="number">256</span>)</span><br><span class="line">        self.output = nn.Linear(<span class="number">256</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.output(F.relu(self.hidden(x)))</span><br><span class="line"></span><br><span class="line">net = MLP()</span><br><span class="line">X = torch.randn(size=(<span class="number">2</span>, <span class="number">20</span>))</span><br><span class="line">Y = net(X)</span><br></pre></td></tr></table></figure><p>接下来，我们将模型的参数存储在一个叫做“<code>mlp.params</code>”的文件中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.save(net.state_dict(), <span class="string">&#x27;mlp.params&#x27;</span>)</span><br></pre></td></tr></table></figure><p>为了恢复模型，我们实例化了原始多层感知机模型的一个备份。 这里我们不需要随机初始化模型参数，而是直接读取文件中存储的参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">clone = MLP()</span><br><span class="line">clone.load_state_dict(torch.load(<span class="string">&#x27;mlp.params&#x27;</span>))</span><br><span class="line">clone.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">输出结果：</span></span><br><span class="line"><span class="string">MLP(</span></span><br><span class="line"><span class="string">  (hidden): Linear(in_features=20, out_features=256, bias=True)</span></span><br><span class="line"><span class="string">  (output): Linear(in_features=256, out_features=10, bias=True)</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.0 多层感知机</title>
      <link href="/post/58837.html"/>
      <url>/post/58837.html</url>
      
        <content type="html"><![CDATA[<h1 id="多层感知机"><a href="#多层感知机" class="headerlink" title="多层感知机"></a>多层感知机</h1><p>多层感知机即MLP神经网络的定义已经在<a href="https://www.nightswatch.icu/post/40324.html">神经网络：表述</a>所详细描述过了，这一章主要描述在Pytorch中的实现</p><h2 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h2><p><em>激活函数</em>（activation function）通过计算加权和并加上偏置来确定神经元是否应该被激活， 它们将输入信号转换为输出的可微运算。 大多数激活函数都是非线性的。 由于激活函数是深度学习的基础，下面简要介绍一些常见的激活函数</p><p><strong>ReLU函数</strong></p><p>最受欢迎的激活函数是<em>修正线性单元</em>（Rectified linear unit，<em>ReLU</em>）， 因为它实现简单，同时在各种预测任务中表现良好。 ReLU提供了一种非常简单的非线性变换。 给定元素$x$，ReLU函数被定义为该元素与0的最大值</p><script type="math/tex; mode=display">ReLU(x)=max(x,0)</script><p>通俗地说，ReLU函数通过将相应的活性值设为0，仅保留正元素并丢弃所有负元素。 为了直观感受一下，我们可以画出函数的曲线图。 正如从图中所看到，激活函数是分段线性的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = torch.arange(-<span class="number">8.0</span>, <span class="number">8.0</span>, <span class="number">0.1</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">y = torch.relu(x)</span><br><span class="line">d2l.plot(x.detach(), y.detach(), <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;relu(x)&#x27;</span>, figsize=(<span class="number">5</span>, <span class="number">2.5</span>))</span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraoutput_mlp_76f463_21_0.svg" alt="../_images/output_mlp_76f463_21_0.svg"></p><p>当输入为负时，ReLU函数的导数为0，而当输入为正时，ReLU函数的导数为1。 注意，当输入值精确等于0时，ReLU函数不可导。 在此时，我们默认使用左侧的导数，即当输入为0时导数为0。 我们可以忽略这种情况，因为输入可能永远都不会是0</p><p>使用ReLU的原因是，它求导表现得特别好：要么让参数消失，要么让参数通过。 这使得优化表现得更好，并且ReLU减轻了困扰以往神经网络的<strong>梯度消失问题</strong></p><p>其他的激活函数，比如sigmoid函数之前已经介绍过了，所以略过</p><hr><h2 id="从零实现"><a href="#从零实现" class="headerlink" title="从零实现"></a>从零实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">256</span></span><br><span class="line">train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size)</span><br></pre></td></tr></table></figure><h3 id="初始化模型参数"><a href="#初始化模型参数" class="headerlink" title="初始化模型参数"></a>初始化模型参数</h3><p>Fashion-MNIST中的每个图像由 28×28=784个灰度像素值组成。 所有图像共分为10个类别。 忽略像素之间的空间结构， 我们可以将每个图像视为具有784个输入特征 和10个类的简单分类数据集。 首先，我们将实现一个具有单隐藏层的多层感知机， 它包含256个隐藏单元。 注意，我们可以将这两个变量都视为超参数。 通常，我们选择2的若干次幂作为层的宽度。 因为内存在硬件中的分配和寻址方式，这么做往往可以在计算上更高效。</p><p>我们用几个张量来表示我们的参数。 注意，对于每一层我们都要记录<strong>一个权重矩阵和一个偏置向量</strong>。 跟以前一样，我们要为损失关于这些参数的梯度分配内存。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">num_inputs, num_outputs, num_hiddens = <span class="number">784</span>, <span class="number">10</span>, <span class="number">256</span></span><br><span class="line"></span><br><span class="line">W1 = nn.Parameter(torch.randn(num_inputs, num_hiddens, requires_grad=<span class="literal">True</span>) * <span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line">b1 = nn.Parameter(torch.zeros(num_hiddens, requires_grad=<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line">W2 = nn.Parameter(torch.randn(num_hiddens, num_outputs, requires_grad=<span class="literal">True</span>) * <span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line">b2 = nn.Parameter(torch.zeros(num_outputs, requires_grad=<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line">params = [W1, b1, W2, b2]</span><br></pre></td></tr></table></figure><hr><h3 id="激活函数-1"><a href="#激活函数-1" class="headerlink" title="激活函数"></a>激活函数</h3><p>RELU函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">relu</span>(<span class="params">X</span>):</span></span><br><span class="line">    a = torch.zeros_like(X)</span><br><span class="line">    <span class="keyword">return</span> torch.<span class="built_in">max</span>(X, a)</span><br></pre></td></tr></table></figure><hr><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>因为我们忽略了空间结构， 所以我们使用<code>reshape</code>将每个二维图像转换为一个长度为<code>num_inputs</code>的向量。 只需几行代码就可以实现我们的模型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">net</span>(<span class="params">X</span>):</span></span><br><span class="line">    X = X.reshape((-<span class="number">1</span>, num_inputs))</span><br><span class="line">    H = relu(X@W1 + b1)  <span class="comment"># 这里“@”代表矩阵乘法</span></span><br><span class="line">    <span class="keyword">return</span> (H@W2 + b2)</span><br></pre></td></tr></table></figure><hr><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loss = nn.CrossEntropyLoss(reduction=<span class="string">&#x27;none&#x27;</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p>直接调用<code>d2l</code>包的<code>train_ch3</code>函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num_epochs, lr = <span class="number">10</span>, <span class="number">0.1</span></span><br><span class="line">updater = torch.optim.SGD(params, lr=lr)</span><br><span class="line">d2l.train_ch3(net, train_iter, test_iter, loss, num_epochs, updater)</span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoratyporaoutput_mlp-scratch_106d07_81_0.svg" alt="../_images/output_mlp-scratch_106d07_81_0.svg"></p><hr><h2 id="简洁实现"><a href="#简洁实现" class="headerlink" title="简洁实现"></a>简洁实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br></pre></td></tr></table></figure><p>与softmax回归的简洁实现相比， 唯一的区别是我们添加了2个全连接层（之前我们只添加了1个全连接层）。 第一层是隐藏层，它包含256个隐藏单元，并使用了ReLU激活函数。 第二层是输出层。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">net = nn.Sequential(nn.Flatten(),</span><br><span class="line">                    nn.Linear(<span class="number">784</span>, <span class="number">256</span>),</span><br><span class="line">                    nn.ReLU(),</span><br><span class="line">                    nn.Linear(<span class="number">256</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_weights</span>(<span class="params">m</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(m) == nn.Linear:</span><br><span class="line">        nn.init.normal_(m.weight, std=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line">net.apply(init_weights);</span><br></pre></td></tr></table></figure><ul><li><code>nn.Sequential</code>是一个容器，按照在其中添加模块的顺序执行这些模块。这允许你快速地堆叠不同的层来构建神经网络。</li><li><code>nn.Flatten()</code>层将输入的二维图像张量自动展平成一维张量，以便后续的全连接层（<code>nn.Linear</code>）可以处理它们。</li><li><code>nn.Linear(784, 256)</code>定义了一个全连接层，它接受784个输入特征并输出256个特征。这些特征数对应于隐藏层的神经元数量。</li><li><code>nn.ReLU()</code>是一个非线性激活函数，用于引入非线性，使得网络可以学习复杂的模式。</li><li><code>nn.Linear(256, 10)</code>定义了第二个全连接层，它将隐藏层的256个特征映射到10个输出特征，这10个特征对应于分类任务的类别数量。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">batch_size, lr, num_epochs = <span class="number">256</span>, <span class="number">0.1</span>, <span class="number">10</span></span><br><span class="line">loss = nn.CrossEntropyLoss(reduction=<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">trainer = torch.optim.SGD(net.parameters(), lr=lr)</span><br><span class="line"></span><br><span class="line">train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size)</span><br><span class="line">d2l.train_ch3(net, train_iter, test_iter, loss, num_epochs, trainer)</span><br></pre></td></tr></table></figure><hr><h2 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h2><p>在训练参数化机器学习模型时， <em>权重衰减</em>（weight decay）是最广泛使用的正则化的技术之一， 它通常也被称为$L_2$<em>正则化</em>。 这项技术通过函数与零的距离来衡量函数的复杂度， 因为在所有函数$f$中，函数$f=0$（所有输入都得到值0） 在某种意义上是最简单的</p><p>首先，我们将定义一个函数来随机初始化模型参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_params</span>():</span></span><br><span class="line">    w = torch.normal(<span class="number">0</span>, <span class="number">1</span>, size=(num_inputs, <span class="number">1</span>), requires_grad=<span class="literal">True</span>)</span><br><span class="line">    b = torch.zeros(<span class="number">1</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> [w, b]</span><br></pre></td></tr></table></figure><p>定义$L_2$范数惩罚</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">l2_penalty</span>(<span class="params">w</span>):</span></span><br><span class="line">    <span class="keyword">return</span> torch.<span class="built_in">sum</span>(w.<span class="built_in">pow</span>(<span class="number">2</span>)) / <span class="number">2</span></span><br></pre></td></tr></table></figure><p>定义训练代码实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">lambd</span>):</span></span><br><span class="line">    w, b = init_params()</span><br><span class="line">    net, loss = <span class="keyword">lambda</span> X: d2l.linreg(X, w, b), d2l.squared_loss</span><br><span class="line">    num_epochs, lr = <span class="number">100</span>, <span class="number">0.003</span></span><br><span class="line">    animator = d2l.Animator(xlabel=<span class="string">&#x27;epochs&#x27;</span>, ylabel=<span class="string">&#x27;loss&#x27;</span>, yscale=<span class="string">&#x27;log&#x27;</span>,</span><br><span class="line">                            xlim=[<span class="number">5</span>, num_epochs], legend=[<span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;test&#x27;</span>])</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> train_iter:</span><br><span class="line">            <span class="comment"># 增加了L2范数惩罚项，</span></span><br><span class="line">            <span class="comment"># 广播机制使l2_penalty(w)成为一个长度为batch_size的向量</span></span><br><span class="line">            l = loss(net(X), y) + lambd * l2_penalty(w)</span><br><span class="line">            l.<span class="built_in">sum</span>().backward()</span><br><span class="line">            d2l.sgd([w, b], lr, batch_size)</span><br><span class="line">        <span class="keyword">if</span> (epoch + <span class="number">1</span>) % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">            animator.add(epoch + <span class="number">1</span>, (d2l.evaluate_loss(net, train_iter, loss),</span><br><span class="line">                                     d2l.evaluate_loss(net, test_iter, loss)))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;w的L2范数是：&#x27;</span>, torch.norm(w).item())</span><br></pre></td></tr></table></figure><p>先采用<code>lambd=0</code>禁用权重衰减</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train(lambd=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>w的L2范数是：12.963241577148438</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraoutput_weight-decay_ec9cc0_81_1.svg" alt="../_images/output_weight-decay_ec9cc0_81_1.svg"></p><p>然后使用<code>lambd=3</code>来运行代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train(lambd=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>w的L2范数是： 0.3556520938873291</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraoutput_weight-decay_ec9cc0_96_1.svg" alt="../_images/output_weight-decay_ec9cc0_96_1.svg"></p><hr><p><strong>简洁代码实现</strong></p><p>由于权重衰减在神经网络优化中很常用， 深度学习框架为了便于我们使用权重衰减， 将权重衰减集成到优化算法中，以便与任何损失函数结合使用。 此外，这种集成还有计算上的好处， 允许在不增加任何额外的计算开销的情况下向算法中添加权重衰减。 由于更新的权重衰减部分仅依赖于每个参数的当前值， 因此优化器必须至少接触每个参数一次。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_concise</span>(<span class="params">wd</span>):</span></span><br><span class="line">    <span class="comment"># 创建一个简单的线性模型</span></span><br><span class="line">    net = nn.Sequential(nn.Linear(num_inputs, <span class="number">1</span>))</span><br><span class="line">    <span class="comment"># 初始化模型参数</span></span><br><span class="line">    <span class="keyword">for</span> param <span class="keyword">in</span> net.parameters():</span><br><span class="line">        param.data.normal_()</span><br><span class="line">    <span class="comment"># 使用均方误差作为损失函数</span></span><br><span class="line">    loss = nn.MSELoss(reduction=<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">    <span class="comment"># 设置训练的轮数和学习率</span></span><br><span class="line">    num_epochs, lr = <span class="number">100</span>, <span class="number">0.003</span></span><br><span class="line">    <span class="comment"># 配置优化器，为权重参数应用L2正则化，但偏置参数不应用衰减</span></span><br><span class="line">    trainer = torch.optim.SGD([</span><br><span class="line">        &#123;<span class="string">&quot;params&quot;</span>:net[<span class="number">0</span>].weight,<span class="string">&#x27;weight_decay&#x27;</span>: wd&#125;,  <span class="comment"># 为权重参数应用权重衰减</span></span><br><span class="line">        &#123;<span class="string">&quot;params&quot;</span>:net[<span class="number">0</span>].bias&#125;], lr=lr)  <span class="comment"># 偏置参数没有衰减</span></span><br><span class="line">    <span class="comment"># 用于绘图的实用工具</span></span><br><span class="line">    animator = d2l.Animator(xlabel=<span class="string">&#x27;epochs&#x27;</span>, ylabel=<span class="string">&#x27;loss&#x27;</span>, yscale=<span class="string">&#x27;log&#x27;</span>,</span><br><span class="line">                            xlim=[<span class="number">5</span>, num_epochs], legend=[<span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;test&#x27;</span>])</span><br><span class="line">    <span class="comment"># 训练循环</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> train_iter:</span><br><span class="line">            trainer.zero_grad()  <span class="comment"># 清除之前的梯度</span></span><br><span class="line">            l = loss(net(X), y)  <span class="comment"># 计算当前批次的损失</span></span><br><span class="line">            l.mean().backward()  <span class="comment"># 反向传播</span></span><br><span class="line">            trainer.step()  <span class="comment"># 更新模型参数</span></span><br><span class="line">        <span class="comment"># 每5个epoch评估一次模型的训练和测试损失，并更新绘图</span></span><br><span class="line">        <span class="keyword">if</span> (epoch + <span class="number">1</span>) % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">            animator.add(epoch + <span class="number">1</span>,</span><br><span class="line">                         (d2l.evaluate_loss(net, train_iter, loss),</span><br><span class="line">                          d2l.evaluate_loss(net, test_iter, loss)))</span><br><span class="line">    <span class="comment"># 打印权重的L2范数，以观察权重大小</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;w的L2范数：&#x27;</span>, net[<span class="number">0</span>].weight.norm().item())</span><br></pre></td></tr></table></figure><p>这段代码演示了如何使用PyTorch的高级API来实现带有权重衰减的模型训练过程。通过<code>torch.optim.SGD</code>配置中的<code>weight_decay</code>参数，我们可以为模型的权重参数添加L2正则化，而通过将偏置参数单独列出并不为其设置<code>weight_decay</code>，我们避免了对偏置参数应用权重衰减，这是因为偏置参数的正则化通常对控制模型复杂度的影响较小，而且可能会导致过度正则化的问题。整个训练过程中，我们定期评估模型在训练集和测试集上的损失，以监控模型的学习进度。</p><hr><h2 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>丢弃法（Dropout）是一种在深度学习中常用的正则化技术，由Hinton和他的学生在2012年提出。它被广泛应用于减少神经网络在训练过程中的过拟合。过拟合是机器学习模型面临的常见问题，发生在模型对训练数据学得太好，以至于失去了泛化到未见数据的能力。</p><p>丢弃法的工作原理相当直接：在训练过程中，通过随机选择忽略网络中的一部分神经元，即在每个训练批次中，每个神经元都有一定概率被暂时从网络中丢弃，不参与这次前向和后向传播过程。这个概率通常是一个超参数，由开发者设置。被丢弃的神经元不会在这次迭代中进行权重更新</p><p>标准暂退法正则化中，通过按保留（未丢弃）的节点的分数进行规范化来消除每一层的偏差。 换言之，每个中间活性值ℎ以<em>暂退概率p</em>由随机变量ℎ′替换，如下所示：</p><script type="math/tex; mode=display">\begin{split}\begin{aligned}h' =\begin{cases}    0 & \text{ 概率为 } p \\    \frac{h}{1-p} & \text{ 其他情况}\end{cases}\end{aligned}\end{split}</script><p>根据此模型的设计，其期望值保持不变</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoradropout2.svg" alt="../_images/dropout2.svg"></p><hr><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dropout_layer</span>(<span class="params">X, dropout</span>):</span></span><br><span class="line">    <span class="comment"># 确保dropout概率值在0到1之间</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="number">0</span> &lt;= dropout &lt;= <span class="number">1</span></span><br><span class="line">    <span class="comment"># 如果dropout概率为1，意味着丢弃所有元素，直接返回一个全0的张量</span></span><br><span class="line">    <span class="keyword">if</span> dropout == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> torch.zeros_like(X)</span><br><span class="line">    <span class="comment"># 如果dropout概率为0，意味着保留所有元素，直接返回输入张量</span></span><br><span class="line">    <span class="keyword">if</span> dropout == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> X</span><br><span class="line">    <span class="comment"># 生成一个随机张量，其形状与输入X相同，元素值介于0到1之间</span></span><br><span class="line">    mask = (torch.rand(X.shape) &gt; dropout).<span class="built_in">float</span>()</span><br><span class="line">    <span class="comment"># 应用生成的mask来随机丢弃一部分元素，通过与mask相乘实现</span></span><br><span class="line">    <span class="comment"># 然后对剩下的元素进行缩放，以保持其总体期望值不变</span></span><br><span class="line">    <span class="keyword">return</span> mask * X / (<span class="number">1.0</span> - dropout)</span><br></pre></td></tr></table></figure><ul><li><p><code>mask = (torch.rand(X.shape) &gt; dropout).float()</code></p><p>这行生成一个随机张量，其形状与<code>X</code>相同，元素值在0到1之间。然后，将这个随机张量与<code>dropout</code>概率进行比较，得到一个布尔张量（True表示元素值大于<code>dropout</code>概率，即这个神经元应该保留；False表示元素值小于或等于<code>dropout</code>概率，即这个神经元应该丢弃）。通过调用<code>.float()</code>将布尔张量转换为浮点张量（1.0表示保留，0.0表示丢弃）。</p></li><li><p><code>return mask * X / (1.0 - dropout)</code></p><p>使用生成的<code>mask</code>与输入<code>X</code>进行元素乘法，实现了随机丢弃神经元的效果。丢弃的神经元对应的元素会变为0。此外，对剩余的元素进行了缩放，即除以<code>(1.0 - dropout)</code>，这是为了在训练过程中保持输入的总体期望值不变，因为在测试时，我们不会应用丢弃法，所有神经元都参与计算。</p></li></ul><hr><p><strong>定义模型参数</strong></p><p>使用引入的Fashion-MNIST数据集。 我们定义具有两个隐藏层的多层感知机，每个隐藏层包含256个单元。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">num_inputs, num_outputs, num_hiddens1, num_hiddens2 = <span class="number">784</span>, <span class="number">10</span>, <span class="number">256</span>, <span class="number">256</span></span><br></pre></td></tr></table></figure><p><strong>定义模型</strong></p><p>我们可以将暂退法应用于每个隐藏层的输出（在激活函数之后）， 并且可以为每一层分别设置暂退概率： 常见的技巧是在靠近输入层的地方设置较低的暂退概率。 下面的模型将第一个和第二个隐藏层的暂退概率分别设置为0.2和0.5， 并且暂退法只在训练期间有效。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义两个丢弃率：对于第一个隐藏层是20%，对于第二个隐藏层是50%</span></span><br><span class="line">dropout1, dropout2 = <span class="number">0.2</span>, <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义神经网络类Net，继承自nn.Module</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="comment"># 初始化网络结构</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, num_inputs, num_outputs, num_hiddens1, num_hiddens2,</span></span></span><br><span class="line"><span class="params"><span class="function">                 is_training = <span class="literal">True</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()  <span class="comment"># 调用父类的初始化方法</span></span><br><span class="line">        self.num_inputs = num_inputs  <span class="comment"># 输入层的维度</span></span><br><span class="line">        self.training = is_training  <span class="comment"># 标记是否为训练模式</span></span><br><span class="line">        <span class="comment"># 定义第一个隐藏层，连接输入层和第一个隐藏层</span></span><br><span class="line">        self.lin1 = nn.Linear(num_inputs, num_hiddens1)</span><br><span class="line">        <span class="comment"># 定义第二个隐藏层，连接第一个和第二个隐藏层</span></span><br><span class="line">        self.lin2 = nn.Linear(num_hiddens1, num_hiddens2)</span><br><span class="line">        <span class="comment"># 定义输出层，连接第二个隐藏层和输出层</span></span><br><span class="line">        self.lin3 = nn.Linear(num_hiddens2, num_outputs)</span><br><span class="line">        <span class="comment"># 定义ReLU激活函数</span></span><br><span class="line">        self.relu = nn.ReLU()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义模型的前向传播路径</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, X</span>):</span></span><br><span class="line">        <span class="comment"># 将输入数据X通过第一个全连接层，然后应用ReLU激活函数</span></span><br><span class="line">        H1 = self.relu(self.lin1(X.reshape((-<span class="number">1</span>, self.num_inputs))))</span><br><span class="line">        <span class="comment"># 如果是训练模式，对第一个隐藏层的输出应用丢弃法</span></span><br><span class="line">        <span class="keyword">if</span> self.training == <span class="literal">True</span>:</span><br><span class="line">            H1 = dropout_layer(H1, dropout1)</span><br><span class="line">        <span class="comment"># 将处理过的数据通过第二个全连接层，然后应用ReLU激活函数</span></span><br><span class="line">        H2 = self.relu(self.lin2(H1))</span><br><span class="line">        <span class="comment"># 如果是训练模式，对第二个隐藏层的输出应用丢弃法</span></span><br><span class="line">        <span class="keyword">if</span> self.training == <span class="literal">True</span>:</span><br><span class="line">            H2 = dropout_layer(H2, dropout2)</span><br><span class="line">        <span class="comment"># 将处理过的数据通过输出层得到最终输出</span></span><br><span class="line">        out = self.lin3(H2)</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化网络模型，指定输入、输出和隐藏层的维度</span></span><br><span class="line">net = Net(num_inputs, num_outputs, num_hiddens1, num_hiddens2)</span><br></pre></td></tr></table></figure><p>这个网络模型通过在两个隐藏层后应用丢弃法来防止过拟合。在训练过程中，每一层的某些神经元输出会以一定概率（<code>dropout1</code>和<code>dropout2</code>定义的）被随机丢弃</p><hr><p><strong>训练与测试</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num_epochs, lr, batch_size = <span class="number">10</span>, <span class="number">0.5</span>, <span class="number">256</span></span><br><span class="line">loss = nn.CrossEntropyLoss(reduction=<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size)</span><br><span class="line">trainer = torch.optim.SGD(net.parameters(), lr=lr)</span><br><span class="line">d2l.train_ch3(net, train_iter, test_iter, loss, num_epochs, trainer)</span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraoutput_dropout_1110bf_66_0.svg" alt="../_images/output_dropout_1110bf_66_0.svg"></p><hr><h3 id="简洁实现-1"><a href="#简洁实现-1" class="headerlink" title="简洁实现"></a>简洁实现</h3><p>对于深度学习框架的高级API，我们只需在每个全连接层之后添加一个<code>Dropout</code>层， 将暂退概率作为唯一的参数传递给它的构造函数。 在训练时，<code>Dropout</code>层将根据指定的暂退概率随机丢弃上一层的输出（相当于下一层的输入）。 在测试时，<code>Dropout</code>层仅传递数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">net = nn.Sequential(nn.Flatten(),</span><br><span class="line">        nn.Linear(<span class="number">784</span>, <span class="number">256</span>),</span><br><span class="line">        nn.ReLU(),</span><br><span class="line">        <span class="comment"># 在第一个全连接层之后添加一个dropout层</span></span><br><span class="line">        nn.Dropout(dropout1),</span><br><span class="line">        nn.Linear(<span class="number">256</span>, <span class="number">256</span>),</span><br><span class="line">        nn.ReLU(),</span><br><span class="line">        <span class="comment"># 在第二个全连接层之后添加一个dropout层</span></span><br><span class="line">        nn.Dropout(dropout2),</span><br><span class="line">        nn.Linear(<span class="number">256</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_weights</span>(<span class="params">m</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(m) == nn.Linear:</span><br><span class="line">        nn.init.normal_(m.weight, std=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line">net.apply(init_weights);</span><br></pre></td></tr></table></figure><hr><h2 id="梯度爆炸和消失"><a href="#梯度爆炸和消失" class="headerlink" title="梯度爆炸和消失"></a>梯度爆炸和消失</h2><h3 id="梯度消失"><a href="#梯度消失" class="headerlink" title="梯度消失"></a>梯度消失</h3><p>梯度消失问题发生在深度网络的梯度在反向传播过程中变得非常小，几乎为零。这意味着网络权重的更新非常微小，甚至不会发生，使得网络很难学习和改进。梯度消失通常发生在使用了像<code>Sigmoid</code>或<code>Tanh</code>这样的激活函数的深度网络中，因为这些激活函数的导数在输入值非常高或非常低时趋于0。</p><h3 id="梯度爆炸"><a href="#梯度爆炸" class="headerlink" title="梯度爆炸"></a>梯度爆炸</h3><p>梯度爆炸问题是指在网络的反向传播过程中，梯度变得异常大。这会导致权重更新过大，使得网络权重变得非常不稳定，最终可能导致模型无法收敛，或者在训练过程中出现数值计算上的溢出。梯度爆炸通常发生在深度网络中，尤其是当网络架构很复杂，或者使用了不适当的权重初始化策略时。</p><hr><h3 id="权重初始化"><a href="#权重初始化" class="headerlink" title="权重初始化"></a>权重初始化</h3><p>Xavier初始化，是一种特定的参数初始化方法，旨在解决梯度消失和梯度爆炸的问题，特别是在使用$Sigmoid$或$Tanh$激活函数时。</p><p>Xavier初始化的基本思想是保持输入和输出的方差一致，以确保所有层中的梯度都有适当的尺度。这通过根据前一层的连接数自动调整权重的尺度来实现。</p><p>具体来说，对于任意给定的层，Xavier初始化方法将权重初始化为从均匀分布或正态分布中抽取的值，其中均匀分布的范围是$([-a, a])$，正态分布的标准差是($\sigma$)。这里的(a)和($\sigma$)计算如下：</p><ul><li>均匀分布的情况下，$(a = \sqrt{\frac{6}{n_{\text{in}} + n_{\text{out}}}})$，其中$(n_{\text{in}})$是层的输入单元数，$(n_{\text{out}})$是层的输出单元数。</li><li>正态分布的情况下，$\sigma = \sqrt{\frac{2}{n_{\text{in}} + n_{\text{out}}}}$。</li></ul><p>这样的初始化方法可以在训练初期防止梯度过小或过大，有助于加快收敛速度，提高模型训练的稳定性。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.0 softmax回归</title>
      <link href="/post/56727.html"/>
      <url>/post/56727.html</url>
      
        <content type="html"><![CDATA[<h1 id="softmax回归"><a href="#softmax回归" class="headerlink" title="softmax回归"></a>softmax回归</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Softmax回归，也常被称为多项Logistic回归，是Logistic回归模型在多类分类问题上的推广。它主要用于处理多分类问题，其中类别数大于2。Softmax回归模型能够给出一个对象属于每个类别的概率，并且这些概率的总和为1。这使得Softmax回归成为处理多类别直接选择问题的一个自然选择。</p><p>在之前的机器学习中已经学习过<a href="https://www.nightswatch.icu/post/62980.html">logistic回归</a>了，而<code>logistic</code>回归是<code>softmax</code>回归的一种特殊形式，即$n=2$的情况</p><p>对于输入数据$\{(x_1,y_1),(x_2,y_2),\ldots,(x_m,y_m)\}$有$k$个类别，即$y_i \in \{1,2,\ldots,k\}$，那么softmax回归主要估算输入数据$x_i$归属每一类的概率，即：</p><script type="math/tex; mode=display">h_{\theta}\left(x_i\right)=\left[\begin{array}{c}{p\left(y_i=1 | x_i ; \theta\right)} \\ {p\left(y_i=2 | x_i ; \theta\right)} \\ {\vdots} \\ {p\left(y_i=k | x_i ; \theta\right)}\end{array}\right]=\frac{1}{\sum_{j=1}^{k} e^{\theta_{j}^{T} x_i}}\left[\begin{array}{c}{e^{\theta_{1}^{T} x_i}} \\ {e^{\theta_{2}^{T} x_i}} \\ {\vdots} \\ {e^{\theta_{k}^{T} x_i}}\end{array}\right] \\</script><p>其中，$\theta_1,\theta_2,\ldots,\theta_k \in \theta$是模型的参数，乘以$\frac{1}{\sum_{j=1}^{k} e^{\theta_{j}^{T} x_i}}$是为了让概率位于$[0,1]$并且概率之和为 1，softmax 回归将输入数据 $x_i$归属于类别 $j$的概率为</p><script type="math/tex; mode=display">p\left(y_i=j | x_i ; \theta\right)=\frac{e^{\theta_{j}^{T} x_i}}{\sum_{l=1}^{k} e^{\theta_{l}^{T} x_i}} \\</script><hr><h3 id="矢量化"><a href="#矢量化" class="headerlink" title="矢量化"></a>矢量化</h3><p>为了提高计算效率并且充分利用GPU，我们通常会对小批量样本的数据执行矢量计算。</p><p>假设我们读取了一个批量的样本$\mathbf{X}$，其中特征维度（输入数量）为$d$，批量大小为$n$。</p><p>此外，假设我们在输出中有$q$个类别。</p><p>那么小批量样本的特征为$\mathbf{X} \in \mathbb{R}^{n \times d}$，</p><p>权重为$\mathbf{W} \in \mathbb{R}^{d \times q}$，</p><p>偏置为$\mathbf{b} \in \mathbb{R}^{1\times q}$。</p><p>softmax回归的矢量计算表达式为：</p><script type="math/tex; mode=display"> \begin{aligned} \mathbf{O} &= \mathbf{X} \mathbf{W} + \mathbf{b}, \\ \hat{\mathbf{Y}} & = \mathrm{softmax}(\mathbf{O}) \end{aligned}</script><p>相对于一次处理一个样本，小批量样本的矢量化加快了$\mathbf{X}$和$\mathbf{W}$的矩阵-向量乘法。由于$\mathbf{X}$中的每一行代表一个数据样本，那么softmax运算可以<strong>按行</strong>执行：对于$\mathbf{O}$的每一行，我们先对所有项进行幂运算，然后通过求和对它们进行标准化。</p><p>$\mathbf{X} \mathbf{W} + \mathbf{b}$的求和会使用广播机制，小批量的未规范化预测$\mathbf{O}$和输出概率$\hat{\mathbf{Y}}$都是形状为$n \times q$的矩阵。</p><hr><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>softmax函数给出了一个向量$\hat{\mathbf{y}}$，我们可以将其视为“对给定任意输入$\mathbf{x}$的每个类的条件概率”。</p><p>例如，$\hat{y}_1$=$P(y=\text{猫} \mid \mathbf{x})$。</p><p>假设整个数据集$\{\mathbf{X}, \mathbf{Y}\}$具有$n$个样本，其中索引$i$的样本由特征向量$\mathbf{x}^{(i)}$和独热标签向量$\mathbf{y}^{(i)}$组成。</p><p>我们可以将估计值与实际值进行比较：</p><script type="math/tex; mode=display">P(\mathbf{Y} \mid \mathbf{X}) = \prod_{i=1}^n P(\mathbf{y}^{(i)} \mid \mathbf{x}^{(i)}).</script><p>根据最大似然估计，我们最大化$P(\mathbf{Y} \mid \mathbf{X})$，相当于最小化负对数似然：</p><script type="math/tex; mode=display">-\log P(\mathbf{Y} \mid \mathbf{X}) = \sum_{i=1}^n -\log P(\mathbf{y}^{(i)} \mid \mathbf{x}^{(i)})= \sum_{i=1}^n l(\mathbf{y}^{(i)}, \hat{\mathbf{y}}^{(i)})</script><p>其中，对于任何标签$\mathbf{y}$和模型预测$\hat{\mathbf{y}}$，损失函数为：</p><script type="math/tex; mode=display">l(\mathbf{y}, \hat{\mathbf{y}}) = - \sum_{j=1}^q y_j \log \hat{y}_j</script><hr><h3 id="导数"><a href="#导数" class="headerlink" title="导数"></a>导数</h3><p>由于softmax和相关的损失函数很常见，因此我们需要更好地理解它的计算方式。</p><p>利用softmax的定义，我们得到：</p><script type="math/tex; mode=display">\begin{aligned}l(\mathbf{y}, \hat{\mathbf{y}}) &=  - \sum_{j=1}^q y_j \log \frac{\exp(o_j)}{\sum_{k=1}^q \exp(o_k)} \\&= \sum_{j=1}^q y_j \log \sum_{k=1}^q \exp(o_k) - \sum_{j=1}^q y_j o_j\\&= \log \sum_{k=1}^q \exp(o_k) - \sum_{j=1}^q y_j o_j.\end{aligned}</script><p>考虑相对于任何未规范化的预测$o_j$的导数，我们得到：</p><script type="math/tex; mode=display">\partial_{o_j} l(\mathbf{y}, \hat{\mathbf{y}}) = \frac{\exp(o_j)}{\sum_{k=1}^q \exp(o_k)} - y_j = \mathrm{softmax}(\mathbf{o})_j - y_j.</script><p>换句话说，导数是我们<code>softmax</code>模型分配的概率与实际发生的情况（由独热标签向量表示）之间的<strong>差异</strong>。</p><p>从这个意义上讲，这与我们在回归中看到的非常相似，其中梯度是观测值$y$和估计值$\hat{y}$之间的差异。</p><hr><h2 id="图像分类数据集"><a href="#图像分类数据集" class="headerlink" title="图像分类数据集"></a>图像分类数据集</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch.utils <span class="keyword">import</span> data</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line">d2l.use_svg_display()</span><br></pre></td></tr></table></figure><p>通过框架中的内置函数将Fashion-MNIST数据集下载并读取到内存中。</p><h3 id="读取数据集"><a href="#读取数据集" class="headerlink" title="读取数据集"></a>读取数据集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过ToTensor实例将图像数据从PIL类型变换成32位浮点数格式，</span></span><br><span class="line"><span class="comment"># 并除以255使得所有像素的数值均在0～1之间</span></span><br><span class="line"><span class="comment"># 这个步骤通常是对图像数据进行预处理的标准步骤，因为它有助于神经网络更好地学习图像特征。</span></span><br><span class="line">trans = transforms.ToTensor()</span><br><span class="line">mnist_train = torchvision.datasets.FashionMNIST(</span><br><span class="line">    root=<span class="string">&quot;../data&quot;</span>, train=<span class="literal">True</span>, transform=trans, download=<span class="literal">True</span>)</span><br><span class="line">mnist_test = torchvision.datasets.FashionMNIST(</span><br><span class="line">    root=<span class="string">&quot;../data&quot;</span>, train=<span class="literal">False</span>, transform=trans, download=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>Fashion-MNIST由10个类别的图像组成， 每个类别由<em>训练数据集</em>（train dataset）中的6000张图像 和<em>测试数据集</em>（test dataset）中的1000张图像组成。 因此，训练集和测试集分别包含60000和10000张图像。 测试数据集不会用于训练，只用于评估模型性能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">len</span>(mnist_train), <span class="built_in">len</span>(mnist_test)</span><br></pre></td></tr></table></figure><p>输出结果是(60000,10000)，每个输入图像的高度和宽度均为28像素。 数据集由灰度图像组成，其通道数为1。 </p><p>Fashion-MNIST中包含的10个类别，分别为t-shirt（T恤）、trouser（裤子）、pullover（套衫）、dress（连衣裙）、coat（外套）、sandal（凉鞋）、shirt（衬衫）、sneaker（运动鞋）、bag（包）和ankle boot（短靴）。 以下函数用于在数字标签索引及其文本名称之间进行转换。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_fashion_mnist_labels</span>(<span class="params">labels</span>):</span>  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回Fashion-MNIST数据集的文本标签&quot;&quot;&quot;</span></span><br><span class="line">    text_labels = [<span class="string">&#x27;t-shirt&#x27;</span>, <span class="string">&#x27;trouser&#x27;</span>, <span class="string">&#x27;pullover&#x27;</span>, <span class="string">&#x27;dress&#x27;</span>, <span class="string">&#x27;coat&#x27;</span>,</span><br><span class="line">                   <span class="string">&#x27;sandal&#x27;</span>, <span class="string">&#x27;shirt&#x27;</span>, <span class="string">&#x27;sneaker&#x27;</span>, <span class="string">&#x27;bag&#x27;</span>, <span class="string">&#x27;ankle boot&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> [text_labels[<span class="built_in">int</span>(i)] <span class="keyword">for</span> i <span class="keyword">in</span> labels]</span><br></pre></td></tr></table></figure><p>现在可以创建一个函数来可视化这些样本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_images</span>(<span class="params">imgs, num_rows, num_cols, titles=<span class="literal">None</span>, scale=<span class="number">1.5</span></span>):</span>  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    绘制图像列表。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    imgs: 一个图像集合，可以是PIL图像或者是PyTorch张量。</span></span><br><span class="line"><span class="string">    num_rows: 要显示的行数。</span></span><br><span class="line"><span class="string">    num_cols: 要显示的列数。</span></span><br><span class="line"><span class="string">    titles: （可选）一个标题列表，用于每张图像。</span></span><br><span class="line"><span class="string">    scale: （可选）图像显示的缩放比例，默认为1.5。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 计算整个画布的大小</span></span><br><span class="line">    figsize = (num_cols * scale, num_rows * scale)</span><br><span class="line">    <span class="comment"># 创建一个子图序列</span></span><br><span class="line">    _, axes = d2l.plt.subplots(num_rows, num_cols, figsize=figsize)</span><br><span class="line">    <span class="comment"># 将axes数组扁平化，方便遍历</span></span><br><span class="line">    axes = axes.flatten()</span><br><span class="line">    <span class="comment"># 遍历图像和对应的轴（axes）进行绘图</span></span><br><span class="line">    <span class="keyword">for</span> i, (ax, img) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(axes, imgs)):</span><br><span class="line">        <span class="keyword">if</span> torch.is_tensor(img):</span><br><span class="line">            <span class="comment"># 如果图像是PyTorch张量，则将其转换为numpy数组并显示</span></span><br><span class="line">            ax.imshow(img.numpy())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果图像是PIL图像，则直接显示</span></span><br><span class="line">            ax.imshow(img)</span><br><span class="line">        <span class="comment"># 隐藏x和y轴的标签</span></span><br><span class="line">        ax.axes.get_xaxis().set_visible(<span class="literal">False</span>)</span><br><span class="line">        ax.axes.get_yaxis().set_visible(<span class="literal">False</span>)</span><br><span class="line">        <span class="comment"># 如果提供了标题，为每张图像设置标题</span></span><br><span class="line">        <span class="keyword">if</span> titles:</span><br><span class="line">            ax.set_title(titles[i])</span><br><span class="line">    <span class="comment"># 返回绘制的轴（axes），以便于进一步的操作或调整</span></span><br><span class="line">    <span class="keyword">return</span> axes</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以下是训练数据集中前几个样本的图像及其相应的标签。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X, y = <span class="built_in">next</span>(<span class="built_in">iter</span>(data.DataLoader(mnist_train, batch_size=<span class="number">18</span>)))</span><br><span class="line">show_images(X.reshape(<span class="number">18</span>, <span class="number">28</span>, <span class="number">28</span>), <span class="number">2</span>, <span class="number">9</span>, titles=get_fashion_mnist_labels(y));</span><br></pre></td></tr></table></figure><ul><li><code>X.reshape(18, 28, 28)</code>: 将获取的图像数据<code>X</code>重塑成18个28x28大小的图像。<code>DataLoader</code>返回的图像数据默认是扁平化的或有不同的维度，所以需要将其重塑回原始图像的尺寸以便于显示。</li><li><code>2, 9</code>: 指定在显示图像时使用2行9列的网格。因为一共有18个样本，这样的布局可以确保所有样本都能被显示出来。</li></ul><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20240220153046704.png" alt="image-20240220153046704"></p><hr><h3 id="小批量读取"><a href="#小批量读取" class="headerlink" title="小批量读取"></a>小批量读取</h3><p>为了使我们在读取训练集和测试集时更容易，我们使用内置的数据迭代器，而不是从零开始创建。 回顾一下，在每次迭代中，数据加载器每次都会读取一小批量数据，大小为<code>batch_size</code>。 通过内置数据迭代器，我们可以随机打乱了所有样本，从而无偏见地读取小批量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">batch_size = <span class="number">256</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_dataloader_workers</span>():</span>  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用4个进程来读取数据&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line">train_iter = data.DataLoader(mnist_train, batch_size, shuffle=<span class="literal">True</span>,</span><br><span class="line">                             num_workers=get_dataloader_workers())</span><br></pre></td></tr></table></figure><p>读取训练数据所需的时间：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">timer = d2l.Timer()</span><br><span class="line"><span class="keyword">for</span> X, y <span class="keyword">in</span> train_iter:</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line"><span class="string">f&#x27;<span class="subst">&#123;timer.stop():<span class="number">.2</span>f&#125;</span> sec&#x27;</span></span><br></pre></td></tr></table></figure><p>3.25sec左右</p><hr><h3 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h3><p>定义<code>load_data_fashion_mnist</code>函数，用于获取和读取Fashion-MNIST数据集。 这个函数返回训练集和验证集的数据迭代器。 此外，这个函数还接受一个可选参数<code>resize</code>，用来将图像大小调整为另一种形状。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data_fashion_mnist</span>(<span class="params">batch_size, resize=<span class="literal">None</span></span>):</span>  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;下载Fashion-MNIST数据集，然后将其加载到内存中&quot;&quot;&quot;</span></span><br><span class="line">    trans = [transforms.ToTensor()]</span><br><span class="line">    <span class="keyword">if</span> resize:</span><br><span class="line">        trans.insert(<span class="number">0</span>, transforms.Resize(resize))</span><br><span class="line">    trans = transforms.Compose(trans)</span><br><span class="line">    mnist_train = torchvision.datasets.FashionMNIST(</span><br><span class="line">        root=<span class="string">&quot;../data&quot;</span>, train=<span class="literal">True</span>, transform=trans, download=<span class="literal">True</span>)</span><br><span class="line">    mnist_test = torchvision.datasets.FashionMNIST(</span><br><span class="line">        root=<span class="string">&quot;../data&quot;</span>, train=<span class="literal">False</span>, transform=trans, download=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> (data.DataLoader(mnist_train, batch_size, shuffle=<span class="literal">True</span>,</span><br><span class="line">                            num_workers=get_dataloader_workers()),</span><br><span class="line">            data.DataLoader(mnist_test, batch_size, shuffle=<span class="literal">False</span>,</span><br><span class="line">                            num_workers=get_dataloader_workers()))</span><br></pre></td></tr></table></figure><hr><h2 id="从零实现"><a href="#从零实现" class="headerlink" title="从零实现"></a>从零实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> IPython <span class="keyword">import</span> display</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">256</span></span><br><span class="line">train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size)</span><br></pre></td></tr></table></figure><hr><h3 id="初始化模型参数"><a href="#初始化模型参数" class="headerlink" title="初始化模型参数"></a>初始化模型参数</h3><p>原始数据集中的每个样本都是28×28的图像。 本节将展平每个图像，把它们看作长度为784的向量</p><p>在softmax回归中，我们的输出与类别一样多。 因为我们的数据集有10个类别，所以网络输出维度为10。 因此，权重将构成一个784×10的矩阵， 偏置将构成一个1×10的行向量。 与线性回归一样，我们将使用正态分布初始化我们的权重<code>W</code>，偏置初始化为0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义输入向量的维度，对于FashionMNIST数据集，每张图像是28x28像素，</span></span><br><span class="line"><span class="comment"># 因此当图像被展平成向量时，它的大小是784</span></span><br><span class="line">num_inputs = <span class="number">784</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义输出向量的维度，这里有10个输出类别，对应于FashionMNIST数据集的10种服装类别</span></span><br><span class="line">num_outputs = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化权重矩阵W。</span></span><br><span class="line"><span class="comment"># 使用正态分布随机初始化，均值为0，标准差为0.01。</span></span><br><span class="line"><span class="comment"># W的形状是(num_inputs, num_outputs)，这样每个输入特征都会与每个输出类别关联一个权重。</span></span><br><span class="line">W = torch.normal(<span class="number">0</span>, <span class="number">0.01</span>, size=(num_inputs, num_outputs), requires_grad=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化偏置项b。</span></span><br><span class="line"><span class="comment"># 由于每个输出类别都有一个偏置，所以b的形状是(num_outputs,)。</span></span><br><span class="line"><span class="comment"># 初始化为0，并且设置requires_grad=True，以便于在反向传播时计算梯度。</span></span><br><span class="line">b = torch.zeros(num_outputs, requires_grad=<span class="literal">True</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="定义softmax操作"><a href="#定义softmax操作" class="headerlink" title="定义softmax操作"></a>定义softmax操作</h3><p>实现softmax由三个步骤组成：</p><ol><li>对每个项求幂（使用<code>exp</code>）；</li><li>对每一行求和（小批量中每个样本是一行），得到每个样本的规范化常数；</li><li>将每一行除以其规范化常数，确保结果的和为1。</li></ol><p>在查看代码之前，我们回顾一下这个表达式：</p><script type="math/tex; mode=display">\mathrm{softmax}(\mathbf{X})_{ij} = \frac{\exp(\mathbf{X}_{ij})}{\sum_k \exp(\mathbf{X}_{ik})}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">softmax</span>(<span class="params">X</span>):</span></span><br><span class="line">    X_exp = torch.exp(X)</span><br><span class="line">    partition = X_exp.<span class="built_in">sum</span>(<span class="number">1</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> X_exp / partition  <span class="comment"># 这里应用了广播机制</span></span><br></pre></td></tr></table></figure><p>参数<code>keepdim=True</code>意味着在求和后保持原有的维度，不会降维。即按行求和</p><hr><h3 id="定义模型"><a href="#定义模型" class="headerlink" title="定义模型"></a>定义模型</h3><p>定义softmax操作后，我们可以实现softmax回归模型。 下面的代码定义了输入如何通过网络映射到输出。 注意，将数据传递到模型之前，我们使用<code>reshape</code>函数将每张原始图像展平为向量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">net</span>(<span class="params">X</span>):</span></span><br><span class="line">    <span class="keyword">return</span> softmax(torch.matmul(X.reshape((-<span class="number">1</span>, W.shape[<span class="number">0</span>])), W) + b)</span><br></pre></td></tr></table></figure><ul><li><code>X.reshape((-1, W.shape[0]))</code>将输入<code>X</code>重塑，以便于与权重矩阵<code>W</code>进行矩阵乘法。这里假设<code>X</code>的每一行是一个独立的样本。</li><li><code>torch.matmul(...)</code>执行矩阵乘法。</li><li><code>+ b</code>将偏置项<code>b</code>加到矩阵乘法的结果上。</li><li><code>softmax(...)</code>将线性模型的输出通过softmax函数转换成概率分布。</li></ul><hr><h3 id="定义损失函数"><a href="#定义损失函数" class="headerlink" title="定义损失函数"></a>定义损失函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cross_entropy</span>(<span class="params">y_hat, y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> - torch.log(y_hat[<span class="built_in">range</span>(<span class="built_in">len</span>(y_hat)), y])</span><br><span class="line"></span><br><span class="line">cross_entropy(y_hat, y)</span><br></pre></td></tr></table></figure><p><code>y_hat[range(len(y_hat)), y]</code>是一个高效的索引操作，它选择了每个样本预测概率中对应于真实标签的概率。具体来说，对于每个样本<code>i</code>，它选择<code>y_hat[i, y[i]]</code>，即第<code>i</code>个样本的真实类别<code>y[i]</code>对应的预测概率。</p><p><code>- torch.log(...)</code>计算每个选中概率的负对数。负对数损失对于正确分类的预测（预测概率接近1）几乎为0，而对于错误分类的预测（预测概率接近0）则非常大。这意味着模型在训练过程中被激励去增加正确类别的预测概率。</p><hr><h3 id="分类精度"><a href="#分类精度" class="headerlink" title="分类精度"></a>分类精度</h3><p>当预测与标签分类<code>y</code>一致时，即是正确的。 分类精度即正确预测数量与总预测数量之比。 虽然直接优化精度可能很困难（因为精度的计算不可导）， 但精度通常是我们最关心的性能衡量标准，我们在训练分类器时几乎总会关注它。</p><p>为了计算精度，我们执行以下操作。 首先，如果<code>y_hat</code>是矩阵，那么假定第二个维度存储每个类的预测分数。 我们使用<code>argmax</code>获得每行中最大元素的索引来获得预测类别。 然后我们将预测类别与真实<code>y</code>元素进行比较。 由于等式运算符“<code>==</code>”对数据类型很敏感， 因此我们将<code>y_hat</code>的数据类型转换为与<code>y</code>的数据类型一致。 结果是一个包含0（错）和1（对）的张量。 最后，我们求和会得到正确预测的数量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accuracy</span>(<span class="params">y_hat, y</span>):</span>  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算预测正确的数量。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    y_hat: 模型的预测输出。可以是每个类别的得分或概率。</span></span><br><span class="line"><span class="string">    y: 真实的标签。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">    预测正确的样本数占总样本数的比例。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 检查预测输出是否为二维且类别数大于1，</span></span><br><span class="line">    <span class="comment"># 如果是，则使用argmax获取每个样本最高得分的类别索引作为预测类别</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(y_hat.shape) &gt; <span class="number">1</span> <span class="keyword">and</span> y_hat.shape[<span class="number">1</span>] &gt; <span class="number">1</span>:</span><br><span class="line">        y_hat = y_hat.argmax(axis=<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 比较预测类别（y_hat）和真实标签（y）是否相同，</span></span><br><span class="line">    <span class="comment"># 结果是一个布尔型张量，其中True表示预测正确，False表示预测错误。</span></span><br><span class="line">    cmp = y_hat.<span class="built_in">type</span>(y.dtype) == y</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将布尔型张量转换为与y相同的数据类型（通常是整型），</span></span><br><span class="line">    <span class="comment"># 然后计算True的数量（即预测正确的数量）。</span></span><br><span class="line">    <span class="comment"># 最后，将其转换为float类型，以便计算准确率。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">float</span>(cmp.<span class="built_in">type</span>(y.dtype).<span class="built_in">sum</span>())</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>同样，对于任意数据迭代器<code>data_iter</code>可访问的数据集， 我们可以评估在任意模型<code>net</code>的精度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluate_accuracy</span>(<span class="params">net, data_iter</span>):</span>  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算在指定数据集上模型的精度。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    net: 要评估的模型，可以是任何具有前向传播功能的PyTorch模型。</span></span><br><span class="line"><span class="string">    data_iter: 数据迭代器，用于提供评估数据集的批次数据。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">    模型在整个数据集上的准确率。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 检查是否为PyTorch的nn.Module模型。如果是，则将模型设置为评估模式。</span></span><br><span class="line">    <span class="comment"># 评估模式会关闭模型中的Dropout和BatchNorm等层的训练行为，以保证前向传播的一致性。</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(net, torch.nn.Module):</span><br><span class="line">        net.<span class="built_in">eval</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 初始化一个累加器实例用于跟踪正确预测的数量和预测的总数量。</span></span><br><span class="line">    metric = Accumulator(<span class="number">2</span>)  <span class="comment"># 正确预测数、预测总数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 不计算梯度，以节省计算资源，因为在评估模式下不需要进行反向传播。</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter:</span><br><span class="line">            <span class="comment"># 计算当前批次的准确率，并累加到metric中。</span></span><br><span class="line">            <span class="comment"># net(X)调用模型进行预测，accuracy函数计算准确率。</span></span><br><span class="line">            metric.add(accuracy(net(X), y), y.numel())</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算整个数据集上的总准确率。</span></span><br><span class="line">    <span class="comment"># metric[0]是正确预测的数量，metric[1]是预测的总数量。</span></span><br><span class="line">    <span class="keyword">return</span> metric[<span class="number">0</span>] / metric[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>这里定义一个实用程序类<code>Accumulator</code>，用于对多个变量进行累加。 在上面的<code>evaluate_accuracy</code>函数中， 我们在<code>Accumulator</code>实例中创建了2个变量， 分别用于<strong>存储正确预测的数量和预测的总数量</strong>。 当我们遍历数据集时，两者都将随着时间的推移而累加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Accumulator</span>:</span>  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;在n个变量上累加&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, n</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    类的初始化方法。</span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    n (int): 指定需要累加的变量的数量。</span></span><br><span class="line"><span class="string">    属性:</span></span><br><span class="line"><span class="string">    data (list of float): 用于存储每个变量的累加值的列表，初始时每个变量的值都设置为0.0。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    self.data = [<span class="number">0.0</span>] * n</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, *args</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    将传入的值加到累加器的对应变量上。</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    *args: 可变数量的参数，每个参数对应于需要累加到的变量的增量值。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    说明:</span></span><br><span class="line"><span class="string">    - 使用zip函数将self.data中的当前累加值和传入的增量值配对。</span></span><br><span class="line"><span class="string">    - 对每对值进行相加操作，并更新self.data中的累加值。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    self.data = [a + <span class="built_in">float</span>(b) <span class="keyword">for</span> a, b <span class="keyword">in</span> <span class="built_in">zip</span>(self.data, args)]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reset</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    重置累加器，将所有变量的累加值重置为0.0。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    self.data = [<span class="number">0.0</span>] * <span class="built_in">len</span>(self.data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, idx</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使累加器支持下标访问操作。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    idx (int): 需要访问的变量的索引。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">    float: 指定索引处变量的当前累加值。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> self.data[idx]</span><br></pre></td></tr></table></figure><p>该类非常有用于跟踪和累加如模型训练过程中的损失值、准确率计数或任何需要进行累加操作的场景。例如，在处理批量数据时累加损失值，或者统计一个周期内的正确预测数量。通过提供<code>add</code>和<code>reset</code>方法，<code>Accumulator</code>类使得这些操作既直观又方便</p><hr><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p>首先，我们定义一个函数来训练一个迭代周期。 请注意，<code>updater</code>是更新模型参数的常用函数，它接受批量大小作为参数。 它可以是<code>d2l.sgd</code>函数，也可以是框架的内置优化函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_epoch_ch3</span>(<span class="params">net, train_iter, loss, updater</span>):</span>  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    训练模型一个迭代周期。</span></span><br><span class="line"><span class="string">参数:</span></span><br><span class="line"><span class="string">net: 训练的神经网络模型。</span></span><br><span class="line"><span class="string">train_iter: 训练数据的迭代器。</span></span><br><span class="line"><span class="string">loss: 损失函数。</span></span><br><span class="line"><span class="string">updater: 参数更新器，可以是PyTorch的优化器或自定义的更新函数。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">返回:</span></span><br><span class="line"><span class="string">训练过程中的平均损失和平均准确率。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 如果net是PyTorch的神经网络模型，设置为训练模式。</span></span><br><span class="line"><span class="comment"># 这对于某些特定层如Dropout和BatchNorm层在训练和评估阶段行为不同是必要的。</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">isinstance</span>(net, torch.nn.Module):</span><br><span class="line">    net.train()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用Accumulator实例来跟踪损失和准确率的累积值，以及处理的总样本数。</span></span><br><span class="line">metric = Accumulator(<span class="number">3</span>)  <span class="comment"># 分别对应损失总和、准确度总和、样本数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历训练数据迭代器</span></span><br><span class="line"><span class="keyword">for</span> X, y <span class="keyword">in</span> train_iter:</span><br><span class="line">    <span class="comment"># 前向传播：计算预测值</span></span><br><span class="line">    y_hat = net(X)</span><br><span class="line">    <span class="comment"># 计算损失</span></span><br><span class="line">    l = loss(y_hat, y)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果updater是PyTorch优化器，则使用优化器进行反向传播和参数更新</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(updater, torch.optim.Optimizer):</span><br><span class="line">        updater.zero_grad()  <span class="comment"># 清除梯度</span></span><br><span class="line">        l.mean().backward()  <span class="comment"># 反向传播</span></span><br><span class="line">        updater.step()  <span class="comment"># 更新参数</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 对于自定义更新器，先进行反向传播，然后调用更新函数</span></span><br><span class="line">        l.<span class="built_in">sum</span>().backward()  <span class="comment"># 反向传播</span></span><br><span class="line">        updater(X.shape[<span class="number">0</span>])  <span class="comment"># 调用更新函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 更新累积器数据</span></span><br><span class="line">    metric.add(<span class="built_in">float</span>(l.<span class="built_in">sum</span>()), accuracy(y_hat, y), y.numel())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算平均损失和平均准确率</span></span><br><span class="line"><span class="keyword">return</span> metric[<span class="number">0</span>] / metric[<span class="number">2</span>], metric[<span class="number">1</span>] / metric[<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>这个函数非常重要，因为它封装了训练过程中的核心逻辑，使得对模型的训练变得清晰且易于管理。它支持使用PyTorch的标准优化器，也支持使用自定义的参数更新逻辑，提供了很好的灵活性。通过返回训练过程中的平均损失和平均准确率，这个函数还帮助我们监控模型训练的进度和效果。</p><blockquote><p>在展示训练函数的实现之前，我们定义一个在动画中绘制数据的实用程序类<code>Animator</code>， 它能够简化本书其余部分的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animator</span>:</span>  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;在动画中绘制数据&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, xlabel=<span class="literal">None</span>, ylabel=<span class="literal">None</span>, legend=<span class="literal">None</span>, xlim=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 ylim=<span class="literal">None</span>, xscale=<span class="string">&#x27;linear&#x27;</span>, yscale=<span class="string">&#x27;linear&#x27;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 fmts=(<span class="params"><span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;m--&#x27;</span>, <span class="string">&#x27;g-.&#x27;</span>, <span class="string">&#x27;r:&#x27;</span></span>), nrows=<span class="number">1</span>, ncols=<span class="number">1</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 figsize=(<span class="params"><span class="number">3.5</span>, <span class="number">2.5</span></span>)</span>):</span></span><br><span class="line">        <span class="comment"># 增量地绘制多条线</span></span><br><span class="line">        <span class="keyword">if</span> legend <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            legend = []</span><br><span class="line">        d2l.use_svg_display()</span><br><span class="line">        self.fig, self.axes = d2l.plt.subplots(nrows, ncols, figsize=figsize)</span><br><span class="line">        <span class="keyword">if</span> nrows * ncols == <span class="number">1</span>:</span><br><span class="line">            self.axes = [self.axes, ]</span><br><span class="line">        <span class="comment"># 使用lambda函数捕获参数</span></span><br><span class="line">        self.config_axes = <span class="keyword">lambda</span>: d2l.set_axes(</span><br><span class="line">            self.axes[<span class="number">0</span>], xlabel, ylabel, xlim, ylim, xscale, yscale, legend)</span><br><span class="line">        self.X, self.Y, self.fmts = <span class="literal">None</span>, <span class="literal">None</span>, fmts</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        <span class="comment"># 向图表中添加多个数据点</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(y, <span class="string">&quot;__len__&quot;</span>):</span><br><span class="line">            y = [y]</span><br><span class="line">        n = <span class="built_in">len</span>(y)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(x, <span class="string">&quot;__len__&quot;</span>):</span><br><span class="line">            x = [x] * n</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.X:</span><br><span class="line">            self.X = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.Y:</span><br><span class="line">            self.Y = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> i, (a, b) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(x, y)):</span><br><span class="line">            <span class="keyword">if</span> a <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> b <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                self.X[i].append(a)</span><br><span class="line">                self.Y[i].append(b)</span><br><span class="line">        self.axes[<span class="number">0</span>].cla()</span><br><span class="line">        <span class="keyword">for</span> x, y, fmt <span class="keyword">in</span> <span class="built_in">zip</span>(self.X, self.Y, self.fmts):</span><br><span class="line">            self.axes[<span class="number">0</span>].plot(x, y, fmt)</span><br><span class="line">        self.config_axes()</span><br><span class="line">        display.display(self.fig)</span><br><span class="line">        display.clear_output(wait=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></blockquote><p>接下来我们实现一个训练函数， 它会在<code>train_iter</code>访问到的训练数据集上训练一个模型<code>net</code>。 该训练函数将会运行多个迭代周期（由<code>num_epochs</code>指定）。 在每个迭代周期结束时，利用<code>test_iter</code>访问到的测试数据集对模型进行评估。 我们将利用<code>Animator</code>类来可视化训练进度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_ch3</span>(<span class="params">net, train_iter, test_iter, loss, num_epochs, updater</span>):</span>  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    训练模型。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    net: 要训练的神经网络模型。</span></span><br><span class="line"><span class="string">    train_iter: 训练数据集的迭代器。</span></span><br><span class="line"><span class="string">    test_iter: 测试数据集的迭代器。</span></span><br><span class="line"><span class="string">    loss: 使用的损失函数。</span></span><br><span class="line"><span class="string">    num_epochs: 训练的总周期数。</span></span><br><span class="line"><span class="string">    updater: 参数更新器，可以是PyTorch的优化器或自定义的更新函数。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 初始化动画生成器，用于可视化训练过程。</span></span><br><span class="line">    animator = Animator(xlabel=<span class="string">&#x27;epoch&#x27;</span>, xlim=[<span class="number">1</span>, num_epochs], ylim=[<span class="number">0.3</span>, <span class="number">0.9</span>],</span><br><span class="line">                        legend=[<span class="string">&#x27;train loss&#x27;</span>, <span class="string">&#x27;train acc&#x27;</span>, <span class="string">&#x27;test acc&#x27;</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 开始训练过程，遍历每一个训练周期。</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        <span class="comment"># 训练模型一个迭代周期，并返回训练损失和训练精度。</span></span><br><span class="line">        train_metrics = train_epoch_ch3(net, train_iter, loss, updater)</span><br><span class="line">        <span class="comment"># 在测试集上评估模型的精度。</span></span><br><span class="line">        test_acc = evaluate_accuracy(net, test_iter)</span><br><span class="line">        <span class="comment"># 使用动画生成器添加当前周期的训练损失、训练精度和测试精度。</span></span><br><span class="line">        animator.add(epoch + <span class="number">1</span>, train_metrics + (test_acc,))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 训练结束后，获取最后一个周期的训练损失和训练精度。</span></span><br><span class="line">    train_loss, train_acc = train_metrics</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 断言语句用于检查训练过程是否达到预期的效果。</span></span><br><span class="line">    <span class="comment"># 检查训练损失是否小于0.5。</span></span><br><span class="line">    <span class="keyword">assert</span> train_loss &lt; <span class="number">0.5</span>, train_loss</span><br><span class="line">    <span class="comment"># 检查训练精度是否在合理范围内（大于0.7，小于等于1）。</span></span><br><span class="line">    <span class="keyword">assert</span> train_acc &lt;= <span class="number">1</span> <span class="keyword">and</span> train_acc &gt; <span class="number">0.7</span>, train_acc</span><br><span class="line">    <span class="comment"># 检查测试精度是否在合理范围内（大于0.7，小于等于1）。</span></span><br><span class="line">    <span class="keyword">assert</span> test_acc &lt;= <span class="number">1</span> <span class="keyword">and</span> test_acc &gt; <span class="number">0.7</span>, test_acc</span><br></pre></td></tr></table></figure><p>作为一个从零开始的实现，使用小批量随机梯度下降来优化模型的损失函数，设置学习率为0.1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lr = <span class="number">0.1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">updater</span>(<span class="params">batch_size</span>):</span></span><br><span class="line">    <span class="keyword">return</span> d2l.sgd([W, b], lr, batch_size)</span><br></pre></td></tr></table></figure><p>现在，我们训练模型10个迭代周期。 请注意，迭代周期（<code>num_epochs</code>）和学习率（<code>lr</code>）都是可调节的超参数。 通过更改它们的值，我们可以提高模型的分类精度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num_epochs = <span class="number">10</span></span><br><span class="line">train_ch3(net, train_iter, test_iter, cross_entropy, num_epochs, updater)</span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraoutput_softmax-regression-scratch_a48321_222_0.svg" alt="../_images/output_softmax-regression-scratch_a48321_222_0.svg"></p><h3 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h3><p>现在训练已经完成，我们的模型已经准备好对图像进行分类预测。 给定一系列图像，我们将比较它们的实际标签（文本输出的第一行）和模型预测（文本输出的第二行）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict_ch3</span>(<span class="params">net, test_iter, n=<span class="number">8</span></span>):</span>  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    预测标签并显示图像及其真实标签和预测标签。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    net: 训练好的神经网络模型。</span></span><br><span class="line"><span class="string">    test_iter: 测试数据集的迭代器。</span></span><br><span class="line"><span class="string">    n: 要展示的图像数量，默认为8。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 从测试数据迭代器中取出一批数据。</span></span><br><span class="line">    <span class="comment"># 这里只取第一批数据用于展示。</span></span><br><span class="line">    <span class="keyword">for</span> X, y <span class="keyword">in</span> test_iter:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取这批数据的真实标签，并转换为对应的文字标签。</span></span><br><span class="line">    trues = d2l.get_fashion_mnist_labels(y)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 使用模型对这批数据进行预测，获取预测结果的最大值索引作为预测标签，</span></span><br><span class="line">    <span class="comment"># 并转换为对应的文字标签。</span></span><br><span class="line">    preds = d2l.get_fashion_mnist_labels(net(X).argmax(axis=<span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 为每张图像准备标题，包含真实标签和预测标签。</span></span><br><span class="line">    titles = [true +<span class="string">&#x27;\n&#x27;</span> + pred <span class="keyword">for</span> true, pred <span class="keyword">in</span> <span class="built_in">zip</span>(trues, preds)]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 使用d2l.show_images函数显示图像及其标题。</span></span><br><span class="line">    <span class="comment"># 图像被重塑为28x28的大小，只展示前n张图像。</span></span><br><span class="line">    d2l.show_images(</span><br><span class="line">        X[<span class="number">0</span>:n].reshape((n, <span class="number">28</span>, <span class="number">28</span>)), <span class="number">1</span>, n, titles=titles[<span class="number">0</span>:n])</span><br><span class="line">    </span><br><span class="line">    predict_ch3(net, test_iter)</span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20240220183258116.png" alt="image-20240220183258116"></p><hr><h2 id="简洁实现"><a href="#简洁实现" class="headerlink" title="简洁实现"></a>简洁实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">256</span></span><br><span class="line">train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size)</span><br></pre></td></tr></table></figure><p>softmax回归的输出层是一个全连接层。 因此，为了实现我们的模型， 我们只需在<code>Sequential</code>中添加一个带有10个输出的全连接层。 同样，在这里<code>Sequential</code>并不是必要的， 但它是实现深度模型的基础。 我们仍然以均值0和标准差0.01随机初始化权重。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># PyTorch不会隐式地调整输入的形状。因此，</span></span><br><span class="line"><span class="comment"># 我们在线性层前定义了展平层（flatten），来调整网络输入的形状</span></span><br><span class="line">net = nn.Sequential(nn.Flatten(), nn.Linear(<span class="number">784</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_weights</span>(<span class="params">m</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(m) == nn.Linear:</span><br><span class="line">        nn.init.normal_(m.weight, std=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line">net.apply(init_weights);</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loss = nn.CrossEntropyLoss(reduction=<span class="string">&#x27;none&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在PyTorch中，<code>nn.CrossEntropyLoss</code>是一个常用的损失函数，特别适用于多类分类问题。这个函数结合了<code>nn.LogSoftmax</code>和<code>nn.NLLLoss</code>（负对数似然损失）两个操作在一个单独的类中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trainer = torch.optim.SGD(net.parameters(), lr=<span class="number">0.1</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num_epochs = <span class="number">10</span></span><br><span class="line">d2l.train_ch3(net, train_iter, test_iter, loss, num_epochs, trainer)</span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraoutput_softmax-regression-concise_75d138_66_0.svg" alt="../_images/output_softmax-regression-concise_75d138_66_0.svg"></p><p>和以前一样，这个算法使结果收敛到一个相当高的精度，而且这次的代码比之前更精简了。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.0 线性回归</title>
      <link href="/post/62658.html"/>
      <url>/post/62658.html</url>
      
        <content type="html"><![CDATA[<h1 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h1><p>线性回归的概念以及普通的numpy实现已经在机器学习的<a href="https://www.nightswatch.icu/post/53740.html">多变量线性回归</a>的章节中实现过了，所以这节侧重于写一下在Pytorch框架下，实现线性回归</p><h2 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h2><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br></pre></td></tr></table></figure><p><code>%matplotlib inline</code>是<code>Jupyter</code>笔记本中的特殊命令，它允许<code>Matplotlib</code>生成的图形直接在笔记本中显示，而不是在单独的窗口中显示。这通常用于数据科学和机器学习环境，以便方便地可视化数据和结果。</p><hr><h3 id="生成数据集"><a href="#生成数据集" class="headerlink" title="生成数据集"></a>生成数据集</h3><p>为了简单起见，我们将根据带有噪声的线性模型构造一个人造数据集。 我们的任务是使用这个有限样本的数据集来恢复这个模型的参数。 我们将使用低维数据，这样可以很容易地将其可视化。 在下面的代码中，我们生成一个包含1000个样本的数据集， 每个样本包含从标准正态分布中采样的2个特征。 我们的合成数据集是一个矩阵$X$</p><p>我们使用线性模型参数$\theta=[2,-3.4]^T,b=4.2$和噪声$\epsilon$生成数据集和标签</p><script type="math/tex; mode=display">y=X\theta+b+\epsilon</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">synthetic_data</span>(<span class="params">theta, b, num_examples</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;生成y=Xw+b+噪声&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 生成服从正态分布的随机数据矩阵X，形状为(num_examples, len(w))</span></span><br><span class="line">    X = torch.normal(<span class="number">0</span>, <span class="number">1</span>, (num_examples, <span class="built_in">len</span>(w)))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算标签y，其中y = X\theta + b</span></span><br><span class="line">    y = X@theta + b</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 添加均值为0、标准差为0.01的噪声，模拟真实数据中的随机性</span></span><br><span class="line">    y += torch.normal(<span class="number">0</span>, <span class="number">0.01</span>, y.shape)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 返回生成的数据矩阵X和相应的标签y，标签y的形状为列向量</span></span><br><span class="line">    <span class="keyword">return</span> X, y.reshape((-<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义真实的权重和偏置,即Theta参数</span></span><br><span class="line">true_t = torch.tensor([<span class="number">2</span>, -<span class="number">3.4</span>])</span><br><span class="line">true_b = <span class="number">4.2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用synthetic_data函数生成包含1000个样本的合成数据集</span></span><br><span class="line">features, labels = synthetic_data(true_t, true_b, <span class="number">1000</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>torch.normal</code>是<code>PyTorch</code>中用于生成服从正态分布（高斯分布）的随机数的函数。其基本语法如下：</p><p><code>torch.normal(mean, std, size, out=None)</code></p><ul><li><code>mean</code>: 正态分布的均值。</li><li><code>std</code>: 正态分布的标准差。</li><li><code>size</code>: 指定生成随机数张量的形状。</li><li><code>out</code>（可选）: 输出张量，用于存储结果。</li></ul><p>均值决定正态分布的峰值的横坐标，而标准差决定了正态分布图像的宽度</p><p>注意，<code>features</code>中的每一行都包含一个二维数据样本， <code>labels</code>中的每一行都包含一维标签值（一个标量）。</p><hr><h3 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">d2l.set_figsize()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取第二列的特征和标签，并将其转换为 NumPy 数组</span></span><br><span class="line">x = features[:, <span class="number">1</span>].detach().numpy()</span><br><span class="line">y = labels.detach().numpy()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制散点图</span></span><br><span class="line">d2l.plt.scatter(x,y,<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>通过生成第二个特征<code>features[:, 1]</code>和<code>labels</code>的散点图， 可以直观观察到两者之间的线性关系。<img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231211133001618.png" alt="image-20231211133001618"></p><p>在绘制图形时，<code>Matplotlib</code>函数通常期望接收<code>NumPy</code>数组而不是<code>PyTorch</code>张量。因此，使用<code>.detach().numpy()</code>的组合可以将<code>PyTorch</code>张量转换为<code>NumPy</code>数组。这样，我们可以在<code>Matplotlib</code>中轻松地使用这些数组，而不必担心梯度计算。也就是说<code>detach</code>函数删除了<code>tensor</code>中的<code>grad</code>属性</p><hr><h3 id="读取数据集"><a href="#读取数据集" class="headerlink" title="读取数据集"></a>读取数据集</h3><p>通常，我们利用GPU并行运算的优势，处理合理大小的“小批量”。 每个样本都可以并行地进行模型计算，且每个样本损失函数的梯度也可以被并行计算。 GPU可以在处理几百个样本时，所花费的时间不比处理一个样本时多太多。</p><p>同时我们也会采取 小批量梯度下降法来进行最优化，关于小批量梯度下降，在机器学习中已经有过介绍了，参见<a href="https://www.nightswatch.icu/post/9245.html">大规模机器学习</a></p><p>在下面的代码中，我们定义一个<code>data_iter</code>函数， 该函数接收批量大小、特征矩阵和标签向量作为输入，生成大小为<code>batch_size</code>的小批量。 每个小批量包含一组特征和标签。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_iter</span>(<span class="params">batch_size, features, labels</span>):</span></span><br><span class="line">    <span class="comment"># 获取数据集中样本的总数</span></span><br><span class="line">    num_examples = <span class="built_in">len</span>(features)</span><br><span class="line">    <span class="comment"># 创建一个包含样本索引的列表，用于后续的随机打乱</span></span><br><span class="line">    indices = <span class="built_in">list</span>(<span class="built_in">range</span>(num_examples))</span><br><span class="line">    <span class="comment"># 将样本索引随机打乱，以进行随机批次训练</span></span><br><span class="line">    random.shuffle(indices)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 从 0 开始，每次迭代按批次大小移动，以获取每个批次的起始索引</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, num_examples, batch_size):</span><br><span class="line">        <span class="comment"># 选择当前批次的样本索引，并将其转换为 PyTorch 张量</span></span><br><span class="line">        batch_indices = torch.tensor(indices[i: <span class="built_in">min</span>(i + batch_size, num_examples)])</span><br><span class="line">        <span class="comment"># 使用 yield 返回当前批次的特征和标签，以迭代器的方式逐批获取数据</span></span><br><span class="line">        <span class="keyword">yield</span> features[batch_indices], labels[batch_indices]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>yield</code> 是一个用于定义<strong>生成器函数</strong>的关键字，用于生成迭代器。生成器函数是一种特殊的函数，它可以通过 <code>yield</code> 语句生成一个值，并在下一次调用时从上次离开的地方继续执行。</p><p><code>yield features[batch_indices], labels[batch_indices]</code> 的作用是将当前批次的特征和标签返回给调用者，然后暂停函数的执行。下次迭代时，函数会从上次离开的地方继续执行，而不是从头开始。这种方式使得生成器函数可以有效地处理大量数据，因为它不需要一次性加载所有数据到内存中。</p><p>然后 输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">batch_size = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter(batch_size, features, labels):</span><br><span class="line">    <span class="built_in">print</span>(X, <span class="string">&#x27;\n&#x27;</span>, y)</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure><hr><h3 id="初始化模型参数"><a href="#初始化模型参数" class="headerlink" title="初始化模型参数"></a>初始化模型参数</h3><p>在我们开始用小批量随机梯度下降优化我们的模型参数之前， 我们需要先有一些参数。 在下面的代码中，我们通过从均值为0、标准差为0.01的正态分布中采样随机数来初始化权重， 并将偏置初始化为0</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">theta = torch.normal(<span class="number">0</span>, <span class="number">0.01</span>, size=(<span class="number">2</span>,<span class="number">1</span>), requires_grad=<span class="literal">True</span>)</span><br><span class="line">b = torch.zeros(<span class="number">1</span>, requires_grad=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>在初始化参数之后，我们的任务是更新这些参数，直到这些参数足够拟合我们的数据。 每次更新都需要计算损失函数关于模型参数的梯度。 有了这个梯度，我们就可以向减小损失的方向更新每个参数。 </p><p>因为手动计算梯度很枯燥而且容易出错，所以没有人会手动计算梯度。 我们使用上一章中引入的<strong>自动微分</strong>来计算梯度。</p><hr><h3 id="定义模型"><a href="#定义模型" class="headerlink" title="定义模型"></a>定义模型</h3><p>接下来，我们必须定义模型，将模型的输入和参数同模型的输出关联起来。 回想一下，要计算线性模型的输出， 我们只需计算输入特征$X$和模型权重$\theta$的矩阵-向量乘法后加上偏置$b$。 注意，上面的$X\theta$是一个<strong>向量</strong>，而$b$是一个<strong>标量</strong></p><p>根据广播机制： 当我们用一个向量加一个标量时，标量会被加到向量的每个分量上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">linreg</span>(<span class="params">X, theta, b</span>):</span>  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;线性回归模型&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> X@theta + b</span><br></pre></td></tr></table></figure><hr><h3 id="定义损失函数"><a href="#定义损失函数" class="headerlink" title="定义损失函数"></a>定义损失函数</h3><p>因为需要计算损失函数的梯度，所以我们应该先定义损失函数。 </p><p> 在实现中，我们需要将真实值<code>y</code>的形状转换为和预测值<code>y_hat</code>的形状相同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">squared_loss</span>(<span class="params">y_hat, y</span>):</span>  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;均方损失&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> (y_hat - y.reshape(y_hat.shape)) ** <span class="number">2</span> / <span class="number">2</span></span><br></pre></td></tr></table></figure><hr><h3 id="定义优化算法"><a href="#定义优化算法" class="headerlink" title="定义优化算法"></a>定义优化算法</h3><p>在每一步中，使用从数据集中随机抽取的一个小批量，然后根据参数计算损失的梯度。 接下来，朝着减少损失的方向更新我们的参数。 下面的函数实现小批量随机梯度下降更新。 该函数接受模型参数集合、学习速率和批量大小作为输入。每 一步更新的大小由学习速率<code>lr</code>决定。 因为我们计算的损失是一个批量样本的总和，所以我们用批量大小（<code>batch_size</code>） 来规范化步长，这样步长大小就不会取决于我们对批量大小的选择。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sgd</span>(<span class="params">params, lr, batch_size</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;小批量随机梯度下降&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="comment"># 遍历所有模型参数</span></span><br><span class="line">        <span class="keyword">for</span> param <span class="keyword">in</span> params:</span><br><span class="line">            <span class="comment"># 更新参数：param = param - learning_rate * param.grad / batch_size</span></span><br><span class="line">            param -= lr * param.grad / batch_size</span><br><span class="line">            <span class="comment"># 梯度清零，为下一轮梯度计算做准备</span></span><br><span class="line">            param.grad.zero_()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 <code>PyTorch</code> 中，<code>torch.no_grad()</code> 是一个上下文管理器，用于指定在其范围内的代码块中不需要计算梯度。这在一些情况下是有用的，例如在参数更新时，我们不希望计算梯度，只想执行更新操作。</p><p>通过使用 <code>torch.no_grad()</code>，我们可以显式地告诉 <code>PyTorch</code> 在这个上下文中不追踪梯度，从而提高效率和减少计算开销。</p><p>在深度学习中，<code>params</code> 通常是指模型的参数集合。模型的参数是那些需要在训练过程中进行更新的可学习的权重和偏置等。在 <code>PyTorch</code> 中，模型的参数通常通过 <code>nn.Module</code> 类的 <code>parameters()</code> 方法来获取。</p><hr><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p>现在我们已经准备好了模型训练所有需要的要素，可以实现主要的训练过程部分了。 理解这段代码至关重要，因为从事深度学习后， 相同的训练过程几乎一遍又一遍地出现。 在每次迭代中，我们读取一小批量训练样本，并通过我们的模型来获得一组预测。 计算完损失后，我们开始反向传播，存储每个参数的梯度。 最后，我们调用优化算法<code>sgd</code>来更新模型参数。</p><p>​    </p><script type="math/tex; mode=display">theta:={\theta}_j-\alpha\frac{1}{b}\sum_\limits{k=i}^{i+b-1}\left( h_{\theta}\left(x^{(k)}\right)-{y}^{(k)} \right){x_j}^{(k)}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">lr = <span class="number">0.03</span>  <span class="comment"># 学习率，控制参数更新的步长</span></span><br><span class="line">num_epochs = <span class="number">3</span>  <span class="comment"># 训练循环的迭代次数</span></span><br><span class="line">net = linreg  <span class="comment"># 模型，这里使用线性回归模型</span></span><br><span class="line">loss = squared_loss  <span class="comment"># 损失函数，这里使用平方损失函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">    <span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter(batch_size, features, labels):</span><br><span class="line">        <span class="comment"># 计算小批量数据的损失，X为特征，y为标签</span></span><br><span class="line">        l = loss(net(X, theta, b), y)  </span><br><span class="line">        <span class="comment"># 因为l形状是(batch_size,1)，而不是一个标量。</span></span><br><span class="line">        <span class="comment"># l中的所有元素被加到一起，并以此计算关于[theta,b]的梯度</span></span><br><span class="line">        l.<span class="built_in">sum</span>().backward()</span><br><span class="line">        <span class="comment"># 使用参数的梯度更新参数，实现小批量随机梯度下降</span></span><br><span class="line">        sgd([theta, b], lr, batch_size)  </span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="comment"># 在整个训练集上计算整体损失，用于观察训练进展</span></span><br><span class="line">        train_l = loss(net(features, theta, b), labels)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;epoch <span class="subst">&#123;epoch + <span class="number">1</span>&#125;</span>, loss <span class="subst">&#123;<span class="built_in">float</span>(train_l.mean()):f&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>更新参数这一步骤，本来是要写成如下形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参数 -= (学习率/一批的数量) * 偏导数(形式是 误差*X矩阵)</span><br></pre></td></tr></table></figure><p>注意这两步：</p><ul><li><p><code>l.sum().backward()</code>的作用是，更新<code>theta</code>和<code>b</code>的梯度属性<code>grad</code>，即更新了偏导数</p></li><li><p><code>sgd([theta, b], lr, batch_size)</code> 函数实现了<code>theta</code>的下降，函数内部直接使用了更新后的偏导数</p></li></ul><hr><h2 id="简洁实现"><a href="#简洁实现" class="headerlink" title="简洁实现"></a>简洁实现</h2><h3 id="生成数据集-1"><a href="#生成数据集-1" class="headerlink" title="生成数据集"></a>生成数据集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils <span class="keyword">import</span> data</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line">true_w = torch.tensor([<span class="number">2</span>, -<span class="number">3.4</span>])</span><br><span class="line">true_b = <span class="number">4.2</span></span><br><span class="line">features, labels = d2l.synthetic_data(true_w, true_b, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>直接使用传统方法生成了</p><hr><h3 id="读取数据集-1"><a href="#读取数据集-1" class="headerlink" title="读取数据集"></a>读取数据集</h3><p>我们可以调用框架中现有的API来读取数据。 我们将<code>features</code>和<code>labels</code>作为API的参数传递，并通过数据迭代器指定<code>batch_size</code>。 此外，布尔值<code>is_train</code>表示是否希望数据迭代器对象在每个迭代周期内打乱数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_array</span>(<span class="params">data_arrays, batch_size, is_train=<span class="literal">True</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    构造一个PyTorch数据迭代器</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">        - data_arrays: 包含特征和标签的数据元组</span></span><br><span class="line"><span class="string">        - batch_size: 每个小批量的样本数</span></span><br><span class="line"><span class="string">        - is_train: 一个布尔值，指示是否是训练数据，默认为 True</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        - data_iter: PyTorch 数据迭代器</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 创建 TensorDataset 对象，将特征和标签组合成一个数据集</span></span><br><span class="line">    dataset = data.TensorDataset(*data_arrays)</span><br><span class="line">    <span class="comment"># 使用 DataLoader 构造数据迭代器，按批次加载数据</span></span><br><span class="line">    <span class="keyword">return</span> data.DataLoader(dataset, batch_size, shuffle=is_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例用法</span></span><br><span class="line">batch_size = <span class="number">10</span></span><br><span class="line"><span class="comment"># 创建一个 PyTorch 数据迭代器，用于按批次加载特征和标签数据</span></span><br><span class="line">data_iter = load_array((features, labels), batch_size)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用<code>data.TensorDataset</code>将数据打包，使用<code>data.DataLoader</code>按<code>batch_size</code>解包，并且<code>shuffle=True</code>,打乱输出</p><blockquote><p><code>data</code> 是一个模块或库的名称，它包含 <code>TensorDataset</code> 和 <code>DataLoader</code> 等用于处理数据的类</p><ul><li><p><code>torch.utils.data.TensorDataset</code> 主要用于包装多个张量（特征和标签）作为一个数据集。这个类的主要优势在于它可以方便地将多个张量按相同的索引进行配对，形成一个样本。在训练过程中，我们通常有特征和对应的标签，<code>TensorDataset</code> 可以将它们组合成一个数据集，以便使用 PyTorch 中的 <code>DataLoader</code> 来按批次加载数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> TensorDataset</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设有特征张量 features 和标签张量 labels</span></span><br><span class="line">features = torch.tensor([[<span class="number">1.0</span>, <span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>], [<span class="number">5.0</span>, <span class="number">6.0</span>]])</span><br><span class="line">labels = torch.tensor([<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 TensorDataset 将特征和标签组合成数据集</span></span><br><span class="line">dataset = TensorDataset(features, labels)</span><br></pre></td></tr></table></figure></li><li><p><code>torch.utils.data.DataLoader</code> 是 PyTorch 中用于创建数据迭代器的类，主要用于按批次加载数据。它提供了多线程数据加载、数据打乱以及按照指定批次大小生成数据的功能。在深度学习中，通常使用 <code>DataLoader</code> 将数据集划分为小批量，以便输入到模型中进行训练或评估。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 使用 DataLoader 按批次加载数据</span></span><br><span class="line">batch_size = <span class="number">2</span></span><br><span class="line">data_loader = DataLoader(dataset, batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 在训练循环中按批次迭代</span></span><br><span class="line"><span class="keyword">for</span> batch_features, batch_labels <span class="keyword">in</span> data_loader:</span><br><span class="line">    <span class="comment"># 进行模型训练或其他操作</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Batch Features:&quot;</span>, batch_features)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Batch Labels:&quot;</span>, batch_labels)</span><br></pre></td></tr></table></figure></li></ul></blockquote><p>这里我们使用<code>iter</code>构造Python迭代器，并使用<code>next</code>从迭代器中获取第一项。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">next</span>(<span class="built_in">iter</span>(data_iter))</span><br></pre></td></tr></table></figure><ul><li><code>data_iter</code> 是一个 PyTorch 数据迭代器，你可以使用 <code>iter(data_iter)</code> 将其转换为一个迭代器对象。</li><li><code>next(...)</code> 函数用于获取迭代器的下一个元素。</li></ul><hr><h3 id="定义模型-1"><a href="#定义模型-1" class="headerlink" title="定义模型"></a>定义模型</h3><p>观察线性回归的神经网络图：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231212094027669.png" alt="image-20231212094027669"></p><p>这是一个单层神经网络，每个输入都与每个输出（在本例中只有一个输出）相连，将这种变换 称为<strong>全连接层</strong>（fully-connected layer）或称为 稠密层（dense layer）</p><p>对于标准深度学习模型，我们可以使用框架的预定义好的层。这使我们只需关注使用哪些层来构造模型，而不必关注层的实现细节。 我们首先定义一个模型变量<code>net</code>，它是一个<code>Sequential</code>类的实例。 <code>Sequential</code>类将多个层串联在一起。 当给定输入数据时，<code>Sequential</code>实例将数据传入到第一层， 然后将第一层的输出作为第二层的输入，以此类推。 在下面的例子中，我们的模型只包含一个层，因此实际上不需要<code>Sequential</code>。 但是由于以后几乎所有的模型都是多层的，在这里使用<code>Sequential</code>会让你熟悉“标准的流水线”。</p><p>接下来，我们会使用<code>Pytorch</code>中的<code>Sequential</code>类定义全连接层</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nn是神经网络的缩写</span></span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"></span><br><span class="line">net = nn.Sequential(nn.Linear(<span class="number">2</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><ul><li><code>nn.Linear(2, 1)</code>：这是一个线性层，它将输入的特征维度从 2 降到 1。第一个参数是输入特征的数量，即输入的维度为 2；第二个参数是输出特征的数量，即输出的维度为 1。这个线性层执行的操作类似于一个简单的线性变换，其中包含权重和偏置。</li><li><code>nn.Sequential(...)</code>：这是一个 <code>Sequential</code> 容器，它按照顺序包含了一个或多个神经网络层。在这里，它只包含了一个线性层。</li><li>返回一个 <code>PyTorch</code> 的神经网络模型，具体而言是 <code>nn.Sequential</code> 类的一个实例</li></ul><hr><h3 id="初始化模型参数-1"><a href="#初始化模型参数-1" class="headerlink" title="初始化模型参数"></a>初始化模型参数</h3><p>在使用<code>net</code>之前，我们需要初始化模型参数。 如在线性回归模型中的权重和偏置。 深度学习框架通常有预定义的方法来初始化参数。 在这里，我们指定每个权重参数应该从均值为0、标准差为0.01的正态分布中随机采样， 偏置参数将初始化为零。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net[<span class="number">0</span>].weight.data.normal_(<span class="number">0</span>, <span class="number">0.01</span>)</span><br><span class="line">net[<span class="number">0</span>].bias.data.fill_(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>考虑一个简单的线性层的计算，以一个神经元为例：</p><script type="math/tex; mode=display">output=activation(weight×input+bias)</script><p>其中：</p><ul><li><code>weight</code> 是权重参数，表示输入的权重；</li><li><code>input</code> 是输入特征；</li><li><code>bias</code> 是偏置参数，是一个常数项；</li><li><code>activation</code> 是激活函数，将加权和加上偏置的结果进行非线性映射。</li></ul><hr><h3 id="定义损失函数-1"><a href="#定义损失函数-1" class="headerlink" title="定义损失函数"></a>定义损失函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loss = nn.MSELoss()</span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">\text{MSE Loss} = \frac{1}{n} \sum_{i=1}^{n} (\hat{y}_i - y_i)^2</script><p>在 PyTorch 中，<code>nn.MSELoss()</code> 是均方误差损失（Mean Squared Error Loss）的实现。均方误差是回归问题中常用的损失函数，用于衡量模型预测值与真实值之间的平方差。</p><hr><h3 id="定义优化算法-1"><a href="#定义优化算法-1" class="headerlink" title="定义优化算法"></a>定义优化算法</h3><p>小批量随机梯度下降算法是一种优化神经网络的标准工具， PyTorch在<code>optim</code>模块中实现了该算法的许多变种。 当我们实例化一个<code>SGD</code>实例时，我们要指定优化的参数 （可通过<code>net.parameters()</code>从我们的模型中获得）以及优化算法所需的超参数字典。 小批量随机梯度下降只需要设置<code>lr</code>值，这里设置为0.03。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trainer = torch.optim.SGD(net.parameters(), lr=<span class="number">0.03</span>)</span><br></pre></td></tr></table></figure><ul><li><code>torch.optim</code> 是 PyTorch 中包含各种优化算法的模块。</li><li><code>SGD</code> 表示随机梯度下降优化算法，是深度学习中最基本和常用的优化算法之一。</li><li><code>net.parameters()</code> 返回神经网络模型中所有可学习参数（权重和偏置）的迭代器。</li><li><code>lr=0.03</code> 是学习率，用于控制参数更新的步幅。学习率是一个超参数，需要根据具体问题进行调整。</li><li>返回一个 PyTorch 的 SGD（随机梯度下降）优化器对象<code>trainer</code>。这个优化器对象被用于更新神经网络模型中所有可学习参数的数值，以最小化定义的损失函数。</li></ul><hr><h3 id="训练-1"><a href="#训练-1" class="headerlink" title="训练"></a>训练</h3><p>在每个迭代周期里，我们将完整遍历一次数据集（<code>train_data</code>）， 不停地从中获取一个小批量的输入和相应的标签。 对于每一个小批量，我们会进行以下步骤:</p><ul><li>通过调用<code>net(X)</code>生成预测并计算损失<code>l</code>（前向传播）。</li><li>通过进行反向传播来计算梯度。</li><li>通过调用优化器来更新模型参数。</li></ul><p>为了更好的衡量训练效果，我们计算每个迭代周期后的损失，并打印它来监控训练过程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置训练的总轮数</span></span><br><span class="line">num_epochs = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历每一轮训练</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">    <span class="comment"># 遍历数据迭代器，获取每个小批量的特征 X 和标签 y</span></span><br><span class="line">    <span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter:</span><br><span class="line">        <span class="comment"># 计算当前小批量的损失</span></span><br><span class="line">        l = loss(net(X), y)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 梯度清零，防止梯度累积</span></span><br><span class="line">        trainer.zero_grad()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 反向传播，计算梯度</span></span><br><span class="line">        l.backward()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 使用优化器更新模型参数</span></span><br><span class="line">        trainer.step()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算整个训练集上的损失</span></span><br><span class="line">    l = loss(net(features), labels)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 输出当前轮次的训练损失</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;epoch <span class="subst">&#123;epoch + <span class="number">1</span>&#125;</span>, loss <span class="subst">&#123;l:f&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面我们比较生成数据集的真实参数和通过有限数据训练获得的模型参数。 要访问参数，我们首先从<code>net</code>访问所需的层，然后读取该层的权重和偏置。 正如在从零开始实现中一样，我们估计得到的参数与生成数据的真实参数非常接近。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">w = net[<span class="number">0</span>].weight.data</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;w的估计误差：&#x27;</span>, true_w - w.reshape(true_w.shape))</span><br><span class="line">b = net[<span class="number">0</span>].bias.data</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;b的估计误差：&#x27;</span>, true_b - b)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.0 Pytorch入门</title>
      <link href="/post/40793.html"/>
      <url>/post/40793.html</url>
      
        <content type="html"><![CDATA[<h1 id="Pytorch入门"><a href="#Pytorch入门" class="headerlink" title="Pytorch入门"></a>Pytorch入门</h1><h2 id="Numpy2Pytorch"><a href="#Numpy2Pytorch" class="headerlink" title="Numpy2Pytorch"></a>Numpy2Pytorch</h2><h3 id="数组对象tensor"><a href="#数组对象tensor" class="headerlink" title="数组对象tensor"></a>数组对象tensor</h3><p>首先，我们介绍n维数组，也称为张量（tensor）。无论使用哪个深度学习框架，它的张量类（在<code>MXNet</code>中为<code>ndarray</code>，在<code>PyTorch</code>和<code>TensorFlow</code>中为<code>Tensor</code>）都与<code>Numpy</code>的<code>ndarray</code>类似。</p><p>但深度学习框架又比<code>Numpy</code>的<code>ndarray</code>多一些重要功能：首先，<strong>GPU很好地支持加速计算</strong>，而NumPy仅支持CPU计算；其次，张量类支持自动微分。这些功能使得张量类更适合深度学习</p><hr><p>以下是<code>ndarray</code>和<code>tensor</code>之间的对比，方便快速入手<code>tensor</code></p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>当涉及到比较 PyTorch 的 <code>Tensor</code> 和 NumPy 的 <code>ndarray</code> 的属性时，它们之间有很多相似之处。下面是一些主要属性的对比：</p><div class="table-container"><table><thead><tr><th>属性</th><th>NumPy 的 <code>ndarray</code></th><th>PyTorch 的 <code>Tensor</code></th></tr></thead><tbody><tr><td>数据类型</td><td><code>ndarray.dtype</code></td><td><code>tensor.dtype</code></td></tr><tr><td>形状</td><td><code>ndarray.shape</code></td><td><code>tensor.shape</code></td></tr><tr><td>维度</td><td><code>ndarray.ndim</code></td><td><code>tensor.dim()</code></td></tr><tr><td>元素个数</td><td><code>ndarray.size</code></td><td><code>tensor.numel()</code></td></tr><tr><td>设备（CPU/GPU）</td><td>-</td><td><code>tensor.device</code></td></tr><tr><td>改变形状</td><td><code>ndarray.reshape(new_shape)</code></td><td><code>tensor.view(new_shape)</code></td></tr><tr><td>展开</td><td><code>ndarray.flattern</code></td><td><code>tensor.view(-1)</code></td></tr><tr><td>转置</td><td><code>ndarray.T</code></td><td><code>tensor.T</code></td></tr><tr><td>张量类型</td><td>-</td><td><code>torch.FloatTensor</code>, <code>torch.IntTensor</code>, 等</td></tr></tbody></table></div><p>需要注意的是，虽然有很多相似之处，但也有一些语法和方法上的区别。例如，<code>PyTorch</code> 使用 <code>.view()</code> 来改变形状，而 <code>NumPy</code> 使用 <code>.reshape()</code></p><hr><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><div class="table-container"><table><thead><tr><th>操作</th><th>NumPy</th><th>PyTorch</th></tr></thead><tbody><tr><td>创建零数组</td><td><code>np.zeros(shape)</code></td><td><code>torch.zeros(shape)</code></td></tr><tr><td>创建单位矩阵</td><td><code>np.eye(n)</code></td><td><code>torch.eye(n)</code></td></tr><tr><td>创建全一数组</td><td><code>np.ones(shape)</code></td><td><code>torch.ones(shape)</code></td></tr><tr><td>从现有数据创建数组</td><td><code>np.array([1, 2, 3])</code></td><td><code>torch.tensor([1, 2, 3])</code></td></tr><tr><td>创建等间隔的数组</td><td><code>np.arange(start, stop, step)</code></td><td><code>torch.arange(start, end, step)</code></td></tr><tr><td>创建指定范围的数组</td><td><code>np.linspace(start, stop, num)</code></td><td><code>torch.linspace(start, end, steps=num)</code></td></tr><tr><td>随机数数组</td><td><code>np.random.rand(shape)</code></td><td><code>torch.rand(shape)</code></td></tr><tr><td>随机整数数组</td><td><code>np.random.randint(low, high, size)</code></td><td><code>torch.randint(low, high, size)</code></td></tr></tbody></table></div><p>大多类似，<code>PyTorch</code>可以直接使用<code>rand</code>类创建随机数，而<code>Numpy</code>要借助<code>random</code>类</p><hr><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><p>当涉及到比较 PyTorch 的 <code>Tensor</code> 和 NumPy 的 <code>ndarray</code> 的运算时，它们之间有很多相似之处。下面是一些主要运算的对比：</p><div class="table-container"><table><thead><tr><th>运算</th><th>NumPy 的 <code>ndarray</code></th><th>PyTorch 的 <code>Tensor</code></th></tr></thead><tbody><tr><td>元素级加法</td><td><code>a + b</code></td><td><code>a + b</code></td></tr><tr><td>元素级乘法</td><td><code>a * b</code></td><td><code>a * b</code></td></tr><tr><td>元素级除法</td><td><code>a / b</code></td><td><code>a / b</code></td></tr><tr><td>元素级取余</td><td><code>a % b</code></td><td><code>torch.remainder(a, b)</code></td></tr><tr><td>矩阵乘法</td><td><code>np.dot(matrix_a, matrix_b)</code></td><td><code>torch.mm(matrix_a, matrix_b)</code></td></tr><tr><td>转置</td><td><code>ndarray.T</code></td><td><code>tensor.t()</code></td></tr><tr><td>归约操作（求和）</td><td><code>np.sum(array)</code></td><td><code>tensor.sum()</code></td></tr><tr><td>归约操作（平均值）</td><td><code>np.mean(array)</code></td><td><code>tensor.mean()</code></td></tr><tr><td>最大值</td><td><code>np.max(array)</code></td><td><code>tensor.max()</code></td></tr><tr><td>最小值</td><td><code>np.min(array)</code></td><td><code>tensor.min()</code></td></tr><tr><td>按维度归约操作</td><td><code>np.sum(array, axis=0)</code></td><td><code>tensor.sum(dim=0)</code></td></tr><tr><td>元素级比较</td><td><code>a &gt; b</code>, <code>a == b</code>, etc.</td><td><code>torch.gt(a, b)</code>, <code>torch.eq(a, b)</code>, etc.</td></tr><tr><td>索引和切片</td><td><code>ndarray[1:3]</code></td><td><code>tensor[1:3]</code></td></tr><tr><td>L2 范数</td><td><code>np.linalg.norm(a, ord=2)</code></td><td><code>torch.norm(a, p=2)</code></td></tr><tr><td>广播</td><td>可以通过 NumPy 自动广播进行运算</td><td>广播是默认行为，无需额外操作</td></tr></tbody></table></div><p>需要注意的是，虽然许多运算在语法上非常相似，但有些函数名称和方法可能会有所不同。此外，<code>PyTorch</code> 的 <code>Tensor</code> 具有自动微分功能，这是深度学习中反向传播的基础，而 <code>NumPy</code> 不具备这个功能。</p><hr><h3 id="连接与删除"><a href="#连接与删除" class="headerlink" title="连接与删除"></a>连接与删除</h3><div class="table-container"><table><thead><tr><th>操作</th><th>NumPy 的 <code>ndarray</code></th><th>PyTorch 的 <code>Tensor</code></th></tr></thead><tbody><tr><td>连接数组</td><td><code>np.concatenate([a, b])</code></td><td><code>torch.cat([a, b], dim=0)</code></td></tr><tr><td>沿轴连接数组</td><td><code>np.stack([a, b], axis=0)</code></td><td><code>torch.stack([a, b], dim=0)</code></td></tr><tr><td>删除元素</td><td><code>np.delete(ndarray, indices, axis)</code></td><td><code>tensor.index_select(dim, indices)</code></td></tr><tr><td>插入元素</td><td><code>np.insert(ndarray, index, values, axis)</code></td><td>不直接支持</td></tr><tr><td>去重</td><td><code>np.unique(ndarray)</code></td><td><code>torch.unique(tensor)</code></td></tr><tr><td>翻转数组</td><td><code>np.flip(ndarray, axis)</code></td><td><code>torch.flip(tensor, dims)</code></td></tr></tbody></table></div><hr><h3 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h3><p>使用<code>torch.tensor(x)</code>可以轻松把<code>numpy</code>转换为<code>tensor</code>类型</p><p>使用<code>x=torch_tensor.numpy()</code>可以把<code>tensor</code>换算为<code>numpy</code>类型</p><hr><h2 id="自动微分"><a href="#自动微分" class="headerlink" title="自动微分"></a>自动微分</h2><h3 id="链式法则"><a href="#链式法则" class="headerlink" title="链式法则"></a>链式法则</h3><script type="math/tex; mode=display">\frac{\partial y}{\partial x_i} = \frac{\partial y}{\partial u_1} \frac{\partial u_1}{\partial x_i} + \frac{\partial y}{\partial u_2} \frac{\partial u_2}{\partial x_i} + \cdots + \frac{\partial y}{\partial u_m} \frac{\partial u_m}{\partial x_i}</script><p>假设$x,w$是一个$n$维的向量，<script type="math/tex">z=(<x,w>-y)^2</script>，求解$\frac{\partial z}{\partial w}$</p><p>我们首先对式子进行分解：假设<script type="math/tex">a=<x,w>,b=a-y,z=b^2</script>，那么</p><script type="math/tex; mode=display">\begin{align*}\frac{\partial z}{\partial w}&=\frac{\partial z}{\partial b}\frac{\partial b}{\partial a}\frac{\partial a}{\partial w}\\ &=\frac{\partial b^2}{\partial b}\frac{\partial a-y}{\partial a}\frac{\partial<x,w>}{\partial w}\\ &= 2b\cdot1\cdot x^T\\ &=2(<x,w>-y)x^T\end{align*}</script><p>用<strong>计算图</strong>的形式表示</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231209182918457.png" alt="image-20231209182918457" style="zoom: 50%;" /></p><p>通过前向传播，计算每一层的输出，并存储中间变量的梯度</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231209193053597.png" alt="image-20231209193053597" style="zoom: 50%;" /></p><p>然后根据<strong>前向传播存储计算得到的梯度</strong>的值，可以反过来求导，这叫反向传播</p><script type="math/tex; mode=display">\frac{\partial y}{\partial x}=(((\frac{\partial y}{\partial u_n}(\frac{\partial u_n}{\partial u_{n-1}})\cdots )\frac{\partial u_2}{\partial u_1})\frac{\partial u_1}{\partial x}</script><hr><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p><code>tensor</code>除了包含了很多与<code>numpy</code>相同功能的函数外，其独特的点在于，<strong>内置很多深度学习相关的属性和函数</strong></p><p><strong>梯度追踪属性：</strong></p><ul><li><strong><code>requires_grad</code>：</strong> 一个布尔值，指定是否对该张量进行梯度追踪。默认情况下，创建张量时 <code>requires_grad</code> 是 <code>False</code>，但可以通过设置为 <code>True</code> 来启用梯度追踪。例如：<code>torch.tensor([1.0], requires_grad=True)</code>。</li><li><strong><code>grad</code>：</strong> 用于存储计算得到的梯度。在执行反向传播后，该属性将包含相对于某个标量的梯度值。例如，在计算了某个标量损失相对于张量 <code>x</code> 的梯度后，可以通过 <code>x.grad</code> 获取梯度。</li></ul><p><strong>自动微分属性：</strong></p><ul><li><strong><code>grad_fn</code>：</strong> 一个指向创建该张量的函数的引用。该属性是一个 <code>torch.autograd.Function</code> 对象，用于构建计算图。在进行反向传播时，这个计算图用于计算梯度。例如，如果张量是通过加法操作创建的，<code>grad_fn</code> 将是一个指向加法函数的引用。</li></ul><p><strong>反向传播</strong>：</p><ul><li><code>tensor.backward()</code>函数：<code>tensor.backward()</code> 会计算损失相对于创建 <code>y</code> 的计算图中所有叶子节点（通常是模型参数）的梯度。在反向传播期间，<code>PyTorch</code> 会根据链式法则（链式求导）计算梯度，并将这些梯度存储在相应的张量的 <code>grad</code> 属性中。</li></ul><p>例：对$y=2xx^T$，对关于列向量$x$求导</p><p>在计算<code>y</code>关于<code>x</code>的梯度之前，需要将<code>requires_grad</code>设置为<code>True</code>，之后可以用<code>x</code>的<code>grad</code>属性来存储梯度</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个张量并启用梯度追踪</span></span><br><span class="line">x = torch.arange(<span class="number">4.0</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印初始梯度（在进行任何计算之前，梯度为None）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;初始梯度:&quot;</span>, x.grad)  <span class="comment"># 输出 None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行一个计算，y = 2 * x·x （点积）</span></span><br><span class="line">y = <span class="number">2</span> * torch.dot(x, x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行反向传播以计算梯度</span></span><br><span class="line">y.backward()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印计算得到的梯度</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;计算后的梯度:&quot;</span>, x.grad)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果是：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">初始梯度: <span class="literal">None</span></span><br><span class="line">计算后的梯度: tensor([ <span class="number">0.</span>,  <span class="number">4.</span>,  <span class="number">8.</span>, <span class="number">12.</span>])</span><br></pre></td></tr></table></figure><hr><p>如果最终的<code>y</code>不是一个标量，而是一个向量，那么我们一般会用<code>sum</code>函数对<code>y</code>求和，使其变为一个标量运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">x = torch.arange(<span class="number">4.0</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">y=x*x</span><br><span class="line">y.<span class="built_in">sum</span>().backward()</span><br><span class="line"><span class="built_in">print</span>(x.grad)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果是：tensor([0., 2., 4., 6.])</span></span><br></pre></td></tr></table></figure><hr><p>有时，我们希望将某些计算移动到记录的计算图之外。 例如，假设<code>y</code>是作为<code>x</code>的函数计算的，而<code>z</code>则是作为<code>y</code>和<code>x</code>的函数计算的。 想象一下，我们想计算<code>z</code>关于<code>x</code>的梯度，但由于某种原因，希望将<code>y</code>视为一个常数， 并且只考虑到<code>x</code>在<code>y</code>被计算后发挥的作用。</p><p>这里可以分离<code>y</code>来返回一个新变量<code>u</code>，该变量与<code>y</code>具有相同的值， 但丢弃计算图中如何计算<code>y</code>的任何信息。 换句话说，梯度不会向后流经<code>u</code>到<code>x</code>。 因此，下面的反向传播函数计算<code>z=u*x</code>关于<code>x</code>的偏导数，同时将<code>u</code>作为常数处理， 而不是<code>z=x*x*x</code>关于<code>x</code>的偏导数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义变量 x，并启用梯度追踪</span></span><br><span class="line">x = torch.tensor([<span class="number">2.0</span>], requires_grad=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算 y = x^2</span></span><br><span class="line">y = x*x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分离 y，并得到一个新的变量 u</span></span><br><span class="line">u = y.detach()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算 z = u * x</span></span><br><span class="line">z = u * x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行反向传播，计算 z 关于 x 的梯度</span></span><br><span class="line">z.backward()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印 x 的梯度</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;梯度值:&quot;</span>, x.grad)</span><br><span class="line"><span class="comment">#结果不是8，而是4</span></span><br></pre></td></tr></table></figure><p><code>y.detach()</code> 将 <code>y</code> 分离，得到一个新的变量 <code>u</code>。然后，<code>z = u * x</code> 中的 <code>u</code> 被视为常数，不再与计算图有关。因此，<code>z.backward()</code> 只计算了 <code>z</code> 关于 <code>x</code> 的梯度，而不计算 <code>u</code> 关于 <code>x</code> 的梯度。最终，打印出了 <code>x</code> 的梯度。</p><p>当希望冻结某些层或变量，不让其参与梯度更新时有用</p><hr><p>总结一下，计算的步骤为：</p><ol><li><strong>定义模型：</strong> 创建模型并设置参数的 <code>requires_grad</code> 以启用梯度追踪。</li><li><strong>前向传播：</strong> 使用模型进行前向传播，计算输出。</li><li><strong>计算损失：</strong> 定义损失函数，计算模型输出与真实标签之间的损失。</li><li><strong>反向传播：</strong> 调用 <code>backward()</code> 方法，<code>PyTorch</code> 会根据计算图自动计算梯度。</li><li><strong>参数更新：</strong> 根据梯度和优化算法更新模型参数。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络大题</title>
      <link href="/post/23456.html"/>
      <url>/post/23456.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络大题"><a href="#计算机网络大题" class="headerlink" title="计算机网络大题"></a>计算机网络大题</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>针对874来说，最重要的考点有3个：路由器的转发过程，TCP的拥塞过程，访问网站的过程</p><p>数据交换方式：<br><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/SgDTPOBYh8XEtZw.png" alt="image-20220615202917918" style="zoom:67%;" /></p><p>假设传输完整报文(数据)的总时间之和为$T$，传输一个分组所用时间为$T_s$，假设中间有$n$个路由器（存储转发方式）</p><p>报文交换所需的时间：$T_N=n×T$</p><p>分组交换所需的时间：$T_F=T+n×T_s$</p><hr><p>路由器的转发过程</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/SZdKtCwg4kyjFXn.png" alt="image-20210510143204263"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/aVceqfF6WiMhQl2.png" alt="image-20210510143337978"></p><ol><li><p>首要的就是要注意<strong>默认路由</strong>的概念，每一个路由器都要有一个默认路由，如果要访问互联网的话，目的网络和子网掩码都是0.0.0.0，即0.0.0.0/0</p></li><li><p>IP分组在被路由器转发的过程中，</p><p>一定变化的标识有：</p><ul><li>生存时间TTL</li><li>头部校验和</li></ul><p>可能变化的标识有</p><ul><li>总长度(取决于是否分片)    </li><li>标志(和分片有关的标志 )   </li><li>片偏移(是否分片)</li><li>源IP地址（取决于源IP地址是否是私网地址）</li><li>目的IP地址（取决于目的IP地址是否是私网地址）</li></ul></li></ol><hr><p>访问网站的过程</p><p>TTP连接分为<strong>持续连接和非持续连接</strong></p><p>持续连接又分为非流水的持续连接和流水的持续连接</p><p>如果用户向服务器请求数据，比如说3个图片和1个网页</p><ul><li>非流水的持续连接</li></ul><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/lU4m6BxYavrzq7A.png" alt="image-20210526125834400" style="zoom: 80%;" /></p><p>需要的是建立TCP的时间，因为第三次握手就可以传输数据了，所以总时间是1次RTT的建立连接时间+n次数据传输和RTT时间</p><p>需要5个RTT时间+4个对象的传输时间</p><ul><li>流水的持续连接</li></ul><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/6tjlfNcrbiuF1ev.png" alt="image-20210526125946863" style="zoom: 80%;" /></p><p>建立了TCP连接之后，剩下的文件可以持续发送，所以只需要3个RTT时间</p><p>需要3个RTT时间+4个对象的传输时间</p><p>非持续连接</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/RFNlfI5KaYT8JCO.png" alt="image-20210526130048609" style="zoom:67%;" /></p><p>每次发送一个数据就需要建立TCP连接，即需要2次RTT</p><p>需要8个RTT+4对象传输时间</p><hr><p>数据帧的封装过程：</p><p>MAC帧：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/VNvFh31WwLtEo9u.png" alt="image-20210429185723929"></p><ul><li>长度在64~1518字节</li><li>数据载荷部分在46~1500字节</li><li>地址长度为6B</li></ul><p>IP数据报</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/BpcMX15ytDbiVGm.png" alt="image-20210510201659621"></p><ul><li>首部固定部分长度为20B，其中首部长度4B，片偏移的单位为8B</li><li>地址长度为4B</li></ul><p>TCP报文</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/iDSjosP6Z5nvOQ8.png" alt="image-20210512223248172"></p><ul><li>首部长度固定为20字节</li><li>端口号占了2字节</li></ul><p>封装过程：</p><p>IP数据报封装TCP报文段</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221209184027108.png" alt="image-20221209184027108"></p><p>MAC封装IP数据报</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221209184115077.png" alt="image-20221209184115077"></p><hr><h2 id="408"><a href="#408" class="headerlink" title="408"></a>408</h2><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/QRmDdH1cXFPVnke.png" alt="image-20210518152433911" style="zoom: 67%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：此题考察了争用期的概念，以及以太网帧的相关知识</p><ol><li>最长时间就是争用期的时间=2/200000*2=$2×10^{-5}s$，而最短的时间则是，数据发送到刚好一半的位置被检测到了碰撞，为争用期的一半，是$10^{-5}s$</li><li>主机的有效数据传输速率=有效数据/总时间，总时间=最长数据帧发送时延+信号的传播时延+主机乙确认帧的发送实验+传输时延</li></ol><p>甲发送时延=$(1518<em>8)/(1</em>10^7)=1.2144ms$  传输时延=$2/200000$=0.01ms，乙发送时延=$(64*8)/(10^7)=0.0512ms$</p><p>总时间为：1.2144+0.01*2+0.0512=1.2856ms</p><p>因为MAC帧的数据帧格式为<img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/3A1LXf8wbYznDIT.png" alt="image-20210506120334489" style="zoom:67%;" /></p><p>MAC帧中有18个字节不需要数据载荷，有效数据传输速率为$(1500<em>8)/(1.2856</em>10^{-3})=9.33Mbps$</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/PJtGNEh9cFyWZMD.png" alt="image-20210522162158606"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><ol><li><p>t0到t1时刻期间，甲方收到了的数据帧是R0,1表示收到了第0帧，R1,3表示收到了第0,1,2帧，R3.3表示收到了第0,1,2帧，所以甲方断定乙方已正确接收的数据帧数是3帧，正确接收的是，S0,0   S1.0   S2.0</p></li><li><p>数据帧的发送序号和确认序号字段均为3比特，那么发送窗口大小为$2^3-1=7$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/XDZcYeqptHC8NV5.png" alt="image-20210522165228362" style="zoom:67%;" /></p></li></ol><p>此时最多还可以发送5个数据帧，因为主机甲没有收到主机乙的2号数据帧，所以会一直请求第2号数据帧，其中第一个帧是S5,2最后一个帧是S1,2</p><ol><li><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/8IJc1CQw5sr2BP9.png" alt="image-20210522170555815" style="zoom:67%;" /></p><p>此时要重传的数据帧是S2,3 S3,3 S4,3，一共3个</p></li></ol><ol><li><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/1gAUfOvWdxauotm.png" alt="image-20210522171003499" style="zoom:80%;" /></p><p>甲可以达到的最大信道利用率是：发送数据的时间/从开始发送第0个数据帧到收到第0个确认帧的时间=7个数据帧的发送时间/(2a+2b)</p></li></ol><p>​       信道利用率为50%</p></div></div><hr><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/k6KNy89nXTl4wtP.png" alt="image-20210518123946639"  /></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/pIrWaYVONo3QByR.png" alt="image-20210518123957521"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p> 解析：此题考察网络中IP地址，路由跳转等知识点</p><p>① 首先判断该网络为C类地址，在划分子网的时候，题目要求是每个局域网不少于120个地址，所以$2^x&gt;120+2$，x至少为7，所以只有借用第一位主机号作为网络号，局域网1的地址为202.118.1.0到202.118.1.127，局域网1的地址块为 <strong>202.118.1.0/25</strong>，局域网2的地址为202.118.1.128到202.118.1.256，局域网2的地址块为  <strong>202.118.1.128/25</strong></p><p>② 给出R1的路由表 </p><div class="table-container"><table><thead><tr><th style="text-align:left">目的IP地址</th><th>子网掩码</th><th>下一跳IP地址</th><th>接口</th></tr></thead><tbody><tr><td style="text-align:left">202.118.1.0</td><td>255.255.255.128</td><td>无</td><td>E1</td></tr><tr><td style="text-align:left">202.118.1.128</td><td>255.255.255.128</td><td>无</td><td>E2</td></tr><tr><td style="text-align:left">0.0.0.0</td><td>0.0.0.0</td><td>202.118.2.2</td><td>L0</td></tr><tr><td style="text-align:left">202.118.3.2</td><td>255.255.255.255</td><td>202.118.2.2</td><td>L0</td></tr></tbody></table></div><p>需要注意的是，因为没有指明是到互联网中的那一条路由，所以是采用默认路由的方式进行配置，而到域名服务器是到一个特定主机的路由，所以采用对特定主机的方式进行配置</p><p>③ 要路由聚合技术，则需要找到局域网1和局域网2的共同前缀，为202.118.1，则聚合了之后，其聚合路由地址为<strong>202.118.1.0/24</strong></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/QiXTtv7yqcAP1RM.png" alt="image-20210518172036987"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/dVunIrAKo5fLM3c.png" alt="image-20210518172129028"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/nGUJZ248QcCmqNH.png" alt="image-20210518172045742"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/4ySLZvurXjCiKxD.png" alt="image-20210518172052740"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>本题是对以太网帧格式，IP分组格式，IP地址，MAC地址，ARP协议，HTTP/1.1持续的非流水线方式的综合考查</p><ol><li><p>根据层层封装的原理，IP数据报会被封装在以太网帧中进行发送，则以太网帧中的第1个到第6个字节是目的MAC地址，主机的默认网关地址为 00 21 27  21 51 ee         第31个字节到第34个字节是源IP地址，40 aa 62 20 十进制表示是 64.170.98.32</p></li><li><p>使用ARP协议确定目的MAC地址，封装该协议的请求报文采用广播形式，目的MAC地址为FF FF FF FF FF FF</p></li><li><p>需要注意的是，在题目的图中，是进行了有效数据传输的，所以发出Web请求是在第三次握手的时候</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/RBUqtguZHlXcfLb.png" alt="image-20210518192758534" style="zoom:50%;" /></p><p>一共经过了6个RTT</p></li><li><p>在经过路由器转发时，需要修改IP分组中的源IP地址，生存时间，首部校验和，</p></li></ol><p>因为IP地址是私有地址，所以在经过路由器转发的时候会改变其源IP地址</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/ONsM1ePQfhptqak.png" alt="image-20210520144551905" style="zoom: 80%;" /></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/VZpaKlgImGy83QH.png" alt="image-20210520144557289" style="zoom:67%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p> 解析：本题考察路由表转发，路由聚合等知识点</p><p>①</p><div class="table-container"><table><thead><tr><th>目的网络</th><th>下一跳</th><th>接口</th></tr></thead><tbody><tr><td>194.17.20.128/25</td><td>直连</td><td>E0</td></tr><tr><td>153.14.5.0/24</td><td>153.14.3.2</td><td>S0</td></tr><tr><td>194.17.20.0/23</td><td>194.17.24.2</td><td>S1</td></tr></tbody></table></div><p>② 通过E0来转发该IP分组，因为目的网络的前缀更长</p><p>③  BGP，通过TCP建立连接</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/DB5XcrRh6AOyUxn.png" alt="image-20210520171435267" style="zoom: 80%;" /></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/IdQp74HJVKjvO3w.png" alt="image-20210520171442954" style="zoom: 80%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>① 因为图中标注了权值，所以采用的是OSPF协议，则要将192.1.7.0和192.1.6.0聚合起来</p><div class="table-container"><table><thead><tr><th>目的网络</th><th>下一跳</th><th>接口</th></tr></thead><tbody><tr><td>192.1.1.0/24</td><td>直连</td><td>E0</td></tr><tr><td>192.1.5.0/24</td><td>10.1.1.10</td><td>L1</td></tr><tr><td>192.1.6.0/23</td><td>10.1.1.2</td><td>L0</td></tr></tbody></table></div><p>②  通过L0转发分组，收到的IP分组TTL为64-3=61</p><p>③</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/qWhPgElI3NCY4fV.png" alt="image-20210520172427620" style="zoom: 80%;" /></p><p>需要增加一条特殊的直连网络，网络前缀Prefix为0.0.0.0/0，度量Metric为10</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/rTjhNbVlyIg1OnD.png" alt="image-20210522184131547"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><ol><li>将192.168.1.0均分给两个子网，按图中格式，说明子网掩码为255.255.255.128，销售部的广播地址是192.168.1.127，技术部的子网地址是192.168.1.128，还有254-208=46个子网可以分配</li><li>需要注意的是，IP数据报里面的偏移量一定要是8的整数倍，1500B的IP分组，数据载荷部分为1480B，分为两部分，每段能最多封装780B的数据载荷，至少分为2片，则第1段分776B，而第2段分704B，第1的片偏移量为0，第2段的片偏移量为776/8=97</li></ol></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/1CwEZYdA6LNcH5x.png" alt="image-20210522202310386"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><ol><li><p>路由器，交换机，交换机</p></li><li><p>设备1的所有接口需要配置IP地址，</p><p>IF1 192.168.1.254/30    IF2    192.168.1.1     IF3 192.168.1.65</p></li><li><p>NAT服务</p></li><li><p>H4</p></li></ol></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221209204846900.png" alt="image-20221209204846900"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><ol><li><p>两个子网使用了相同的网段，且路由器开启了 NAT功能，加上题干给出了 NAT表的结构，因此需要配置NAT表。路由器R2开启NAT服务，当路由器R 从 WAN 口收到H2或 H3发来的数据时，根据NAT表发送给Web服务器的对应端口。外网IP 地址应该为路由器的外端IP 地址，内网IP 地址应该为Web服务器的地址，Web服务器的默认端口为8 0 ,因此内网端口号固定为8 0 ,当其他网络的主机访问Web服务器时，默认访问的端口应该也是8 0 ,但是访问的目的IP 是路由器的IP 地址，因此NAT表中的外部端口最好也统一为80。题目中并未要求对H 1进行访问，因此H 1的NAT表项可以不写。R 2 的NAT表配置如下：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221209205318365.png" alt="image-20221209205318365"></p></li><li><p>由于启用了 NAT服务，H 2发送的P 的源IP 地址应该是H 2 的内网地址，目的地址应该是R2 的外网IP 地址，源 IP 地址是192.168.1.2,目的IP 地址是203.10.2.2</p><p>R3转发后，将P的源IP 地址改为R3的外网IP 地址，目的IP地址仍然不变，源 IP 地址是203 .10 .2 .6 ,目的IP 地址是203.10.2.2</p><p>R2转发后，将 P 的目的IP 地址改为Web服务器的内网地址，源地址仍然不变，源 IP 地址是203 .1 0 .2 .6 ,目的IP 地址是192.168.1.2</p></li></ol></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221209210929710.png" alt="image-20221209210929710"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><ol><li><p>根据过程：DNS  ARP  TCP  HTTP  可知用了DNS这一协议，在传输层用UDP，在网络层用IP，在数据链路层用CSMA/CD</p></li><li><p>首先第一步是H1向域名服务器请求查询域名，那么S肯定记录下端口4和H1的对应关系，同时ARP广播找寻域名服务器的MAC地址，得到答复后，记录下端口1和域名服务器的关系，然后H1向abc网站发送请求，S交换机又需要通过ARP广播确定R的MAC地址，得到回应后确定了端口2和R的关系，所以S的交换表为：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221209211406558.png" alt="image-20221209211406558"></p></li><li><p>由上述过程可得，H2至少收到了2次ARP广播帧，MAC地址都为FF-FF-FF-FF-FF-FF</p></li></ol></div></div><hr><h3 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/OS4AtzjDxlwp7Qm.png" alt="image-20210518205638100" style="zoom: 80%;" /></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/mlxL2jsotknuq1H.png" alt="image-20210518205653004" style="zoom:80%;" /></p><p>已知，题目给出IP数据报格式以及TCP报文格式</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/2sOpQZd1J5Nn8mw.png" alt="image-20210510201659621" style="zoom:67%;" /></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/KVcvw214d6xSZa7.png" alt="image-20210512223248172" style="zoom:50%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><ol><li><p>题目已经给出了主机H的IP地址，对比IP数据报的首部格式，第13到16字节是其源IP地址，192.168.0.8化为16进制形式为 c0 a8 00 08，对比可知，编号为1.3.4的分组是H发送的   </p><p>建立TCP连接需要经过3报文握手，前两次握手的SYN标志位是1，第三次握手SYN=0，ACK=1，可以根据以上取值来寻找分组，可以看到5个分组的首部字段长度都为5，所以在可变部分都没有进行添加，则分组的前20字节为IP数据报部分，后20字节为TCP报文段，可以得出1分组的SYN位是1,ACK=0,第2个分组的SYN位是1,ACK=1，第3个分组的SYN=0,ACK=1,所以在1.2.3完成了TCP连接建立</p><p>以太网的最小帧长为64字节，除去首部和尾部共16字节外，数据载荷的最小长度为46字节<img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/542KOlh3TEAbuns.png" alt="image-20210518211555026"></p><p>本题中，数据载荷部分就是IP分组，若IP分组的长度小于46字节，就需要填充，根据IP数据报中的总长度字段，可以得出，第3，5号需要填充</p></li><li><p>在TCP报文段中找到序号的值，从第4号分组中开始，应用层的初始序号为84 6b 41 c6 ，在第5号分组中，确认序号为84 6b 41 d6，因此收到的数据量=确认序号-初始序号，结果为16字节</p></li><li><p>需要找到生存时间，可以找到其发出前的生存时间为40H，而2号和5号收到的分组，生存时间都为31H，可以算出生存时间减少了15，所以经过了15个路由器</p></li></ol></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/3TV985FsyAiGPoE.png" alt="image-20210520200540939"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/PBeKA7jixg6nzVC.png" alt="image-20210520200549881"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><ol><li>最大范围是从111.123.15.5到111.123.15.254，目的地址是255.255.255.255，源地址是0.0.0.0</li><li>会广播发送，MAC的目的地址为FF-FF-FF-FF-FF-FF，是00-a1-a1-a1-a1-a1</li><li>子网掩码为255.255.255.0和WWW服务器的子网掩码相同，能访问到WWW服务器，默认网关是111.123.15.2，属于配置错误，无法连接到Internet</li></ol></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/BRJzme8Y2aog1Sh.png" alt="image-20210522004408908" style="zoom:67%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><ol><li><p>第二次握手TCP段的SYN位是1，ACK位是1，确认号是1+100=101</p></li><li><p>H3在收到了第8个确认段后，拥塞窗口应该是1+8=9，第8个确认段发送回来的接收窗口应该是20-8=12，H3的发送窗口会取拥塞窗口和接收窗口的最小值，也就是9</p></li><li><p>发送窗口等于0的时候，就是接收窗口全部被填满了，一共接收了20个数据段，那么下一个待发送的数据段序号为101+1024×20=20581                                                                            </p><p>在经过1个RTT后，接收窗口为1，第2个RTT后，接收窗口为3，第3个RTT后，接收窗口为7，第4个RTT后，接收窗口为15，第5个RTT后，接收窗口被填满，用时200ms×5=1s</p><p>在此期间，传输了1024×20×8b的数据，所以传输速率为20.48kb/s</p></li><li><p>在4报文挥手中，S释放连接的最快速度是1.5个RTT，也就是1.5×200ms=300ms</p></li></ol></div></div><hr><h2 id="874"><a href="#874" class="headerlink" title="874"></a>874</h2><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221209170743267.png" alt="image-20221209170743267"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221209173642332.png" alt="image-20221209173642332"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>具体过程如下:</p><ol><li>DNS查询IP地址</li><li>ARP查询到MAC地址</li><li>主机于服务器建立TCP链接</li><li>主机发送HTTP协议请求，服务器响应请求</li></ol><p>传输层协议是：TCP，拥塞控制方法有：慢开始  拥塞避免  快重传  快恢复</p><ul><li>慢开始：开始的时候将拥塞窗口设为1，在拥塞窗口没达到门槛时，窗口数隔一个周期翻倍</li><li>拥塞避免：当拥塞窗口达到了门槛时，每次拥塞窗口只加一，如果发生了拥塞，则将拥塞窗口重置为1，门槛调整为原来的一半</li><li>快重传：要求接受方接受到消息后立即重传，而发送方接受到3个重复确认后，就立即重传</li><li>快恢复：快重传之后，立即将门槛和拥塞窗口设为当前的一半，然后开始拥塞避免</li></ul></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221209221341255.png" alt="image-20221209221341255"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><ol><li>数据量是3200bit，按分组交换的形式，传输时延是3200bit/1Mbps=3.2ms,经过路由器为4个，分组发送的总时间=5×1+3.2×5=21ms</li><li>3100/1Mbps=3.1ms，5+8+3.1×5=18.5ms</li><li>3200/1Mbps=33ms，5+4+3.2×5=25ms</li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络重点题</title>
      <link href="/post/13956.html"/>
      <url>/post/13956.html</url>
      
        <content type="html"><![CDATA[<h1 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a><strong>选择题</strong></h1><h2 id="408"><a href="#408" class="headerlink" title="408"></a>408</h2><p>09~21</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/Q6tAsoK3r1kn7Ly.png" alt="image-20210518114846042" style="zoom:67%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：这个是基本概念问题，从下而上，第一个提供的是传输层,所以选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/FBRMkwIDnuaTKdG.png" alt="image-20210518145934778" style="zoom:67%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：网络体系结构并没有描述协议的内部实现细节，所以选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/sRiGIDf3Ynw2Mct.png" alt="image-20210518230116890" style="zoom:67%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：在OSI参考模型中，应用层的相邻层是表示层，负责解决双方交换信息的表示问题，所以选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/FaEqoigQLG4tHPu.png" alt="image-20210520145739421" style="zoom:67%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：按照OSI参考模型的结构，直接为会话层提供服务的是会话层的下一层，传输层，所以选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/5iKbacjIhH1gwrp.png" alt="image-20210522011224206" style="zoom:67%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：注意是OSI参考模型，一共有7层，除了物理层和应用层之外，其余还有5层，则一共的额外开销是100B，那么传输效率为400/500=80%，所以选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/XfSybj3FA5MCBLI.png" alt="image-20210522193943123"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：OSI参考模型的自下而上的第5层是会话层，作用是会话管理，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/aiDQEsY5jrWKRc2.png" alt="image-20210522203306340" style="zoom:50%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：语法：定义收发双方所交换信息的格式    语义：定义收发双方所有完成的操作   同步：定义收发双方的时序关系，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221201195923357.png" alt="image-20221201195923357"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：传输层的下一层是网络层，自然是路由选择，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221211032032261.png" alt="image-20221211032032261"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：WEB服务出现在ARPANET之后，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/DFlSA7LuXgbdR2N.png" alt="image-20210520201927463" style="zoom:67%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：R1是路由器，在网络层工作，属于第3层，Switch是交换机，在数据链路层工作，属于第二层，Hub是集线器，在物理层工作，属于第一层，所以选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/FCkjmAUuN6gyQlS.png" alt="image-20210520202137801" style="zoom: 80%;" /></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/l9wf8ZoCHDVyEMF.png" alt="image-20210520202251041" style="zoom: 80%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p> 解析：明显考察的是香农公式的相关知识$c=W×log_2(1+\frac{S}{N})$</p><p>理论最大传输速率约为80kbps，那么实际速率是40kbps</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/VzIfN3vqrPMl2Fp.png" alt="image-20210520203224961" style="zoom:67%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：本题考察交换机和集线器的区别，交换机会点对点的传播信息，而集线器只会将数据广播出去，所以能收到该数据帧的有H3和H2</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/zK2EelsTYXgGh8N.png" alt="image-20210520203512911" style="zoom:67%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p> 解析：H3和H4之间是100Base-T以太网总线，传输速率是100Mbps，以太网规定争用期为512比特时间，所以本题中的以太网争用时间为$ 512/100Mb/s=5.12\mu s$，争用期包含信号端到端的传播时延和HUB双向再生比特流的时间，</p><p>该以太网端到端的单程信号传播时延为  $5.12\mu s/2-1.535\mu s=1.025\mu s$</p><p>因此H3到H4的最远距离为：200×1.025=205m</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/mZCAIQEdpoPxkf3.png" alt="image-20210520205353069" style="zoom:67%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：R3向R2通告的内容是，R3无法到达该网络，但R3并没有向R1更新信息，而R2收到R1更新后，会认为到达目的网络，可以从R1到R3再到目的网络，距离为3</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/8bo5icTN7svgdUl.png" alt="image-20210520205628428" style="zoom:67%;" /></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/qT23a9S7ZmMe4Co.png" alt="image-20210520210319191" style="zoom:67%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：因为点对点链路使用的是201.1.3.x/30地址，则可分配地址只有两个，分别是202.1.3.9和202.1.3.10，所以R2的L0接口地址为202.1.3.10，目的IP地址就是WEB服务器地址为130.18.10.1，所以答案选D      </p></div></div><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/8VpTZaW7loDGFM2.png" alt="image-20210520210529318" style="zoom:67%;" /></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/LRC9tyw5NVFpsGS.png" alt="image-20210520210548519" style="zoom:67%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：可以知道H1和H2是在同一个网络的，H3和H4在同一个网络，所以A D都不可能发生，H2和H4的默认网关是192.168.3.254，是R2的网络路由器，所以可以访问到互联网，H1和H3的默认网关在图上没有显示，所以不能正常进行IP通信</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/CgIEWomcPS4bkzd.png" alt="image-20210521121256546" style="zoom:67%;" /></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/yF2IsB81iWEopfc.png" alt="image-20210521121326368" style="zoom:67%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：如果在本地域名服务器中就有缓存，就不需要发送DNS查询，最少为0次，如果没有缓存，使用迭代方式查询，先向根域名服务器查询，然后就向顶级域名服务器查询.com，然后向权限域名服务器查询xyz.com，然后向权限域名服务器查询abc.xyz.com，最多查询4次</p></div></div><hr><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a><strong>物理层</strong></h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/uxgGq3oHfLsRh4K.png" alt="image-20210518115012608" style="zoom:67%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：这个主要考察的知识点是奈氏准则和调制的相关知识点，首先采用4个相位，每个相位有4种振幅，则一共有16种波形，那么可以调制的比特数量为$log_216=4$，再利用奈斯准则，传输速率为 $2×3×4=24kbps$,所以选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/Un5DQBafEO3iI6o.png" alt="image-20210518155951861"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：采用4相位调制，那么码元数为$log_24=2$，波特率×码元数=比特率，波特率=2400/2=1200波特，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/IYEJtpyK9QZX8bF.png" alt="image-20210518193433805"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p> 解析：</p><p>机械特性：指明接口所用接线器的形状和尺寸      </p><p>电气特性：指明在接口电缆的各条线上出现的电压的范围</p><p>功能特性：指明某条线上出现的某一电平表示各种意义</p><p>过程特性：指明对于不同功能的各种可能事件的出现顺序</p><p>选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/InJdVB6Q2LXmjvC.png" alt="image-20210518235712448"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析： 10 BaseT网卡使用的是曼彻斯特编码，以中间时刻的跳变来表示数据，如果正跳变表示1，则该波形的数据是11001001，如正跳变表示0，则该波形的数据是0011 0110，所以此题选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/IESUwqQn1oPy2he.png" alt="image-20210520150153454"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：根据香农公式和奈氏准则，A，B，C都会影响传输速率，所以选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/kFcKVGZy4WMeYgt.png" alt="image-20210520172742345" style="zoom:67%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：很明显，编码1是不归零编码，编码2是曼彻斯特编码，选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/4OsZSdLYDjt6peV.png" alt="image-20210522011449198"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p> 解析：根据奈氏准则，在无噪声情况下的极限数据传输速率为：2W·Baud</p><p>​           根据香农定律，极限数据传输速率$W·log_2(S/N+1)=W·log_21001=9.8W$</p><p>​           2W·Baud&gt;9.8W,那么Baud&gt;4.9,则$log_2X&gt;4.9$，X至少是32</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/XAUZwTVCWbisPeI.png" alt="image-20210522183111952"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：物理地址就是MAC地址，位于数据链路层，所以选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/QEx638iVYmI5cKb.png" alt="image-20210522194144701"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：100BaseT中的T指的是Twisted pair (双绞线)</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221201200051943.png" alt="image-20221201200051943"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：是差分曼彻斯特编码，第一个码元无法判断信息，但根据之后的码元，跳变是0，不跳变1，所以选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221210192631507.png" alt="image-20221210192631507"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：M进制的码元表明有M个波形，因此码元和比特的关系为：$log_2M=b$，所以A正确，对于B来说，600波特是600B/s，C也同理，D选项只是说了50码元，但是没有说码元的进制，不确定</p></div></div><hr><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a><strong>数据链路层</strong></h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/QXeprG7DnqgYEZm.png" alt="image-20210518115342948" style="zoom:67%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p> 解析：考察的是回退N帧协议，协议特点是采用了累计确认的机制，如果收到了N帧的确认，那么N帧以及N帧之前的数据都可以确认接受了，即使N帧之前有些帧没有收到，那也可以确认收到</p><p>此题中，收到了0.2.3帧的确认，那么可以默认其收到了3帧以及3帧之前的确认，所以要重发的帧是4.5.6.7共4个帧，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/C2xeh7nXvZdIH9Q.png" alt="image-20210518115751909" style="zoom:67%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：以太网交换机工作在计算机网络的数据链路层，PDU(协议数据单元)对于数据链路层来说，就是帧，以太网交换机进行转发时，目的地址是目的物理地址，也称为MAC地址，所以选A</p></div></div><hr><p><strong>重点</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/DTscBdVoEyXR6PY.png" alt="image-20210518120126170" style="zoom:67%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p> 解析：此题考察CSMA/CD协议的相关概念，需要了解的是争用期，最小帧长等概念</p><p>争用期=信号在数据信道中往返的时间，最小帧长=争用期×传输速率</p><p>在此题中，假设减少的距离是X，$\frac{x}{2×10^8}×2×10^9=800$,x=80,所以是80m，选D</p></div></div><hr><p><strong>重点</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/vP5bxcQoUgN98Ft.png" alt="image-20210518150127586" style="zoom:67%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p> 解析：H1到H2的路径，至少包含两个路由器，也就是要经过两次转发</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/mKfaV2wo9tYBDxQ.png" alt="image-20210518150242675" style="zoom: 67%;" /></p><p>题目要求忽略传播时延，最终花费的时间为所有分组的发送时延+1个分组的发送时延×2</p><p>需要的时间=$(980×8)/(1×10^8)×980000/980+(1000×8)/(1×10^8)×2=80.16ms$，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/bNWnaSv3iFdzRjx.png" alt="image-20210518151623430" style="zoom:67%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：集线器可以扩展网络的广播域和碰撞域，网桥可以扩展网络的广播域，只有路由器可以隔绝网络风暴，所以选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/JneOcN2ojqfv1lm.png" alt="image-20210518160154849" style="zoom:67%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：采用选择重传协议，SR协议没有采用累计确认机制，所以超时的帧都会被重传，重传的帧数为0   2，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/sHdmgJwQyRcVO1K.png" alt="image-20210518161936781"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：只有CSMA/CA协议会对正确收到的数据帧进行确认，因为CSMA/CA是无线网采用的协议，误码率高，所以采用确认机制</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/y98ZN2AmYL54DSH.png" alt="image-20210518194406240" style="zoom:67%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：很明显,以太网的MAC协议就是CSMA/CD协议，而无线网的MAC协议是CSMA/CA,所以CSMA/CD提供的是无连接的不可靠服务，选A</p></div></div><hr><p><strong>重点</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/uW4zlRMAQrE76T1.png" alt="image-20210518200126699" style="zoom:67%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p> 解析：根据回退N帧协议的特点，从发送第一个数据帧开始，在未收到确认帧的情况下，可以一直连续不断的发送数据帧，为了信道利用率最高，所以应该是在发送数据帧到收到数据帧的总时间内，发送窗口的值至少应该比可以发送的帧的数目要大</p><p>假如数据帧的长度是128字节，发送一帧的时间是(128*8)/16000=64ms，发送一帧到收到确认为止的总时间为64+270×2+64=668ms，这段时间内，可以发送帧的数量为668/64=10.4375，所以至少要发送窗口至少大于11，$2^x&gt;11$，x至少应该是4</p><p>之所以选择128字节，因为如果选择更大的字节数，那么可以发送的帧的数量会变小，题目问的是要让信道利用率达到最高，所以比特数至少是4</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/f4LJRxDakMpPcGy.png" alt="image-20210518202619556" style="zoom:67%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：基本概念，选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/2tPoH1kwJlLizOc.png" alt="image-20210519150629063"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p> 解析：主要考察报文交换和分组交换</p><p>采用报文交换，一次性发送8MB数据，忽略传播时延，那么需要的时间为发送时延×2=1600ms</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/Sc2EW6sxIXpNBmR.png" alt="image-20210520142459426" style="zoom: 50%;" /></p><p>采用分组交换，一次发送10KB大小的分组，忽略传播时延，那么需要的时间为所有分组的发送时延+最后一个分组的路由器发送时延=800+1ms=801ms</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/DgXsdJopSZRhe87.png" alt="image-20210520142537260" style="zoom:50%;" /></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/va5sWtVr2cI7eu6.png" alt="image-20210520142606259"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：CDMA TDMA FDMA 都是静态划分信道的方法，不会产生冲突，CSMA是动态接入控制中的随机接入，会发生冲突，所以选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/OFns42fwdPKla9g.png" alt="image-20210520142843498"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：考查数据链路层中的可靠传输，对于比特流，数据链路层采用的是每5个1之间插入1个0的方法来实现可靠传输，所以选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/AFGH9URbpvnSWzk.png" alt="image-20210520143031298"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p> 解析：以太网交换机有两种方式，一种是存储转发，一种是直通转发</p><p>直通转发就是在读取以太网帧的目的MAC后直接转发数据，目的MAC地址为6B，所以接受完目的MAC地址所耗费的时间=$(6×8)/(100×10^6)=0.48\mu s$,所以选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/J2BNTeiCdhbkXDu.png" alt="image-20210520145924491"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p> 解析：考察交换机自学习的过程</p><p>a向c发送信息，由于路由表中没有c的信息，所以会进行洪泛转发，转发端口为{2,3},并记录下a和端口1之间的关系</p><p>c向a发送信息，由于路由表中已经记录有a的消息，所以会进行单播转发，转发端口为{1}</p><p>所以选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/EIBKstRvyuDnU71.png" alt="image-20210520150305095"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p> 解析：甲乙之间的单向传播时延是50ms，则来回的总时间是100ms，在这个时间段内，主机甲发送一个分组所用的时间是 $(1000×8)/(100×10^6)=0.08ms$，0.08×1000=80ms&lt;100ms,所以主机甲在100ms内可以发送1000个分组，数据传输速率=数据传输量/数据传输时间，</p><p>$(1000×8×1000)/0.1=80Mbps$</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/dfyontNiqYxBrzE.png" alt="image-20210520153036349"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：考察的是CDMA码分多址，将C的序列分为4个一组，与A的码片分组做内积，可以得到1，-1，1，说明发送的信息是101</p></div></div><hr><p><strong>重点</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/YcnJI3ysG91OtTK.png" alt="image-20210520173146460"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p> 解析：<img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/NMWkqV7TB42idZm.png" alt="image-20210520174502038"></p><p>为了使链路利用率不小于80%，总时间的(a+b+c)的80%都应处于连续发送数据帧的过程</p><p>总时间的80%=$((1000×8)/(128×10^3)+250ms+250ms)× 0.8 =450ms$</p><p>在450ms内发送的比特数量为450×128=57600b=7200B=7.2个数据帧</p><p>后退N帧协议的发送窗口尺寸$W_t≤2^n-1$</p><p>选择重传协议的发送窗口尺寸$W_t≤2^{n-1}$，所以帧的比特数量最少是4</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/WoDRd2TQLsftaJ9.png" alt="image-20210520192957448" style="zoom: 80%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：CSMA/CD是以太网的传输协议，并不使用于无线网络，所以选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/DUBLTy1HeEYvscz.png" alt="image-20210520193120575"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：以太网本质上是一种多端口网桥，可以扩大网络的广播域，并不增加网络的冲突域，所以B，C错误，以太网交换机是工作数据链路层的协议，并不知道上层网络层协议，所以不能实现网络层协议，D也错误，答案是A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/4QtONyx7JzUGc2L.png" alt="image-20210522012112072"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p> 解析：IEEE 802.11的数据帧有3个地址，格式如下</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/1j9hS8B6rqFTJgs.png" alt="image-20210521202246159"></p><p>则在该题中，数据帧是去往AP的，地址1为AP地址，地址2是源地址，地址3是目的地址，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/R3XPd7i9Naq8ecC.png" alt="image-20210522183219523"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：通过RTS与CTS帧的交换进行信道预约，所以选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/YvyJoHnNqsOSD1a.png" alt="image-20210522183303294"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p> 解析：假设数据帧的长度为X，信道利用率=发送时延/(发送时延+传输时延)</p><p>$(X/3×10^3)/(X/3×10^3+0.4)=0.4$，X=800</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/QAf9KFdGYr4kcPe.png" alt="image-20210522183535656"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：数据包在发送过程中，MAC地址会改变，而IP地址不变，所以MAC地址分别是-51和-61，选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/tJQdeVuSWZyCviF.png" alt="image-20210522194434850"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p> 解析：如果是接收窗口最大的话，那么一定是选择重传协议</p><p>发送窗口$W_T$和接收窗口$W_R$的取值范围 $W_R+W_T≤2^{n}$，所以接收窗口的最大值为3</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/HB8xejrTJQYLgNt.png" alt="image-20210522195848422"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p> 解析：最小帧长=争用期×发送速率</p><p>争用期=$128×8/10^5=10.24\mu s$，那么，单向传播时延是$10.24\mu s/2=5.12\mu s$</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/7uHG8tZnFhg9Y1e.png" alt="image-20210522203637108"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：集线器拓展冲突域和广播域，交换机扩展广播域，隔绝冲突域，路由器隔绝冲突域和广播域，所以选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/HjWRBMSbLrwVzt9.png" alt="image-20210522203811615"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p> 解析：信道利用率=发送时延/(传输时延+发送时延+确认帧发送时延)</p><p>​          $0.8/(0.8×2+0.2×2)=40$%</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/zZdpSkqLDjrHAVx.png" alt="image-20210522224753381"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/mfcKeD4bsE97RBV.png" alt="image-20210522224801958" style="zoom: 50%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：IFS2,IFS3,IFS4是短帧间间隔SIFS，而IFS1是DIFS，比SIFS长的多</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221211032216008.png" alt="image-20221211032216008"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：注意是双工状态，最后要乘2，选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221211033114811.png" alt="image-20221211033114811"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：需要进行CRC循环验证，步骤如下：</p><ol><li>多项式比特序列为11001，即需要在11110011的后面补上4个0，即为111100110000</li><li>然后让111100110000和11001进行异或除法(相异为1，相同为0)，直到求出余数为1110</li><li>将1110写到比特序列后，变成111100111110，即选D</li></ol><p>补充：如果最后余数为不够4位，则在前面补0</p></div></div><hr><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a><strong>网络层</strong></h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/8WZpbVdz3DUTtYP.png" alt="image-20210518150937614" style="zoom:67%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：在RIP协议中，距离16代表不可达，所以选择D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/6ndW1MjovQrtxJi.png" alt="image-20210518151057669" style="zoom:67%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：拥塞丢弃分组是源点抑制</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/psGOjKfoybqPc2I.png" alt="image-20210518151149727" style="zoom:67%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p> 解析：考察定长子网的概念</p><p>首先判断该IP地址为C类地址，然后子网掩码为255.255.255.248，换算成2进制，最后的字节        248=11111000，即借用了主机号的前5位作为网络号，所以网络中的最大子网个数为$2^5=32$ ,地址数量为$2^3=8$,每个子网需要一个网络地址和一个广播地址，所以最大可分配地址个数为6，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/pqP3iJF5lZ1tjR7.png" alt="image-20210518155846660" style="zoom:67%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：基本概念，IP协议提供的是无连接不可靠的数据报服务</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/jTVvtCPOZRn3dyI.png" alt="image-20210518170139628"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p> 解析：考察的是路由器的跳转问题</p><p>让R1的IP分组正确地达到所有子网，首先可以确定的是下一跳的地址肯定是R2的接口192.168.1.2，然后将子网聚合，得到聚合地址块 </p><p>将192.168.2.0/25和192.168.2.128/25聚合得到192.168.2.0/24，网络地址为192.168.2.0，子网掩码为255.255.255.0，所以选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/OVqQtmB38veiMPR.png" alt="image-20210518170754509"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p> 解析：考察划分子网的知识，192.168.4.0是C地址，/30说明将主句号的前6位都用作了网络号，主机号只有两位，而能够作为子网地址的只有192.168.4.2和192.168.4.1</p><p>如果192.168.4.3是单播地址，那么能接收的IP分组最大主机数为1，如果为广播地址，则接收该目的地址的IP分组的最大主机数为该地址块中可分配的地址数，最大为2，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/d1bQktA3X7gEsy6.png" alt="image-20210518193241992" style="zoom:67%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：ICMP(Internet Control Message Protocol)是网际控制报文协议，由IP数据报封装，所以选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/9scKOIXpQVEouUz.png" alt="image-20210518202502679" style="zoom:50%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：IP路由器确实能对收到的IP分组头进行差错校验，但是并不能保证传输的IP分组不丢失，所以选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/vwPbaTO2mkXzAFy.png" alt="image-20210518202708247" style="zoom: 67%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p> 解析：该主机的是B类地址，子网掩码是255.255.252.0,252转化为2进制是 1111 1100，主机号的前6位被占用为网络号，主机的IP地址的广播地址为</p><div class="table-container"><table><thead><tr><th>网络号</th><th>主机号</th></tr></thead><tbody><tr><td>180.80.010011</td><td>11.11111111</td></tr></tbody></table></div><p>是180.80.79.255 选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/3TvIEXBAzODV5CP.png" alt="image-20210520193410429"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：当目的地址的网络可以和多个目的网络匹配上时，选择后缀最长的网络，所以选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/t1eAQqh4SjKBI8D.png" alt="image-20210522012838576"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p> 解析：0.0.0.0表示主机地址，可以作为源地址，但是不能作为目的IP地址</p><p>​          127.0.0.1表示环回测试地址，既可以作为源地址，又可以作为目的地址</p><p>​           20.10.10.3是普通的A类地址，既可以作为源地址，又可以作为目的地址</p><p>​          255.255.255.255是广播地址，不可以作为源地址，可以作为目的IP地址</p><p>选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/kY8alpCWg17XMqP.png" alt="image-20210522013143558" style="zoom:67%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：基本概念问题，分别是UDP,IP,TCP</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/IMVPZSuX9p3qnmg.png" alt="image-20210522013239411"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：划分为128个规模的子网，则$log_2X=128,X=7$，需要借用7位主机号来分配网，剩下的主机号为16-7=9，最大IP地址个数为$2^9=512$，而可以分配的IP地址数为512-2=510</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/6E3SmqjK7eAwUTB.png" alt="image-20210522183705668"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p> 解析：路由聚合的方法：找待聚合的各网络的共同前缀</p><p>聚合之后的网络地址为：35.230.32.0/19</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/wklpfSt9isaVX2B.png" alt="image-20210522200316020"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p> 解析：划分为5个子网，1个是可能的最小子网，那么另外4个子网要尽可能的大</p><p>101.200.16.0/20 的主机号段是 101.200.0001 |0000   0000 0000</p><p>第21位为0 也是就/21地址块是最大的地址块，然后就第21位为1的地址块再进行细分，第22位为0的地址块是第二大地址块，就第22为1的地址块细分，第23为0的地址块是第3大地址块，就第23为1的地址块进行细分，第24位为0和为1的地址块是第4，第5大地址块，也就是尽可能小的地址块，地址数量为：$2^8=256$</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/hd46TCB28U3PjxN.png" alt="image-20210522203441818"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：建立虚电路的时候需要进行路由选择，虚电路网络不需要为每条虚电路预分配带宽，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221201200438385.png" alt="image-20221201200438385"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：B只能组成4个子网，并不能形成3个子网，所以选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221201200625071.png" alt="image-20221201200625071"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：首先，IP数据报的数据部分除了最后一个外，必须是8的整数倍，MTU=800B，所以每次只能运送776B的数据部分，1560/776=2.02，所以需要至少3次，MF表示后面还有分片，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221201200953336.png" alt="image-20221201200953336"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：路由器E到各个网络都必须经过其他路由器，即将路由器E到其他路由器的距离+其他路由器到网络的距离，选最小的，即为D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221211015300022.png" alt="image-20221211015300022"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：$2^x&gt;24$,所以x至少为5，主机号至少为5，那么选D</p></div></div><hr><h3 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a><strong>运输层</strong></h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/1lJZXBq3gGQH5kf.png" alt="image-20210518122513494" style="zoom:67%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p> 解析：此题考察的是TCP协议的确认机制，在TCP报文中，当正确收到了报文X，那么回传的确认的报文序号是X+1,</p><p>在此题中，第一个段的序号为200，则第二个段的序号为200+300=500，正确收到第二个段后，应该发送第三个段的序号，则为500+500=1000，选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/AoJGRFExdUqj3pB.png" alt="image-20210518122754848" style="zoom:67%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p> 解析：此题考察的是TCP协议的拥塞控制，当发生堵塞的时候，慢开始门限会变为原来的一半，而发送窗口会重置为1,</p><p>此题中，拥塞窗口为16KB时发生了堵塞，则发送窗口变为1，慢开始门限变为8，经过4个RTT，则发送窗口从，1变为2,2变为4,4变为8，到8的时候启动拥塞避免算法，从8到9，所以选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/e2fAoHLEaUzJiZl.png" alt="image-20210518151923330" style="zoom:67%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p> 解析：此题考察TCP连接的流量控制原理</p><p>当主机乙收到了第一个段的确认段时，滑动窗口向前移动，接收窗口同时变为2000字节，此时，接收窗口内有待确认的第2段，以及还未发送的第3段，所以还可以发送的最大字节数为1000字节，所以此题选A</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/pRWfjhZsqOumGX9.png" alt="image-20210518152214261"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/OMiN3VUcJHlhPqW.png" alt="image-20210518171315692" style="zoom:67%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：考察的知识点是TCP连接的建立过程，当主机甲发送SYN=1,seq=x时，主机乙如果要建立连接，应该要回复SYN=1,ACK=1,seq=y,ack=x+1,综上选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/q6uydviKbIkgLnc.png" alt="image-20210518171754133" style="zoom:67%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p> 解析：考察TCP协议中的确认机制</p><p>TCP协议并没有累计确认机制，所以主机乙正确接受到第1和第3段后，会向主机甲发送的确认序号应该是第2段的序号，也就是900-400=500  选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/YiUXL2BqMCHe9GE.png" alt="image-20210520143945241"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：收到乙的确认序号为2046，则要发送的需要就是2046，收到了乙的数据段序号为1913，载荷为100字节，则发送的确认序号就是1913+100=2013，所以选B</p></div></div><hr><p><strong>重点</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/pZgy4YsDcFPoG7B.png" alt="image-20210520153314038"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p> 解析：考察TCP的拥塞控制</p><p>当发生超时的时候拥塞窗口为8kb，则会将慢开始门限变为4KB，发送窗口为1KB，进行慢开始算法</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/XNQuFqHrgtkaP6I.png" alt="image-20210520153953116"></p><p>10个RTT后拥塞窗口变为12KB，但是乙每次都会发送接收窗口为10KB的确认段，甲的发送窗口取决于接收窗口和拥塞窗口的最小值，所以甲的发送窗口为10KB，选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/8duDeLT1JI2fRWU.png" alt="image-20210520170943143"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：UDP协议提供是无连接服务，TCP和UDP都可以提供复用/分用服务，而UDP协议并不提供可靠数据传输服务，所以选择B</p></div></div><hr><p><strong>重点</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/CMoJylqLNDtuAab.png" alt="image-20210520193616428"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：乙收到的数据全部存入缓存，不被取走，以为着每次接收过后，接收窗口的值都会降低，在不发生阻塞的情况下，阻塞窗口会一直提高，发送窗口的取值是阻塞窗口和接收窗口的最小值，在4个RTT后，接收窗口的值是16-1-2-4-8=1，阻塞窗口的值是1-2-4-8-16，取最小值，发送窗口是1KB，选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/tyvaHVonEpOJ48N.png" alt="image-20210522013619849" style="zoom:67%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：拥塞窗口的增长是1-2-4-8-16-32，接收窗口的减少是64-63-61-57-49-33-1，至少需要5个RTT，时间为5×5ms=25ms</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/DSa71VlTkHA4NIJ.png" alt="image-20210522183840681"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：分用是指在目的主机收到了报文后，按照目的端口号将数据交付给上面的进程，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/bLiURE5N6GQ8cqI.png" alt="image-20210522201852567" style="zoom:67%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：若TCP支持快重传，那么会在收到连续的3次相同的确认报文后立即开始重传，时间点在t3，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/4QWSYHJ1pofwKq7.png" alt="image-20210522202017259"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：第三次握手的TCP段的ACK=y+1,y是第二次握手时乙发送的初始序列号，则为2046+1=2047，选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/pxO3l7JZv8LgNMz.png" alt="image-20210522224946606"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：最长时间是在达到了慢开始门限值后，再开始增加的拥塞窗口，8到20需要经过12个RTT，就是24ms，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/fOvdXNgMqJsxLcD.png" alt="image-20210522225200566"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：在4次挥手中，甲向乙发送的FIN段是第一次挥手，其不携带任何信息，所以甲给乙发了5000-1000=4000，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221201201147252.png" alt="image-20221201201147252"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：此时客户的状态时TIME_WAIT，经过2MSL后，关闭，选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221201201405074.png" alt="image-20221201201405074"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：UDP的首部大小为8B，而TCP的首部大小为20B，所以是D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221201201821978.png" alt="image-20221201201821978"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：甲已经发送了200B，而乙并没有确认，所以只能发送300B，之后的数据序号为701~1000，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221211032113431.png" alt="image-20221211032113431"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：TCP协议通过差错控制和纠正来保证可靠传输，选C</p></div></div><hr><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a><strong>应用层</strong></h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/DjWxgaIdPiwSAVU.png" alt="image-20210518123414257" style="zoom:67%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：此题考察应用层的FTP协议，在建立FTP连接时，先建立TCP控制连接用来传递FTP命令，然后再建立FTP数据连接传输数据，FTP控制连接一直建立，而FTP数据连接是有数据连接时才建立，所以此题选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/cVi4lo5qXB7Yedb.png" alt="image-20210518152248551" style="zoom:67%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：在递归查询中，用户主机和本地域名服务器发送的消息都是一条，消息由服务器层层递进，选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/Nu1W6gvlxAesSMB.png" alt="image-20210518203353153" style="zoom:67%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：用户于邮件服务器，邮件服务器之间都采用的是STMP协议，而用户从邮件服务器中取出数据采用的是POP3协议，所以选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/X1fa9vtigxKNbcS.png" alt="image-20210520144447533"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：从邮件服务器向用户代理发送邮件使用的是POP3协议，所以选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/pzY3n9FtRQ6VKfU.png" alt="image-20210520171145886"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：如果家庭局域网与ISP之间通过PPP协议，而主机使用ARP协议来获取MAC地址，查询DNS地址会用到UDP协议，所以选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/86s7HRFc3dCKqGL.png" alt="image-20210520172617313" style="zoom:67%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：POP协议的传输层协议是TCP协议，所以是有链接可靠的数据传输服务，选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/xlrtMHvF3cXjA94.png" alt="image-20210520194448098" style="zoom:80%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：因为有Cookie，所以该浏览器曾经浏览过该网址，GET报文请求浏览index.html。确实存放在该网址上，Connection方式是Close，代表不是持续连接，所以选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/Hbr73KgU6VuGJt5.png" alt="image-20210522014253809"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：服务器与服务器的TCP21端口建立控制连接，但是数据连接的建立端口取决于是被动连接还是主动连接，所以连接端口不一定是20，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/Qdroyf1ntFOAiM4.png" alt="image-20210522183020071"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：DNS使用的是UDP协议，所以是无连接服务，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/IR9w8X4NmYByga7.png" alt="image-20210522184003448"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：SMTP传输的数据都是ASCII文本，如果不是ASCII文本，就会通过MIME来转换</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/9JYkutZfoTrUXq8.png" alt="image-20210522202122259"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：很明显在C/S模型中，客户和客户之间不可以直接通信，所以选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/yCiek52OLFp7dR6.png" alt="image-20210522225412986"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：主机与WEB服务器建立连接需要三报文握手，要经过2个RTT时间，也就是20ms，题目没有给出主机和本地域名服务器之间的交互时间，所以忽略不计，那么最短时间就是20ms，最长时间是，经过根域名服务器，com顶级域名服务器，abc.com权限域名服务器，经过3次查询，最长时间是20+30ms=50ms</p></div></div><hr>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.应用层</title>
      <link href="/post/60874.html"/>
      <url>/post/60874.html</url>
      
        <content type="html"><![CDATA[<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>应用层解决应用进程的交互来实现特定网络应用的问题，是计算机网络体系结构的最顶层，是设计和建立计算机网络的最终目的</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/OSyt5AorhqlB46X.png" alt="image-20210513222908382"></p><h2 id="客户服务器方式和对等方式"><a href="#客户服务器方式和对等方式" class="headerlink" title="客户服务器方式和对等方式"></a>客户服务器方式和对等方式</h2><p>网络应用程序运行在处于网络边缘的不同的端系统，通过彼此间的通信来共同完成某项任务</p><p>开发一种新的网络应用首先要考虑的问题就是网络应用程序在各种端系统上的组织方式和他们之间的关系</p><p>目前主要流行的是以下两种：</p><ul><li>客户/服务器(Client/Server,C/S)方式</li><li>对等(Peer-to-Peer,P2P)方式</li></ul><hr><p>客户/服务器就是指通信中所涉及的两个应用进程</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/EjC9Fg7wWLGUlNr.png" alt="image-20210513223841461"></p><p>客户是服务请求方，服务器是服务提供方</p><p>服务器总是处于运行状态，并等待客户的服务请求，服务器具有固定端口号(例如HTTP服务器的默认端口号为80)，而运行服务器的主机也具有固定的IP地址</p><p>C/S方式是因特网上传统的，同时也是最成熟的方式，很多网络应用采用的就是C/S方式</p><p>基于C/S方式的应用程序通常是<strong>服务集中型</strong>的，即应用服务集中在网络中比客户计算机少得多的服务器计算机上</p><ul><li>由于一台服务器计算机要为多个客户机提供服务，在C/S应用中，常会出现服务器计算机跟不上众多客户机请求的情况</li><li>为此，在C/S应用中，常用计算机集群来构建一个强大的虚拟服务器</li></ul><hr><p>对等方(Peer-to-Peer)方式</p><p>在P2P方式中，没有固定的服务请求者和服务提供者，分布在网络边缘各端系统中的应用进程是对等的，被称为对等方。对等方相互之间直接通信，每个对等方既是服务的请求者，又是服务的提供者</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/5sZOb8uQ1XEVGNw.png" alt="image-20210513234930891"></p><p>基于P2P的应用是<strong>服务分散型</strong>的，因为服务不是集中在少数几个服务器中，而是分散在大量对等计算机中</p><p>P2P最突出的特性之一就是它的<strong>可拓展性</strong>，因为系统每增加一个对等方，不仅增加的是服务的请求者，同时也增加恶劣服务的提供者，系统性能不会因为规模的增大而降低</p><p>P2P<strong>具有成本上的优势</strong>，因为它通常不需要庞大的服务器设置和服务器带宽</p><hr><h2 id="域名系统DNS"><a href="#域名系统DNS" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h2><p>域名系统DNS(Domain Name System)是因特网使用的命名系统，用来把便于人们记忆的具有特定含义的主机名，转为方便于机器处理的IP地址</p><p><strong>DNS使用的是UDP连接</strong>，因为UDP速度快于TCP</p><p>当我们在浏览器地址栏中输入某个Web服务器的域名时，用户主机会首先在自己的DNS高速缓存中查找该域名所对应的IP地址，如果没有找到，则会向网络中某台DNS服务器查询，DNS服务器中有域名和IP地址的映射数据库</p><p>因特网采用<strong>层次树状结构</strong>的域名结构</p><p>域名的结构由若干个分量组成，各分量之间用点隔开，分别代表不同级别的域名</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/KYqXzifdwscmZ9r.png" alt="image-20210515120908885"></p><ul><li>每一级的域名都由英文字母和数字组成，不超过63个字符，不区分大小写</li><li>级别最低的域名写在最左边，而级别最高的顶级域名写在最右边</li><li>完整的域名不超过255个字符</li></ul><p>域名系统既不规定一个域名需要包含多少个下级域名，也不规定每一级的域名代表了什么意思</p><p>各级域名由其上一级的域名管理结构管理，而最高的顶级域名则由因特网名称与数字地址分配机构ICANN进行管理</p><p>顶级域名TLD(Top Level Domain)分为以下三类：</p><ul><li>国际顶级域名nTLD   采用ISO 3166的规定，如cn表示中国，us表示美国等</li><li><p>通用顶级域名gTLC   最常用的通用顶级域名有7个，即：com(公司企业)，net(网络服务机构)，org(非营业性组织)，int(国际组织)，edu(美国教育结构)，gov(美国政府部门)，mil(美国军事机构)</p></li><li><p>反向域arpa  用于反向域名解析，即IP地址反向解析为域名</p></li></ul><p>在国家顶级域名下注册的二级域名均由该国家自行确定</p><p>我国将二级域名划分为以下两类：</p><ul><li>类别域名    共7个 ：ac(科研机构)，com(工，商，金融等企业)，edu(教育机构)，gov(政府部门)，net(提供网络服务的机构)，mil(军事机构)和org(非盈利性组织)</li><li>行政区域名：共34个，适用于我国的各省，自治区，直辖市等等</li></ul><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/iqCzNKnUvcPTsMS.png" alt="image-20210515134747409" style="zoom:67%;" /></p><p>域名和IP地址的映射关系必须保存在域名服务器中，供其他应用查询，DNS使用分布在各地的域名服务器来实现域名到IP地址的转换</p><p>域名服务器可以划分为以下四种不同的类型：</p><ul><li>根域名服务器</li></ul><p>根域名服务器是最高层次的域名服务器，每个根服务器都知道所有的顶级域名服务器的域名及其IP地址，因特网共有13个不同IP地址的根域名服务器，根域名服务器通常不直接对域名进行解析，而是返回该域名所属顶级域名的顶级域名服务器的IP地址</p><ul><li>顶级域名服务器</li></ul><p>这些域名服务器负责管理该顶级域名服务器注册的所有二级域名</p><ul><li>权限域名服务器</li></ul><p>这些域名服务器负责管理某个区的域名，每个主机的域名都必须在某个权限域名服务器处注册登记，因此权限域名服务器知道其管辖的域名与IP地址的映射关系，另外，权限域名服务器还知道其下级域名服务器的地址</p><ul><li>本地域名服务器</li></ul><p>本地域名服务器不属于上述的域名服务器的等级结构，当一个主机发出DNS请求报文时，这个报文首先被送往该主机的本地域名服务器，本地域名服务器起着代理的作用，会将该报文转发到上述的域名服务器的等级结构中，有时被称为默认域名服务器</p><hr><p>域名解析的过程</p><ul><li><strong>递归查询</strong></li></ul><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/TEr7sRIaFfUeZxm.png" alt="image-20210515135549482"></p><p>本地域名服务器直接询问根域名服务器，然后根域名服务器再层层向下询问，得到信息后，原路返回</p><ul><li><strong>迭代查询</strong></li></ul><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/c7uXIAfeao3QKzD.png" alt="image-20210515135633703"></p><p>通过本地域名服务器向直接向根域名服务器查询，然后根域名服务器告诉本地域名服务器下级的域名服务器的地址</p><p>由于递归查询对于被查询的域名服务器负担太大，通常采用以下模式：</p><p><strong>从请求主机到本地域名服务器的查询是递归查询，而其余的查询是迭代查询</strong></p><hr><p>为了提高DNS的查询效率，并减轻根域名服务器的负荷和减少因特网上的DNS查询报文数量，在域名服务器广泛使用了告诉缓存。高速缓存用来存放查询过的域名以及从何处获得域名映射消息的记录</p><div class="note primary flat"><p>DNS查询的最少次数是0(命中高速缓存)，DNS查询的最多次数取决于域名长度</p></div><p>由于域名到IP地址的映射关系并不是永久不变，为保持高速缓存中的内容，域名服务器应为每项内容设计计时器并删除超过合理时间的项</p><hr><h2 id="文件传送协议FTP"><a href="#文件传送协议FTP" class="headerlink" title="文件传送协议FTP"></a>文件传送协议FTP</h2><p>将某台计算机中的文件通过网络传送到可能相距很远的另一台计算机中，是一项基本的网络应用，就是文件传送</p><p>文件传送协议(File Transfer Protocol)是因特网上使用得最广泛的文件传送协议</p><ul><li>FTP提供交互式的访问，允许客户指明文件的类型和格式，并允许文件具有存储权限</li><li>FTP屏蔽了各个计算机的细节，因而适合在异构网络中任意计算机之间传送文件</li></ul><p>FTP的常见用途是在计算机之间传输文件，尤其是用于批量传输文件</p><p>FTP的另一个常见用途是让网站设计者将构成网络内容的大量文件批量上传到他们的Web服务器</p><hr><p>FTP的基本工作原理</p><p>主动模式</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/SHev7QzY3asxqfp.png" alt="image-20210515194212745"></p><p>FTP随机选择一个临时端口号，与FTP服务器的熟知端口号建立TCP连接，用来传送控制命令，当有数据要传输的时候，FTP客户通过FTP服务器来与自己的另一个临时端口号建立TCP连接，建立数据通道，这种模式称为主动模式，建立数据通道时，FTP服务器主动连接FTP客户</p><p>控制连接在整个会话过程中一直保持打开，用于传送FTP相关控制命令</p><p>数据连接用于文件传输，在每次文件传输时才建立，传输结束就关闭</p><p>被动模式</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/gILweWfCOoKGUDF.png" alt="image-20210515194728197"></p><p>当有数据要传输时，FTP客户通过命令通道告知FTP服务器开启某个临时端口被动等待TCP连接，建立数据通道，这种模式称为被动模式，建立数据通道时，FTP被动等待FTP客户的连接</p><hr><h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><p>电子邮件系统采用客户/服务器方式</p><p>电子邮件系统的三个主要组成构件：用户代理，邮件服务器，以及电子邮件所需的协议</p><ul><li>用户代理是用户与电子邮件系统的接口，又称为电子邮件客户端软件</li><li>邮件服务器是电子邮件系统的基础设施，因特网上所有的ISP都有邮件服务器，其功能是发送和接收邮件，同时还要负责维护用户的邮箱</li><li>协议包括邮件发送协议(例如STMP)和邮件读取协议(例如POP3，IMAP)</li></ul><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/tMcGLlQy4wFsiSv.png" alt="image-20210515195419673"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20210515195428356.png" alt="image-20210515195428356"></p><p>简单邮件传送协议SMTP(Simple Mail Transfer Protocol)的基本工作原理</p><p>发送方会周期性地对邮件进行缓存扫描，如果发现有邮件，则会和SMTP服务器进行<strong>TCP连接</strong>，端口号为25，之后SMTP客户就可以通过该连接对SMTP服务器发送相关的控制命令，SMTP也会给SMTP客户发送相应的应答，共21种</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/omgxbZTyQkCinLS.png" alt="image-20210515200349045"></p><p>电子邮件的信息格式并不是由SMTP定义的，而是在RFC 822中单独定义，一个电子邮件有信封和内容两部分，而内容又由首部和主体两部分构成</p><hr><p>SMTP协议只能传送ASCII码文本数据，不能传送可执行文件或其他的二进制对象</p><p>SMTP不能满足多媒体邮件的需要，并且许多其他国家的文字也无法用SMTP传送</p><p>为了解决SMTP传送非ASCII码文本的问题，提出了<strong>多用途因特网拓展MIME</strong>(Multipurpose Internet Mail Extensions)，可以将非ASCII码的内容转换为ASCII码的形式</p><ul><li>增加了5个新的邮件首部字段，这些字段提供了有关邮件主体的信息</li><li>定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化</li><li>定义了传送编码，可对任何内容格式进行转换，而不会被邮件系统改变</li></ul><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/theAIg9qYT7pUGW.png" alt="image-20210515210516453"></p><hr><p>常见的邮件读取协议</p><p>邮局协议POP(Post Office Protocol)：非常简单功能有限的邮件读取协议，用户只能以下载并删除方式或下载并保留方式从邮件服务器下载邮件到用户方计算机，不允许客户在邮件服务器上管理自己的邮件</p><p>因特网邮件访问协议IMAP(Internet Message Access Protocol)：功能比POP3强大的邮件读取协议，用户在自己计算机上就可以操控邮件服务器中的邮箱，就像在本地操控一样，因此IMAP是一个联机协议</p><p>POP3和IMAP4都采用<strong>基于TCP连接的客户/服务器方式</strong>，POP3使用熟知端口110，IMAP使用熟知端口143</p><hr><p>现在越来越多的人使用万维网的电子邮件，通过浏览器登录邮件服务器万维网网站就可以撰写，收发，阅读邮件</p><p>用户可以通过用一个邮箱服务器，之间通过HTTP超文本链接协议发送信息</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/n7blLXS6uUzmHp3.png" alt="image-20210515211343604"></p><p>不同的邮件服务器之间也可以通过SMTP进行传送</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/FgwPX8l1CBpbxHv.png" alt="image-20210515211416771"></p><hr><h2 id="万维网WWW"><a href="#万维网WWW" class="headerlink" title="万维网WWW"></a>万维网WWW</h2><p>万维网WWW(World Wide Web)并非某种特殊的计算机网络，它是一个大规模，联机式的信息储存所，是运行在因特网上的一个分布式应用</p><p>利用网页之间的超链接将不同网站的网页链接成一张逻辑上的信息网</p><p>浏览器最重要的部分是<strong>渲染引擎</strong>，也就是浏览器内核，负责对网页内容进行解析和显示</p><hr><p>为了方便地访问在世界范围的文档，万维网使用统一资源定位符URL来指明因特网上任何种类资源的位置</p><p>URL由以下4个部分组成：</p><p>&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</p><p>万维网的文档由超文本标记语言HTML,层叠样式表CSS，脚本语言JavaScript</p><hr><p>超文本传输协议HTTP(HyperText Transfer Protocol)</p><p>定义了浏览器怎样向万维网服务器请求万维网文档，以及万维网服务器怎样把万维网文档传送给浏览器</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/BIcYUuFVzpCxsrZ.png" alt="image-20210515215654346"></p><p>HTTP/1.0采用非持续连接方式，在该方式下，<strong>每次浏览器请求一个文件都要与服务器建立TCP连接</strong>，收到响应后立即关闭连接</p><ul><li>每请求一个文档就要有两倍的RTT的开销</li><li>为了减少时延，浏览器通常会建立多个并行的TCP连接同时请求多个对象，但是这样会大量占用万维网服务器的资源</li></ul><p>HTTP/1.1采用<strong>持续连接</strong>方式，在该方式下，万维网服务器在发送响应后仍然保持这条连接，使同一个客户和该服务器可以继续在这条连接上传送HTTP请求报文和响应报文</p><hr><p>HTTP的报文格式</p><p>HTTP是面向文本的，其报文的每一个字段都是一些ASCII码串，并且每个字段的长度都是不确定的</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/fMioPSTwae4WEAH.png" alt="image-20210515224748271"></p><p>万维网使用Cookie在服务器上记录用户信息</p><ul><li>早期的万维网应用非常简单，仅仅是用户查看存放在不同服务器上的各种静态文档，因此HTTP被设计为一种无状态的协议，这样可以简化服务器的设计</li><li>Cookie提供了一种机制使得万维网服务器能够记住用户，而无需用户主动提供用户标识信息，也就是说，Cookie是一种对无状态的HTTP进行状态化的技术</li></ul><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/RkDqZ2bK7Xg6f4r.png" alt="image-20210515225045453"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/9ilfFxUJ1wnYXrj.png" alt="image-20210515225139099"></p><hr><p>万维网缓存和代理服务器</p><ul><li>在万维网中还可以使用缓存机制来提高万维网的效率</li><li>万维网缓存又称为Web缓存(Web Cache)，位于中间系统上的Web缓存又称为代理服务器</li><li>Web缓存把最近一些请求和响应暂存在本地磁盘中，当新请求到达时，若发现这个请求与展示存放的记录相同，就返回暂存的响应，而不需要按URL的地址再次去因特网访问该资源</li></ul><hr><p>HTTP连接分为<strong>持续连接和非持续连接</strong></p><p>持续连接又分为非流水的持续连接和流水的持续连接</p><p>如果用户向服务器请求数据，比如说3个图片和1个网页</p><ul><li>非流水的持续连接</li></ul><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/lU4m6BxYavrzq7A.png" alt="image-20210526125834400" style="zoom: 80%;" /></p><p>需要5个RTT时间+4个对象的传输时间</p><ul><li>流水的持续连接</li></ul><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/6tjlfNcrbiuF1ev.png" alt="image-20210526125946863" style="zoom: 80%;" /></p><p>需要3个RTT时间+4个对象的传输时间</p><p>非持续连接</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/RFNlfI5KaYT8JCO.png" alt="image-20210526130048609" style="zoom:67%;" /></p><p>需要8个RTT+4对象传输时间</p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.运输层</title>
      <link href="/post/9992.html"/>
      <url>/post/9992.html</url>
      
        <content type="html"><![CDATA[<h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>物理层</strong>，<strong>数据链路层</strong>以及<strong>网络层</strong>共同解决了将主机通过异构网络互联起来所面临的问题，实现了主机到主机之间的通信</p><p>实际上在计算机网络中进行通信的实际是位于通信两段主机中的<strong>进程</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/g5DYbqGCWcL3KfA.png" alt="image-20210512160739809"></p><p>运输层直接为应用进程间的逻辑通信提供服务</p><p>运输层向高层用户屏蔽了下面网络核心的细节，它使应用进程看见的就好像是在两个运输层实体之间有一条端到端的逻辑通信信道</p><p>根据应用需求不同，因特网的运输层为应用层提供了两种不同的运输协议，即<strong>面向连接的TCP和无连接的UDP</strong>，这两种协议是重点内容</p><hr><h2 id="端口号和复用和分用"><a href="#端口号和复用和分用" class="headerlink" title="端口号和复用和分用"></a>端口号和复用和分用</h2><p>为了使运行在不同操作系统的计算机进程之间能够进行网络通信，就必须使用统一的方法对TCP/IP体系的应用进程进行标识</p><p>TCP/IP体系的运输层采用<strong>端口号</strong>来区分应用层的不同应用进程</p><p>端口号使用<strong>16比特</strong>表示，取值范围0~65535</p><ul><li>熟知端口号：0~1023，IANA把这些端口号指派给了TCP/IP体系中最重要的一些应用协议，例如FTP使用21/20，HTTP使用80</li><li>登记端口号：1024~49151，为没有熟知端口号的应用程序使用，使用这类端口号必须在IANA按照规定登记，防止重复</li><li>短暂端口号：49152~65535，为客户进程选择暂时使用，当服务器进程收到客户进程的报文时，就知道客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用</li></ul><p><strong>端口号只具有本地意义</strong>，即端口号只是为了标识本计算机应用层中各进程，在因特网中，不同计算机中的相同端口号没有联系</p><hr><p>发送方的某些应用报文在运输层使用UDP协议进行封装，这叫做UDP复用，而另一些应用报文，使用TCP协议封装，叫做TCP复用，运输层使用端口号来区分进程</p><p>无论是UDP的用户数据保，还是TCP的报文，在网络层要通过IP协议封装，这叫做IP复用</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/WnaL4MjiHroCpqX.png" alt="image-20210512162319927"></p><p>接收方的网络层收到了IP数据报后进行IP分用，根据协议字段的取值来上交给运输层的UDP和TCP协议，然后TCP和UDP协议通过解析端口号将数据上交给不同的应用</p><hr><p>TCP/IP体系的应用层常用协议所使用的运输层熟知端口号</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/tZMEAXgQHKjaYNf.png" alt="image-20210512162610354"></p><p>这里的端口号指的是服务器上的端口号，比如：HTTP协议的端口号为80的意义是 服务器的端口号为80，客户端访问服务器时一般使用临时的端口号</p><hr><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><p>Internet协议集支持一个无连接的传输协议，该协议称为用户数据报协议（UDP，User Datagram Protocol，UDP 为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据包的方法</p><p>UDP只在IP数据报服务上增加了很少功能，即复用分用和差错检测功能</p><hr><p>首部格式</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220621162816065.png" alt="image-20220621162816065"></p><p>UDP长度指的是数据报的整个长度，UDP校验和检测整个UDP数据报是否有错，错就丢弃</p><p>分用时，如果找不到对应的目的端号，就丢弃报文，并给发送方发送ICMP“端点不可达”差错报文</p><hr><p>检验过程</p><p>UDP数据报的首部会添加一个“伪首部”以校验</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220621163952550.png" alt="image-20220621163952550"></p><p>伪首部只有在计算校验和时才出现，不向下传送也不向上递交</p><p><strong>校验和是可选的</strong></p><hr><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><h3 id="首部格式"><a href="#首部格式" class="headerlink" title="首部格式"></a>首部格式</h3><p>为了实现可靠运输，TCP采用了<strong>面向字节流</strong>的方式</p><p>但TCP在发送数据时，是从发送缓存取出一部分或全部字节并给其添加一个首部使之成为TCP报文段进行发送</p><ul><li>一个TCP报文段由首部和数据载荷两部分构成</li><li>TCP的全部功能都体现在它首部中各字段的作用</li></ul><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/iDSjosP6Z5nvOQ8.png" alt="image-20210512223248172"></p><p>源端口：占16比特，写入源端口号，用来标识发送该TCP报文段的应用进程</p><p>目的端口：占16比特，写入目的端口号，用来表示接收该TCP报文段的应用进程</p><hr><p>序号：占32个比特，取值范围$[0,2^{32}-1]$，序号增加到最后一个后，下一个序号就又回到0</p><p>序号指出本TCP报文段数据载荷第一个字节的序号</p><hr><p>确认号：占32比特，取值范围$[0,2^{32}-1]$,确认号增加到最后一个后，下一个确认号就又回到0</p><p>指期望收到对方下一个TCP报文段的数据载荷的第一个字节的序号，<strong>同时也是对之前收到的所有数据的确认</strong></p><p>若确认号=n，则表明到序号n-1为止的所有数据都已正确接收，期望接收序号为n的数据</p><p>确认标志位ACK：取值为1时，确认号字段才有效，取值为0时，确认号字段无效</p><p>TCP规定，在连接建立后所有传送的TCP报文段都必须把ACK置1</p><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/BDkqPgZE2H5d1Yc.png" alt="image-20210512225242924"></p><p>数据偏移：占4比特，并以<strong>4字节为单位</strong></p><p>用来指出TCP报文段的数据载荷部分的起始处距离TCP报文段的起始处有多远，这个字段实际上是指出了TCP报文段的<strong>首部长度</strong></p><p>首部的固定长度为20字节，最大长度为60字节，若不是4的倍数，则填充到4的倍数</p><p>窗口：占16比特，以字节为单位，指出发送本报文段的一方的接收窗口</p><p>窗口值作为接收方让发送方设置其发送窗口的依据，以<strong>接收方的接受能力来控制发送能力，称为流量控制</strong></p><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/2iQU8dvORr4YTIu.png" alt="image-20210512235922525"></p><ul><li>同步标志位SYN：在TCP连接建立时用来同步序号</li><li>终止标志位FIN：用来释放TCP连接</li><li>复位标志位RST：用来复位TCP连接，当RST=1时，表明TCP连接出现了异常，必须释放连接，然后重新连接</li><li>推动标志位PSH：接收方的TCP收到该标志位为1的报文段会<strong>尽快上交应用进程</strong>，而不必等到接收缓存都填满后再向上交付</li><li>紧急标志位URG：取值为1时紧急指针字段有效，取值为0时紧急指针字段无效</li></ul><hr><p>紧急指针：占16比特，以字节为单位，用来指明紧急数据的长度</p><p>当发送方有紧急数据时，可将紧急数据插队到发送缓存的最前面，并立刻封装到一个TCP报文段中发送、紧急指针会指出本报文数据载荷部分包含了多长的紧急数据</p><p>校验和：占16比特，检查范围包括TCP报文段的首部和数据载荷两部分</p><p>在计算校验和时，要在TCP报文段的前面加上12字节的伪首部</p><p>扩展部分扩展了TCP报文的功能</p><ul><li>最大报文段MSS选项：TCP报文段数据载荷的最大长度</li><li>窗口扩大选项：为了扩大窗口</li><li>时间戳选项：用来计算往返时间RTT，用来处理序号超范围的情况，又称为防止序号绕回PAWS</li></ul><p>填充：由于选项的长度可变，因此使用填充来确保报文段首部能被4整除</p><hr><h3 id="TCP和UDP的对比"><a href="#TCP和UDP的对比" class="headerlink" title="TCP和UDP的对比"></a>TCP和UDP的对比</h3><div class="table-container"><table><thead><tr><th>名称</th><th style="text-align:center">用户数据报协议UDP(User Datagram Protocol)</th><th>传输控制协议TCP(Transmission Control Protocol)</th></tr></thead><tbody><tr><td>连接方式</td><td style="text-align:center">无连接</td><td>有连接</td></tr><tr><td>传输方式</td><td style="text-align:center">支持单播，多播以及广播</td><td>只支持单播</td></tr><tr><td>面向对象</td><td style="text-align:center">面向应用报文</td><td>面向字节流</td></tr><tr><td>服务类型</td><td style="text-align:center">不可靠服务</td><td>可靠服务</td></tr><tr><td>首部类型</td><td style="text-align:center">仅8字节</td><td>最小20字节，最大60字节</td></tr><tr><td>校验和</td><td style="text-align:center">可选</td><td>必需</td></tr></tbody></table></div><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/sbaecJrmFzoDBT7.png" alt="image-20210512163645535"></p><hr><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>流量控制(flow control)就是让发送方的发送速率不要太快，让接收方来得及接收，采用流量控制以同步设备速度以便发送数据</p><p>TCP采用<strong>滑动窗口</strong>机制来很方便的在TCP连接上实现对发送方的流量控制</p><ul><li><p><strong>TCP接收方利用自己的接收窗口的大小来限制发送方发送窗口的大小</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/89mfxFCRv5XGVIY.png" alt="image-20210512164457098"></p></li></ul><p>接收方可以在确认报文的时候调整接收窗口的大小，从而限制发送方发送窗口的大小，其他的协议细节，与选择重传协议类似</p><p>考虑这样一种情况</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/t9MmQ6YPxj1IVTi.png" alt="image-20210512164820161"></p><p>此时A会一直等待B发送的非0窗口的通知，B也一直等待A发送的数据，若不采取措施，这种互相等待而形成的死锁局面会一直持续下去</p><p>为了解决这种情况，当发送方的发送窗口被调控到0的时候，就会启动一个<strong>持续计时器</strong>，若持续计时器超时，就发送一个<strong>零窗口探测报文</strong>，仅携带一个字节的数据，而对方在确认这个探测报文段时，给出自己的接收窗口值，如果接受窗口值仍然是0，那么收到这个报文段的一段就会重新启动持续计时器。</p><hr><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>在某些阶段，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏，这种情况就叫做<strong>拥塞(congestion)</strong></p><p>若出现拥塞而不进行控制，整个网络的吞吐量将随输入负荷的增大而下降</p><p>TCP有4种拥塞控制算法</p><ul><li>慢开始</li><li>拥塞避免</li><li>快重传</li><li>快恢复</li></ul><p>发送方要维护一个叫做<strong>拥塞窗口cwnd</strong>的状态变量，其值取决于网络的拥塞程度，并且动态变化</p><ul><li>拥塞窗口cwnd的维护原则：只要网络没有出现拥塞，拥塞窗口就在增大一些，但只要网络出现拥塞，拥塞窗口就减少一些</li><li>判断出现网络拥塞的依据：没有按时收到应当到达的确认报文(发生超时重传)</li></ul><p>发送方将拥塞窗口作为<strong>发送窗口swnd</strong>，即<strong>swnd=cwnd</strong></p><div class="note primary flat"><p>发送窗口=MIN[拥塞窗口，接收窗口]</p></div><p>维护一个慢开始门限<strong>ssthresh(slow start threshold)状态变量</strong>：</p><ul><li>当cwnd&lt;ssthresh时，使用慢开始算法</li><li>当cwnd&gt;ssthresh时，停止使用慢开始算法而改用拥塞避免算法</li><li>当cwnd=ssthresh时，既可以使用慢开始算法，也可以使用拥塞避免算法</li></ul><hr><p><strong>慢开始算法</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/KpTjQfmAnRoW9ew.png" alt="image-20210512190921019"></p><p>开始设定cwnd=1，ssthresh=16</p><p>当cwnd没有到ssthresh时，cwnd呈指数增长，这就是慢开始算法</p><p><strong>拥塞避免</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/7C5HRNjYqvlSU3E.png" alt="image-20210512191125121"></p><p>当cwnd超过了ssthresh时，开始使用拥塞避免算法，此时cwnd不再指数增长，而是每次加1，直到出现拥塞情况</p><p> 当重传计时器超时，则判断网络很可能出现了拥塞，进行以下工作：</p><ul><li>将ssthresh值更新为发生拥塞cwnd值的<strong>一半</strong></li><li>将cwnd<strong>减少为1</strong>，并重新开始执行慢开始算法</li></ul><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/xFCKuhfEmgVMapT.png" alt="image-20210512191519560"></p><ul><li>慢开始是指一开始向网络注入的报文段少，并不是指拥塞窗口cwnd增长速度慢</li><li>拥塞避免并非完全能够避免拥塞，而是指在拥塞避免阶段将拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞</li></ul><div class="note primary flat"><p>达到慢开始门限后，每次都增加1个窗口，这和拥塞没有关系</p></div><p><strong>快重传</strong></p><p>有时候个别报文段会在网络中丢失，但实际上网络并未发生拥塞，这会导致发送方的超时重传，并误认为网络发送了拥塞，这样会启动慢开始算法，降低效率</p><p>采用快重传算法可以让发送方尽早知道发生了个别报文段的丢失</p><p>所谓快重传，就是使发送方<strong>尽快进行重传</strong>，而不是等超时重传计时器超时在重传</p><ul><li>要求接收方不要等待自己发送数据时才进行捎带确认，而是立即发送确认</li><li>即使收到了失序的报文段也要立即发出对已收到报文段的重复确认</li><li>发送方一旦收到了<strong>3个连续的重复确认</strong>，就将相应的报文段立即重传，而不是等待超时重传计时器</li></ul><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/r4baEuUdniJSGZK.png" alt="image-20210512192324785"></p><p><strong>快恢复</strong></p><p>发送方一旦收到了3个重复确认，就是现在只是丢失了个别的报文段，于是不启动慢开始算法，而执行<strong>快恢复算法</strong></p><ul><li>发送方将慢开始门限ssthresh值和拥塞窗口cwnd值调整为<strong>当前窗口的一半</strong>，开始执行拥塞避免算法</li></ul><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/hvmARyI1MbaCgD8.png" alt="image-20210512194138350" style="zoom:67%;" /></p><hr><h3 id="超时重传时间的选择"><a href="#超时重传时间的选择" class="headerlink" title="超时重传时间的选择"></a>超时重传时间的选择</h3><p>TCP超时重传的时间的选择是一个很复杂的问题</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/4b7qsftCFizpUVO.png" alt="image-20210512194423673"></p><p>如果将重传时间RTO的值设置的比RTT0小，那么会导致不必要的重传，使网络负荷增大</p><p>如果将重传时间RTO的值设置的比RTT0大，那么会导致网络的空闲时间增大，降低传输效率</p><p>所以超时重传时间<strong>RTO</strong>的值应<strong>略大于</strong>往返时间<strong>RTT</strong></p><hr><p>问题在于RTT会随着不同网络环境而<strong>发生变化</strong>，所以不能使用某次测量得到的RTT样本来计算超时重传时间RTO</p><p>利用每次测量得到的RTT样本，计算<strong>加权平均往返时间$RTT_s$(</strong>又称为平滑的往返时间)</p><p>$RTT_{S1}=RTT_1$</p><p>新的$RTT_S=(1-α)×旧的RTT_S+α×新的RTT样本$</p><p>在上式中，$0≤α&lt;1$</p><ul><li><p>若α接近0，则新RTT样本对$RTT_s$的影响不大</p></li><li><p>若α接近1，则新RTT样本对$RTT_s$的影响较大</p></li></ul><p>RFC6298推荐的α值为1/8，即<strong>0.125</strong></p><hr><h3 id="可靠传输的实现"><a href="#可靠传输的实现" class="headerlink" title="可靠传输的实现"></a>可靠传输的实现</h3><p>TCP基于以字节为单位的滑动窗口来实现可靠传输</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/9vDiRKLBI2fc8jh.png" alt="image-20210512201955142"></p><p>接收方会发送自己的接受窗口尺寸以及希望收到下一个字节的序号</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/5QMlwet7fZb4GXO.png" alt="image-20210512202102075"></p><p>如果要描述发送窗口的状态，可以使用3个指针P1,P2,P3分别指向相应的字节序号</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/lPJtgTCwxRuI51f.png" alt="image-20210512202702306"></p><p>虽然发送方的发送窗口是根据接收窗口设置的，但在同一时刻，发送方的发送窗口并不总是和接收方的接收窗口一样大</p><ul><li>网络传送窗口需要经历一定的时间滞后，并且时间不确定</li><li>发送方还可能根据网络当时的拥塞情况适当减少自己的发送窗口尺寸</li></ul><p>对于不按序到达的数据应如何处理，TCP并无明确规定</p><ul><li>如果接收方把不按序到达的数据一律丢弃，那么接收窗口管理比较简单，但是会浪费网络资源</li><li>TCP通常对不按序到达的数据临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程</li></ul><p>TCP要求接收方必须有<strong>累计确认和捎带确认机制</strong>，这样可以减少传输开销</p><ul><li>接收方不应过分推迟发送确认，否则会导致不必要的超时重传</li><li>捎带确认实际上不会经常发生，因为大多数应用程序很少同时在两个方向上发送数据</li></ul><p><strong>TCP的通信是全双工通信</strong>，通信中的每一行都在发送和接受报文段，因此，每一行都有自己的发送窗口和接收窗口</p><hr><h3 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立"></a>连接建立</h3><p> TCP是面向连接的协议，基于运输连接来传送TCP报文段</p><p>TCP运输连接有以下3个阶段</p><ul><li>建立TCP连接</li><li>数据传送</li><li>释放TCP连接</li></ul><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/UPaKZB9EMILOdCl.png" alt="image-20210512203914881"></p><hr><p>TCP使用“三报文握手”建立连接</p><p>一开始，两端TCP进程都属于关闭状态</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/gf7ZFMVlGCpyuD3.png" alt="image-20210512204038983"></p><p>TCP服务器进程首先开始建立传输控制块，用来存储一些重要信息</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/RvLBPJy4YsMntSF.png" alt="image-20210512204211022"></p><p>之后TCP服务器开始进入监听状态，等待TCP客户发起连接，由于TCP服务器是等待客户建立连接，所以是<strong>被动打开</strong></p><p>然后TCP客户同样建立传输控制块，然后向TCP服务器发送TCP连接请求报文段，并进入同步已发送状态，报文段首部中同部位<strong>SYN被设置为1</strong>，序号字段seq设置为x<img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/x4hRL23NcopS6wH.png" alt="image-20210512204454452"></p><p>当TCP服务器接收到报文后，则向TCP客户进程发送TCP连接请求确认报文段，并进入同步已接收状态</p><p>报文中的SYN和ACK都设置为1，表示这是一个TCP连接请求确认报文段，序号字段seq被设置了一个初始值y，作为TCP服务器进程所选择的初始序号，ack=x+1，这是对TCP客户进程所选择的初始序号的确认</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/7YLctdHjPTC8h1I.png" alt="image-20210512204850732"></p><p>TCP客户进程在收到TCP连接请求确认报文段后，还要向TCP服务器发送一个普通的TCP确认报文段，并进入连接已建立状态，ACK=1，表示这是普通的确认报文段，seq=x+1，因为第一个报文段的序号为x，ack=y+1，是对TCP服务器进程所选择的初始序号的确认</p><blockquote><p>三次挥手中的第三次挥手，已经可以传递信息了</p></blockquote><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/dQwnclMTEVbgfrt.png" alt="image-20210512205406891"></p><p>TCP采取<strong>三握手连接</strong>是为了防止已失效的连接请求报文段突然又传送到了TCP服务器，因而导致错误</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/fEYqJ6iDn5o3Uh9.png" alt="image-20210512205704419"></p><hr><h3 id="连接释放"><a href="#连接释放" class="headerlink" title="连接释放"></a>连接释放</h3><p>TCP通过“四报文挥手”来释放报文段</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/sd3rkPJYITE6pS4.png" alt="image-20210512210014482"></p><p>如果是TCP客户想要发送释放TCP连接，则会发送TCP连接释放报文段，并进入终止等待1状态，该报文段中的<strong>FIN和ACK都会设置为1</strong>，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认，序号seq报文段的值设置为u，等<strong>于TCP客户进程之前已传送过的数据的最后一个字节序号加1</strong>，ack=v，等于<strong>TCP客户之前收到的数据的最后一个字节加1</strong></p><blockquote><p>此时的报文段虽然Seq为u，但是并不携带任何数据</p></blockquote><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/xARhSiy2LPbXdVk.png" alt="image-20210512210354884"></p><p>TCP服务器在收到TCP连接释放报文段后，会发送一个普通的TCP确认报文段并进入关闭等待状态，ACK=1表示这是一个普通的TCP确认报文，seq=v，等于TCP服务器进程之前已传送过的数据的最后一个字节，ack=u+1，是对TCP连接释放报文段的确认</p><p>TCP服务进程此时会通知高层进程，TCP客户进程要断开与自己的TCP连接，此时，从TCP客户进程到TCP服务器进程这个方向上的连接就释放了，此时TCP连接属于<strong>半关闭状态</strong>，因为<strong>TCP客户已经没有数据要发送了，但TCP服务器进程如果还有数据要发送</strong>，TCP客户进程<strong>仍要</strong>接收</p><p>这个状态可能要持续一段时间，当TCP客户收到了TCP确认报文段后，会进入终止等待2状态</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/ERvewlp1BnOMNV4.png" alt="image-20210512211114614"></p><p>当TCP服务器没有数据要发送了，应用就会通知服务器释放连接</p><p>TCP服务器进程发送TCP连接释放报文段并进入<strong>最后确认状态</strong>，报文段中的FIN和ACK设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认，假定seq=w，这是在半关闭状态下，TCP服务器进程可能又发送了一些数据，确认号ack的值为u+1，这是对之前收到的TCP连接释放报文段的<strong>重复确认</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/vzlYWLgTb1a75m6.png" alt="image-20210512211502771"></p><p>TCP客户进程收到了TCP连接释放报文段后，必须针对该报文段发送普通的TCP确认报文段，之后进入时间等待状态，ACK=1，表示这是不同的TCP确认报文段，seq的值为u+1，确认号ack的值设置为w+1，是对收到的TCP连接释放报文段的确认</p><p>TCP服务器进程在收到后就进入关闭状态，而TCP客户进程还要经过2MSL后才能进入关闭状态</p><p>MSL(Maximum Segment Lifetime)意思是最长报文段寿命</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/enjvk1QtZKyFp7c.png" alt="image-20210512211902948"></p><p>设置2MSL的意义在于，加入最后TCP客户发送的普通的TCP确认报文段丢失了，TCP服务器发送的TCP连接释放报文段会超时重传，如果不设置2MSL，那么TCP客户关闭后，就无法接受到超时重传的消息，就会导致TCP服务器一直在最后确认阶段</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/Bubr2iHIVqnUpCE.png" alt="image-20210512212138764"></p><hr><p>如果TCP双方在建立连接后，TCP客户方突然出现了故障，显然，TCP服务器就不会再收到TCP客户的数据，应该有措施让TCP服务器进程不要再白白等待下去</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/dLJcQeHtIjPGlkx.png" alt="image-20210512212609291"></p><p>为了避免这种情况，TCP服务器每收到一次TCP客户进程的数据，就重新设置并启动保活计时器</p><p>若保活计时器定时周期内未收到TCP客户进程发来的数据，则当保活计时器到时候，TCP服务器进程就向TCP客户进程发送一个探测报文段，以后每隔75秒发送一次探测报文段，若一连发送10个探测报文段仍无TCP客户进程的响应，TCP服务器进程就会认为TCP客户端进程故障，则会关闭这个连接</p><hr>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.网络层</title>
      <link href="/post/9495.html"/>
      <url>/post/9495.html</url>
      
        <content type="html"><![CDATA[<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>网络层的主要任务是实现网络互连，进而实现数据包在各网络之间的传输</p><p>主要功能如下</p><ul><li>转发信息</li><li>路由选择</li><li>拥塞控制</li></ul><hr><h2 id="网络层提供的服务"><a href="#网络层提供的服务" class="headerlink" title="网络层提供的服务"></a>网络层提供的服务</h2><p>面向连接的虚电路服务</p><ul><li><p>核心思想是可靠通信由网络来保证</p></li><li><p>必须建立网络层的连接—–虚电路VC</p></li><li><p>目的主机的地址仅在连接建立阶段使用，之后每个分组的首部只需携带一条虚电路的编号</p></li></ul><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/EpZB6nkU71dWc3m.png" alt="image-20210507104138583"></p><p>这种通信方式如果再使用可靠传输的网络协议，就可使所发送的分组最终正确到达接收方</p><p>通信结束后，需要释放之前所建立的虚电路</p><p><strong>然而因特网并没有采用这种方法</strong></p><hr><p>无连接的数据报服务</p><ul><li><p>可靠通信应当由用户主机来保证</p></li><li><p>不需要建立网络层连接</p></li><li><p>每个分组可走不同的路径</p></li><li><p>每个分组的首部必须携带目的分组的完整地址</p></li></ul><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/ZocIlWz1MdHXBAF.png" alt="image-20210507104439633"></p><p>这种通信方式所传送的分组可能误码，丢失，重复和失序</p><p>由于网络本身不采用端到端的可靠传输服务，所以网络中的路由器就可以做的比较简单，而且价格低廉，因特网采用了这种设计思想，将复杂的网络处理功能置于因特网的边缘，而将相对简单的尽最大努力的分组交付功能置于因特网核心</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/6OoxKNLTFqAJGcy.png" alt="image-20210507104654352"></p><hr><h2 id="IPv4地址"><a href="#IPv4地址" class="headerlink" title="IPv4地址"></a>IPv4地址</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>IPv4就是给因特网上每一台主机（或路由器）的每一个接口分配一个在全世界范围内是唯一的32比特的标识符</p><p>IP地址由因特网名字和数据分配机构ICANN进行分配</p><p>IPv4地址的编址方法经历了3个阶段：分类编址    划分子网    无分类编址</p><p>IPv4地址由32个比特组成，采用点分十进制表示方法以方便用户使用</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/arx6pTyMLq25eSW.png" alt="image-20210507110644819"></p><hr><h3 id="分类编址的IPv4地址"><a href="#分类编址的IPv4地址" class="headerlink" title="分类编址的IPv4地址"></a>分类编址的IPv4地址</h3><p>分为A类地址 B类地址 C类地址 D类地址 E类地址</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/H3y5uzR6B8WbeAd.png" alt="image-20210507110823896"></p><ul><li>只有A类，B类，C类地址可以分配给网络各接口</li><li><strong>主机号为全0的地址是网络地址</strong>，不能分配给主机或路由器接口</li><li><strong>主机号为全1的地址是广播地址</strong>，不能分配给主机或路由器接口</li></ul><hr><p>A类</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/8vwSdIczJZ1rqnG.png" alt="image-20210507115249485"></p><p><strong>最小网络号0，保留不指派</strong></p><p>第一个可指派的网络号为1，网络地址为1.0.0.0</p><p><strong>最大网络号127，作为本地环回测试地址，不指派</strong></p><hr><p>B类</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/kclJBEPbLNXvhGC.png" alt="image-20210507115314323"></p><p>最小网络号也是第一个可指派的网络号128.0 网络地址为128.0.0.0</p><p>最大网络号也是最后一个可指派的网络号191.255 网络地址为191.255.0.0</p><hr><p>C类</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/dDobkj2M3NSRZcU.png" alt="image-20210507115441232"></p><p>最小主机号也是第一个可指派的网络号192.0.0，网络地址为192.0.0.0</p><p>最大主机号也是最后一个可指派的网络号223.255.255，网络地址为223.255.255.0</p><hr><p>A类，B类，C类里面分别有私有IP地址，这类地址不会被路由器识别，只适合用于内部通信</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/x4hoKGyXsv36uYP.png" alt="image-20220619205516362"></p><p>网段个数是指可以分配的网络号的数量</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/49KQEdYx5sp1omi.png" alt="image-20210507120510325"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/VBer1ZcpMJFAP67.png" alt="image-20220619195751064"></p><hr><h3 id="划分子网的IPv4地址"><a href="#划分子网的IPv4地址" class="headerlink" title="划分子网的IPv4地址"></a>划分子网的IPv4地址</h3><p>如果需要的IP地址个数在在变化，如果每次都要申请，会很浪费IP地址</p><p>可以从主机号部分借用一部分比特作为子网号，计算机需要知道主机号中有多少位作为了子网号，所以需要<strong>子网掩码</strong></p><p>32bit的子网掩码可以表明分类IP地址的主机号部分被借用了几个比特作为子网号</p><ul><li>子网掩码使用连续的比特1来对应网络号和子网号</li><li>子网掩码使用连续的比特0来对应主机号</li><li>将划分子网的IPv4地址与其相应的子网掩码进行<strong>逻辑与运算</strong>就可以得到IPv4所在子网的网络地址</li></ul><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/mAunLsaNr4EW5Ze.png" alt="image-20210507121200065"></p><p>子网号占据了多少个1说明就借用了几个比特，1个子网号可以划分2个子网</p><hr><p>默认的子网掩码是指未划分子网的情况下使用的子网掩码</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/MvdG3ln7IazycmV.png" alt="image-20210507123011637"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/cGUu9TQtpS2Mjhd.png" alt="image-20210507123018503"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/5HdtK3YoPLcOqIV.png" alt="image-20210507123047394"></p><hr><h3 id="无分类编址的IPv4地址-CIDR"><a href="#无分类编址的IPv4地址-CIDR" class="headerlink" title="无分类编址的IPv4地址(CIDR)"></a>无分类编址的IPv4地址(CIDR)</h3><p>数量巨大的C类网因为地址空间太小并没有得到充分的运用，而因特网的IP地址在加速消耗，整个IPv4地址空间面临全面耗尽的威胁</p><p>为此，因特网工程任务组IETF又提出了采用无分类编址的方法</p><p>无分类域间路由选择CIDR(Classless Inter-Domain Routing)</p><ul><li>CIDR消除了传统A类，B类和C类地址，以及划分子网的概念</li><li>CIDR可以更加有效地分配IPv4的地址空间</li></ul><p>CIDR采用斜线记法，在IPv4地址后面加上斜线，在斜线后面写上<strong>网络前缀所占的比特数量</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/Ed2gyKjrLZVzwN9.png" alt="image-20210507123900406"></p><p>CIDR实际上是将网络前缀都相同的连续的IP地址组成一个CIDR地址块</p><p>只要知道CIDR地址块中的任何一个地址，就可以知道该地址块的全部细节</p><ul><li>地址块的最小地址，最大地址</li><li>地址块的地址数量</li><li>地址块聚合某类网络的数量</li><li>地址掩码</li></ul><hr><p><strong>路由聚合（构造超网）</strong></p><p>将有很多共同前缀的路由信息通过CIDR的方式打包发送给另一个路由</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/aSsx9bHvjKTApgm.png" alt="image-20210507124504885"></p><p>聚合地址块：172.1.4.0/22</p><ul><li><p>网络前缀越长，地址块越小，路由越具体</p></li><li><p>如果路由器查表转发分组的时候发现有多条路由可选，则<strong>选择网络前缀最长</strong>的那条，称为最长前缀匹配，因为这样的路由更具体</p></li></ul><hr><h3 id="IPv4地址的应用规划"><a href="#IPv4地址的应用规划" class="headerlink" title="IPv4地址的应用规划"></a>IPv4地址的应用规划</h3><p>根据网络中主机和路由器的数目可以进行IPv4地址的划分，有两种方式</p><p>定长的子网掩码FLSM(Fixed Length Subnet Mask)</p><ul><li>使用同一个子网掩码来划分子网，每个子网分配的IP地址相同</li></ul><p>如果网络中子网数目是n个，那么最少需要借用$log_2n$个比特充当子网掩码</p><p>如果网络中子网的最大主机数是x个，那么根据网络类型，要确保主机地址被借用后，也可以有足够的地址满足要求</p><hr><p>变长的子网掩码VLSM(Variable Length Subnet Mask)</p><ul><li>使用不同的子网掩码来划分子网，每个子网分配的IP地址不同</li></ul><p>在分配地址的时候，每个子块的起点位置不能随意选取，只能选取块大小整数倍的地址作为起点</p><div class="note primary flat"><p>比如将101.200.16.0/20划分为5个子网，求最小子网的大小，101.200.16.0 的前20位是网络号，则第21位为0，划分为最大的第一块，从第21位开始，10是第二块同理，110是第三块 ，1110是第四块，1111第五块，最小的大小为$2^8=256$</p></div><hr><h2 id="IPv4数据报的首部格式"><a href="#IPv4数据报的首部格式" class="headerlink" title="IPv4数据报的首部格式"></a>IPv4数据报的首部格式</h2><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/sYpZA9k1ouI3mra.png" alt="image-20210510203030287"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/BpcMX15ytDbiVGm.png" alt="image-20210510201659621"></p><p>固定部分是每个IP数据报都要包含的内容，可变字段是可以根据需求添加的内容</p><ul><li><strong>版本</strong></li></ul><p>占4个比特，表示IP协议的版本，通信协议的IP协议版本必须一致，目前广泛使用的是IPv4</p><ul><li><strong>首部长度</strong></li></ul><p>占4比特，用来表示IP数据报首部的长度，该字段的取值以4字节为单位</p><p>最小10进制取值为5，表示只有20字节固定部分，最大10进制取值为15，表示20字节固定部分和最大400字节可变部分</p><ul><li><strong>区分服务</strong></li></ul><p>占8个比特，利用该字段的不同数值可提供不同等级的服务质量，一般情况下不使用</p><ul><li><strong>总长度</strong></li></ul><p>占16比特，表示IP数据报的总长度(首部+数据载荷)</p><p>最大取值为十进制的65535，<strong>以字节为单位</strong></p><hr><p><strong>标识，标志，片偏移</strong>三个字段共同用于IP数据报分片</p><p>以太网的数据链路层规定MTU的值为1500字节，如果IP数据报的大小超过了这么多，就需要进行分片</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/ISBAp8NTQqnUdig.png" alt="image-20210510203710260"></p><ul><li><strong>标识</strong></li></ul><p>占16比特，属于同一个数据报的各分片数据报应该具有相同的标识</p><ul><li><strong>标志</strong></li></ul><p>占3个比特，各比特含义如下</p><p>DF(Don’t Fragment)位：1表示不允许分片 0表示允许分片</p><p>MF(More Fragment)位：1表示后面还有分片 0表示这是最后一个分片</p><p>保留位：必须为0</p><ul><li><strong>片偏移</strong></li></ul><p>占13个比特，指出分片数据报的数据载荷部分偏移其原数据报的位置有多少个单位</p><div class="note primary flat"><p>IP头部格式中的“总长度（16bit）”和“偏移（13bit）”两个字段所决定了片偏移量为8位，$2^{16}/2^{13}=2^3=8B$，（总长度和偏移都是以字节为单位）如果偏移单位小于8B，比如是4B，则8位的片偏移量不能准确表示出偏移，如果偏移单位大于8B，比如是16B，则只需要12个bit的偏移就能表示，而不需要13bit</p></div><p>因为片偏移量<strong>以8个字节为单位</strong>，<strong>所以除了最后一个分片外，其余分片的数据载荷必须是8的整数倍</strong>，在分片的时候需要注意</p><hr><ul><li><strong>生存时间</strong></li></ul><p>占8个比特，以条数为单位，转发IP数据报时，将IP数据报首部中的该字段的值减1，若不为0则转发</p><ul><li><strong>协议</strong></li></ul><p>占8个比特，指明IPv4数据报的数据部分是何种协议数据单元</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/pI47QveCkDzjMUJ.png" alt="image-20210510205506569"></p><ul><li><strong>首部检验和</strong></li></ul><p>占16个比特，用来检测首部在传输工程中是否出现差错，比CRC检验码简单，称为因特网检验和</p><p>IP数据报每经过一个路由器，路由器都要重新计算首部检验和，因为某些字段可能会发生变化，在IPv6中不再计算检验和</p><hr><ul><li><strong>源IP地址和目的IP地址</strong></li></ul><p>各占32比特，用来填写发送该IP数据报的源主机的IP地址和接收该IP数据报的目的主机的IP地址</p><hr><ul><li><strong>可选字段</strong></li></ul><p>长度从1个字节到40个字节不等，用来支持排错，测量以及安全等措施，实际上很多被使用</p><ul><li><strong>填充字段</strong></li></ul><p>用来确保首部长度为4字节的整数倍，使用全0进行填充</p><hr><h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><p>经过使用CIDR和NAT技术可以延缓IPv4地址的减少，但治标不治本，IPv4地址已经被用完了，基于此，产生了新的IP地址标准，即IPv6</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220619233231860.png" alt="image-20220619233231860" style="zoom:80%;" /></p><p>首部格式</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220620003539625.png" alt="image-20220620003539625" style="zoom: 67%;" /></p><p><strong>版本</strong>：指明了协议版本，总是6<br><strong>优先级</strong>：区分数据报的类别和优先级<br><strong>流标签</strong>：“流”是互联网络上从特定源点到特定终点的一系列数据报。所有属于同一个流的数据报都具有同样的流标签<br><strong>下一个首部</strong>：标识下一个扩展首部或上层协议首部<br><strong>跳数限制</strong>：相当于IPv4的TTL</p><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">IPv4</th><th style="text-align:center">IPv6</th></tr></thead><tbody><tr><td style="text-align:center">地址</td><td style="text-align:center">4B</td><td style="text-align:center">16B</td></tr><tr><td style="text-align:center">校验字段</td><td style="text-align:center">√</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">可选字段</td><td style="text-align:center">√</td><td style="text-align:center">移出首部</td></tr><tr><td style="text-align:center">配置</td><td style="text-align:center">DHCP</td><td style="text-align:center">自动配置</td></tr><tr><td style="text-align:center">首部长度</td><td style="text-align:center">4B的倍数</td><td style="text-align:center">8B的倍数</td></tr><tr><td style="text-align:center">分片</td><td style="text-align:center">路由器和主机</td><td style="text-align:center">主机</td></tr><tr><td style="text-align:center">协议字段</td><td style="text-align:center">√</td><td style="text-align:center">× (改为下一个首部)</td></tr><tr><td style="text-align:center">总长度</td><td style="text-align:center">√</td><td style="text-align:center">×(改为有效载荷长度)</td></tr><tr><td style="text-align:center">服务类型</td><td style="text-align:center">√</td><td style="text-align:center">×</td></tr></tbody></table></div><hr><p>地址表示形式</p><p>使用冒号十六进制记法：4BFA:AA12:0216:FEBC:BA5F:039A:BE9A:2170</p><p>如果有很多0，可以直接用0:压缩，一连串的0可以被一对冒号取代</p><p>双协议栈技术指在一台设备上同时启用IPv4协议栈和IPv6协议栈</p><hr><h2 id="动态主机配置协议DHCP"><a href="#动态主机配置协议DHCP" class="headerlink" title="动态主机配置协议DHCP"></a>动态主机配置协议DHCP</h2><p>动态主机配置协议DHCP(Dynamic Host Configuration Protocol)提供了一种机制，称为即插即用。这种机制允许一台计算机加入新网络时可<strong>自动获取</strong>IP地址等网络配置信息</p><p>在网络中配置DHCP服务器，让接入网络中的主机开机启动DHCP，就可以通过DHCP自动获取网络配置信息</p><hr><p>DHCP的工作过程</p><p>DHCP采用C/S方式，是<strong>应用层协议</strong>，<strong>使用UDP所提供的服务</strong>，也就是说DHCP在运输层会被封装成UDP用户数据报，服务器使用的UDP端口是67，客户使用的UDP端口是68</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/5KdCRkAHO3czbQY.png" alt="image-20210514222041851"></p><p>DHCP广播发送DHCP发现报文，源IP地址为0.0.0.0，因为主机目前还未分配到IP地址，因此使用该地址代替，目的地址为255.255.255.255，因为主机不知道有几个DHCP服务器，也不知道它们的主机地址是多少，所以采用广播地址</p><p>在DHCP发现报文中，封装有事物ID和DHCP客户端的MAC地址，DHCP服务器收到了发现报文后，根据其中封装的DHCP客户端的MAC地址来查找自己的数据库，看是否有相关的配置信息，如果有，就使用这些配置信息来构建并发送DHCP提供报文，如果没有，则采用默认配置信息构建并发送DHCP提供报文</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/jQCpqar54WNIcOl.png" alt="image-20210514223448736">因为DHCP客户还没有IP地址，所以采用广播地址，DHCP客户会根据报文中的事物ID来判断是否是自己所请求的报文</p><p>如果DHCP客户接受到多个DHCP服务器报文，则会从中选择一个，并会向所选择的DHCP服务器发送DHCP请求报文</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/ehaqlTdIUF2x7kS.png" alt="image-20210514224637960"></p><p>源IP地址为0.0.0.0，因为DHCP客户才选择了一个服务器作为自己的DHCP服务器，首先需要征得服务器的同意才能正式使用租用的IP地址</p><p>目的IP地址仍为广播地址，这样不用向网络中的每一个DHCP服务器发送DHCP请求报文，来告知他们是否被选择成为服务器</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/miT97GJ1fLeh82R.png" alt="image-20210514225517190"></p><p> 如果服务器接收该请求，则会给DHCP客户发送DHCP确认报文，DHCP收到该确认报文后，则会正式使用该IP地址</p><p>当租用期过了一半时，DHCP客户会向DHCP服务器发送DHCP请求报文，来请求更新租用期</p><p>如果DHCP服务器同意延长，则会更新租用期，若不同意，则立即停止使用租用的IP地址，并重新发送发现报文，如果服务器不响应，则在0.875倍租用期的时候重新发送请求报文。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/3ROsaMbYg1jHnrA.png" alt="image-20210514230445756"></p><p>DHCP客户可以随时提前终止DHCP服务器所提供的租用期，只需要向DHCP服务器发送DHCP释放报文段即可</p><hr><p>DHCP中继代理</p><p>在实际应用情况下，如果主机网络和DHCP服务器中有路由器的话，则主机无法通过DHCP服务器来配置网络信息，因为路由器不会转发客户的DHCP发现报文</p><p>解决办法是给该路由器配置DHCP服务器的IP地址，并使之成为DHCP中继代理，这样就可以通过DHCP来自动获取网络配置信息了，当路由器获取到广播DHCP发现报文后，会单播转发给DHCP服务器</p><hr><h2 id="IP数据报的转发"><a href="#IP数据报的转发" class="headerlink" title="IP数据报的转发"></a>IP数据报的转发</h2><h3 id="转发过程"><a href="#转发过程" class="headerlink" title="转发过程"></a>转发过程</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/63fKrSG5hpJZl49.png" alt="image-20210507155405472" style="zoom: 80%;" /></p><p>每个网络中都有其网络地址和子网掩码</p><p>同一个网络中的主机可以直接通信，而不同网络中的主机则需要路由器进行中转</p><p>问题是源主机如何判断目的主机是否需要是同一个网络中的？</p><p>可以将目的主机与源主机的子网掩码相与来得到目的网络地址，该地址与源主机的网络地址不相等，就可以知道目的主机与源主机不在同一个网络</p><p>这样就要通过路由器来转发数据，又有一个问题，主机怎么知道路由器的存在？</p><p>实际上，每一个主机都必须指定一个路由器，称为<strong>默认网关</strong>，如果主机要通过路由器传输信息，则会把数据传输给默认网关</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/AsLZF7miplrxhKW.png" alt="image-20210507160139055" style="zoom:80%;" /></p><p>如果路由器收到了IP数据报，该如何转发</p><ol><li>首先检查IP数据报，若出错，则直接丢弃该IP数据报，若没有出错，则直接进行转发</li><li>根据IP数据报的目的地址在路由表中查找匹配的条目：若找到匹配的条目，则转发给条目中指示的下一跳，若找不到，则丢弃数据报，并通告源主机</li></ol><p>路由器在配置的时候就知道了各个接口所连接的网络和地址掩码</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/Mt7DNdAY2TeRV1h.png" alt="image-20210507160639084"></p><p>将目的地址与地址掩码相与，得到目的网络地址，如果相同则转发，不同则查找下一个条目</p><hr><h3 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h3><ul><li>单播</li></ul><p>用于发送数据包到单个目的地，且每发送一个单播报文都使用一个单播IP地址作为目的地址，是一种点对点传输方式</p><hr><ul><li>广播</li></ul><p>是指发送数据包到同一广播域或子网内所有设备的一种数据传输方式，是一种点对多点的传输方式</p><p>如果在网络中发送广播，即目的地址是广播地址，则广播只会在本网络中传播，而路由器会判断出是广播，不会进行转发，所以路由器可以隔离广播风暴</p><hr><ul><li>组播</li></ul><p>当网络中的某些用户需要特定数据时，组播数据发送者仅发送一次数据，借助组播路由协议为组播数据包建立组播分发树，被传递的数据到达距离用户端尽可能近的节点后才开始复制和分发，是一种点对多点的传输方式</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220620234316623.png" alt="image-20220620234316623"></p><p>组播提高了数据传送效率，减少了拥塞的可能性，组播组的主机可以是在同一个物理网络，也可以来自不同的物理网络</p><p>IP组播地址让源设备能够将分组发送给一组设备。属于多播组的设备将被分配一个组播组IP地址</p><p>组播地址的范围为224.0.0.0~239.255.255.255(D类地址)，一个D类地址表示一个组播组。只能用作分组的目的地址。源地址总是单播地址</p><div class="note primary flat"><p>组播数据报不提供可靠传输，应用于UDP</p></div><p>对组播数据报不产生ICMP报文，并非所有D类地址都可以作为组播地址</p><hr><p>网际组管理协议IGMP</p><p>IGMP（Internet Group Management Protocol）协议让路由器知道是否有主机参加或退出了某个组播组</p><p>当主机要加入组播组时，该主机向组播地址发送一个IGMP报文，本地组播路由器收到IGMP报文后，利用组播路由选择协议把该成员关系发给其他组播路由器</p><p>本地组播路由器周期性的探询本地局域网上的主机，确认是否还是组播组的成员</p><p>组播路由器只知道所连接的局域网中有无组播组的成员</p><hr><p>组播路由选择协议</p><p>组播路由选择协议可以找出源主机为根节点的组播转发树</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220620235502527.png" alt="image-20220620235502527" style="zoom:80%;" /></p><hr><h2 id="网络地址转换NAT"><a href="#网络地址转换NAT" class="headerlink" title="网络地址转换NAT"></a>网络地址转换NAT</h2><p>NAT(Network Address Translation)：能使大量使用内部专用地址的专用网络用户共享少量外部全球地址来访问因特网上的主机和资源</p><p>使用私有地址的主机想要与因特网的主机上进行通信，需要一个NAT路由器，至少有一个有效地外部全球IP地址，所有的使用私有地址的主机在和外界通信的时候都要在NAT路由器上将IP地址转换成全球IP地址</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/c9Dv1RWkzLEfew5.png" alt="image-20210510225648917"></p><p>NAT路由器会建立一个转换表来记录私有地址和全球IP地址之间的转换关系</p><p>该转换方法存在一个问题：如果NAT路由器具有N个全球IP地址，那么至多有N个内网主机能够同时和因特网上的主机通信</p><p>所以推出了网络地址与端口转换技术NAPT，将运输层的端口号和IP地址一起转换，这样用一个全球IP地址就可以使多个拥有本地地址的主机同时和因特网上的主机进行通信</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/jiBPgp34nEWvFot.png" alt="image-20210510235817887"></p><p>对于一些P2P网络应用，需要外网主机主动与内网主机进行通信，在通过NAT时会遇到问题，需要网络应用自己使用一些特殊的NAT穿越技术来解决问题</p><hr><h2 id="虚拟专用网VPN"><a href="#虚拟专用网VPN" class="headerlink" title="虚拟专用网VPN"></a>虚拟专用网VPN</h2><p>虚拟专用网VPN(Virtual Private Network)：利用公网的因特网作为本机构各专用网之间的通信载体</p><p>由于IPv4地址的紧缺，一个机构所申请到的地址数量很少，因此，虚拟专用网中各主机所分配的地址应该是本机构可只有分配的专用地址，而不是需要申请的，在因特网上使用的公有地址</p><p>有 10.0.0.0~10.255.255.255(10/8地址块)</p><p>   172.16.0.0~172.31.255.255(172.16/12地址块)</p><p>   192.168.0.0~192.168.255.255(192.168/16地址块)</p><p>私有地址只能用于内部通信，不能在因特网上传输，路由器对目的地址是私有地址的IP数据报一律不进行转发</p><p>很显然，两个私有地址之间要实现远程通信，需要两个有公网IP的路由器</p><p>假设需要远程通信，在主机1把数据包传送给路由器1，路由器1吧IP数据报加密，然后用IP数据报的形式通过因特网传输到路由器2，路由器2解析加密的IP数据报，然后把数据发送给主机2</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/IFujaoiqhW9sNmd.png" alt="image-20210510224501522"></p><p>从逻辑上看来R1和R2好像是点对点链路，所以也把这种技术称为<strong>IP隧道技术</strong></p><p>同一机构内不同部分的内部网络所构成的虚拟专用网VPN又称为内联网VPN</p><p>有时一个结构的VPN需要有某些外部机构参与进来，这样的VPN称为外联网VPN</p><p>在外地工作的员工需要访问公司内部的专用网络时，只要在任何地点接入到因特网，运行PC中的VPN软件，在员工的PC和公司的主机之间建立VPN隧道，即可以访问专用网络中的资源，这种VPN称为远程接入VPN</p><hr><h2 id="移动IP"><a href="#移动IP" class="headerlink" title="移动IP"></a>移动IP</h2><p>移动IP技术是移动节点以固定的网络IP地址，实现跨越不同网段的漫游功能，并保证了基于网络IP的网络权限在漫游过程中不发生任何改变</p><p>移动节点：具有永久IP地址的移动设备</p><p>归属代理：一个移动节点的归属网络</p><p>永久地址：移动节点在归属网络中的原始地址</p><p>外部代理：在外部网络中帮助移动节点完成移动管理功能的实体</p><p>转交地址：可以是外部代理地址或动态配置的一个地址</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220621002517370.png" alt="image-20220621002517370"></p><p>A进入到外部网络后：</p><ol><li>获得外部代理的转交地址</li><li>移动节点通过外部代理发送注册报文给归属代理</li><li>归属代理接受请求，并将移动节点的永久地址和转交地址绑定，并返回注册响应报文</li><li>外部代理接收注册响应，并转发给移动节点</li></ol><hr><h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>路由器是一种具有多个输入端口和输出端口的专用计算机，任务是转发分组</p><p>路由器可以划分为路由选择部分和分组转发部分</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/RHPzq4sQo63StN9.png" alt="image-20210510152558418" style="zoom:67%;" /></p><p>路由表如果收到了路由报文就会更新自己的路由表</p><ul><li>路由表一般仅包含从目的网络下一跳的映射</li><li>路由表需要对网络拓扑变化的计算最优化</li><li>转发表是从路由表得出的</li><li>转发表的结构应当使查找过程最优化</li></ul><p><strong>路由器将网络隔离成多个广播域和多个冲突域</strong></p><hr><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>路由器有<strong>转发</strong>以及<strong>路由选择</strong>两大功能，可以将路由器实现转发功能的过程称为<strong>数据平面</strong>，实现路由选择的功能称为<strong>控制平面</strong></p><p>控制平面的传统方法：路由选择算法运行在每台路由器中，并且每台路由器中都包含转发和路由选择两种功能</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/wps9ERWzfUrPDQn.png" alt="image-20220619160335379"></p><p>控制平面的SDN(Software-Defined Networking)方法：控制平面从路由器物理上分离。<strong>路由器仅实现转发</strong>，远程控制器计算和分发转发表以供每台路由器使用</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/1uESUf4XkoRHqWc.png" alt="image-20220619160530325"></p><p>远程控制器可能在具有高可靠性的远程数据中心中，并可能由ISP或某些第三方管理，远程控制器计算出路由转发表，是由软件控制的，所以叫做SDN</p><hr><h2 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>路由协议分为静态路由选择和动态路由选择</p><p>静态路由选择方式相对简单，需要管理员手动配置路由信息，不能及时适应网络变化，所以一般在小规模网络中采用</p><p>动态路由选择方式比较复杂，路由器之间彼此交换信息，按照路由算法优化出路由表项，能较好地适应网络状态的变化，所以适用于大规模网络</p><hr><h3 id="静态路由配置和路由环路"><a href="#静态路由配置和路由环路" class="headerlink" title="静态路由配置和路由环路"></a>静态路由配置和路由环路</h3><p>静态路由配置是指用户或网络管理员使用路由器的相关命令给路由器人工配置路由表</p><p>这样配置不能及时适应网络状态，可以出现以下导致路由环路的错误</p><ul><li>配置错误</li><li>聚合了不存在的网络</li><li>网络故障</li></ul><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/iVE4WbDHCRlKwha.png" alt="image-20210510142840511"></p><p>如果此时R1的收到的IP数据报要转发给目的主机，但是在R1中并没有相关路由配置</p><p>此时就需要给R1的路由表配置相关信息，使R1下一跳在R2</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/SZdKtCwg4kyjFXn.png" alt="image-20210510143204263"></p><p>如果<strong>R2接入了因特网</strong>，那么众多IP数据报需要通过R1转发到达R2，如果是一条一条配置的话工作量太大了，此时我们可以使用<strong>默认路由</strong>的概念</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/aVceqfF6WiMhQl2.png" alt="image-20210510143337978"></p><p>将目的网络设置成0.0.0.0/0，此时其他的IP数据报都会默认跳转到R2，然后由R2转发到互联网上，子网掩码为0.0.0.0</p><hr><p>有时候我们可以给路由器添加针对某个主机的<strong>特定主机路由条目</strong>，确保路由器转发到指定的主机上</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/bMV3DuOFcYHl89S.png" alt="image-20210510143718110"></p><p>如果要给192.168.2.1的主机添加特定主机路由配置，就在路由器中设置成192.168.2.1/32，即子网掩码为255.255.255.255</p><p>这样网络的前缀最长，路由最具体，当路由器具有多种转发路径可以选择的时候，会采取最长前缀匹配原则，转发的时候会有最高的优先级</p><hr><p>路由配置错误导致的路由环路问题</p><p>假如R1收到数据要转发给R2，而R2的路由错误配置。导致R2的数据要转发回R1，那么就出现了路由环路的问题</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/Fhp7AtekyVGzgQW.png" alt="image-20210510144229295"></p><p>为了防止IP数据报在路由环路中永久的兜圈，在IP数据报首部设有<strong>生存时间TTL字段</strong></p><p>当IP数据报进入路由器后，TTL字段的值就减1，若TTL的值不等于0，则被路由器转发，否则被丢弃</p><hr><p>聚合了不存在的网络导致的路由环路问题</p><p>如果在路由器中聚合了不存在的网络地址，当R2收到后会转发给R1，而R1收到后转发给R2，那么就形成了路由环路</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/qa7doPVQYunMWNy.png" alt="image-20210510145250091"></p><p>针对这种情况，可以在R2中添加针对不存在的聚合网络的黑洞路由，一旦IP数据报进入到黑洞路由后就会被丢弃</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/5jxPcpa2L6KwoSI.png" alt="image-20210510145407140"></p><p>因为黑洞路由更具体，所以会优先转发黑洞路由</p><hr><p>网络故障导致的路由环路</p><p>假设路由器自动检测到其中的一条直连网络出现了故障而不可达，就会在路由表中删除该条目，如果R2转发数据给地址，会通过R1转发，R1查找不到该地址，又通过默认路由到R2中，形成了路由环路</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/cQ4rKRTMhGlUZWb.png" alt="image-20210510145726319"></p><p>针对这种情况，可以在R1中添加针对被删除网络的黑洞路由，这样就不会形成环路了</p><hr><h3 id="动态路由配置协议"><a href="#动态路由配置协议" class="headerlink" title="动态路由配置协议"></a>动态路由配置协议</h3><p>在自治系统内部使用的协议是内部网络协议IGP，在两个自治系统之间使用的协议是外部网关协议EGP</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/3aBFJGqzelm6WNo.png" alt="image-20220619182750888"></p><p>RIP基于距离向量，路由器只掌握相连的邻居和链路费用</p><p>OSPF基于链路状态，所有路由器掌握完整的网络拓扑和链路费用信息</p><hr><h4 id="路由信息协议RIP"><a href="#路由信息协议RIP" class="headerlink" title="路由信息协议RIP"></a>路由信息协议RIP</h4><p>路由信息协议RIP(Routing Information Protocol)是内部网关协议IGP中最先得到广泛使用的协议之一</p><p>RIP要求自治系统AS内的每一个路由器都要维护从它自己到AS内其它每一个网络的距离记录。这是一组距离，称为“距离向量D-V(Distance-Vector”</p><p>RIP使用跳数作为度量来衡量到达目的网络的距离</p><ul><li>路由器到直连网络的距离定义为1</li><li>路由器到非直连网络的距离定义为经过的路由器数加1</li><li>允许一条路径最多只能包含15个路由器。<strong>距离等于16相当于不可达</strong>，所以RIP只适用于小型互联网</li><li><strong>RIP被封装在UDP协议中</strong></li></ul><p>RIP协议认为“距离短”的路由就是最优选择的路由，也就是所通过路由器数量最少的路由</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/jetkNZxXP1vmW7g.png" alt="image-20210510180046128"></p><p>尽管R1到R2的带宽，但是RIP会认为R1到R4的更好</p><p>到到达同一网络由多条距离相等的路由时，可以进行<strong>等价负载均衡</strong>，也就是将通信量均衡地分布到多条等价的路由上</p><p>RIP包含有以下三个要点</p><ul><li>和谁交换信息    仅和相邻路由器交换信息</li><li>交换什么信息    自己的路由表</li><li>合适交换信息    周期性交换</li></ul><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/gMuyKjoIRkP5flY.png" alt="image-20210510180407506"></p><hr><p>RIP的基本工作过程</p><ol><li>当路由器刚开始工作的时，只知道自己到直连网络的距离为1，并不知道和自己相邻路由器的信息</li><li>每个路由器仅和相邻路由器周期性地交换并更新路由信息</li><li>若干次交换和更新后，每个路由器都知道到达本AS内各网络的最短距离和下一跳地址，称为<strong>收敛</strong></li></ol><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/Tx6i5XuY4WBKPFn.png" alt="image-20210510181014661"></p><hr><p>RIP更新报文</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/iOctXFuBf3dQ2P1.png" alt="image-20210510181150740"></p><p>这是C的路由表，而C的相邻路由器接收到该路由表时，会对其进行改造，成如下形式</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/hQfDsGw4CBWAkLH.png" alt="image-20210510181341506"></p><p>所有的距离加1，并且下一跳都变为C</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220620025604986.png" alt="image-20220620025604986"></p><p>然后对比C的路由表和自己的路由表</p><ul><li>如果目的网络和下一跳一样，则要更新信息</li><li>发现了新的网络，进行添加</li><li>如果目的网络一样，距离一样，下一跳不一样，就进行等价负载均衡</li><li>如果目的网络一样，距离不一样，下一跳不一样，如果新路由的距离短，则更新信息，如果距离更长，则不更新</li></ul><hr><p>RIP存在有坏消息传播得慢这一问题</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/2CgVGtcKAukY4va.png" alt="image-20210510181845024"></p><p>如果N1故障了，R1会将其距离设置为16，并把信息传输给R2，R2之前的路由表信息是，到达N1的距离为2，因为路由表在周期性的更新信息</p><p>那么，如果R2的路由器信息更早的到达的R1，R1则不再会认为到N1的距离为16，而是会更新为3，同时将此路由表信息传输给R2,R2接受到后，就会认为到达N1的距离为4</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/QrmzCp6uxqcGRPV.png" alt="image-20210510182217999"></p><p>直到R1和R2都认为到N1的距离为16才会终止</p><p>”坏消息传的慢“，又称为路由环路或距离无穷计数问题，这是距离向量算法的一个固有问题，可以采取多种措施减少出现该问题的概率或减少该问题带来的危害</p><ul><li>设置最大路径距离为15</li><li>当路由表发生变化的时候立即发送更新报文(触发更新)，而不是周期性发送</li><li>让路由器记录收到某特定路由信息的接口，而不让同一路由信息再通过此接口向反方向传送(即水平分割)</li></ul><hr><h4 id="开放最短路径优先OSPF"><a href="#开放最短路径优先OSPF" class="headerlink" title="开放最短路径优先OSPF"></a>开放最短路径优先OSPF</h4><p>开放最短路径优先OSPF(Open Shortest Path First)是为了克服RIP的缺点而开发出来的</p><ul><li>“开放”表明OSPF不是受某一家厂商控制，而是公开发表的</li><li>“最短路径优先”是因为使用了迪杰斯特拉提出的最短路径算法SPF</li></ul><p>OSPF基于<strong>链路状态</strong>，而不像RIP那样是基于距离向量的</p><p>OSPF采用SPF算法计算路由，从算法上保证了<strong>不会产生路由环路</strong></p><p>OSPF<strong>不限制网络规模</strong>，更新效率高，收敛速度快</p><p>链路状态是指本路由器都和哪些路由器相邻，以及相应链路的“代价”(cost)</p><ul><li>代价可以是很多指标，比如距离，时延，带宽等由网络管理人员决定</li></ul><hr><p>OSPF报文</p><p>OSPF相邻路由器之间通过交互问候(Hello)分组，建立和维护邻居关系</p><ul><li><p>Hello分组封装在IP数据报中，发往组播地址224.0.0.5(所有的OSPF路由器)</p></li><li><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220620025621464.png" alt="image-20220620025621464"></p></li><li><p>发送周期为10秒</p></li><li><p>如果40秒未收到来自邻居路由器的Hello分组，则认为该邻居路由器不可达</p></li></ul><p>使用OSPF的每个路由器都会产生链路状态通告LSA(Link State Advertisement)，LSA包含以下信息：</p><ul><li>直连网络的链路状态信息</li><li>邻居路由器的链路状态信息</li></ul><p>LSA被封装在链路状态更新分组LSU中，采用洪泛法发送</p><p>使用OSPF的每个路由器都有一个<strong>链路状态数据库LSDB</strong>，用于存储LSA</p><p>通过各路由器洪范发送封装有自己LSA的LSU分组，各路由器的LSDB最终<strong>达成一致</strong></p><p>使用OSPF的各路由器基于LSDB进行最短路径优先SPF计算，构建出各自到达其他路由器的最短路径，即构建各自的路由表</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220620025749056.png" alt="image-20220620025749056"></p><hr><p>OSPF的工作原理</p><p>OSPF有以下5种分组</p><ul><li>问候分组 用来发现和维护邻居路由器的可达性</li><li>数据库描述 向邻居路由器给出自己的链路状态数据库中的所有链路状态项目的摘要信息</li><li>链路状态请求 向邻居路由器请求发送某些链路状态项目的详细信息</li><li>链路状态更新(LSU) 路由器使用这种分组进行洪泛转发</li><li>链路状态确认 对LSU的确认分组</li></ul><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220620025705076.png" alt="image-20220620025705076"></p><p>每30分钟或者链路状态发生变化，都会通过洪泛法来发送LSU，并给该路由器发送确认分组</p><hr><p>OSPF在多点接入网络中，很容易产生多个多播分组</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220620025757195.png" alt="image-20220620025757195"></p><p>为了减少多播分组的发送，OSPF采用选举指定路由器DR(Designated Router)和备用的指定路由器BDR的方法</p><p><strong>所有的非DR/BDR只与DR/BDR建立邻居关系，通过其交换网络</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/ik1L5XhGtIJBrqV.png" alt="image-20210510193841039"></p><hr><p>为了让OSPF能够用于规模更大的网络，OSPF把一个自治系统再划分为若干个更小的区域(Area)</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/b1xQRpkevwFZHJl.png" alt="image-20210510194014162"></p><p>可以降低洪泛法交换信息的范围局限在每个区域内</p><p>区域内路由器IR(Inter Router)：接口都完全在一个区域内的路由器</p><p>区域边界路由器ABR(Area Border Router)：一个接口用于连接自身区域，另一个用于连接主干</p><p>主干路由器BR(Backbone Router)：主干区域内的路由器</p><p>自治系统边界路由器ASBR(AS Border Router)：专门用于和其他自治系统交换信息</p><hr><h4 id="边界网关协议-BGP"><a href="#边界网关协议-BGP" class="headerlink" title="边界网关协议(BGP)"></a>边界网关协议(BGP)</h4><p>在配置BGP时，每个自治系统的管理员要选择一个路由器作为该自治系统的“BGP发言人”</p><p>不同自治系统的BGP发言人要交换路由信息，<strong>首先必须建立TCP连接</strong>，端口号为179</p><ul><li>在此TCP连接上交换BGP报文以建立BGP会话</li><li>利用BGP会话交换路由信息</li><li>使用TCP连接交换路由信息的两个BGP发言人，彼此称为对方的邻站或对等站</li></ul><p>BGP发言人除了运行BGP外，还必须运行自己所在自治系统的内部网关协议IGP</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/mbYzl7Rw9rq5OtV.png" alt="image-20210510200357288"></p><p>BGP发言人交换网络可达性的信息</p><p>当BGP发现人交换了网络可达性信息之后，各BGP发言人就根据所采用的策略从收到的信息中找出到达各自治系统的较好的路由，也就是构造出树形结构，不存在环路的连通图</p><p>BGP-4有以下4种报文</p><p>OPEN 打开报文 ：用来与相邻的另一个BGP发言人建立关系，让通信初始化</p><p>UPDATE 更新报文 ：用来通告某一路由信息，以及列出要撤销的路由</p><p>KEEPLIVE 保活报文：用来周期性地证实邻站的连通性</p><p>NOTIFICATION 通知报文：用来发送检测到的差错</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>RIP协议是一种分布式的基于距离向量的内部网关路由选择协议，通过<strong>广播UDP</strong>报文来交换信息</p><p><strong>OSPF</strong>是一个内部网关协议，要交换的信息量较大，应该让报文的长度尽量短，所以直接采用<strong>IP数据报</strong></p><p><strong>BGP</strong>是一个外部网关协议，在不同自治系统之间交换路由信息，由于网络环境复杂，所以要保证可靠传输，采用<strong>TCP协议</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/DxpUgusnv2P7JXb.png" alt="image-20220619183039126"></p><hr><h2 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h2><p>主机或路由器通过ICMP(Internet Control Message Protocol)来发送<strong>差错报告报文和询问报文</strong></p><p>被封装在<strong>IP数据报</strong>中发送</p><p>报文一共有一下5种</p><ul><li>终点不可达</li></ul><p>当路由器或主机无法交付数据报时，就向源点发送终点不可达报文</p><ul><li>源点抑制</li></ul><p>当路由器或主机由于拥塞而丢弃数据时，就向源点发送源点抑制报文</p><ul><li>时间超过</li></ul><p>若转发的数据报的生存时间为0，除了丢弃该数据报，还要向源点发送时间超过报文</p><ul><li>参数问题</li></ul><p>如果路由器或目的主机收到IP数据报后，根据其首部的检验和字段发现了误码，就丢弃该数据报，并且向源点发送参数问题报文</p><ul><li>改变路由</li></ul><p>路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的主机</p><p>以下情况不该发送ICMP差错报告报文</p><ul><li>对ICMP差错报文不应发送ICMP差错报文</li><li>对第一个分片的数据报文的所有后序报文都不发送ICMP差错报告报文</li><li>对具有多播地址的数据报不发送</li><li>对具有特殊地址的数据报(127.0.0.0或0.0.0.0)不发送</li></ul><hr><p>ICMP询问报文主要有两种</p><ul><li>回送请求和回答</li></ul><p>ICMP回送请求是由主机或路由器向一个特定的目的主机发出的询问，收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文，用来测试目的站是否可达</p><ul><li>时间戳请求和回答</li></ul><p>ICMP时间戳请求报文是请某个主机或路由器回答当前的时间和日期，用来进行时钟同步和测量时间</p><hr><h2 id="最大最小公平性算法"><a href="#最大最小公平性算法" class="headerlink" title="最大最小公平性算法"></a>最大最小公平性算法</h2><ol><li>所有数据流的速率从零开始</li><li>增加速率，直到任何一个数据流的速率到瓶颈</li><li>调整已到瓶颈的速率（这里是不带权的调整，即均分）</li><li>回到第二步循环</li></ol><p>例题：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221209230047134.png" alt="image-20221209230047134"></p><p>则4条流如图所示：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221209230118581.png" alt="image-20221209230118581"></p><p>因为R4-R5段是最拥挤的段，所以先分配，BCD都分别只占1/3，而因为B占了1/3，所以在R2-R3段，A可以占2/3，所以结果为A:20  B:10 C:10 D:10 所以答案选D</p><hr><h2 id="BGP最佳路径选择算法"><a href="#BGP最佳路径选择算法" class="headerlink" title="BGP最佳路径选择算法"></a>BGP最佳路径选择算法</h2><p>选择顺序：</p><ol><li>首选具有最高 WEIGHT 的路径。</li><li>首选具有最高 LOCAL_PREF的路径</li><li>首选具有最短 AS_PATH 的路径</li><li>首选具有最低源类型的路径</li><li>首选具有最低多出口标识符 (MED) 的路径。</li><li>首选 eBGP 路径而非 iBGP 路径</li></ol>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.数据链路层</title>
      <link href="/post/17624.html"/>
      <url>/post/17624.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>链路：就是从一个结点到相邻结点的一段物理线路，而中间没有任何其他的交换线路</p><p>数据链路：是指把实现通信协议的硬件和软件加到链路上，就构成了数据链路</p><p>数据链路层以<strong>帧</strong>为单位传输和处理数据</p><p>数据链路层在传输数据的时候主要考虑三个问题</p><ul><li><strong>封装成帧</strong></li><li><strong>透明传输</strong></li><li><strong>差错检测</strong></li></ul><p>同时，也要考虑传输数据时的<strong>可靠性</strong></p><hr><p><strong>封装成帧：</strong></p><p>数据链路层给网络层交付的协议数据单元添加帧头和帧尾的操作，称为封装成帧</p><div class="table-container"><table><thead><tr><th>帧尾</th><th>应用层协议单元数据</th><th>运输层协议首部</th><th>网络层协议首部</th><th>帧头</th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>目的是在链路上以帧为单位传输数据</p><hr><p><strong>透明传输：</strong></p><p>是指数据链路层对上层交付的传输数据没有任何限制，就好像数据链路层不存在一样</p><hr><p><strong>差错检测：</strong></p><p>帧在传输过程中可能出现误码，根据帧尾中的检错码就可以检测帧中是否有误码</p><hr><p><strong>可靠传输：</strong></p><p>接收方主机收到有误码的帧后，不会接收该帧，将其丢弃，如果数据链路层提供的是不可靠服务，那么该帧就被永久丢弃了</p><p>如果链路层提供的是可靠服务，就需要其他措施来确保接收方主机还可以重新收到被丢弃的这个帧的正确副本。尽管误码是不能完全避免的，但如果能够实现发送方发送什么，接收方就能收到什么，就称为可靠传输</p><hr><p>对于使用广播信道的数据链路层，还需要考虑<strong>数据的编制问题，和数据在信道传输的碰撞问题</strong></p><hr><h2 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h2><p>封装成帧是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之成为帧</p><ul><li>帧头和帧尾包含有重要的控制信息</li></ul><p>数据链路层会把上层交付下来的协议数据单元封装成帧后，要通过物理层，把各个比特转换成电信号发送到传输媒体，接收方的数据链路层需要从比特流中识别出帧</p><p>有如下方法：</p><ol><li><p>在帧头和帧尾添加标志位做标识</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/YlNw7qMpheJvusa.png" alt="image-20210429185457517"></p><p>帧头和帧尾的作用之一就是帧定界</p><p>在帧头和帧尾的中有一个字节的标识字段，用来标识帧，但是并不是每一种帧都包含了帧定界格式</p></li><li><p>给MAC帧添加前导码</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/VNvFh31WwLtEo9u.png" alt="image-20210429185723929"></p><p>MAC帧交付到物理层后，物理层会给MAC帧添加前导码，然后在转换为电信号发送</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/VH1RZzP8kgsb6Sj.png" alt="image-20210429185816427"></p></li></ol><p>   前导码中的前七个字节为前同步码，作用是使接收方的时钟同步，后一个字节为定界符，用来表示之后的帧是MAC帧，这样就能识别到帧头</p><p>   <strong>以太网</strong>还规定了帧间间隔时间为96bit。所以不需要帧结束定界符</p><hr><h2 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h2><p><strong>透明传输：是指数据链路层对上层交付的传输数据没有任何限制，就好像数据链路层不存在一样</strong></p><hr><p>对于采用帧定界符的帧来说，对比特流进行处理才能实现透明传输</p><p>帧定界标识也是一种字符，上层的数据也有可能使用，如果上层交付的协议数据单元中，包含了帧定界标志，如果不做任何处理的话，接收方就不能正确接收该帧 </p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/24ogtASXLR3fnUd.png" alt="image-20210429192413380"></p><p>如果要求上层的协议数据单元不能包含帧定界标志的话，就不能称为透明传输，实际上为了透明传输，所有的数据链路层协议都会解决这个问题</p><ul><li>面向字节的物理链路使用<strong>字节填充</strong>的方法实现透明传输</li></ul><p>比如，在传输之前，对帧的数据部分进行扫描，如果发现了帧定界符，则在其中加入转义字符，如果其中有转义字符，也需要插入转义字符</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/z98Ps2KSFBdOWuk.png" alt="image-20210429193002873"></p><ul><li>面向比特的物理链路使用<strong>比特填充</strong>的方法实现透明传输</li></ul><p>如果在帧的数据部分出现了帧定界标志，在发送前，可使用<strong>0比特传输法</strong>，每5个连续数据的比特1后面添加一个比特0，接收的时候将其剔除即可</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/3UNFSwfYXP4QbnR.png" alt="image-20210429193544931" style="zoom: 80%;" /></p><hr><p>对于以太网的MAC帧，由于使用CSMA/CD协议，规定了帧间间隔，没有结束字符段，不需要对帧内容进行转义</p><hr><p>为了提高帧的传输效率，应该使帧的数据部分的长度尽可能大些</p><p>考虑到差错控制等多种因素，每一种数据链路层协议都规定了帧的数据部分的长度上限，即<strong>最大传送单元MTU</strong>(Maximum Transfer Unit)</p><hr><h2 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h2><p>比特差错：实际的通信链路都不是理想的，比特在传输构成中可能会产生差错：1可能会变成0，而0也可能变成1，这称为比特差错</p><p>在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率BER</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/uNyDjzZE3OCweRb.png" alt="image-20210429194932945" style="zoom: 80%;" /></p><p>使用 差错检测码来检测数据在传输过程中是否产生了比特差错，是数据链路层要解决的问题</p><hr><p>奇偶校验：在待发送的数据后面添加1位奇偶校验码，使整个数据中“1”的个数为奇数或者偶数</p><p>但是如果传输过程中产生2位误码，那么就无法检出错误了</p><hr><p>循环冗余校验CRC(Cyclic Redundancy Check)</p><ul><li>收发双方约定好一个生成多项式G(x)</li><li>发送方基于待发送的数据和生成多项式计算出差错检测码(冗余码),将其添加到待传输数据的后面一起传输</li><li>接收方通过生成多项式来计算收到的数据是否产生了误码</li></ul><div class="table-container"><table><thead><tr><th><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/HmiqSKWrAvjPz5g.png" alt="image-20210429204755515"  /></th><th><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/yS29dBVCInLG3Fe.png" alt="image-20210429204823494"  /></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>检错码只能检查出帧在传输过程中出现了差错，但并不能定位错误，因此无法纠正错误码</p><p>循环冗余校验CRC有很好的检错能力，虽然计算复杂，但是容易使用硬件实现，因此广泛用于数据链路层</p><hr><h2 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>使用差错检测技术可以检测到帧在传输过程中是否产生了误码</p><p>不可靠传输服务：仅仅丢弃有误码的帧，其他什么都不做</p><p>可靠传输服务：想办法实现发送端发送什么，接收端就收到什么</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/eaFoRULCPQI37ny.png" alt="image-20220618000002417"></p><p>一般情况下，有线链路的误码率比较低，所以为了减小开销，并不要求数据链路层向上提供可靠服务，即使出现误码，问题可由上层处理</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/w7T2AGZU1ldLv3H.png" alt="image-20210429205549920"></p><p><strong>但是对于无线链路，误码率较高，则必须要采用可靠传输服务</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/c9ZeGgQkytWF5C8.png" alt="image-20210429205625927"></p><p>比特差错只是传输差错的一种，从整个计算机网络体系结构来看，传输差错还包括分组丢失，分组失序以及分组重复</p><p><strong>可靠传输服务并不仅局限于数据链路层，其他各层均可选择实现可靠传输</strong>（在运输层的TCP协议）</p><hr><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><ul><li>流量控制是数据链路层的一种功能，流量控制对数据链路上的帧的发送速率进行控制，以使接收方有足够的缓冲空间来接受每个帧</li><li>流量控制的基本方法是由<strong>接收方控制</strong>发送方发送数据的速率</li><li>常见的流量控制方式有两种：停止-等待协议、滑动窗口协议</li></ul><hr><h3 id="停止等待协议SW-Stop-and-Wait"><a href="#停止等待协议SW-Stop-and-Wait" class="headerlink" title="停止等待协议SW(Stop-and-Wait)"></a>停止等待协议SW(Stop-and-Wait)</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/3A95JjmrUoObZCB.png" alt="image-20210429213051724"></p><p>当发送方发送了一个数据包之后，就开始等待，当接收方收到了数据之后，会发送一个确认数据给发送方，当发送方收到了确认数据后，才会继续发送数据，当接收方收到误码后，会把数据包丢弃，然后会发送一个错误信息给发送方，发送方收到后会重传。这样就实现了可靠传输</p><hr><p>但是这样会有一个问题，如何DATA在传输过程<strong>丢失</strong>了，那么接收方就不会发送确认消息，此时该怎么办？</p><p>为了解决这个问题，可以在发送方发送完一个数据分组时，启动一个<strong>超时计时器</strong>。如果到了超时计时器所设置的<strong>重传时间</strong>，而发送方仍收不到接收方的任何消息，则重传原来的数据分组，这就叫做<strong>超时重传</strong></p><p>一般可将重传时间选为略大于从发送方到接收方的平均往返时间</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/nZ2SgTvuCXBe5w1.png" alt="image-20210429214929826"></p><hr><p>这样解决了DATA的丢失问题，但是ACK同样也有可能丢失，当ACK丢失的时候，发送方启动超时重传器，重传了DATA数据包，此时接收方无法判断这个数据包是否是刚才的数据包？此时就导致了<strong>分组重复</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/iEPcApBoK5xbtTZ.png" alt="image-20210429215833717"></p><p>为了避免分组重复这种传输错误，必须给每个分组带上<strong>序号</strong></p><p>对于停止-等待协议，由于每发送一个数据分组就停止等待，只要保证每发送一个新的数据分组，其发送序号与上次发送的数据分组的序号不同就可以了，因此用一个比特来编号就可以了</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/ApeP9glTVcQdDn4.png" alt="image-20210429221644470"></p><hr><p>给数据编号，这样就解决了确认信号的丢失问题，那么需要给确认信号也编号吗？</p><p>假如在收到数据后，接收方发出的确认信号经过了一些延迟，发出去的时候，发送方已经启动重传协议发送了数据0，此时收到了确认数据，发送数据1，发送方收到了重复的数据0，发送ACK表示丢弃，问题是发送方如何判断这个ACK的意思呢？</p><p>确认分组编号就可以解决这种问题</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/NkCOYEpU2W7HAva.png" alt="image-20210429223042978"></p><p>注意事项：</p><ul><li>接收端检测到数据分组有误码时，将其丢弃并等待发送方的超时重传，但对误码率较高的点对点链路，为使发送方尽早重传，也可以给发送方发送NAK分组</li><li>给数据分组编号的时候，需要要1个比特编号就行了，即0和1</li><li>给ACK分组编号，所用的比特和给数据分组编号时候一样，但是数据链路层一般不会出现ACK分组迟到的情况，所以在数据链路层实现SW协议时，可以不用给ACK分组编号</li></ul><hr><h3 id="回退N帧协议GBN-G0-Back-N"><a href="#回退N帧协议GBN-G0-Back-N" class="headerlink" title="回退N帧协议GBN(G0-Back-N)"></a>回退N帧协议GBN(G0-Back-N)</h3><p>因为停止等待协议的信道利用率很低，所以如果能流水线式传输数据分组的话，信道利用率会高很多</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/z2qPviOxgRAsC8J.png" alt="image-20210503122151575"></p><p>主要是通过发送窗口的方式来实现多个数据包的发送</p><p>1.采用3个比特给分组编序号，即0~7</p><p>2.发送窗口的尺寸<strong>不能超过</strong>$2^n-1$，如果发送窗口尺寸为1，则是SW协议</p><p>3.接收窗口的尺寸为1</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/gjBTixKmFDudHc7.png" alt="image-20210503123646724"></p><p><strong>累计确认</strong></p><p>接收方不一定要对收到的数据分组逐个发送确认，而是可以在收到几个数据分组后，对按序到达的最后一个数据分组发送确认，</p><p>比如在接收到3个数据包后，只需要发送一个ACK2就可以了，说明在ACKn<strong>之前</strong>的数据包都成功接收了</p><p>即使确认分组丢失，发送方也不必重传，只要只要后面的确认分组到了就行，使用累计确认也有缺点，当发送方发送的第一个数据包出现误码的时候，接收方只有全部丢弃数据包</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/4VH8vjt1msC7Blc.png" alt="image-20210503124400005" style="zoom:67%;" /></p><p>当出现差错的时候，接收窗口每丢弃一次，就会发送一次之前的ACK序号，当发送窗口接收到重复的ACK时，可以不等超时计时器超时就立刻重传</p><p>尽管之后的数据分组都正确的到达了接收方，但是由于第一个数据分组没有被接收，它们同样也不能被接收，发送方还要重传这些数据分组，这就是所谓的Go-back-N(回退N帧)</p><div class="table-container"><table><thead><tr><th><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/vYNgMOEJymkDVZj.png" alt="image-20210503124832603" style="zoom:67%;" /></th><th><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/5YFodSXRHk238by.png" alt="image-20210503124838991" style="zoom:67%;" /></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><hr><h3 id="选择重传协议SR-Selective-Request"><a href="#选择重传协议SR-Selective-Request" class="headerlink" title="选择重传协议SR(Selective Request)"></a>选择重传协议SR(Selective Request)</h3><p>回退N帧协议的接收窗口尺寸为1，因此接收方只能按序接收正确到达的分组，一个数据的误码导致在其之后的数据不能被接收，这是对通信资源的浪费</p><p>为了提高性能，只重传出现误码的数据分组，因此，接收窗口的尺寸应该大于1，以便接收方先收下失序到达但无误码并且序号落在接收窗口的数据分组，等到所缺分组收齐后再一并送交上层。这就是选择重传协议</p><p><strong>选择重传协议不采用累计确认，而是逐一确认</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/hcEDnk87T9qPs3Q.png" alt="image-20210503144635659"></p><p>发送窗口的尺寸不能超过$1&lt;W_T≤2^{n-1}$，n为编码的比特数</p><p>如果尺寸超过了，则会导致重复分组的问题</p><div class="table-container"><table><thead><tr><th><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/Pa6VmFe5T3KhEnt.png" alt="image-20210503144850644" style="zoom:67%;" /></th><th><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/xs1tRwFaMPdKJGN.png" alt="image-20210503144855854" style="zoom:67%;" /></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><div class="note danger flat"><p>实际上，发送窗口的值应该是和GBN协议一样，最大是$2^{n}-1$，而非$2^{n-1}$，之所以规定成$2^{n-1}$，是因为如果发送窗口＞$2^{n-1}$，而接受窗口=发送窗口的值，会导致分组重复的问题，但是，只要遵循$W_T+W_R=2^{n}$这一规律，发送窗口的值也是可以超过$2^{n-1}$的</p></div><hr><h3 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h3><p>停止等待协议</p><p>发送一个数据分组开始，到收到确认消息，有三段时间，数据分组的发送时延 $T_D$，数据在信道中的往返时间RTT，收到确认分组的处理时延$T_A$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/2fteDsa6QpIBCg7.png" alt="image-20210503121418032" style="zoom:67%;" /></p><p>只有在发送数据的时候才算在利用信道</p><p><strong>信道利用率$U=\frac{T_D}{T_D+RTT+T_A}$</strong></p><p>当往返时延RTT远大于数据帧发送时延$T_D$的时，信道利用率非常低，为了克服停止等待协议信道利用率低的缺点，就产生了另外两种协议，即<strong>后退N帧协议</strong>和<strong>选择重传协议</strong></p><hr><p>滑动窗口协议</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/NMWkqV7TB42idZm.png" alt="image-20210520174502038"></p><p>滑动窗口协议的发送窗口数$Ws$</p><p>数据帧的发送时延$T_S$  (图中的a)</p><p>信号的传播时延$T_p$   (图中的b和c)</p><p>发送时延$T_S$=帧长度/带宽，滑动窗口协议的信道利用率与发送窗口的大小有关，当$Ws × Ts ≥ ( Ts + 2Tp )$时，信道利用率为100%，否则信道利用率为$Ws × Ts / ( Ts + 2Tp )$</p><p>有些时候还要考虑到确认帧的情况</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/1gAUfOvWdxauotm.png" alt="image-20210522171003499" style="zoom:80%;" /></p><p>一般来说确认帧的发送时延可以忽略不计，但是在双向传输中，有可能采用<strong>捎带确认</strong>的方式，此时确认帧会和发送帧一起发出，此时的信道利用率为$Ws × Ts / ( 2Ts + 2Tp )$</p><div class="note primary flat"><p>捎带确认：在计算机通信中，当一个数据帧到达的时候，接收方并不是立即发送一个单独的确认帧，而是抑制一下自己并且开始等待，直到网络层传递给它下一个分组，然后，确认信息被附在往外发送的数据帧上 (在TCP协议中也会用到)</p></div><p>如果要追求信道利用率，则是要在有限的时间内，发送足够多的帧，即<strong>发送的帧的字节数较小</strong>比较合适</p><p>滑动窗口协议的发送窗口Ws、接收窗口Wr以及帧序号的比特数n之间需满足约束关系：$Ws + Wr ≤ 2n$</p><hr><h1 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h1><p>广域网(WAN)，通常跨接很大的物理范围，能连接多个城市和国家，或横跨几个州并提供远距离通信</p><p>广域网的通信子网主要适用<strong>分组交换</strong>技术。广域网的通信子网可以利用公用分组交换网，卫星通信网和无线分组交换网，将不同地区的局域网或计算机系统互连起来，达到<strong>资源共享</strong>的目的。因特网(Internet)是世界范围内最大<strong>广域网</strong>。</p><h2 id="点对点协议PPP"><a href="#点对点协议PPP" class="headerlink" title="点对点协议PPP"></a>点对点协议PPP</h2><p>PPP(Point-to-Point Protocol)是目前使用最广泛的点对点链路层协议。用于使用拨号电话接入因特网时一般都使用PPP协议，是<strong>面向字节</strong>的数据链路层协议。<strong>PPP协议只支持全双工链路。</strong></p><p>PPP协议为在点对点链路传输各种协议数据报提供了一个标准方法，主要由以下三部分构成</p><ul><li>对各种协议数据报的封装方法</li><li>链路控制协议LCP  用于建立，配置以及测试数据链路的连接</li><li>一套网络控制协议NCPs  其中每一个协议支持不同的网络层协议</li></ul><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/qZAsWRLvT56QMEy.png" alt="image-20210506093520648" style="zoom:67%;" /></p><hr><p><strong>封装成帧</strong></p><p>帧的格式</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/qiHJt6DyoQaeNnx.png" alt="image-20210506093558036"></p><p>标志F(Flag)字段：PPP帧的定界符，取值为0x7E</p><p>地址(Address)字段：没什么用</p><p>控制(Control)字段：没什么用</p><p>协议(Protocol)字段：指明帧的数据部分送交那个协议处理</p><p>帧检验序列(Frame Check Sequence)字段：CRC计算出的校验位</p><hr><p><strong>透明传输</strong></p><p>如果是字节的异步链路，则采用字节填充法</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/pmb2s8AekfO3PRq.png" alt="image-20210506093916444"></p><ul><li>将出现的每一个7E字节转变成(7D,5E)</li><li>出现的每一个7D字节转变成(7D,5D)</li><li>出现的每一个ASCII控制字符，则在前插入一个7D，同时将该字符编码加上0x20</li></ul><p>接收方进行反变换就可以恢复原来帧的数据部分</p><p>如果是比特的同步链路则采用比特填充法</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/m1WPFqokbEz3enR.png" alt="image-20210506094216846"></p><p>发送方对帧的数据部分进行扫描，只要发现5个连续的比特1，就立即填充一个比特0</p><hr><p><strong>差错检测</strong></p><p>接收方每收到一个PPP帧，就进行CRC校验，若CRC检验正确，就收下这个帧，反之，就丢弃这个帧，</p><hr><p>总结：使用PPP协议实现了封装成帧和差错检测的功能，但<strong>不提供可靠传输</strong></p><div class="note primary flat"><p>广域网中采用PPP协议是一种建立连接，不可靠的服务</p></div><hr><h1 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>局域网自然就是局部地区形成的一个区域网络，其特点就是分布地区范围有限，可大可小，大到一栋建筑楼 与相邻建筑之间的连接，小到可以是办公室之间的联系。局域网自身相对其他网络传输速度更快，性能更稳定，框架简易，并且是封闭性，这也是很多机构选择的原因所在。局域网自身的组成大体由计算机设备、网络连接设备、网络传输介质3大部分构成，其中，计算机设备又包括服务器与工作站，网络连接设备则包含了<strong>网卡、集线器、交换机</strong>，网络传输介质简单来说就是网线，由同轴电缆、双绞线及光缆3大原件构成。 </p><p>局域网在数据链路层中又分为逻辑链路控制子层(LLC)和介质访问控制子层(MAC)</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/Q2PqTJezd7WAaZF.png" alt="image-20220619004501679"></p><p>LLC层负责识别网络层协议，然后对它们进行封装，为网络层服务，建立连接等</p><p>MAC子层负责数据帧的封装，帧的接受发送，寻址，差错控制等</p><hr><h2 id="以太网（通用局域网）"><a href="#以太网（通用局域网）" class="headerlink" title="以太网（通用局域网）"></a>以太网（通用局域网）</h2><p>以太网（Ethernet）是一种计算机<strong>局域网技术</strong>。IEEE组织的<strong>IEEE 802.3</strong>标准制定了以太网的技术标准，它规定了包括物理层的连线、电子信号和介质访问控制的内容。以太网是目前应用最普遍的局域网技术，取代了其他局域网标准如令牌环网、FDDI和ARCNET</p><p>以太网实现了网络上无线电系统多个节点发送信息的想法，每个节点必须获取电缆或者信道的才能传送信息，每一个节点有全球唯一的48位地址也就是制造商分配给网卡的<strong>MAC地址</strong>，以保证以太网上所有节点能互相鉴别。由于以太网十分普遍，许多制造商把以太网卡直接集成进计算机主板</p><hr><h3 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h3><p>因为信号的衰减和延时，根据不同的介质以太网段有距离限制。例如，10BASE5同轴电缆最长距离500米 （1,640英尺）。最大距离可以通过以太网<strong>中继器</strong>实现，中继器可以把电缆中的信号放大再传送到下一段。中继器最多连接5个网段，但是只能有4个设备（即一个网段最多可以接4个中继器）。这可以减轻因为电缆断裂造成的问题：当一段同轴电缆断开，所有这个段上的设备就无法通讯，中继器可以保证其他网段正常工作。</p><p>中继器(repeater)对信号进行再生和还原，对衰减的信号进行放大，保持与原数据相同，以增加信号的传输距离，适用于完全相同的两类网络的互连，且网速要相同</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/6043426d3f49f.png" alt="img" style="zoom:67%;" /></p><hr><h3 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/SmikXrgJtsa26QF.png" alt="image-20210506171827531" style="zoom:80%;" /></p><ul><li><p>使用集线器的以太网在逻辑上仍是一个总线网，各站共享总线资源，使用的还是CSMA/CD协议</p></li><li><p><strong>集线器只工作在物理层</strong>，它的每个接口仅简单地转发比特，不进行碰撞检测</p></li><li><p>集线器一般有少量的容错能力和网络管理能力</p></li></ul><p>随着应用的拓展，人们逐渐发现星型的网络拓扑结构最为有效，于是设备厂商们开始研制有多个端口的中继器。多端口中继器就是众所周知的集线器（Hub）。集线器可以连接到其他的集线器或者同轴网络。</p><div class="note primary flat"><p>集线器实际上就是多端口的中继器</p></div><p>非屏蔽双绞线最先应用在星型局域网中，之后也在10BASE-T中应用，最后取代了同轴电缆成为以太网的标准。集线器的应用使某条电缆或某个设备的故障不会影响到整个网络，提高了以太网的可靠性。双绞线以太网把每一个网段点对点地连起来，这样终端就可以做成一个标准的硬件，解决了以太网的终端问题。</p><hr><h3 id="快速以太网"><a href="#快速以太网" class="headerlink" title="快速以太网"></a>快速以太网</h3><p>尽管中继器在某些方面分隔了以太网网段，使得电缆断线的故障不会影响到整个网络，但它向所有的以太网设备转发所有的数据。这严重限制了同一个以太网网络上可以相互通信的机器数量。为了减轻这个问题，桥接方法被采用，在工作在物理层的中继器之基础上，桥接工作在<strong>数据链路层</strong>。通过<strong>网桥</strong>时，只有格式完整的数据包才能从一个网段进入另一个网段；<strong>冲突和数据包错误则都被隔离</strong>。通过记录分析网络上设备的MAC地址，网桥可以判断它们都在什么位置，这样它就不会向非目标设备所在的网段传递数据包。像<strong>生成树协议</strong>这样的控制机制可以协调多个<strong>交换机</strong>共同工作。</p><div class="note primary flat"><p>交换机就是多接口网桥</p></div><p>大多数现代以太网用<strong>以太网交换机代替Hub</strong>。尽管布线方式和Hub以太网相同，但交换式以太网比共享介质以太网有很多明显的优势，例如更大的带宽和更好的异常结果隔离设备。</p><p>以太网的标准拓扑结构为总线型拓扑，但目前的<strong>快速以太网</strong>（<strong>100BASE-T</strong>、1000BASE-T）为了减少冲突，将能提高的网络速度和使用效率最大化，使用<strong>交换机</strong>（Switch hub）来进行网络连接和组织。如此一来，以太网的拓扑结构就成了星型；但在逻辑上，以太网仍然使用<strong>总线型拓扑和CSMA/CD</strong>（Carrier Sense Multiple Access/Collision Detection，即载波多重访问/碰撞侦测）的总线技术。</p><p>然而交换机对网络中的广播数据流量不做任何限制，这也影响了网络的性能。通过在三层交换机（有路由转发功能）或路由器上划分<strong>VLAN</strong>可解决这一问题。</p><p>以太网标准：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/5F2wHmoyNtlMjTL.png" alt="image-20220618011502629"></p><p>速度达到100Mbps以上就是快速以太网，以不同的传输介质对标准名称以区分，100BASE-T标准中的T代表双绞线(Twist pair)，100BASE-FX中的F代表光纤(Optical Fibre)</p><hr><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>以太网交换机</p><p>在交换机中，某台主机想要给另一台主机发送信息，其他的主机不会收到信息</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/iOhnPEYskyGMURA.png" alt="image-20210506172451709"></p><ul><li><p>以太网一般有多种接口，每个接口都可以与直接一台主机或另一个以太网交换机相连，一般工作在全双工方式</p></li><li><p>而使用集线器的以太网在逻辑上是共享总线的，要使用CSMA/CD协议，工作在半双工方式</p></li><li><p>以太网交换机具有并行性，能同时连通多对接口，使多对主机能同时通信，无碰撞 </p></li><li><p>以太网交换机工作在<strong>数据链路层</strong>(也包括物理层)，它收到帧后，在帧交换表中查找帧的目的MAC地址所对应的接口号，然后通过该接口转发帧</p></li><li><p>以太网交换机是一种即插即用设备，其内部的帧交换表是通过自学习算法自动逐渐建立起来的</p></li><li><p>帧有两种转发方式：<strong>存储转发</strong>，直通交换</p><div class="note primary flat"><p>存储转发是读取完以太网帧所有数据后再转发，至少需要传输512bit数据，直通转发就是在读取以太网帧的目的MAC后直接转发数据，目的MAC地址为6B=48bit，所以只需要传输48bit</p></div></li></ul><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/chaJdX7ToYDmNPl.png" alt="image-20210506173122785" style="zoom:67%;" /></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/d43DzCnmvlXNpih.png" alt="image-20210506173203078" style="zoom: 80%;" /></p><hr><h3 id="交换机自学习和转发帧"><a href="#交换机自学习和转发帧" class="headerlink" title="交换机自学习和转发帧"></a>交换机自学习和转发帧</h3><p>以太网交换机自学习和转发帧的流程：</p><p>1.收到帧后登记。登记的内容为帧的源MAC地址及进入交换机的接口号</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/vDa7MSbGOQdNpIE.png" alt="image-20210506182814674"></p><p>2.根据帧的目的MAC地址和交换机的帧交换表对帧进行转发，有以下3种情况</p><ul><li>明确转发：交换机知道从哪个接口转发该帧</li></ul><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/myzKd8sUTYrq1Ca.png" alt="image-20210506182948250"></p><ul><li>盲目转发：交换机不知道应当从哪个端口转发帧，只能将其通过除进入交换机的接口外的其他所有接口转发（也称为泛洪）</li></ul><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/C2aWrMvx4TtupNJ.png" alt="image-20210506183112004"></p><ul><li>明确丢弃：交换机知道不应该转发该帧，将其丢弃</li></ul><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/VCXqkh26mrsRKPc.png" alt="image-20210506183245013"></p><p>帧交换机中每条记录都有自己的有效时间，到期删除，原因如下</p><ul><li>交换机的接口改接了另一台主机</li><li>主机更换了网卡</li></ul><hr><h3 id="以太网交换机的生成树协议STP"><a href="#以太网交换机的生成树协议STP" class="headerlink" title="以太网交换机的生成树协议STP"></a>以太网交换机的生成树协议STP</h3><p>为了提高以太网的可靠性，可以添加冗余链路来提高以太网的容错率</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/KNwJosM5pB2fPch.png" alt="image-20210506183936821"></p><p>但是冗余链路会形成网络环路，导致很多问题</p><ul><li>广播风暴 大量消耗网络资源，使网络无法正常转发其他数据帧</li><li>主机会收到重复的广播帧</li><li>交换机的帧交换表震荡</li></ul><p>为了可以在增加网络可靠性的同时，有避免网络环路带来的问题，我们可以使用生成树协议STP(Spanning Tree Protocol)</p><ul><li>STP可以自动计算并构建一个在逻辑上没有环路的网络，其逻辑拓扑结构必须是树型</li><li>最终生成的树型逻辑拓扑要确保连通整个网络</li><li>当首先连接交换机或网络物理拓扑发生变化时，交换机都将进行生成树的重新计算</li></ul><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/UrleYB7P8jEdhDm.png" alt="image-20210506184809995"></p><hr><h3 id="虚拟局域网VLAN"><a href="#虚拟局域网VLAN" class="headerlink" title="虚拟局域网VLAN"></a>虚拟局域网VLAN</h3><p>使用一个或多个以太网交换机互连起来的交换式以太网，其所有站点都属于同一个广播域</p><p>巨大的广播域会带来很多弊端，因为在网络会频繁的出现广播信息</p><p>所以需要分割广播域</p><ul><li>使用路由器可以隔离广播域</li></ul><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/5MDCYIJQF67cpyk.png" alt="image-20210506185804509"></p><p>但是路由器的成本较高</p><ul><li>使用VLAN来分隔广播域</li></ul><p>虚拟局域网VLAN(Virtual Local Area Network)是一种将局域网内的设备划分成与物理位置无关的逻辑组的技术，这些逻辑组具有某些共同的需求</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/csFQB4bOE9Mmrae.png" alt="image-20210506190027134"></p><hr><p>实现机制</p><p>IEEE 802.1帧对以太网的MAC帧格式进行了扩展，插入了4字节的VLAN标记</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/452xEhRAklHbCs6.png" alt="image-20210506190137136"></p><p>VLAN标记的最后12比特称为VLAN标识符VID，唯一地标识了以太网帧属于哪一个VLAN</p><p>VID的有效取值为1~4094，802.1Q帧是由交换机来处理的，而不是用户主机来处理的，当交换机收到普通的以太网帧时，会插入4字节的VLAN标记，称为打标签</p><p>当交换机转发802.1Q帧，<strong>可能</strong>会删除4字节的VLAN标记转变为普通的以太网帧</p><hr><p>交换机的端口类型有以下3种：</p><ul><li>Access</li><li>Trunk</li><li>Hybrid</li></ul><p>交换机各端口的默认VLAN ID</p><p>在华为交换机上称为Port VLAN ID，即端口VLAN ID，简记为PVID</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/cPloE2pKvCSGxbN.png" alt="image-20210506190827177"></p><p>Access端口</p><ul><li><p>Access端口一般用于连接用户计算机</p></li><li><p>Access端口只能属于一个VLAN</p></li><li><p>Access端口的PVID值与端口所属VLAN的ID相同</p></li><li><p>Access端口接收处理方法：一般只接收未打标签的普通以太网帧，根据接收帧的端口PVID给帧打标签，字段中的VID取值与端口的PVID取值相等</p></li><li><p>Access端口发送处理方法：若帧中的VID与端口的PVID相等，则去标签并且转发该帧，否则不转发</p></li></ul><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/DAWpPH6BlhSGtga.png" alt="image-20210506191156814"></p><p>Trunk端口</p><ul><li><p>Trunk端口一般用于交换机之间或交换机与路由器之间的互连</p></li><li><p>Trunk端口可以属于多个VLAN</p></li><li><p>用户可以设置Trunk端口的PVID值，默认情况下，Trunk端口的PVID值为1</p></li></ul><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/iWNoAMZ69ItVrbk.png" alt="image-20210506191803866"></p><ul><li>Trunk端口发送处理方法：对VID等于PVID的帧，去标签转发</li><li>Trunk端口接收处理方法：接收未打标签的帧，根据接收帧的端口的PVID给帧打标签，字段中的VID取值与端口中的PVID取值相等</li></ul><hr><h2 id="无线局域网"><a href="#无线局域网" class="headerlink" title="无线局域网"></a>无线局域网</h2><p>WLAN是Wireless Local Area Network的简称，指应用[无线通信技术将计算机设备互联起来，构成可以互相通信和实现资源共享的网络体系。无线局域网本质的特点是不再使用通信电缆将计算机与网络连接起来，而是通过无线的方式连接，从而使网络的构建和终端的移动更加灵活。</p><p> <strong>IEEE802.11是无线局域网的通用标准</strong>，它是由IEEE所定义的无线网络通信标准，IEEE 802.11下属有很多小的标准（如IEEE802.11b、IEEE802.11g），均使用<strong>CSMA/CA</strong>多路访问控制协议。</p><p>801.11体系结构的基本构件模型是<strong>基本服务集（Basic Service Set，BSS）</strong>。如下图所示</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/FUqKQrIARB2tk5a.png" alt="image-20220618013038494"></p><p> 一个BSS包含一个或多个无线站点和一个<strong>接入点（Access Point，AP）</strong>的中央<strong>基站</strong>。上图表示两个BSS中的AP，它们连接到一个互联网设备上（如交换机或者路由器），互连设备又连接到因特网中。</p><div class="note primary flat"><p>无线局域网中的AP类似于以太网中的集线器</p></div><hr><h2 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h2><h3 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h3><p>适配器是用于<strong>计算机与外界局域网的连接</strong>。适配器本来是在主机箱内插入的一块网络接口板，这种接口板又称为<strong>网络接口卡NIC</strong>（Network Interface Card）或简称为<strong>网卡</strong>。由于现在计算机主板上都已经嵌入了这种适配器，不再单独使用网卡了。</p><p>适配器在接收和发送各种帧时，不使用计算机CPU。这时计算机中的CPU可以处理其他任务。当适配器收到有差错的帧时，就把这个帧直接丢弃而不必通知计算机，当适配器接收到正确的帧时，它就使用中断来通知该计算机，并交付协议栈中网络层。</p><hr><p>当多个主机连接在同一个广播信道上，要实现两个主机之间的通信，则每个主机必须有一个唯一的标识，即一个数据链路层地址</p><p>当每个主机发送的帧中必须携带标识发送主机和接收主机的地址，这类主机是用于媒体接入控制MAC的，因此这类地址被称为<strong>MAC地址</strong></p><p>MAC地址一般被固化在网卡的EEPROM中，因此也被称为<strong>硬件地址</strong>，有时也被称为<strong>物理地址</strong>，但并不意味在MAC地址属于物理层</p><p>一般情况下，用户主机会用有线网卡和无线网卡两个网络适配器，每个适配器有一个全球唯一的MAC地址，而交换机和路由器往往有更多的MAC地址，严格来说，MAC地址是对网络上各<strong>接口</strong>的唯一标识，而不是各设备的唯一标识</p><div class="note primary flat"><p>使用点对点的信道的数据链路层不需要MAC地址</p></div><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/feb57NmRES9aiod.png" alt="image-20210506151527641" style="zoom:67%;" /></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/ArQCqty54JngopK.png" alt="image-20210506151613766" style="zoom: 80%;" /></p><p>字节发送顺序是从第一字节到第六字节</p><p>字节内的比特发送顺序是 $b_0$到$b_7$</p><hr><h3 id="以太网的MAC帧格式"><a href="#以太网的MAC帧格式" class="headerlink" title="以太网的MAC帧格式"></a>以太网的MAC帧格式</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/VNvFh31WwLtEo9u.png" alt="image-20210429185723929"></p><hr><h3 id="WLAN的MAC帧格式"><a href="#WLAN的MAC帧格式" class="headerlink" title="WLAN的MAC帧格式"></a>WLAN的MAC帧格式</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/lC5SnzYowGgu6bM.png" alt="image-20210521202418866"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/lj2Bgn4R8UDAS5i.png" alt="image-20210521202246159"></p><p>有三个地址字段，AP是无线访问接入点</p><hr><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>IP地址属于网络层</p><p>IP地址是因特网上的主机和路由器所使用的地址，用于标识两部分信息：</p><ul><li>网络编号：标识因特网上数以百计的网络</li><li>主机编号：标识同一网络上不同主机</li></ul><p>数据包转发过程中IP地址与MAC地址的变化情况</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/ikT94CHX7W1ALnw.png" alt="image-20210506162942242"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/wK5v3F2sTOuzoGB.png" alt="image-20210506163046761"></p><p><strong>数据包转发过程中源IP地址和目的IP地址保持不变</strong></p><p><strong>数据包转发过程中源MAC地址和目的MAC地址逐个链路改变</strong></p><p>主机和路由器在转发过程中知道对方的IP地址，却不知道对方的MAC地址</p><hr><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><p>地址解析协议ARP(Address Resolution Protocol)，是根据主机IP地址获取其MAC地址的一种协议</p><p>每个主机都有自己的ARP高速缓存表，源主机在自己的ARP高速缓存表中查找目的主机的IP地址所对应的MAC地址，若找到了，则可以封装MAC帧进行发送，若找不到则发送ARP请求(封装在广播MAC帧中)</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/uG5wzVXpNZ3tY6g.png" alt="image-20210506164039820"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/udMKqHnTvB6QIsw.png" alt="image-20210506164054208"></p><p>目的主机收到了ARP请求后，将源主机的IP地址与MAC地址记录到自己的ARP高速缓存表中，然后给源主机发送ARP响应(封装在单播MAC帧中)，ARP响应中包含有目的主机的IP地址和MAC地址</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/ObJFtKQg9S3X4wy.png" alt="image-20210506164323603"></p><p>源主机收到了ARP响应后，将目的主机的IP地址与MAC地址记录到自己的ARP高速缓存表中，然后就可以封装之前想发送的MAC帧并发送给目的主机</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/dqzKoxPVAIv6DcB.png" alt="image-20210506164333188"></p><p>ARP的作用范围：逐段链路或逐个网络使用</p><p>ARP高速缓存表中的类型分为静态和动态</p><p>静态是手工设置的，不同操作系统下的生命周期不同，动态的是自动获取的，生命周期默许为两分钟</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/NKb2gZ9TDV7sFSm.png" alt="image-20210506164517772" style="zoom:67%;" /></p><p>除了ARP请求和响应外，ARP还有其他类型的报文</p><p>ARP没有安全验证机制，存在ARP欺骗问题</p><hr><h2 id="媒体接入控制"><a href="#媒体接入控制" class="headerlink" title="媒体接入控制"></a>媒体接入控制</h2><p>所有主机共享信道会导致在各主机同时发送数据时会发生信号的碰撞，使信息发送失败，共享信道要着重考虑的一个问题就是如何协调多个发送和接收站点对一个共享传输媒体的占用，即<strong>媒体接入控制MAC(Medium Access Control)</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/YXg3pa7PvCyRAM5.png" alt="image-20220618000521901"></p><hr><h3 id="静态划分信道"><a href="#静态划分信道" class="headerlink" title="静态划分信道"></a>静态划分信道</h3><p>信道复用</p><p>复用(Multiplexing)是通信技术中的一个重要概念，复用就是通过一个物理线路同时传输多路用户的信号</p><p>当网络中传输媒体的传输容量大于多条单一信道的总通信量时，可利用复用技术在一条物理线路上建立多条通信信道来充分利用传输媒体的带宽</p><p><strong>频分复用(FDM)</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/ONfq3RCaJkhyUmQ.png" alt="image-20210506101102625" style="zoom:80%;" /></p><p>将传输线路的资源划分成多个子频带，形成多个子信道</p><p>频分复用的所有用户同时占用不同的频带资源并行通信</p><p><strong>时分复用(TDM)</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/GTukjH6Qnoe9bNy.png" alt="image-20210506101436703" style="zoom:67%;" /></p><p>将时间划分为一个个小的时隙，每对用户只在被划分的时间中传递信息</p><p>时分复用的所有用户在不同的时间占用同样的频带宽度</p><hr><p><strong>波分复用(WDM)</strong></p><p>波分复用其实就是光的频分复用</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/bLmzERWgZ3T7PYu.png" alt="image-20210506101654141" style="zoom:80%;" /></p><p>变换光的波长，来利用波长的不同来传递不同的信息</p><hr><p><strong>码分复用(CDMA)</strong></p><p>实际上由于该技术主要用于多址接入，人们更常用的名词是码分多址CDMA(Code Divison Multiple Access)</p><p>复用和多址的概念：</p><ul><li>复用是将单一媒体的频带资源划分成很多子信道，这些子信道之间相互独立，互不干扰，从媒体的整体频带资源上来看，每个子信道只占用该媒体频带资源的一部分</li><li>多址处理的是动态分配信道给用户，这在用户仅仅暂时占用信道的应用是必须的</li><li>某种程度上，多址是复用的应用</li></ul><p>与FDM和TDM不同，CDM的每一个用户可以在同样的时间使用同样的频带进行通信，由于各用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰</p><p>在CDMA中，每一个比特时间再划分为m个短的间隔，称为<strong>码片(Chip)</strong></p><p>在使用CDMA的每一个站被指派一个唯一的m bit码片序列</p><ul><li>一个站如果要发送比特1，则发送它自己的m bit码片序列</li><li>一个站如果要发送比特0，则发送它自己的m bit码片序列的二进制反码</li></ul><p>码片序列的挑选原则如下：</p><ul><li>分配给每个站的码片序列必须各不相同，实际常采用伪随机码序列</li><li>分配给每个站的码片序列必须正交(规格化內积为0)</li></ul><div class="note primary flat"><p>内积：设二维空间内有两个向量$\vec{a}=(x_1,y_1)$和$\vec{b}=(x_2,y_2)$，定义它们的数量积（又叫内积、点积)为以下实数：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/k2zjUM4qhJbGwX3.png" alt="img"></p><p>更一般地，n维向量的内积定义如下：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/mTZoYN6DQq8weWB.png" alt="img"></p><p>规格化内积：将内积结果除以向量的维数，即是规格化，$a·b=1/n\sum_{i=1}^na_ib_i=0$</p></div><p>用收到的码片序列分别与各站的码片序列进行求内积运算（收到了A站的数据，就用数据和A站的码片做内积），<strong>若计算结果为1，则被判断的站发送了比特1</strong>，<strong>若计算结果为-1，则被判断的站发送了比特0</strong>，<strong>若计算结果为0，则被判断的站没有发送数据</strong></p><hr><h3 id="ALOHA协议"><a href="#ALOHA协议" class="headerlink" title="ALOHA协议"></a>ALOHA协议</h3><p>不监听信道，不按时间发送，随机重发，想发就发</p><p>如果发生冲突，接受方就会检测出错，不予确认，发送方在一定时间内收不到就判断发生冲突</p><p>超时后等一随机时间再重传</p><hr><h3 id="CSMA协议"><a href="#CSMA协议" class="headerlink" title="CSMA协议"></a>CSMA协议</h3><p>和CSMA/CD的差异在于，CSMA会在发送之前检测信道的空闲，确认空闲后之后再发送信息，但是不会在发送过程中检测空闲，属于是先听后发</p><hr><h3 id="CSMA-CD协议（以太网）"><a href="#CSMA-CD协议（以太网）" class="headerlink" title="CSMA/CD协议（以太网）"></a>CSMA/CD协议（以太网）</h3><p><strong>载波监听多址接入/碰撞检测 CSMA/CD(Carrier Sense Multiple Access/Collision Detection)</strong></p><div class="note danger flat"><p>以太网中采用CSMA/CD协议是一种无连接，不可靠的服务</p></div><p>适用于总线型网络</p><p><strong>多址接入MA</strong>：多个站连接在一条总线上，竞争使用总线</p><p><strong>载波监听CS</strong>：每一个站在发送帧之前先要检测一下总线上是否有其他站点在发送帧</p><ul><li>若检测到总线空闲96比特时间，则发送这个帧</li><li>若检测到总线忙，则继续检测并等待总线转为空闲96比特时间</li><li>96比特时间被成为帧间最小间隔，作用是使接收方可以检测出一个帧的结束</li></ul><p><strong>碰撞检测CD</strong>：每一个正在发送帧的站边发送边检测碰撞</p><ul><li>一旦发现总线上出现碰撞，则立即停止发送，退避一段随机时间后再次发送</li></ul><p>以太网还采取一种叫做强化碰撞的措施，这就是当发送帧的站点一旦检测到碰撞，除了立即停止发送帧外，还要再继续发送32或48比特的人为干扰信号，以便有足够多的碰撞信号使所有站点都能检测出碰撞</p><hr><p><strong>争用期(碰撞窗口)</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/8fiTbqPOtQJcFV3.png" alt="image-20210506110901740"></p><ul><li>主机最多经过<strong>$2\tau$</strong>的时长就可检测到本次发送是否遭受了碰撞</li><li>因此，以太网的端到端往返<strong>传播时延</strong>$2\tau$称为<strong>争用期或碰撞窗口</strong></li><li><strong>经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞</strong></li></ul><p>显然，在以太网中发送帧的主机越多，端到端往返传播时延越大，发生碰撞的概率就越大，因此，共享式以太网不能连接太多主机，使用的总线也不能太长</p><p>10Mb/s以太网把<strong>争用期定为512比特发送时间</strong>，因此其总线长度不能超过5120m，但考虑到其他因素，总线长度不能超过2500m</p><hr><p>最小帧长</p><p>以太网规定最小帧长为64字节，即512比特，如果发送的数据非常少，那么必须加入一些填充字节，使帧长不小于64字节</p><p>以太网的最小帧长确保了主机可在帧发送完成之前就检测到该帧的发送过程中是否遭遇了碰撞</p><p>如果在争用期内检测到碰撞，就立即中止发送，这时发送出的数据一定小于64字节，因此但凡长度小于64字节的帧都是由于碰撞而异常中止的无效帧</p><p><strong>最小帧长=争用期×数据传输速率</strong></p><hr><p>最大帧长</p><p>为了避免主机一直发送信息，则帧长应该有上限，以太网MAC帧的最大帧长为1518字节</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/xLO72BuywohQMIf.png" alt="image-20210506120334489"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/AoMGOI9EY8ytHSj.png" alt="image-20210506120358536"></p><hr><p>退避时间—截断二进制指数退避算法</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/vFNxjfzK2oOB8gk.png" alt="image-20210506120431417"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/qNiFwmjUM5yxJIr.png" alt="image-20210506120504474"></p><p>若连续多次发生碰撞，就表明可能有较多的主机参与竞争信道，但使用上述退避算法可使重传需要推迟的平均时间随重传次数而增大，因而减少发生碰撞的概率</p><p>当重传的次数达到16次仍不成功时，则表明同时打算发送帧的主机太多，以至于连续发生碰撞，则丢弃该帧</p><hr><p>信道利用率</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/5YQ9PFOZdGmw3XS.png" alt="image-20210506120858254"></p><p>如果各个主机发送帧都不会产生碰撞，那么在极限情况下，发送一帧占用总线的时间为$T_0+\tau$，而帧的本身的发送时间是$T_0$</p><p>所以<strong>极限信道利用率</strong>$S_{max}=\frac{T_0}{T_0+\tau}$</p><p>以太网的端距离应该短一些，帧应该长一些</p><hr><p>帧发送流程</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/qzU8upI49TbLjra.png" alt="image-20210506121849770" style="zoom:67%;" /></p><p>帧接收流程</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/CMbPFcqB3fdXY78.png" alt="image-20210506121927621" style="zoom:67%;" /></p><hr><h3 id="CSMA-CA协议（无线局域网）"><a href="#CSMA-CA协议（无线局域网）" class="headerlink" title="CSMA/CA协议（无线局域网）"></a>CSMA/CA协议（无线局域网）</h3><p><strong>载波监听多址接入/碰撞避免(Carrier Sense Multiple Access/Collision Avoidance)</strong>：适用于无限局域网使用的协议</p><p>在无线局域网中依然可以使用载波监听多址接入，但是不能使用碰撞检测CD</p><ul><li>因为无线信道的传输条件特殊，信号强度的动态范围非常大，无线网卡上接收到的信号强度往往会远远小于发送信号的强度，如果要在无线网卡上实现碰撞检测CD，对硬件的要求非常高</li><li>即使能够在硬件上实现无线局域网的碰撞检测功能，但由于无线电波传播的特殊性，进行碰撞检测的意义也不大</li></ul><p>802.11无线局域网使用CSMA/CA协议，在CSMA的基础上增加了一个CA功能</p><p>由于不可能避免所有的碰撞，并且无线信道误码率较高，所以还使用了<strong>数据链路层确认机制(停止等待协议)</strong>来保证数据被正确接收</p><div class="note danger flat"><p>无线局域网中采用CSMA/CD协议是一种有连接，可靠的服务</p></div><p>802.11的MAC层标准定义了两种不同的媒体接入控制方式:</p><ul><li>分布式协调功能DCF(Distributed Coordination Function) 在DCF方式下，没有中心控制站点，每个站点使用CSMA/CA协议通过争用信道来获取发送权</li><li>点协调PCF(Point Coordination Function) PCF方式，使用集中控制的接入算法，在实际中较少使用</li></ul><hr><p><strong>帧间间隔IFS(InterFrame Space)</strong></p><p>所有的站点必须在持续检测到信道空闲一段指定时间后才能继续发送帧，这段时间被称为帧间间隔IFS</p><p>帧间间隔的长短取决于该站点要发送的帧的类型：高优先级帧等待时间短，低优先级帧等待时间长</p><ul><li><p>短帧间间隔SIFS(28us)，<strong>是最短的帧间间隔</strong>，用来分隔开属于一次对话的各帧，一个站点应当能够在这段时间内从发送方式切换到接收方式。<strong>使用SIFS的帧类型有ACK帧，CTS帧</strong>，由过长的MAC帧分片后的数据帧，以及所有回答AP探询的帧和在PCF方式中接入点AP发送出的任何帧</p></li><li><p>帧间间隔DIFS(128us)，在DCF方式中用来发送数据帧和管理帧</p></li></ul><hr><p>CSMA/CA协议的工作原理</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/5Rf6DGNXU92V1QK.png" alt="image-20210506144704769"></p><p>检测到信道空闲还要等DIFS再发送的原因是：让高优先级的帧先发送</p><p>发送第1帧后，等待SIFS后再发送的原因是：<strong>SIFS用来分隔帧和帧之间的间隔</strong></p><p>经过DIFS，还要退避一段时间是因为：避免很多站点同时发送数据</p><p>当站点检测到信道是空闲的，并且所发送的数据帧不是成功发送完上一个数据帧之后立即发送的数据帧，则不使用退避算法</p><p>以下情况必须使用退避算法：</p><ul><li>在发送数据帧之前检测到信道处于忙状态</li><li>在每一次重传一个数据帧时</li><li>在每一次成功发送后要连续发送下一个帧时</li></ul><hr><p>退避算法</p><p>在执行退避算法时，站点为退避计时器设置一个随机的退避时间</p><ul><li>当退避计时器的时间减小到0，就可以开始发送数据</li><li>当退避计时器的时间还未减小到0，信道又转到忙状态时，就冻结退避计时器，重新等待信道变为空闲，再经过DIFS，继续启动退避计时器</li></ul><p>进行第i次退避时，退避时间在时隙编号${0,1…2^{2+i}-1}$中随机选择一个，然后乘以基本退避时间，就可以得到随机的退避时间，当时隙编号达到255，也就是第6次退避时就不再增加</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/sI6Jt8frpBVbqSo.png" alt="image-20210506145615797"></p><hr><p>信道预约和虚拟载波监听</p><p>为了尽可能减少碰撞的概率和降低碰撞的影响，802.11标准允许发送数据的站点对信道进行预约</p><ol><li><p>源站在发送数据帧之前先发送一个短的控制帧，称为<strong>RTS(Request To Send)</strong>，包括源地址，目的地址以及这次通信所需的持续时间</p></li><li><p>若目的站正确收到了源站的RTS帧，且媒体空闲，就发送一个响应控制帧，称为<strong>允许发送CTS</strong>(Clear To Send )，它也包括这次通信所需的持续时间</p></li><li>源站收到了CTS帧后，在等待一段时间SIFS后，就可以发送数据帧</li><li>若目的站正确收到了源站发来的数据帧，在等待时间SIFS后，就向源站发送<strong>确认帧ACK</strong></li></ol><p>除源站和目的站以外的其他各站，在收到CTS帧后就推迟接入无限局域网中，这样就保证了源站和目的站之间的通信不会收到其他站的干扰</p><p>如果RTS帧发生碰撞，源站就收不到CTS帧，需执行退避算法重传RTS帧</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/n7iSqGXpCZQVOyW.png" alt="image-20210506150303279"></p><p>由于RTS帧和CTS帧很短，发生碰撞和碰撞产生的开销很小，所以用很小的代价对信道进行预约是值得的</p><p>除了RTS和CTS会携带通信需要持续的时间，数据帧也能携带通信所需要的时间，这称为802.11的虚拟载波监听机制</p><p>利用虚拟载波监听机制，站点只要监听到RTS帧，CTS帧或数据帧中的任何一个，就能知道信道被占用的持续时间，而不需要真正监听到信道上的信号，因此虚拟载波监听可以减少隐蔽站的问题</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/j3FhRGpOmNLvtSw.png" alt="image-20210506150644858"></p><hr><h3 id="令牌传递协议"><a href="#令牌传递协议" class="headerlink" title="令牌传递协议"></a>令牌传递协议</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220619153853955.png" alt="image-20220619153853955" style="zoom:80%;" /></p><p>令牌是一个特殊格式的MAC控制帧，不含任何信息</p><p>令牌在主机之间传递，只有接收到令牌的主机才能发送信息，将数据帧和令牌结合在一起发送，接受方接受到之后，再将令牌发送出去，令牌环网是不会检测到碰撞的</p><p>每个结点都可以在一定的时间获得发送数据的权利，而不是无限的持有令牌</p><p>应用于负载较重，通信量较大的网络中</p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.物理层</title>
      <link href="/post/38801.html"/>
      <url>/post/38801.html</url>
      
        <content type="html"><![CDATA[<h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/Qni2LAWXguIrHfS.png" alt="image-20210427211044376"></p><p>物理层的作用是解决在各种传输媒体上传输比特0和1的问题</p><p>物理层的接口主要有以下4个特性：</p><ol><li><p>机械特性：指明接口所用接线器的形状和尺寸，引脚数目和排列，固定和锁定装置</p></li><li><p>电气特性：指明在接口电缆的各条线上出现的电压的范围</p></li><li><p>功能特性：指明某条线上出现的某一电平表示何种意义</p></li><li><p>过程特性：指明对于不同功能的各种可能事件的出现顺序</p></li></ol><p>物理层的协议比较多，都包含了以上4种特性，需要掌握特性，而不是具体协议</p><hr><h2 id="传输媒体"><a href="#传输媒体" class="headerlink" title="传输媒体"></a>传输媒体</h2><p>传输媒体并不属于互联网的体系结构，处于物理层之下</p><p>导引型传输媒体</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/Y32oDNV4FSAsUWT.png" alt="image-20210427211851913" style="zoom:67%;" /></p><ul><li>同轴电缆(Coaxial Cable)：由导体铜质芯线，绝缘层，网状编织屏蔽层和塑料外层构成，根据特性阻抗不同分类，主要用于有线电视系统</li><li>双绞线(Twisted Pair)：由两根采用一定规则并排绞合的，相互绝缘的铜导线组成，绞合可以较少相邻导线之间的电磁干扰，因为价格便宜，所以非常常用，主要用于局域网和传统电话网</li><li>光纤(Optical Fiber)：利用光导纤维传递光脉冲来进行通信，光纤通信的带宽远远大于目前其他通信系统的带宽</li></ul><p>非导引型传输媒体</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/e9oZ1RIKHjLOxf5.png" alt="image-20210427211908326" style="zoom:67%;" /></p><hr><h2 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h2><h3 id="串行传输与并行传输"><a href="#串行传输与并行传输" class="headerlink" title="串行传输与并行传输"></a>串行传输与并行传输</h3><p>串行传输是指数据是一个比特一个比特依次发送，在发送和接收端直接，只需要1条传输线路</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/8MlFadYIwzUsRD7.png" alt="image-20210427212050037"></p><p>并行传输是指数据是一次发送n个比特，在发送和接收端之间需要n条传输线路</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/6Fjy7Rvpw8Efoeq.png" alt="image-20210427212142899"></p><p>一般电脑之间的远距离传输是串行传输，而电脑内部之间，CPU和内存之间通过总线进行并行传输</p><hr><h3 id="同步传输与异步传输"><a href="#同步传输与异步传输" class="headerlink" title="同步传输与异步传输"></a>同步传输与异步传输</h3><p>同步传输是指数据块以稳定的比特流的形式进行传输，字节之间没有间隔</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/CUrw4J7Xzg2aZ5Q.png" alt="image-20210427212341718"></p><p>接收端在比特信号的中间时刻进行检测，来判断是比特0还是比特1，由于不同设备的时钟不同，累计误差会导致判别错位</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/YdyXljM7wkmPzZ8.png" alt="image-20210427212513348"></p><p>所以需要采用方法使收发双方<strong>同步</strong></p><ul><li><p>外同步：在收发双方之间添加一条单独的时钟信号线</p></li><li><p>内同步：发送端将时钟同步信号编码到发送数据中一起传输(例如<strong>曼彻斯特编码</strong>)</p></li></ul><hr><p>异步传输：让字节作为独立的传输单位，字节之间的时间间隔不是固定的</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/AsqM68vzcLKPeUV.png" alt="image-20210427212802907"></p><p>接收端仅在每个字节的起始处对字节内的比特实现同步，为此通常在每个字节前后加上<strong>起始位和结束位</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/JA2xmi5MrTBFP1s.png" alt="image-20210427212900846"></p><p>异步是指字节之间异步(间隔不是固定的)</p><hr><h3 id="单工，半双工，全双工通信"><a href="#单工，半双工，全双工通信" class="headerlink" title="单工，半双工，全双工通信"></a>单工，半双工，全双工通信</h3><p>单工通信：又称为单向通信</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/D4d6cPrvSICfUEb.png" alt="image-20210427213158360"></p><p>半双工通信：又称为双向交替通信，双方设备可以交换信息，但不能同时进行</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/I69ofsPFG1axByU.png" alt="image-20210427213134387"></p><p>全双工：又称为双向同时通信，双方设备可以同时通信</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/1hMaTFxNdverYC5.png" alt="image-20210427213247983"></p><hr><h2 id="编码和调制"><a href="#编码和调制" class="headerlink" title="编码和调制"></a>编码和调制</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>消息（message)：计算机要处理的文字，图片等</p><p>数据（data）：是运送消息的实体</p><p>信号（signal）：是数据的电磁表现</p><p>基带信号：是信源发出的原始电信号</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/whJLsHBgID4zbjk.png" alt="image-20210427224355044"></p><p>基带信号又分数字基带信号和模拟基带信号，都能够进行编码和调制</p><p>将基带信号变成数据信号的过程叫做编码</p><p>将基带信号变成模拟信号的过程叫做调制</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/Qfn3MOX9YrKkhNe.png" alt="image-20210427225310553" style="zoom:67%;" /></p><p><strong>码元</strong>：在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/G9VAxtjfTZrLzQe.png" alt="image-20210427225542783"></p><hr><h3 id="常用编码"><a href="#常用编码" class="headerlink" title="常用编码"></a>常用编码</h3><p>1.不归零编码<strong>NRZ</strong>：用正电平和负电平来表示</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/B3ITsUpHZw8b2Xk.png" alt="image-20210427225904493"></p><p>当接受到连续信号的时候，系统需要判断码元的个数，这需要额外的一根传输线来传输时钟信号，使发送方和接受方同步</p><hr><p>2.反向不归零编码<strong>NRZI</strong>：用电平信号的翻转表示</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/pf5TxiVEjXQqecG.png" alt="image-20220618141944802"></p><p>如果电平和前一个码元一致，代表该码元表示的是1，如果电平和前一个码元相反，则表示的是0</p><p>USB数据线的传输采用此方法</p><hr><p>2.归零编码<strong>RZ</strong>：用正电平，负电平，零电平表示</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/SwZAUavTNfkuhjm.png" alt="image-20210427230347670"></p><p>每个码元传输结束后信号都要归零，所以接收放只要在信号归零后进行采样即可，不需要时钟信号，实际上，这相当于将时钟信号用归零方式编码在了数据之内，这称为<strong>自同步</strong>信号</p><p>但是，归零编码中的大部分数据带宽都用来归零了，编码效率低</p><hr><p>3.<strong>曼彻斯特编码</strong>：在每个码元的中间时刻信号都会发生跳变，根据跳变的方向来判断比特</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/1ijDMuf8WovU2Ge.png" alt="image-20210427231357417"></p><p>码元中间时刻的跳变既可以表示时钟，又可以表示数据，编码效率只有50%</p><p>是传统以太网的编码方式</p><hr><p>4.<strong>差分曼彻斯特编码</strong>：每个码元的中间时刻信号会跳变，但是只表示时钟信号，根据每个周期码元开始处电平是否和上个周期一致表示数据，跳变则说明该比特是0，不跳变则说明该比特是1。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/BojK4kYe9b6VqAh.png" alt="image-20210427231909998"></p><p>比曼彻斯特编码变化少，更适合较高的传输速率</p><hr><p>5.4B/5B编码</p><p>在通信网络中，接收端需要从接收数据中恢复时钟信息来保证同步，这就需要线路中所传输的二进制码流<strong>有足够多的跳变</strong>，即不能有过多连续的高电平或低电平，否则<strong>无法提取时钟信息</strong></p><p>4B/5B编码其实就是用5bit的二进制码来代表4bit二进制码。此编码的效率是80%，比曼切斯特码高。4B/5B编码的目的在前面已经说过了，就是让码流产生足够多的跳变。4位二进制共有16种组合，5位二进制共有32种组合，如何从32种组合种选取16种来使用呢？这里需要满足两个规则：</p><p>1). 每个5比特码组中不含多于3个“0”；</p><p>2). 或者5比特码组中包含不少于2个“1”；</p><div class="note primary flat"><p>百兆以太网用的4B/5B编码与MLT-3编码组合方式，发送码流先进行4B/5B编码，再进行MLT-3编码，最后再上线路传输</p></div><hr><h3 id="基本调制方法"><a href="#基本调制方法" class="headerlink" title="基本调制方法"></a>基本调制方法</h3><p>可以调幅，调频，调相</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/Pp8SDcoOLe7gnhH.png" alt="image-20210428000528585"></p><p>使用基本调制方法，1个码元只能包含1个比特信息，如果要让一个码元包括更多的比特，可以使用<strong>混合调制</strong></p><p>因为频率和相位是相关的，即频率是相位随时间的变化率，所以不能一起混合调制</p><p>混合调制可以让相位和振幅一起调制，称为<strong>正交振幅调制QAM</strong> </p><hr><p>举例 QAM16</p><p>可以有16种相位，每种相位有1或2种振幅可选</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/KghFbVqRElCiwdT.png" alt="image-20210428001140955" style="zoom:67%;" /></p><p>QAM可以调制出16种码元，每种码元可以表示$log_216=4$种比特</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/OBPNrndpRlyuEI3.png" alt="image-20210428001350815" style="zoom:67%;" /></p><p>码元与4个比特的对应关系采用格雷码，任意两个相邻码元只有1个比特不同</p><hr><h2 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h2><p>信号在信道中传输的一般都会失真，当失真严重的时候就无法判断信号</p><p>造成信号的失真因素主要有：</p><ul><li>码元传输</li><li>信号传输距离</li><li>噪声干扰</li><li>传输媒体质量</li></ul><hr><p><strong>奈氏准则：在假定的理想条件下，为了避免码间串扰，码元传输速率是有上限的</strong></p><p>带宽：指信道能通过的最高频率和最低频率之差</p><p>理想<strong>低通信道</strong>的最高码元传输速率=<strong>2W Baud=2W码元 /秒</strong></p><p>理想<strong>带通信道</strong>的最高码元传输速率=<strong>W Baud=W码元/秒</strong>    （W：信号带宽   Baud：波特，即码元/秒）</p><p>低通信道和带通信道的区别是：低通信道只有上限，而带通信道有上下限</p><p><strong>波特率</strong>：码元的传输速率又称波特率，与比特率之间有一定关系，当<code>1</code>个码元携带<code>n</code>比特的信息量时，则波特率换成比特率时，数值要乘以<code>n</code></p><p>要提高信息传输速率，就必须设法让每一个码元携带更多个比特的信息，这需要多元调制</p><hr><p>信道的极限信息传输速率还要受限于实际的信号在信道中传输时的信噪比</p><p><strong>香农公式</strong>：<strong>带宽受限且有高斯白噪声干扰的信道的极限信息传输速率</strong></p><p><strong>$c=W×log_2(1+S/N)$</strong></p><p>C：信道的极限信息传输速率</p><p>W：信号带宽</p><p>S：信道内所传信号的平均功率</p><p>N：信道内的高斯噪声功率</p><p>S/N：信噪比，使用分贝(dB)作为度量单位 =$10×log_{10}(S/N)$</p><p>信道带宽或信道中信噪比越大，信号的极限传输速率越高</p><hr><h2 id="信息交换方式"><a href="#信息交换方式" class="headerlink" title="信息交换方式"></a>信息交换方式</h2><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p>电话交换机接通电话线的方式称为电路交换</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/qsZg7Ul9v6ezMK2.png" alt="image-20210426194030792"></p><p>原理：在数据传输期间，源结点和目的结点之间有一条由中间结点构成的专用物理连接线路，在数据传输结束之前，这条线路一直保持</p><p>当使用电路交换来传送计算机数据的时候，线路的传输效率很低</p><p>特点：独占资源，用户始终会占据固定的传输带宽，适合远程处理信息传输或实时性要求高的大量数据传输情况</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/CmKzcyW9j5A21QJ.png" alt="image-20210426194551234"></p><hr><h3 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h3><p>报文是网络中交换与传输的数据单元，即站点一次性要发送的数据块，包含了将要发送的完整的数据信息</p><p>无需在两个站点之间建立一条专用通路，其数据传输的单位是报文，过程采用存储转发方式</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/cHpI9xwVaz8ouMK.png" alt="image-20210426194608172.png"></p><hr><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>大多数计算机不能连续的发送数据，所以实际上网络系统把数据分割成小块，然后逐块发送，这种小块叫分组</p><p>分组交换和报文交换的工作方式基本相同，都是存储转发的方式，主要差别是分组交换要限制说传输的数据单位的长度</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/7tPchzVH3Ose5RB.png" alt="image-20210426194357711" style="zoom:67%;" /></p><p>由发送方 中转方 接收方组成</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/chOA1R9Pvf7JGmI.png" alt="image-20210426194430256"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/qijTFte94YaphCR.png" alt="image-20210426194625967"></p><ol><li><p>数据报方式<br>源主机要将报文分为多个分组，发送到结点上，结点收到分组后，需要对分组进行差错检测和路由选择</p><p>数据报方式为网络层提供无连接方式，可能会发生分组乱序，丢失，重复的问题，同时会带来转发时延，因为有冗余线路，对故障的适应性很好</p></li><li><p>虚电路方式</p><p>虚电路方式将数据报方式和电路交换方式结合，一条源主机到目的主机的路线在逻辑上类似于电路的路径，路径上所有的结点都要维持这条虚电路的建立，要经过建立连接，数据传输，释放连接的过程</p><p>虚电路方式为网络层提供了连接服务，源节点与目的节点之间建立了一条逻辑连接，而非实际连接，在路过结点时，只进行差错检测，不进行路由选择，对故障的适应性很差</p></li></ol><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/wETtBUGKReVPSsk.png" alt="image-20220615203804437" style="zoom:67%;" /></p><hr><p>三种数据交换方式</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/SgDTPOBYh8XEtZw.png" alt="image-20220615202917918" style="zoom:67%;" /></p><p>假设传输完整报文(数据)的总时间之和为$T$，传输一个分组所用时间为$T_s$，假设中间有$n$个路由器（存储转发方式）</p><p>报文交换所需的时间：$T_N=n×T$</p><p>分组交换所需的时间：$T_F=T+n×T_s$</p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.计算机网络—概述</title>
      <link href="/post/21933.html"/>
      <url>/post/21933.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>网络：由若干结点(Node)和连接这些结点的链路(Link)组成</p><p>互联网：多个网络可以通过<strong>路由器</strong>互连起来，这样就构成了一个覆盖范围更大的网络，即互联网，所以互联网是网络的网络</p><p>因特网：是世界上最大的互联网络</p><p>internet：是一个通用名词，泛指由多个计算机连接的网络，这些网络之间的协议可以是任意的</p><p>Internet：是一个专有名词，指当前全球最大，开放的，由众多网络相互连接成的特定计算机网络，采用TCP/IP协议族作为基本规则</p><hr><ul><li>定义</li></ul><p>计算机网络并没有一个准确的定义</p><p>简单定义：一个互相连接的，自治的计算机的集合</p><p>较好定义：计算机网络主要是由一些通用的，可编程的硬件互联而成的，而这些硬件并非专门用来实现某一特定目的的。这些可编程硬件能够用来传送多种不同类型的数据,并能支持广泛和日益增长的应用</p><hr><p>ISP(Internet Service Provider)：<strong>因特网服务提供者</strong></p><p>因特网协会ISOC是一个国际性组织，负责对因特网进行全面管理，以及在世界范围内促进其发展和使用</p><hr><ul><li>组成</li></ul><p>因特网由边缘部分和核心部分组成</p><p>边缘部分：由所有连接在因特网上的主机组成。这部分是用户直接使用的，用来进行通信</p><p>核心部分：有大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/WO5IqkdV269eKYi.png" alt="image-20210426193841099"></p><hr><ul><li>功能</li></ul><p><strong>数据通信</strong>，资源共享，分布式处理，负载均衡等</p><hr><ul><li>分类</li></ul><p>按交换技术分类：电路交换网络 报文交换网络 分组交换网络</p><p>按使用者分类：公用网 专用网</p><p>按传输技术分类：广播式网络 (公共通信信道)  点对点网络(适用分组存储转发和路由选择机制)</p><p>按覆盖范围分类：广域网（WAN） 城域网（MAN）局域网（LAN）个域网（PAN）</p><p>按拓扑结构分类：</p><ul><li>总线型网络</li></ul><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/BmqzGrhKVHDlNMi.png" alt="image-20210426195243863"></p><ul><li>星型网络</li></ul><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/BH1IMoFSkLAi6Rf.png" alt="image-20210426195255906"></p><ul><li>环形网络</li></ul><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220620030930107.png" alt="image-20220620030930107"></p><ul><li>网状型网络</li></ul><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/ovNhu8Z7AqVXjGB.png" alt="image-20210426195357462"></p><hr><h2 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h2><p>包含有8个指标：速率 带宽 吞吐量 时延 时延带宽积 往返时间 利用率 丢包率</p><h3 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h3><p>比特是计算机中数据量的单位 </p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220620031001846.png" alt="image-20220620031001846"></p><p>速率：连接在计算机网络主机在数字信道传送比特的速率，也称比特率</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220620031013416.png" alt="image-20220620031013416"></p><p>特别要注意的是，<strong>速率中的k和数据量中的K含义是不同的</strong></p><p>数据量中的K表示$2^{10}$,而在数据率中表示$10^3$</p><hr><p>所以如果100MB的数据，网卡的发送速率为100Mbps，那么需要几秒传输成功呢？</p><p>首先需要把100MB换算成bit，那么就是</p><script type="math/tex; mode=display">2^{10}*2^{10}*100=2^{20}*100B=2^{20}*8*100bit</script><p>而100Mbps代表每秒传输</p><script type="math/tex; mode=display">100*10^{3}*10^{3}=1*10^{8}bit</script><p>所以需要      </p><script type="math/tex; mode=display">(8*2^{20}*100)/(1*10^8)s \approx8.388s</script><p>有时候可以估算，将1M估算为$10^{6}$</p><hr><h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><p>用来表示网络的通信线路所能传送数据的能力，因此网络带宽表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据率”</p><p>单位：b/s(kb/s,Mb/s)</p><hr><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p>表示在单位时间内通过某个网络的数据量</p><hr><h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><p>时延即是指：分组从源主机传送到目的主机的过程中，花费的时间</p><p>时延一般有3种</p><p>发送时延：主机将分组发送到传播线路的时间，发送时延=分组长度(b)/发送速率(kb/s)</p><p>传播时延：分组在传输线路中传送的时间，传播速率=传播距离/传播速度</p><p>处理时延：分组被中间的路由器处理的时间，一般不计算</p><p>而主要的时延有可能是发送时延，也有可能是传播时延，依据具体情况而定</p><hr><h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><p>时延带宽积=传播时延×带宽</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220620031107710.png" alt="image-20220620031107710"></p><p>又称为以比特为单位的链路长度</p><hr><h3 id="往返时间"><a href="#往返时间" class="headerlink" title="往返时间"></a>往返时间</h3><p>RTT(Round-Trip-Time)：指源主机发送分组开始，直到源主机又确认到来自目的的主机确认分组为止</p><hr><h3 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h3><p>信道利用率：表示某信道有百分之几的时间是被利用的</p><p>网络利用率：全网络的信道利用率的加权平均</p><p>当某信道的利用率增大的时，信道引起的时延也会增加，所以利用率不是越高越好，如果用$D_0$表示网络空闲时的时延，D表示网络当前的时延，那么在适当的假定条件下， $D=\frac{D_0}{1-U}$</p><p>当网络的利用达到50%的时候，时延就要加倍</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220620031051857.png" alt="image-20220620031051857"></p><hr><h3 id="丢包率"><a href="#丢包率" class="headerlink" title="丢包率"></a>丢包率</h3><p>丢包率是指分组丢失率，在一定的时间范围内，传输过程中丢失的分组数量与总分组数量的比率</p><hr><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><p>OSI体系结构</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220620031156873.png" alt="image-20220620031156873"></p><p>是法律上的国际标准，<br>其下三层被称为通信子网，是各种传输介质和通信设备以及相应的网络协议组成，比如集线器中继器在物理层，交换机和网桥在数据链路层，路由器在网络层，负责实现数据通信的基本功能<br>上三层被称为资源子网，是实现资源共享功能的设备和软件的集合，复杂实现资源共享</p><hr><p>TCP/IP体系结构</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/pP9j1RDwsmdvLSz.png" alt="image-20210426204319691" style="zoom:67%;" /></p><p>是事实上的国际标准</p><hr><p>原理体系结构</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/ArsxIQqzBkHbcVN.png" alt="image-20210426205055288" style="zoom: 67%;" /></p><p>用于教学</p><p>TCP/IP体系和OSI体系的区别在于，OSI体现在网络层采用了无连接+面向链接的方式，而TCP/IP协议在传输层采用的是无连接+面向连接方式</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220620031142305.png" alt="image-20220620031142305"></p><hr><h3 id="分层的必要性"><a href="#分层的必要性" class="headerlink" title="分层的必要性"></a>分层的必要性</h3><p>考虑一个问题，电脑之间如何实现通信？</p><p>1.肯定是先考虑采用什么物理介质来连接电脑，比如，光纤，双绞线网线</p><p>以及采用什么样的物理接口，用什么样的信号来表示bit</p><p>这些问题都属于<strong>物理层</strong>，该层传输的是<strong>比特流(bit)</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/UgYIGa62MbLurNX.png" alt="image-20210426205402002"></p><hr><p>2.一般来说，计算机网络是由多台电脑组成的，直接通过总线联络，假设已经解决了物理层的问题了，那么在总线中传输的时候，主机如何知道数据是否是发给自己的呢？</p><p>这就涉及到如何标识网络中各个主机的问题了，主机如何从一连串比特中区分地址和数据。</p><p>这些问题属于<strong>数据链路层</strong>，该层传输的是<strong>帧(frame)</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/nI6rclb7JuyZeSz.png" alt=""></p><hr><p>3.当解决了物理层和数据链路层之后，我们就可以在一个网络中通信了，然后当今互联网被称为网络的网络，由很多个网络组成，所以在互联网中通信的时候，我们还需要考虑如何标识网络的问题</p><p>如何标识各网络以及网络中的各主机（IP地址）？路由器如何转发分组？如何进行路由选择的问题</p><p>这些问题属于<strong>网络层</strong>，该层传输的是<strong>数据包(packet)</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/fWY4ljbX9Va3LZB.png" alt="image-20210426210448356"></p><hr><p>4.解决了以上3层，就可以实现分组在网络之间传输了</p><p>然后这还不够，如果电脑中运行有多个进程，电脑收到了分组后，如何判断分组是那个进程所需要的呢？</p><p>如何解决进程之间的网络通信问题？</p><p>以及假如路由器在丢包，那么该如何处理？</p><p>这些问题都属于<strong>运输层</strong>，该层传输的是<strong>数据段(segment)</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/i7XIlbYdZURt59G.png" alt="image-20210426210648645"></p><hr><p>5.解决了以上4层，就可以实现进程之间基于网络的通信了</p><p>在此基础上，只需要制定各种应用层协议 ，并根据应用进程之间的交互来编写特定的网络应用程序，就可以来完成特定的网络应用</p><p>比如有支持万维网应用的HTTP协议</p><p>支持电子邮件的SMTP协议</p><p>支持文件传输的FTP协议等</p><p>这些问题全部属于<strong>应用层</strong>，该层传输的<strong>数据(data)</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/lpdNzaSQ9u8wbeR.png" alt="image-20210426210942288"></p><hr><p>总的概况</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/x8dn21au5PKXUh6.png" alt="image-20210426211033451"></p><hr><h3 id="专用术语"><a href="#专用术语" class="headerlink" title="专用术语"></a>专用术语</h3><p>实体：指任何发送或接受信息的硬件或软件进程</p><p>对等实体：收发双方相同层次中的实体</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/HSk6elzEKx2Qvwr.png" alt="image-20210426211817282"></p><hr><p>协议：控制两个对等实体进行逻辑通信的规则的集合·</p><p>协议包括三要素 语法 语义 同步</p><ul><li><p>语法：定义所交换信息的格式</p></li><li><p>语义：定义收发双方所要完成的操作</p></li><li><p>同步：定义收发双方的时序关系</p></li></ul><hr><p>在协议的控制下，两个对等实体间的逻辑通信使得本层能够向上一层提供服务，很明显，协议是水平的，服务是垂直的</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/iFgaMKxwtI7QuT9.png" alt="image-20210426213108478"></p><p>服务访问点：在统一系统中相邻两层的实体交换信息的逻辑接口</p><p>服务原语：上层使用下层所提供的服务必须通过与下层交换一些指令，这些命令称为服务原语</p><p><strong>协议数据单元PDU：对等层次之间的数据包称为该层的协议数据单元</strong></p><p>服务数据单元SDU：同一系统内，层与层之间交换的数据包称为服务数据单元</p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.指令系统</title>
      <link href="/post/790.html"/>
      <url>/post/790.html</url>
      
        <content type="html"><![CDATA[<h1 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h1><hr><h2 id="指令的概念和格式"><a href="#指令的概念和格式" class="headerlink" title="指令的概念和格式"></a>指令的概念和格式</h2><p>指令：指计算机执行某种操作的命令，是计算机运行的最小功能单位</p><p>计算机的所有指令的集合构成该机的指令系统，也称为指令集</p><p>一条指令是机器语言的一个语句，是一组有意义的二进制代码，由操作码字段和地址码字段两部分组成</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/To8UarBPJSFIQVW.png" alt="image-20220316185716163"></p><hr><p>按<strong>地址码长度</strong>分类：</p><p>而根据指令的不同，一条指令可能包含多个地址码，根据地址码数目的不同，可以将指令分为零地址指令，一地址指令……</p><ul><li>零地址指令</li></ul><ol><li>不需要操作数，如空操作，停机，关中断等指令，</li><li>堆栈计算机，两个操作数隐含存放在栈顶和次栈顶，计算结果压回栈顶</li></ol><ul><li>一地址指令</li></ul><ol><li>只需要单操作数，如加1，取反等操作  </li><li>需要两个操作数，但其中一个操作数隐含在某个寄存器中（比如ACC）</li></ol><ul><li>二，三地址指令</li></ul><p>​      常用于需要两个操作数的算数运算，逻辑运算等相关指令</p><ul><li><p>四地址指令</p><p>常是运算之后接跳转指令</p></li></ul><hr><p>按<strong>指令长度</strong>分类</p><p>指令字长：一条指令的总长度（可改变）</p><p>机器字长：CPU进行一次正数运算所能处理的二进制数据的位数（与ALU有关）</p><p>存储字长：一个存储单元中的二进制代码位数（通常和MDR位数相同）</p><p>指令的长度会影响到取指令所需时间，可以把指令分为定长指令字结构和变长指令字结构</p><hr><p>按<strong>操作码长度</strong>分类</p><p>可以分为定长操作码和可变长操作码</p><hr><p>按<strong>操作类型</strong>分类</p><ol><li><p><strong>数据传送</strong></p><p>LOAD  ：把存储器的数据放到寄存器中</p><p>STORE ： 把寄存器的数据放到存储器中</p></li><li><p><strong>运算</strong></p><p>算数运算：加减乘除，浮点运算</p><p>逻辑运算：与或非，异或，取反</p></li><li><p><strong>移位</strong></p><p>算数移位，逻辑移位，循环移位</p></li><li><p><strong>转移</strong></p><p>无条件转移 JMP  </p><p>条件转移  JZ  </p><p>调用和返回  CALL 和 RETURN</p><p>陷阱(Trap)</p></li><li><p><strong>输入输出</strong></p><p>CPU寄存器和IO端口之间的数据传送</p></li></ol><hr><h2 id="拓展操作码指令格式"><a href="#拓展操作码指令格式" class="headerlink" title="拓展操作码指令格式"></a>拓展操作码指令格式</h2><p>有<strong>定长指令字结构+可变长操作码</strong>  →拓展操作码的指令格式</p><p>即不同地址数使用不同长度的操作码</p><p>假设指令字长为16位，每个地址码占4位，前4位为基本操作码字段OP</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/C8KrRzsbaAqJmUu.png" alt="image-20220316195954835"></p><p>三地址指令地址码占据$A_1,A_2,A_3$，而OP表示操作码，则可以表示16条，但至少保留1111留作拓展操作码用，三地址指令为15条</p><p>二地址指令地址码占据$A_2,A_3$，1111 1111留作拓展操作码使用，共15条</p><p>一地址指令地址码占据$A_3$，1111 1111 1111 留作拓展操作码使用</p><p>零地址指令共16条</p><p>扩展码有两点特点：</p><ol><li><p>不允许短码是长码的前缀（哈夫曼树） </p></li><li><p>各指令的操作码不允许重复</p></li></ol><p>至于根据不同地址指令拓展出适应的地址码，可以参考计算机网络的子网划分问题。</p><hr><p>定长操作码的优点是可以简化计算机硬件设计，提高指令译码和识别速度很有利，缺点是指令数量增加会占用更多固定位，留给操作数地址的位数受限</p><p>拓展操作码可以在指令字长有限的情况下保留比较丰富的指令种类，但是增加了指令译码和分析的难度，使控制器的设计复杂化</p><hr><h2 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h2><p>寻找下一条将要执行的指令地址称为指令寻址</p><p>有两种方式</p><ol><li><p>顺序寻址</p><p>通过程序计数器PC+1，自动形成下一条指令的地址</p></li><li><p>跳跃寻址</p><p>通过转移类指令实现，跳跃就是指下条指令的地址不由程序计数器PC自动给出，而由本条指令给出下条指令地址的计算方式。跳跃指令之后会修改PC的值</p></li></ol><hr><h2 id="数据寻址"><a href="#数据寻址" class="headerlink" title="数据寻址"></a>数据寻址</h2><p>确定本条指令的地址码指明的真实地址</p><p>由于数据寻址的方式很多，为了区分各种方式，通常在指令字中设一个字段，来指明属于何种寻址方式</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/M3vphj2JRuok9eb.png" alt="image-20220316211519385"></p><p>数据寻址一共有10种方式</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/smYbjnycu6dF35V.png" alt="image-20220316211559572"></p><hr><h3 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h3><p>指令中的形式地址就是操作数的真实地址EA</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/uQ6ox39D1zUpifY.png" alt="image-20220317193218843"></p><p>优点：简单，指令执行阶段仅访问一次主存，不需专门计算操作数的地址</p><p>缺点：A的位数决定了该指令操作数的寻址范围，操作数的地址不易修改</p><hr><h3 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h3><p>指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数有效地址所在的存储单元的地址，也就是操作数地址的地址 EA=(A)</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/eOfVWCnp6zxuv5T.png" alt="image-20220317193609475"></p><p>优点：可扩大寻址范围，便于编址程序（跳转）</p><p>缺点：指令在执行过程中要多次访存</p><hr><h3 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h3><p>在指令字中直接给出寄存器的编号，$EA=R_i$，操作数存储在寄存器中</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/8gpCnMQfbq4XmE7.png" alt="image-20220317194055642"></p><p>优点：指令在执行阶段不访问主存，只访问寄存器，指令字短而且执行速度快</p><p>缺点：寄存器价格昂贵，寄存器个数有限</p><hr><h3 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h3><p>寄存器中给出的不是一个操作数，而是操作数所在主存单元的地址</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/APpWbYkLJm34qXn.png" alt="image-20220317194346370"></p><p>优点：相比于间接访存，速度更快</p><hr><h3 id="隐含寻址"><a href="#隐含寻址" class="headerlink" title="隐含寻址"></a>隐含寻址</h3><p>不是明显地给出操作数地址，而是在指令中隐含操作数的地址</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/EbP7YBVT6XUkrnp.png" alt="image-20220317194558522"></p><p>优点：有利于缩短指令字长</p><p>缺点：需增加存储操作数或隐含地址的硬件</p><hr><h3 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h3><p>形式地址A就是操作数本身，又称为立即数，一般采用补码形式，#表示立即寻址方式</p><p>优点：执行阶段不访问主存</p><p>缺点：A的位数限制了立即数的范围</p><hr><h3 id="基址寻址"><a href="#基址寻址" class="headerlink" title="基址寻址"></a>基址寻址</h3><p>将CPU中基址寄存器（BR）的内容加上指令格式中的形式地址A，而形成操作数的有效地址，即EA=(BR)+A</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/JnMoEXuARZct1H9.png" alt="image-20220317201400881"></p><p>也可以用其他寄存器作为基址寄存器</p><p>基址寄存器是面向操作系统的，其内容由操作系统或管理程序确定。在程序执行过程中，基址寄存器的内容不变，形式地址可变</p><p>优点：可扩大寻址范围，有利于多道程序设计，编址浮动程序</p><hr><h3 id="变址寻址"><a href="#变址寻址" class="headerlink" title="变址寻址"></a>变址寻址</h3><p>有效地址EA等于指令字中的形式地址A与变址寄存器IX的内容相加之和</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/DPfIzaMQZpAq6bt.png" alt="image-20220317202334313"></p><p>和基址寻址的区别是，变址寄存器中的地址可以被改变，而形式地址不变，即IX作为偏移量，而形式地址作为基址</p><p>在编制循环程序的时候，可以让数组的起始地址作为形式地址，IX不断增加，来处理数组</p><hr><h3 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h3><p>把程序计数器PC的内容加上指令格式中的形式地址A而形成操作数的有效地址，即EA=（PC）+A，其中A是相对于PC所指地址的偏移量，补码表示</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/PZEV9GNyl613Wvr.png" alt="image-20220317203643274"></p><p>取出当前指令后，PC会指向下一条指令，相对寻址是相对于下一条指令的偏移量</p><p>优点：操作数的地址不是固定的，随PC值的变化而变化，并且与指令地址之间总是相差一个固定值，因此便于程序浮动，广泛用于转移指令</p><hr><h3 id="堆栈寻址"><a href="#堆栈寻址" class="headerlink" title="堆栈寻址"></a>堆栈寻址</h3><p>操作数放在堆栈中，隐含使用堆栈指针SP作为操作数地址</p><p>硬堆栈使用专用的寄存器作为堆栈，而软堆栈是在主存中开辟一段地址作为堆栈使用</p><p>可用于函数调用时保存当前函数的相关信息</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/YbH9LxXsya2wj5B.png" alt="image-20220317215800055"></p><hr><h2 id="CISC和RISC"><a href="#CISC和RISC" class="headerlink" title="CISC和RISC"></a>CISC和RISC</h2><p>CISC：Complex Instruction Set Computer  复杂指令集</p><p>主要是X86架构，主要用于笔记本，台式机等</p><p>一条指令能完成一个复杂的基本功能</p><hr><p>RISC：Reduced Instruction Set Computer    精简指令集</p><p>主要是ARM架构，主要用于手机，平板</p><p>一条指令完成一个基本动作，多条指令组合完成一个复杂的基本功能</p><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/XYOm2sdQJjvHL1n.png" alt="image-20220319143707720"></p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.存储系统</title>
      <link href="/post/46984.html"/>
      <url>/post/46984.html</url>
      
        <content type="html"><![CDATA[<h1 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h1><hr><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="存储系统层次化结构"><a href="#存储系统层次化结构" class="headerlink" title="存储系统层次化结构"></a>存储系统层次化结构</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/q1BjxAs6H2Ne9aW.png" alt="image-20220311211032882"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/fFzOMgHruspdDmQ.png" alt="image-20220311210806966"></p><p>Cache指的是高速缓冲存储器</p><p>主存和辅存之间的交换涉及到了操作系统中的虚拟存储系统部分，解决了主存容量不够的问题</p><p>而Cache和主存之间的交换解决了主存与CPU速度不匹配的问题</p><hr><h3 id="存储器的分类"><a href="#存储器的分类" class="headerlink" title="存储器的分类"></a>存储器的分类</h3><p>按<strong>层级</strong>分：可以分为高速缓存（Cache），主存储器（内存），辅助存储器（外存，磁盘）</p><p>按<strong>存储介质</strong>分：半导体存储器（主存，Cache），磁表面存储器（磁盘，磁带，硬盘），光存储器（光盘）</p><p>按<strong>存储方式</strong>分：</p><ul><li>随机存取存储器 <strong>RAM</strong>（Random Access Memory）：即是读写任何一个存储单元所需时间都相同，与存储单元所在物理位置无关，比如内存条</li><li>顺序存取存储器（Sequential Access Memory，<strong>SAM</strong>）：读写一个存储单元所需时间取决于存储单元所在的物理位置，比如磁带</li><li>直接存取存储器（Direct Access Memory，<strong>DAM</strong>）：既有随机存取特性，也有顺序存取特性。先直接选取信息所在区域，然后按顺序方式存取，比如硬盘</li><li>相联存储器（Associative Memory），即可以按内容访问的存储器，（Content Addres Memory）<strong>CAM</strong>，比如快表</li></ul><p>按<strong>信息的可更改性</strong>：读写存储器（磁盘，内存）只读存储器（CD）</p><p>按<strong>信息的可保存性</strong>：</p><ul><li>断电后，存储信息消失（主存，Cache）</li><li>断电后，存储信息存在（磁盘，光盘）</li><li>信息读出后，原存储信息被破坏（DRAM芯片）</li><li>信息读出后，原存储信息不被破坏（SRAM芯片，磁盘）</li></ul><hr><h3 id="存储器的性能指标"><a href="#存储器的性能指标" class="headerlink" title="存储器的性能指标"></a>存储器的性能指标</h3><p><strong>存储容量</strong>：存储字数×字长</p><p><strong>单位成本</strong>：每位价格=总成本/总容量</p><p><strong>存储速度</strong>：数据传输率（主存带宽 ）=数据的宽度/存储周期</p><p>因为每次存储结束后，存储器需要一定的时间恢复，所以存储时间和存储周期之间是有差别的</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/9Yul2XPy4OivbzR.png" alt="image-20220311213337555"></p><hr><h2 id="主存储器的基本组成"><a href="#主存储器的基本组成" class="headerlink" title="主存储器的基本组成"></a>主存储器的基本组成</h2><h3 id="基本的半导体元件"><a href="#基本的半导体元件" class="headerlink" title="基本的半导体元件"></a>基本的半导体元件</h3><p>以下知识将大量涉及到数电，所以将简要描述知识点（数电里学过了）</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/qurMeSzD9NOmTAI.png" alt="image-20220314194737012"></p><p>MOS管和电容可以组成一个基本的<strong>存储元</strong>，来表示0和1</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/xzf6SOJg94NlQnT.png" alt="image-20220314194007948"></p><p>而多个存储元集中排列在一起，则形成了基本的存储单元，就是<strong>存储字</strong></p><p>而多个存储字会拼接会形成一个<strong>存储体</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/3rilkX5sIbG4YHf.png" alt="image-20220314194316202"></p><p>而操纵这个存储体所需要的器件，就是<strong>译码器</strong></p><hr><h3 id="存储体芯片的基本原理"><a href="#存储体芯片的基本原理" class="headerlink" title="存储体芯片的基本原理"></a>存储体芯片的基本原理</h3><p><strong>译码器</strong>的作用是将MAR的中的地址信号，传达到具体的存储单元中去</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/UVWKD5cjg3HBfoi.png" alt="image-20220314195304494"></p><p>比如MAR中是3位地址，那么译码器会有$2^3=8$条线，连接到具体的存储单元中去，当某一条字选线接通的时候，存储字中的信息就会被存储在MDR中，通过数据总线传输到CPU</p><hr><p>需要一个<strong>控制电路</strong>来保持MAR和MDR中电信号稳定，同时还要有片选线，表示控制电路何时可用，同时还要有读控制线和写控制线，可以用两根线来读和写，也可以用一根线来读和写</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/L4Sv7q13PHaxUWe.png" alt="image-20220314195928191"></p><hr><p>总得来说，整体结构如下</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/QWoC7tkH59jP4mZ.png" alt="image-20220314200014262"></p><p>因为一个内存条里面有多块存储芯片，所以需要<strong>片选线</strong>来指定具体的存储芯片</p><p>而芯片上的金属引脚，就是用来连接地址线，片选线，数据线，读写控制线等的</p><hr><h2 id="SRAM和DRAM"><a href="#SRAM和DRAM" class="headerlink" title="SRAM和DRAM"></a>SRAM和DRAM</h2><p><strong>DRAM</strong>（Dynamic Random Access Memory）：动态RAM</p><p><strong>SRAM</strong>（Static Random Access Memory）：静态RAM</p><p>区别</p><ol><li>利用<strong>MOS管</strong>作为存储元的RAM就是DRAM，SRAM使用的是<strong>双稳态触发器</strong>作为存储元</li><li>DRAM在读出数据时会破坏性读出数据，读出后应有重写的操作，而SRAM在读取数据后不会被破坏，读写数据更快</li><li>DRAM每个存储元制造成本低，集成度高，功耗低 ，SRAM的成本高，功耗高</li></ol><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/PrjFtJq3QCvghG2.png" alt="image-20220314201356840"></p><p>SRAM常常用于Cache，而DRAM常用于主存</p><hr><p> <strong>DRAM的刷新</strong></p><p>刷新是指电容内的电荷只能维持2ms，所以DRAM需要不断的刷新，每次刷新一行存储单元，地址常常是二维的，译码器分为行译码器和列译码器</p><p>刷新操作有硬件支持，读书一行数据后重新输入，占用1个读写周期，不需要CPU控制</p><p>刷新方法有3种</p><ol><li><p>分散刷新 </p><p>每次读写完刷新一个行，将一个存取周期的前一半时间正常读取，后一半时间刷新某行</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/uxqE6FNHM9yPAkd.png" alt="image-20220314202218342"></p></li><li><p>集中刷新</p><p>在2ms内集中安排一个时间刷新，在此期间无法访问存储器，称为死区</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/AHcabRJBgL4l9SQ.png" alt="image-20220314202226554"></p></li><li><p>异步刷新</p><p>2ms内每行需要刷新一次，每隔固定的时间刷新一行，可以在译码阶段刷新</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/6uts5ZVGze2RFBx.png" alt="image-20220314202503063"></p></li></ol><hr><p>DRAM有地址线复用技术，可以将地址分两次传送，只需要n/2条地址线就能完成地址的传输</p><hr><h2 id="只读存取器ROM-Read-Only-Memory"><a href="#只读存取器ROM-Read-Only-Memory" class="headerlink" title="只读存取器ROM(Read-Only Memory)"></a>只读存取器ROM(Read-Only Memory)</h2><p>ROM芯片具有非易失性，断电后数据不会丢失</p><ol><li><p>MROM(Mask Read-Only Memory)——掩模式只读存储器</p><p>厂家在生产的时候直接写入，之后只能读出，任何人不能改写</p></li><li><p>PROM(Programmable) ——可编程只读存储器</p><p>可以用专门的写入器写人信息，写一次后不可更改</p></li><li><p>EPROM(Erasable Programmable)——可擦除可编程只读存储器</p><p>允许用户写入信息，之后用某种方法擦除数据，可进行多次重写 </p></li><li><p>Flash Memory ——闪存（u盘）</p><p>由EEPROM发展而来，断电后也能保存信息，可进行多次快速的擦除重写，由于闪存需要先擦除后写入，因此闪存的写比读更慢</p></li><li><p>SSD（Solid State Drives）——固态硬盘</p><p>有控制单元+存储单元（Flash芯片）构成，在闪存的区别在于控制单元不一样，存储介质一样，可以进行多次快速擦除重写，速度快，功耗低，价格高</p></li></ol><hr><p>BIOS芯片中存储了自举装入程序，负责引导装入操作系统</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/joYuP4HQU13LNmv.png" alt="image-20220314205925651"></p><p>尽管ROM的名字是“Read-Only”，但实际上，很多的ROM也可以 写（u盘）</p><p>很多ROM同样具有随机存取的特点</p><hr><h2 id="主存储器和CPU的连接"><a href="#主存储器和CPU的连接" class="headerlink" title="主存储器和CPU的连接"></a>主存储器和CPU的连接</h2><p>单块存储芯片和CPU的连接</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/38RvyHPSG7cDXIo.png" alt="image-20220314210901820"></p><p>如果想拓展存储体中的字数，需要用到<strong>字拓展法</strong></p><p>如果想拓展数据总线的宽度，需要用到<strong>位拓展法</strong></p><hr><h3 id="字拓展法"><a href="#字拓展法" class="headerlink" title="字拓展法"></a>字拓展法</h3><p>增加主存的<strong>存储字数</strong>，可以使用多个存储芯片，将多余的CPU的引脚来<strong>控制</strong>存储芯片的激活，即<strong>线选法</strong>，n条线输出n个选片信号</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/P6qCe1fsldEUxXV.png" alt="image-20220314212403971"></p><p>而在n条线之后添加译码器，可以输出$2^n$个选片信号，称为片选法</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/RTJu9PysmlFNCBx.png" alt="image-20220314212440866"></p><p>区别如下：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/LY52rGvA1SEcKPh.png" alt="image-20220314212044687"></p><hr><h3 id="位拓展法"><a href="#位拓展法" class="headerlink" title="位拓展法"></a>位拓展法</h3><p>增加主存的<strong>存储字长</strong>，可以用多块存储芯片，将数据总线连接到不同芯片中，将1位芯片扩展到8位</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/AqyPcxNFm39KeTd.png" alt="image-20220314211354925"></p><hr><h3 id="字位同时拓展"><a href="#字位同时拓展" class="headerlink" title="字位同时拓展"></a>字位同时拓展</h3><p>使用多块存储芯片为1组，同时使用译码器来同时实现字位拓展</p><hr><h2 id="双端口RAM和多模块存储器"><a href="#双端口RAM和多模块存储器" class="headerlink" title="双端口RAM和多模块存储器"></a>双端口RAM和多模块存储器</h2><p>DRAM芯片的恢复时间很长，而现代计算机通常是多核CPU，多核CPU之间存在访存问题</p><h3 id="双端口RAM"><a href="#双端口RAM" class="headerlink" title="双端口RAM"></a>双端口RAM</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/YpXvV47b8TkxfEB.png" alt="image-20220315101635030"></p><p>即指RAM提供2个端口，方便两个CPU同时访问，须有有两组完全独立的数据线，地址线，控制线，电路也更复杂</p><p>目的就是为了<strong>优化多核CPU访问一根内存条的速度</strong></p><p>两个端口可以同时对内存的不同地址单元进行读取，也可以对同一地址单元读出数据，但是不能同时对同一地址单元写入数据，也不能对同一地址单元同时读入和写入数据</p><p>解决办法：可以设置一个信号，由逻辑判断决定暂时关闭一个端口，被关闭的端口延后访问</p><hr><h3 id="多模块存储器"><a href="#多模块存储器" class="headerlink" title="多模块存储器"></a>多模块存储器</h3><p>为了提高存储器和CPU之间的速度，可以采用多体并行存储器</p><p>多体存储器分为高位交叉编址和低位高位编址，区别在于将内存条的某几位作为地址进行编址的位置的不同</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/HxcqZzh3LYutl1P.png" alt="image-20220315103114077"></p><p>可以看到，连续的地址由于低位交叉编址，被分配在了不同的内存条中，可以大大减少访问连续地址时的等待时间</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/owx2nE8phizGCM3.png" alt="image-20220315103819743"></p><p>假设每个存储体的存取周期是T，存取时间是r，那么连续存取n个字，耗时是<strong>T+(n-1)r</strong></p><p>为了保证存取的顺畅性，应保证模块数<strong>m=T/r</strong></p><p>双通道：即指的是两个内存条之间采用低位交叉方式进行编址</p><hr><p>单体多字存取器可以将存储器集合在一起，每次读取多个字，相当于位拓展</p><hr><h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><h3 id="基本概念和原理"><a href="#基本概念和原理" class="headerlink" title="基本概念和原理"></a>基本概念和原理</h3><p>Cache即是高速缓冲存储器，由SRAM组成，负责加快内存和CPU之间的数据传输</p><p>假设$t_c$为访问一次Cache所需时间，$t_m$为访问一次主存所需时间</p><p>命中率H：CPU访问的信息在Cache中的比率      </p><p>缺失率： M=1-H</p><p>如果先访问Cache，未命中再访问主存，那么平均访问时间是$t=Ht_c+(1-H)(t_c+t_m)$</p><p>如果同时访问Cache和主存，若Cache命中就立即停止访问主存，那么平均访问时间是$t=Ht_c+(1-H)(t_m)$</p><hr><p>（以下内容和操作系统的存储管理有极大联系）</p><p>为了实现将主存与Cache之间的数据交换，可以将主存的存储空间分块，主存与Cache之间以块为单位进行数据交换</p><p>假如主存的地址是4M，也就是$22$位，其中前12位标记为块号，后10位标记为块内的地址，整个主存被分为$2^{12}=4096$块，每一块包括有1K个地址</p><p>一块又称为一个页，或页面，而Cache中的块也被称为行，Cache的块的大小和主存中块的大小保持一致</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/95fgNAalhFyWOic.png" alt="image-20220315194805849"></p><hr><h3 id="Cache和主存之间的映射"><a href="#Cache和主存之间的映射" class="headerlink" title="Cache和主存之间的映射"></a>Cache和主存之间的映射</h3><ul><li>直接映射</li></ul><p>直接映射，即是<strong>主存块在Cache中的位置=主存块号%Cache总块数</strong></p><p>假设Cache的总块数是$2^3$，则相当于保留下主存块号的后3位，若Cache的总块数为$2^{n}$，则主存块的末尾n位直接反映了它在Cache中的位置，将主存块号的其他位置作为标记即可</p><p>标记的作用是指明Cache中块数对应的内存块数</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/3Aa9gFhVMPZTtGu.png" alt="image-20220315195733249"></p><p>CPU访问内存地址的步骤：</p><ol><li>根据主存块号的后三位确定Cache行</li><li>若主存块号的前19位和Cache标记匹配，且有效位为1，说明Cache命中，则访问块内地址为主存块内地址的单元</li><li>若未命中，则正常访问主存</li></ol><hr><ul><li>全相联映射</li></ul><p>也就是说，主存中的块可以随意放到Cache中去，放入后，将Cache块的标记改为主存地址即可</p><p>CPU访问内存地址步骤：</p><ol><li>主存地址的前22位对比Cache中所有块的标记</li><li>若标记匹配且有效位为1，则访问块内地址为主存块内地址的单元</li><li>若未命中，则正常访问主存</li></ol><hr><ul><li>组相联映射</li></ul><p>组相联映射，所属分组=主存块号%分组数</p><p>分组数为$2^{n}$，则主存块的末尾n位直接反映了它在Cache中分组的位置</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/F7BvcDIVap9QhCd.png" alt="image-20220315204721994"></p><p>CPU访问内存地址的步骤：</p><ol><li>根据主存块号的后2位确定所属分组号</li><li>若主存块号的前20位和Cache标记匹配，且有效位为1，说明Cache命中，则访问块内地址为主存块内地址的单元</li><li>若未命中，则正常访问主存</li></ol><hr><h3 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h3><p>对于全相联映射，当Cache满了之后，需要在全局中选择替换一块</p><p>对于直接映射，当Cache满了之后，可以直接替换掉</p><p>对于组相联映射，当Cache分组内满了之后，才需要在分组内选择替换哪一块</p><p>所以对于全相联映射和组相联映射，需要替换算法以判断替换的块数</p><hr><ul><li>随机算法（RAND）</li></ul><p>如果Cache满了，则随机选择一块进行替换，虽然实现简单，但Cache的命中率会很低</p><hr><ul><li>先进先出算法（FIFO）</li></ul><p>若Cache已满，则替换最先被调入的块，实现简单，但仍然没考虑到局部性原理</p><hr><ul><li>近期最少使用算法（LRU）</li></ul><p>为每一个Cache块设置一个计数器，用于记录每个Cache块已经有多久未被访问了，当Cache满后替换掉计数器最大的</p><p>计数规则如下：</p><ol><li>命中时，将所命中行计数器清零，比其低的计数器加1，其余不变</li><li>未命中且还有空闲行时，新装入的行计数器置0，其余非空闲行全加1</li><li>未命中且无空闲行时，计数器最大的信息块被淘汰，新装行的块计数器置0，其余全加1</li></ol><p>之所以命中时比命中行高的计数器不变，是因为加1了之后没有意义，而且可以用较少的比特位来表示计数器状态，假如Cache块的总数是$2^n$则计数器只用n位，而且Cache装满后，所有计数器的值一定不重复</p><p>这种算法的命中率高，算法性能优秀</p><hr><ul><li>最不经常使用算法（LFU）</li></ul><p>为每一个Cache块设置一个计数器，用于记录每个Cache块被访问过几次，当Cache块满后替换计数器最小的</p><p>新调入的块计数器为0，之后每被访问一次计数器+1，替换时，选择计数器最小的一行</p><p>若有多个计数器最小行，可以按其他策略来选择被替换的行，实际上性能不如LRU</p><hr><h3 id="Cache写策略"><a href="#Cache写策略" class="headerlink" title="Cache写策略"></a>Cache写策略</h3><p>CPU修改了Cache中的数据后，需要保证Cache和内存中的一致性</p><ul><li>写回法</li></ul><p>如果Cache对Cache写命中了，只修改Cache的内容，而不立刻写入主存，只有当此块被换出后才写入主存</p><p>需要设置一个标志位来表示该行是否被修改过</p><ul><li>全写法</li></ul><p>如果Cache对Cache写命中了，同时修改Cache和主存中的内容，可以保证数据的安全，一般使用写缓冲（write buffer）的方法</p><p>即用SRAM制造一个缓存器，实现FIFO的功能，如果要修改Cache，CPU将要修改的主存内容写入到缓存器中，然后由专门的控制电路控制写缓冲器写回到主存中去</p><p>使用写缓冲时，CPU写的速度很快，当写操作很频繁的时候，可以会发生阻塞</p><hr><ul><li>写分配法</li></ul><p>当CPU对Cache没有命中，则把主存中的块调入到Cache中进行修改，通常搭配写回法</p><ul><li>非写分配法</li></ul><p>当CPU对Cache没有命中，则对主存中的数据直接进行修改，通常搭配全写法</p><hr><p>现代计算机通常采用多级Cache，越接近CPU的Cache速度越快，容量越小</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/e9fIc1NTtxGKld5.png" alt="image-20220315212325199"></p><p>Cache和Cache之间常采用全写法和非写分配法，而Cache和主存之间使用写回法和写分配法</p><hr><h2 id="页式存储器"><a href="#页式存储器" class="headerlink" title="页式存储器"></a>页式存储器</h2><p>只介绍其和Cache的联系，具体看操作系统第三章</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/sylVQrROqGhibT7.png" alt="image-20220315212635889"></p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.数据的表示和运算</title>
      <link href="/post/40849.html"/>
      <url>/post/40849.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据的表示和运算"><a href="#数据的表示和运算" class="headerlink" title="数据的表示和运算"></a>数据的表示和运算</h1><hr><h2 id="进位计数制"><a href="#进位计数制" class="headerlink" title="进位计数制"></a>进位计数制</h2><h3 id="任意进制转为十进制"><a href="#任意进制转为十进制" class="headerlink" title="任意进制转为十进制"></a>任意进制转为十进制</h3><p>根据权值进行运算即可</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/qSo1KkMa9jBZ63Q.png" alt="image-20220306150022009"></p><hr><h3 id="二进制和八进制，十六进制的相互转换"><a href="#二进制和八进制，十六进制的相互转换" class="headerlink" title="二进制和八进制，十六进制的相互转换"></a>二进制和八进制，十六进制的相互转换</h3><p>二进制转八进制，将二进制从低位到高位，3位一组，每组转换为对应的八进制符号即可</p><p>二进制转十六进制，将二进制从低位到高位，4位一组，每组转换为对应的十六进制符号即可</p><p>而反过来就是八进制，十六进制转换为二进制</p><hr><h3 id="十进制转为任意进制"><a href="#十进制转为任意进制" class="headerlink" title="十进制转为任意进制"></a>十进制转为任意进制</h3><p>通用方法是使用除基取余法，但实际上一般用拼凑法</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/RS7mL95cfi1Xwqr.png" alt="image-20220306150747121"></p><hr><h3 id="真值和机器数"><a href="#真值和机器数" class="headerlink" title="真值和机器数"></a>真值和机器数</h3><p>真值：实际带有正负号的数</p><p>机器数：把正负号数字化的数</p><hr><h2 id="字符与字符串"><a href="#字符与字符串" class="headerlink" title="字符与字符串"></a>字符与字符串</h2><h3 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h3><p>英文在计算机中通过ASCII码进行存储</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/14EeJrqAQXiN6on.png" alt="image-20220306151604128"></p><p>从32~126为可印刷字符，其余为控制，通信字符</p><hr><h3 id="汉字的存储"><a href="#汉字的存储" class="headerlink" title="汉字的存储"></a>汉字的存储</h3><p>汉字的存储有多种方式，简单介绍一种GB 2312-80</p><p>先通过94×94的的表格存储汉字得到<strong>区位码</strong></p><p>为了避免和ASCII码的前32位冲突，再将区位码+20H得到<strong>国标码</strong></p><p>再将国标码+80H，得到<strong>汉字内码</strong></p><hr><h3 id="字符串的存储"><a href="#字符串的存储" class="headerlink" title="字符串的存储"></a>字符串的存储</h3><p>计算机按字节编址，从地址为2的单元开始，存储字符串，很多语言中用 \0 作为字符串结尾</p><p>而汉字占据两个字节，有两种存储模式，分别是将最高位有效字节存储在低地址单元的大端模式，和将最高位有效位存储在高地址单元的小端模式</p><hr><h2 id="定点数的表示"><a href="#定点数的表示" class="headerlink" title="定点数的表示"></a>定点数的表示</h2><h3 id="无符号数"><a href="#无符号数" class="headerlink" title="无符号数"></a>无符号数</h3><p>无符号数：整个机器字长的全部二进制位均为数值位，没有符号位，相当于绝对值</p><p>8位二进制数可以表示$2^8$种不同状态</p><hr><h3 id="有符号数"><a href="#有符号数" class="headerlink" title="有符号数"></a>有符号数</h3><p>有符号数：用最高位表示数的正负，称为有符号数</p><p>定点数：约定机器数中的小数点位置是固定不变的，一种在符号位的后面，称作定点小数，一种是在最低位之后，称作定点整数</p><hr><ol><li><p><strong>原码</strong></p><p>将最高位作为符号位，剩下的位来表示真值的绝对值，最高位为0表示正数，1表示负数</p><p>如果机器字长为8位，原码整数可以表示的范围是：$-(2^7-1)$ ~ $(2^7-1)$</p><p>真值0有2种形式，+0 和 -0</p></li><li><p><strong>反码</strong></p><p>若符号位为0，则反码与原码相同，若符号位为1，则将原码的数值位全部取反得到反码<br>表示范围和原码一样</p></li><li><p><strong>补码</strong></p><p>正数的补码就是原码，负数的补码=反码末位+1（考虑进位）</p><p>补码的0仅有一种形式 把1 0000 000 规定为$-2^7$</p><p>补码整数表示范围是$-(2^7)$ ~ $(2^7-1)$</p><p>负数补码转换为原码：将除符号位取反，末位+1</p></li><li><p><strong>移码</strong></p><p>在补码的基础上将符号位取反，则是移码，移码相比于补码，可以更清晰的比较数的大小</p></li></ol><p><strong>补码的作用是将ALU中的减法操作转换为加法操作</strong>，就8位机器而言，其能表示的范围是-128~127，本质上可以看做是一个圆圈，从0开始到127,127接着是-128，然后又回到0，加法操作就是就是顺时针拨动，减法操作就是逆时针拨动</p><hr><h2 id="定点数的运算"><a href="#定点数的运算" class="headerlink" title="定点数的运算"></a>定点数的运算</h2><h3 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h3><p>移位：改变各个数码位和小数点的相对位置，从而改变各数码位的位权</p><hr><p><strong>算数移位</strong>：符号位保持不变，对数值位进行移位</p><ol><li><p><strong>原码</strong></p><p><strong>右移</strong>：高位补0，低位舍弃。若舍弃的位是0，相当于÷2，若舍弃的位≠0，那么被舍弃后会<strong>丢失精度</strong></p><p><strong>左移</strong>：低位补0，高位舍弃。若舍弃的位是0，相当于×2，若舍弃的位≠0，那么被舍弃后会出现<strong>严重误差</strong></p></li><li><p><strong>反码</strong></p><p>正数的反码和原码相同，因此对正数反码的移位运算也和原码相同 </p><p>负数的反码是对原码取反，所以对于负数反码来说，右移高位补1，左移低位补1</p></li><li><p><strong>补码</strong></p><p>正数的补码和原码相同，因此对正数反码的移位运算也和原码相同 </p><p>对于负数的补码而言：</p><p>右移：高位补1，低位舍弃</p><p>左移：低位补0，高位舍弃<br><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/ylvYVpSrfwF7hzB.png" alt="image-20220308154237389"></p><p>因为在负数补码中，以最右边的1为分界，右边同原码，左边同反码</p></li></ol><hr><p>总结：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/l47CDRq8d9PBJGj.png" alt="image-20220308154607072"></p><hr><p><strong>逻辑移位</strong>：对所有位进行移位</p><p>右移：高位补0，低位舍弃</p><p>左移：低位补0，高位舍弃</p><hr><p><strong>循环移位</strong></p><p>左移：所有位向左边移动，最低位移到最高位</p><p>右移：所有位向右边移动，最高位移到最低位</p><hr><h3 id="加减运算和溢出"><a href="#加减运算和溢出" class="headerlink" title="加减运算和溢出"></a>加减运算和溢出</h3><p><strong>原码的加减法</strong></p><p>因为原码的符号位会影响运算，所以在涉及到正数和负数之间运算的时候需要用到绝对值和减法器</p><p>正+正    绝对值做加法</p><p>负+负    绝对值做加法，结果为负</p><p>正+负    绝对值大的减绝对值小的，符号同绝对值大的数</p><p>至于减法运算，把减数符号取反后，转变为加法就行</p><hr><p><strong>补码的加减法</strong></p><p>对于补码来说，无论是加法还是减法，都是可以转换成补码做加法操作，符号位也要参与运算</p><hr><p><strong>溢出</strong></p><p>正数+正数才有可能发生上溢（＞127）</p><p>负数+负数才有可能发生下溢  (&lt; -128）</p><hr><p><strong>溢出判断</strong></p><ol><li><p>一位符号位</p><p>$V=A_SB_S\bar{S}_S+\bar{A}_S\bar{B}_SS_S$</p><p>A的符号位是$A_S$,B的符号位是$B_S$，运算结果的符号位是$S_S$</p><p>V=0表示没有溢出，V=1表示有溢出</p><p>当减法操作时，$A_S$=1，$B_S$=1，且$S_S$=0，会判断出溢出</p><p>当加法操作时，$A_S$=0，$B_S$=0，且$S_S$=1，会判断出溢出</p></li></ol><ol><li><p>根据数据位进位情况判断</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/koUgjeWPEuA7vmH.png" alt="image-20220308165630903"></p><p>发生上溢的时候：$C_1$=1 $C_S$=0</p><p>发生下溢的时候：$C_1$=0 $C_S$=1</p><p>$C_S$和$C_1$不同有溢出，用异或操作可以判断溢出，不同为1，相同为0</p><p>$0\oplus 0=0$</p><p>$0\oplus 1=1$</p><p>异或结果为1，说明溢出</p></li></ol><ol><li><p>双符号位</p><p>多加一个符号位，正数的符号位00，负数符号为11</p><p>$S_1\oplus S_2=0$如果两个符号位相同则没有溢出，不同则溢出</p></li></ol><hr><h3 id="符号拓展"><a href="#符号拓展" class="headerlink" title="符号拓展"></a>符号拓展</h3><p>当8位数据拓展到16位数据时，正数都加0，负数反码,补码加1,</p><p>相当于左移嘛</p><hr><h3 id="原码和补码的乘除运算"><a href="#原码和补码的乘除运算" class="headerlink" title="原码和补码的乘除运算"></a>原码和补码的乘除运算</h3><p>略</p><hr><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>C语言中的定点正数都是用“补码”形式存储的</p><p>如果要使用无符号数，要在数据类型前加上 <code>unsigned</code></p><p>当有符号数转化成无符号数时，不会改变内容，而是改变解释方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> x=<span class="number">-4321</span>;                <span class="comment">//short一般占用2个字节</span></span><br><span class="line">unsighed <span class="keyword">short</span> y=(<span class="keyword">unsigned</span> <span class="keyword">short</span>)x;</span><br><span class="line">y=<span class="number">61213</span></span><br></pre></td></tr></table></figure><p>长整数变为短整数时，会将<strong>高位截断，保留低位</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">165537</span> ;<span class="comment">// a:0x 000286a1</span></span><br><span class="line"><span class="keyword">short</span> c=(<span class="keyword">short</span>) a;   <span class="comment">// c: 0x 96a1</span></span><br><span class="line">c=<span class="number">-31071</span></span><br></pre></td></tr></table></figure><p>短整数变长整数时：会经历符号扩展，按补码的规矩，往<strong>高位添1</strong></p><hr><h2 id="数据的存储和排列"><a href="#数据的存储和排列" class="headerlink" title="数据的存储和排列"></a>数据的存储和排列</h2><p>多字节数据在内存中一定是占据连续的几个字节，有最高有效字节MSB，最低有效字节LSB</p><p>对于机器而言，通过小端方式，即让最低位占据在低地址，更便于机器处理数据</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/b6FEL8oZRIGl37U.png" alt="image-20220308202030774"></p><hr><p>现代计算机通常使用按字节编址（8bit），即每个字节对应1个地址，但也支持按字，半字，字节寻址</p><p>假设存储字长为32位，则1个字=32bit，半字=16bit，每次访存只能读取1个字</p><p> 为了实现计算机内部的按字节，半字，字寻址，有两种数据排列方式</p><ol><li><strong>边界对齐方式</strong></li></ol><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/IvrsHuwQOV37UXk.png" alt="image-20220308204732745"></p><p>让边界对齐，按字的来排列数据，空出的部分进行填充</p><ol><li><strong>边界不对齐方式</strong></li></ol><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/N3qFDJw5Ipz1dk4.png" alt="image-20220308204958529"></p><p>对数据进行紧凑的排布，不进行填充</p><hr><p>边界对齐方式是一种用<strong>空间换时间</strong>的方式，因为每次访存只能读取一个字，边界对齐方式可以确保每次都能读取到完整数据</p><p>而边界不对齐方式是用时间换空间的方式，可以需要进行两次访存才能读取到完整数据</p><hr><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><h3 id="浮点数的表示"><a href="#浮点数的表示" class="headerlink" title="浮点数的表示"></a>浮点数的表示</h3><p>定点数可以表示的数字范围是有限的，所以需要<strong>浮点数</strong>  </p><p>浮点数由<strong>阶码</strong>和<strong>尾数</strong>构成，阶码反映数值大小，尾数反映精度</p><p>利用十进制的科学计数法举例，$+123456789=1.234×10^8$，可以记作+8 +1.234 前面的+8就是阶码，+1.234是尾数，而10是底</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/gdVZYXurwGMNU6m.png" alt="image-20220309200920548"></p><p>而在二进制中，阶码是常用补码或移码表示的<strong>定点整数</strong>，尾数是常用原码或补码表示的<strong>定点小数</strong></p><p>浮点数的真值：</p><p>​                                           $N=r^E×M$</p><p>式中的 r 表示阶码的底，通常是2 ，E表示阶码，M表示尾数</p><p>比如 0,10；0.01001    分号前表示的是阶码，分号后表示的是尾数，假设阶码，尾数都用补码表示</p><p>0,10  逗号前是阶码的符号位，阶码是正数，表示2</p><p>0.01001 小数点前是尾数的符号位，尾数是正数，表示$(2^{-2}+2^{-5})$</p><p>所以b=$2^2×(0.01001)$，左移两位，结果是+1.001</p><p>假设存储空间只有1B，那么存储时就会丢失精度</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/tSf3hHQViApNF5C.png" alt="image-20220309203941877"></p><hr><h3 id="浮点数的规格化"><a href="#浮点数的规格化" class="headerlink" title="浮点数的规格化"></a>浮点数的规格化</h3><p>在科学记数法中，规定用 $1≤|a|&lt;10$ 的数来乘10的幂，在浮点数的表示中，自然也对尾数的形式有要求，称为浮点数的规格化</p><p>所以上节的问题，可以将$2^2×(0.01001)$规格化为$2^1×(0.1001)$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/B9fWbCMZnKtliHp.png" alt="image-20220309211202071"></p><p>左规：当浮点数运算的结果为非规格化时要进行规格化处理，将尾数算数左移移位，阶码减一</p><p>右规：当浮点数运算的结果尾数出现溢出（双符号位为01或10）时，将尾数右移一位，阶码加1</p><p>比如a=010；00.1100   b=010；00.1000</p><p>a+b的结果是$2^2×(00.1100+00.1000)=2^2×01.0100$，此时发生了溢出，可以右规，算数右移后，$2^3×00.1010$</p><hr><p>不过以上的例子都是正数，如果是尾数是负数的话，就要考虑到使用原码还是补码进行规格化</p><p>对于原码来说，其尾数的小数点后最高位必须是1，对于补码来说，尾数的小数点后最高位必须是0</p><hr><h3 id="IEEE754"><a href="#IEEE754" class="headerlink" title="IEEE754"></a>IEEE754</h3><p>对于浮点数的表示，国际上有个统一的标准，称为IEEE754</p><p>IEEE754使用移码来表示阶码，移码=真值+偏置值</p><p>在IEEE中，偏置值为127D，即0111 1111B，是$2^{n-1}-1$</p><p>真值为-128，-128加上127，即是顺时针偏移127，结果是补码-1，1000 0001，原码表示是 1111 1111</p><p>真值为-127 -127+127=0000 0000</p><hr><p>IEEE754中规定了浮点数的表示形式</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/bdo8R5MK3nhjwQG.png" alt="image-20220310205028832"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/OE12DAC5b4dFpQw.png" alt="image-20220310205221185"></p><p>最高位是数符，表示的是整个浮点数的正负</p><p>尾数用原码表示，默认了原码的最高位是1，所以有23位</p><p>阶码为-128，-127时有特殊用途，只能取到-126~127之间</p><p>规格化的短浮点数的真值是：$(-1)^s×1.M×2^{E-127}$</p><hr><p>对于单精度浮点数来说，当尾数全为0，阶码真值最小为-126，移码为1，此时的<strong>最小绝对值为$(1.0)_2×2^{-126}$</strong></p><p>最大绝对值是，当尾数全为1，阶码真值最大为254,，移码为127，此时的<strong>最大绝对值为$(1.11..11)_2×2^{127}$</strong></p><hr><p>如果表示值比最小的绝对值还要小，就要使用特殊方法</p><p>当阶码全为0，即真值为-127，但尾数M不全为0时，规定阶码为-126，表示非规格化小数 $±(0.xxx)_2×2^{-126}$</p><p>当阶码和尾数都是0，那就是表示0</p><p>当阶码全为1，尾数全为0时，表示无穷大 $∞$</p><p>当阶码全为1，尾数不全为0时，表示非数值，即非法运算</p><hr><h3 id="浮点数的运算"><a href="#浮点数的运算" class="headerlink" title="浮点数的运算"></a>浮点数的运算</h3><p>运算步骤</p><ol><li>对阶，两个浮点数的阶不同时，让小阶向大阶对齐</li><li>尾数加减</li><li>规格化，保证尾数的最高位是有效位</li><li>舍入，舍入有很多规则，当要丢弃掉一些位时，可以四舍五入，或者全部丢弃</li><li>判断溢出 只有当阶码超过了两位情况下，才算发生了溢出，尾数溢出可以通过规格化来调整</li></ol><hr><h3 id="浮点数的类型转换"><a href="#浮点数的类型转换" class="headerlink" title="浮点数的类型转换"></a>浮点数的类型转换</h3><p>精度从小到大不会发生溢出  char→int→long→double   float→double</p><p>int和float同是32位，当时int表示整数，而float采用IEEE754标准表示整数及其小数，float能表示数的范围比int大得多</p><p>所以int→float：可能会损失精度，而float→int：既有可能发生溢出，也有可能损失精度</p><hr><h2 id="电路的基本原理"><a href="#电路的基本原理" class="headerlink" title="电路的基本原理"></a>电路的基本原理</h2><p>略</p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.计算机概述</title>
      <link href="/post/6876.html"/>
      <url>/post/6876.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机概述"><a href="#计算机概述" class="headerlink" title="计算机概述"></a>计算机概述</h1><hr><h2 id="计算机硬件的基本组成"><a href="#计算机硬件的基本组成" class="headerlink" title="计算机硬件的基本组成"></a>计算机硬件的基本组成</h2><h3 id="早期的冯洛伊曼结构"><a href="#早期的冯洛伊曼结构" class="headerlink" title="早期的冯洛伊曼结构"></a><strong>早期的冯洛伊曼结构</strong></h3><p>冯洛伊曼提出了<strong>存储程序</strong>的思想，即在进行操作计算机计算的时候将指令二进制代码的形式提前直接输入到计算机的主储存器中，而计算机会按照存储的指令逐条执行</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/wilU1R9E2BYjmey.png" alt="image-20220226165739283"></p><p>在计算机系统中的软件和硬件在逻辑上是等效的</p><p>冯洛伊曼计算机的特点有：</p><ul><li>计算机由五大部件组成</li><li>指令和数据以同等地位存储在存储器中，可以按地址寻访</li><li>指令和数据用二进制表示</li><li>指令由操作码(具体运算类型)和地址码组成</li><li>存储程序（提前存储在存储器）</li><li>以<strong>运算器</strong>为中心</li></ul><hr><h3 id="现代计算机结构"><a href="#现代计算机结构" class="headerlink" title="现代计算机结构"></a><strong>现代计算机结构</strong></h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/WbSRpT1r3zAnB5o.png" alt="image-20220226170159297"></p><p>现代以存储器为中心，运算器和控制器直接和存储器连接，现代将运算器和控制器集合在一起，形成了<strong>CPU</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/ed9WEmksOIl38ac.png" alt="image-20220226170515990"></p><hr><h2 id="硬件部件"><a href="#硬件部件" class="headerlink" title="硬件部件"></a>硬件部件</h2><h3 id="主存储器的基本组成"><a href="#主存储器的基本组成" class="headerlink" title="主存储器的基本组成"></a>主存储器的基本组成</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/SytgaUJL9A1G4lB.png" alt="image-20220226171557536"></p><p>MAR（Memory Address Register）：存储地址寄存器</p><p>MDR   (Memory Data Register)：存储数据寄存器</p><p>MAR存放的是地址，存储体通过MAR的内容寻找需要的信息</p><p>MDR存放的是数据，存储体通过MAR找到数据后，将数据放到MDR中</p><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/dlwLAOIP6hMgR1c.png" alt="image-20220226172036544"></p><p>数据在存储体中按地址进行存储</p><p><strong>存储字</strong>：存储单元中二进制代码的组合</p><p><strong>存储字长</strong>：存储单元中二进制的位数</p><p>MAR的位数可以反映存储单元的总个数，而MDR的位数可以反映存储字长</p><p><strong>MAR的位数×MDR的位数=存储器的总容量</strong></p><hr><h3 id="运算器的基本组成"><a href="#运算器的基本组成" class="headerlink" title="运算器的基本组成"></a>运算器的基本组成</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/HAGpLb24DlzZUqh.png" alt="image-20220226172430521"></p><p>运算器用于实现算术运算和逻辑运算</p><p>由ACC  MQ  ALU  X组成，核心是ALU</p><p>ACC：累加器，用于存放操作数，或运算结果</p><p>MQ（Multiple-Quotient Register）：乘商寄存器，在乘除运算的时候，用于存放操作数或运算结果</p><p>ALU（Arithmetric and Logic Unit）：算术逻辑单元，通过内部复杂的电路实现算术运算，逻辑运算</p><p>X：通用的操作数寄存器，用于存放操作数</p><hr><h3 id="控制器的基本组成"><a href="#控制器的基本组成" class="headerlink" title="控制器的基本组成"></a>控制器的基本组成</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/Rc4gHrSTFBaJYfz.png" alt="image-20220226184759208"></p><p>CU：控制单元，分析指令，给出控制信号</p><p>IR（Instruction Register）：指令寄存器，存放当前执行的指令</p><p>PC：程序计数器，存放下一条<strong>指令地址</strong>，有自动加一功能</p><p>完成一条指令需要先取指令，分析指令，再执行指令</p><hr><h3 id="计算机的工作过程"><a href="#计算机的工作过程" class="headerlink" title="计算机的工作过程"></a>计算机的工作过程</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/4gDroFiAhXZtWSp.png" alt="image-20220304195213228"></p><p>从存储体中取一个数的过程：</p><ol><li>PC →MAR  将下一条指令在存储体中的地址传输到MAR中</li><li>MAR→存储体</li><li>MAR→MDR 存储体根据MAR中的地址找到该指令，并将该指令内容传到MDR中去</li><li>MDR→IR  IR存放当前指令</li><li>IR→CU  指令的操作码送到了CU中，分析当前指令的内容，得出这是取数指令</li><li>IR→MAR  指令的地址码送到MAR</li><li>MAR→存储体</li><li>MAR→MDR  MAR根据地址码，取出数放到MDR中</li><li>MDR→ACC  ACC存储了数</li></ol><p>主要是存储体会工作两次，第一次根据PC给出地址码，第二次根据地址码给出数</p><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/VhXc84SiBYbs1Dz.png" alt="image-20220304202001740"></p><p>从存储体中存储一个数的过程：</p><ol><li>PC →MAR </li><li>MAR→存储体</li><li>MAR →MDR 存储体根据MAR的值，将指令放在MDR中</li><li>MDR →IR     将MDR的值放入IR中</li><li>IR →CU         将指令的操作码放入CU中，CU分析出这是存数指令</li><li>IR →MAR       指令的地址码放入MAR中</li><li>ACC →MDR    导致MDR等于操作数</li><li>MAR→存储体</li><li>MDR →存储体    MDR中的操作数会被存入到存储体中，地址为MAR中的地址</li></ol><p>对比存数和取数的操作，可以看出在1~4步取指令以及第5步分析指令阶段，执行的操作是一样的，区别只是在分析指令指令后的操作不同</p><p>CPU通过<strong>指令周期</strong>的不同阶段来区分指令和数据</p><hr><h2 id="计算机的层次结构"><a href="#计算机的层次结构" class="headerlink" title="计算机的层次结构"></a>计算机的层次结构</h2><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/uefaUcPrqO2JQ16.png" alt="image-20220304203734219"></p><p>实际上，有三种级别的语言，上图中只是比较传统的一种语言</p><ol><li>类似C，C++等语言，会先通过编译程序翻译成汇编语言，再由汇编语言翻译成机器语言</li><li>也可以直接用编译程序将高级语言翻译成机器语言</li><li>类似JAVAScript等语言，需要解释器，将源程序的一条语句翻译成机器语言后，立即执行，才会接着翻译下一句</li></ol><hr><h2 id="计算机性能指标"><a href="#计算机性能指标" class="headerlink" title="计算机性能指标"></a>计算机性能指标</h2><p><strong>存储器的性能指标</strong></p><p><strong>容量</strong>=存储单元个数×存储字长/8  =Byte</p><hr><p><strong>CPU的性能指标</strong></p><p>主频：CPU内数字脉冲信号振荡的频率，和时钟周期互为倒数，单位Hz，反映每秒有多少个时钟周期</p><p>CPI(Clock cycle Per Instruction)：执行一条指令所需的时钟周期数</p><p>执行一条指令的耗时为：CPI×CPU时钟周期</p><p>IPS（Instruction Per Second）：每秒执行多少条指令   =主频/平均CPI</p><p>FLOPS：每秒执行的浮点运算次数</p><p>（K=$10^3$，M=$10^6$，G=$10^9$，T=$10^{12}$）</p><hr><p>系统整体的指标</p><p>数据通路带宽：数据总线一次能并行的位数</p><p>吞吐量：系统在单位时间内处理请求的数量</p><p>响应时间：从用户向计算机发送一个请求，到系统对该请求做出响应并获得它所需要的结果的等待时间</p><hr>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.5 ex4：bias vs variance</title>
      <link href="/post/1570.html"/>
      <url>/post/1570.html</url>
      
        <content type="html"><![CDATA[<h1 id="8-5-ex4：bias-vs-variance"><a href="#8-5-ex4：bias-vs-variance" class="headerlink" title="8.5 ex4：bias vs variance"></a>8.5 ex4：bias vs variance</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在本练习的前半部分，你将实现正则化线性回归，用于预测水库中水位变化与水流出量之间的关系。在接下来的一半中，你将进行一些调试学习算法的诊断，并研究偏差与方差的影响。</p><p>必要的文件如下：</p><ul><li><code>ex5.py</code> - Python脚本，通过练习的步骤引导您</li><li><code>ex5data1.mat</code> - 数据集 </li><li><code>featureNormalize.py</code> - 特征归一化函数</li><li><code>plotFit.py</code> - 绘制多项式拟合图 </li><li><code>trainLinearReg.py</code> - 使用您的成本函数训练线性回归 </li></ul><p>需要完成的文件如下：</p><ul><li><code>linearRegCostFunction.py</code> - 正则化线性回归成本函数</li><li><code>learningCurve.py</code> - 生成学习曲线</li><li><code>polyFeatures.py</code> - 将数据映射到多项式特征空间 </li><li><code>validationCurve.py</code> - 生成交叉验证曲线</li></ul><hr><h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> scipy.io <span class="keyword">as</span> scio</span><br><span class="line"><span class="keyword">import</span> linearRegCostFunction <span class="keyword">as</span> lrcf</span><br><span class="line"><span class="keyword">import</span> trainLinearReg <span class="keyword">as</span> tlr</span><br><span class="line"><span class="keyword">import</span> learningCurve <span class="keyword">as</span> lc</span><br><span class="line"><span class="keyword">import</span> polyFeatures <span class="keyword">as</span> pf</span><br><span class="line"><span class="keyword">import</span> featureNormalize <span class="keyword">as</span> fn</span><br><span class="line"><span class="keyword">import</span> plotFit <span class="keyword">as</span> plotft</span><br><span class="line"><span class="keyword">import</span> validationCurve <span class="keyword">as</span> vc</span><br></pre></td></tr></table></figure><hr><h2 id="加载和绘图"><a href="#加载和绘图" class="headerlink" title="加载和绘图"></a>加载和绘图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载训练数据</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;加载和可视化数据...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从ex5data1加载数据：</span></span><br><span class="line">data = scio.loadmat(<span class="string">&#x27;ex5data1.mat&#x27;</span>)</span><br><span class="line">X = data[<span class="string">&#x27;X&#x27;</span>]</span><br><span class="line">y = data[<span class="string">&#x27;y&#x27;</span>].flatten()</span><br><span class="line">Xval = data[<span class="string">&#x27;Xval&#x27;</span>]</span><br><span class="line">yval = data[<span class="string">&#x27;yval&#x27;</span>].flatten()</span><br><span class="line">Xtest = data[<span class="string">&#x27;Xtest&#x27;</span>]</span><br><span class="line">ytest = data[<span class="string">&#x27;ytest&#x27;</span>].flatten()</span><br><span class="line"></span><br><span class="line">m = y.size</span><br></pre></td></tr></table></figure><p><code>data</code>数据集分为三个部分：</p><ul><li>用于模型学习的训练集：<code>X, y</code></li><li>用于确定正则化参数的交叉验证集：<code>Xval, yval</code></li><li>用于评估性能的测试集。这些是在训练期间模型未见过的“未知”示例：<code>Xtest, ytest</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 绘制训练数据</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.scatter(X, y, c=<span class="string">&#x27;r&#x27;</span>, marker=<span class="string">&quot;x&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;水位变化(x)&#x27;</span>,fontproperties=<span class="string">&#x27;SimHei&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;大坝流出的水量(y)&#x27;</span>,fontproperties=<span class="string">&#x27;SimHei&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;程序暂停。按ENTER键继续&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231122214534375.png" alt="image-20231122214534375" style="zoom:67%;" /></p><hr><h2 id="正则化线性回归"><a href="#正则化线性回归" class="headerlink" title="正则化线性回归"></a>正则化线性回归</h2><p>现在应该完善<code>linearRegCostFunction.py</code>文件,实现线性回归功能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">linear_reg_cost_function</span>(<span class="params">theta, x, y, lmd</span>):</span></span><br><span class="line">    <span class="comment"># 初始化一些有用的值</span></span><br><span class="line">    m = y.size</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 你需要正确返回以下变量</span></span><br><span class="line">    cost = <span class="number">0</span></span><br><span class="line">    grad = np.zeros(theta.shape)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算误差</span></span><br><span class="line">    error = x @ theta - y</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算正则化项</span></span><br><span class="line">    reg = lmd * np.<span class="built_in">sum</span>(np.power(theta[<span class="number">1</span>:], <span class="number">2</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算代价函数</span></span><br><span class="line">    cost = (np.<span class="built_in">sum</span>(error**<span class="number">2</span>) + reg) / (<span class="number">2</span> * m)</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算梯度</span></span><br><span class="line">    grad = (error @ x) / m</span><br><span class="line">    grad[<span class="number">1</span>:] += lmd * theta[<span class="number">1</span>:] / m</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cost, grad</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>正则化的线性回归在之前的练习中就已经写过，所有可以很顺利的写出</p><p>注意：正则化是不包含$\theta_0$的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># ===================== 第 2 部分：正则化线性回归代价 =====================</span></span><br><span class="line"><span class="comment"># 您现在应该实现带正则化的线性回归代价函数。</span></span><br><span class="line"></span><br><span class="line">theta = np.ones(<span class="number">2</span>)</span><br><span class="line">cost, _ = lrcf.linear_reg_cost_function(theta, np.c_[np.ones(m), X], y, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;theta = [1  1] 时的代价: &#123;:0.6f&#125;\n(该值应约为303.993192)&#x27;</span>.<span class="built_in">format</span>(cost))</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;程序暂停。按ENTER键继续&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ===================== 第 3 部分：正则化线性回归梯度 =====================</span></span><br><span class="line"><span class="comment"># 您现在应该实现带正则化的线性回归梯度。</span></span><br><span class="line"></span><br><span class="line">theta = np.ones(<span class="number">2</span>)</span><br><span class="line">cost, grad = lrcf.linear_reg_cost_function(theta, np.c_[np.ones(m), X], y, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;theta = [1  1] 时的梯度: &#123;&#125;\n(该值应约为[-15.303016  598.250744])&#x27;</span>.<span class="built_in">format</span>(grad))</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;程序暂停。按ENTER键继续&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行测试程序，观察程序的结果是否等于理想的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================== 第 4 部分：训练线性回归 =====================</span></span><br><span class="line"><span class="comment"># 一旦您正确实现了代价和梯度，train_linear_reg函数将使用您的代价函数来训练正则化线性回归。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 写作说明：数据是非线性的，因此这不会产生很好的拟合。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 lambda = 0 训练线性回归</span></span><br><span class="line">lmd = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">theta = tlr.train_linear_reg(np.c_[np.ones(m), X], y, lmd)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在数据上绘制拟合曲线</span></span><br><span class="line">plt.plot(X, np.dot(np.c_[np.ones(m), X], theta))</span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;程序暂停。按ENTER键继续&#x27;</span>)</span><br></pre></td></tr></table></figure><p>画出拟合曲线</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231122215513243.png" alt="image-20231122215513243" style="zoom:80%;" /></p><hr><h2 id="学习曲线"><a href="#学习曲线" class="headerlink" title="学习曲线"></a>学习曲线</h2><p>完善<code>trainLinearReg.py</code>文件，绘制出学习曲线的图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> trainLinearReg <span class="keyword">as</span> tlr</span><br><span class="line"><span class="keyword">import</span> linearRegCostFunction <span class="keyword">as</span> lrcf</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">learning_curve</span>(<span class="params">X, y, Xval, yval, lmd</span>):</span></span><br><span class="line">    <span class="comment"># 训练样本数</span></span><br><span class="line">    m = X.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 需要正确返回这些值</span></span><br><span class="line">    error_train = np.zeros(m)</span><br><span class="line">    error_val = np.zeros(m)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 训练子集</span></span><br><span class="line">        X_subset = X[:i, :]</span><br><span class="line">        y_subset = y[:i]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用训练子集训练参数</span></span><br><span class="line">        theta = tlr.train_linear_reg(X_subset, y_subset, lmd)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算训练误差</span></span><br><span class="line">        error_train[i - <span class="number">1</span>], _ = lrcf.linear_reg_cost_function(theta, X_subset, y_subset, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算交叉验证误差</span></span><br><span class="line">        error_val[i - <span class="number">1</span>], _ = lrcf.linear_reg_cost_function(theta, Xval, yval, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error_train, error_val</span><br></pre></td></tr></table></figure><p>这里使用<code>for</code>循环，逐渐增加训练集和验证集的样本数<code>m</code>，然后把误差存储在<code>error_train</code>和<code>error_val</code>数组中，从而绘制出随着<code>m</code>增加，误差变化的学习曲线</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">lmd = <span class="number">0</span></span><br><span class="line">error_train, error_val = lc.learning_curve(np.c_[np.ones(m), X], y, np.c_[np.ones(Xval.shape[<span class="number">0</span>]), Xval], yval, lmd)</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(np.arange(m), error_train, np.arange(m), error_val)</span><br><span class="line">plt.title(<span class="string">&#x27;线性回归的学习曲线&#x27;</span>,fontproperties=<span class="string">&#x27;SimHei&#x27;</span>)</span><br><span class="line">plt.legend([<span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;cross validate&#x27;</span>])</span><br><span class="line">plt.xlabel(<span class="string">&#x27;训练样本数&#x27;</span>,fontproperties=<span class="string">&#x27;SimHei&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;误差&#x27;</span>,fontproperties=<span class="string">&#x27;SimHei&#x27;</span>)</span><br><span class="line">plt.axis([<span class="number">0</span>, <span class="number">13</span>, <span class="number">0</span>, <span class="number">150</span>])</span><br><span class="line">plt.show()</span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;程序暂停。按ENTER键继续&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>绘制学习曲线</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231122220954572.png" alt="image-20231122220954572" style="zoom:80%;" /></p><p>可以看到，虽然训练样本数的增加，训练集的误差越来越大，最后趋于平缓，而验证集的误差越来越小，最后也趋于平缓</p><hr><h2 id="多项式回归的特征映射"><a href="#多项式回归的特征映射" class="headerlink" title="多项式回归的特征映射"></a>多项式回归的特征映射</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================== 第 6 部分：多项式回归的特征映射 =====================</span></span><br><span class="line"><span class="comment"># 解决这个问题的一种方法是使用多项式回归。您现在应该完成polyFeatures以将每个示例映射到其次数。</span></span><br><span class="line">p = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将X映射到多项式特征并进行归一化</span></span><br><span class="line"><span class="comment"># 使用 poly_features 函数将原始特征映射到多项式特征空间</span></span><br><span class="line">X_poly = pf.poly_features(X, p)</span><br><span class="line"><span class="comment"># 对映射后的特征矩阵进行归一化处理</span></span><br><span class="line">X_poly, mu, sigma = fn.feature_normalize(X_poly)</span><br><span class="line"> <span class="comment"># 在特征矩阵左侧添加一列全为 1 的偏置列</span></span><br><span class="line">X_poly = np.c_[np.ones(m), X_poly]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将X_poly_test映射并进行归一化（使用mu和sigma</span></span><br><span class="line"><span class="comment"># 使用相同的映射函数将测试集映射到多项式特征空间）</span></span><br><span class="line">X_poly_test = pf.poly_features(Xtest, p)</span><br><span class="line"><span class="comment"># 使用训练集的均值进行归一化</span></span><br><span class="line">X_poly_test -= mu  </span><br><span class="line"><span class="comment"># 使用训练集的标准差进行归一化</span></span><br><span class="line">X_poly_test /= sigma</span><br><span class="line"> <span class="comment"># 添加偏置列</span></span><br><span class="line">X_poly_test = np.c_[np.ones(X_poly_test.shape[<span class="number">0</span>]), X_poly_test] </span><br><span class="line"></span><br><span class="line"><span class="comment"># 将X_poly_val映射并进行归一化（使用mu和sigma）</span></span><br><span class="line"><span class="comment"># 使用相同的映射函数将交叉验证集映射到多项式特征空间</span></span><br><span class="line">X_poly_val = pf.poly_features(Xval, p)</span><br><span class="line"><span class="comment"># 使用训练集的均值进行归一化</span></span><br><span class="line">X_poly_val -= mu</span><br><span class="line"><span class="comment"># 使用训练集的标准差进行归一化</span></span><br><span class="line">X_poly_val /= sigma</span><br><span class="line"><span class="comment"># 添加偏置列</span></span><br><span class="line">X_poly_val = np.c_[np.ones(X_poly_val.shape[<span class="number">0</span>]), X_poly_val]  </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;归一化后的训练样本 1 : \n&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(X_poly[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;程序暂停。按ENTER键继续&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>feature_normalize.py</code>是已经给出的<code>python</code>文件，只需要完成<code>polyFeatures</code>即行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">poly_features</span>(<span class="params">X, p</span>):</span></span><br><span class="line">    <span class="comment"># 需要正确返回以下变量。</span></span><br><span class="line">    X_poly = np.zeros((X.size, p))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ===================== 在这里填写代码 =====================</span></span><br><span class="line">    <span class="comment"># 说明：给定一个向量 X，返回一个矩阵 X_poly，其中 X_poly 的第 p 列包含 X 的 p 次幂的值。</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(p):</span><br><span class="line">        X_poly[:, i] = np.power(X, i + <span class="number">1</span>).flatten()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ==========================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> X_poly</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">假设p=2,那么会输出</span></span><br><span class="line"><span class="string">[x, y, z</span></span><br><span class="line"><span class="string"> x²,y²,z²]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><hr><h2 id="多项式回归的学习曲线"><a href="#多项式回归的学习曲线" class="headerlink" title="多项式回归的学习曲线"></a>多项式回归的学习曲线</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================== 第 7 部分：多项式回归的学习曲线 =====================</span></span><br><span class="line"><span class="comment"># 现在，您将有机会尝试使用多个lambda值进行多项式回归。</span></span><br><span class="line"><span class="comment"># 下面的代码使用lambda = 0运行多项式回归。您可以尝试使用不同的lambda值运行代码，以查看拟合和学习曲线的变化。</span></span><br><span class="line"></span><br><span class="line">lmd = <span class="number">0</span></span><br><span class="line">theta = tlr.train_linear_reg(X_poly, y, lmd)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制训练数据和拟合曲线</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.scatter(X, y, c=<span class="string">&#x27;r&#x27;</span>, marker=<span class="string">&quot;x&quot;</span>)</span><br><span class="line">plotft.plot_fit(np.<span class="built_in">min</span>(X), np.<span class="built_in">max</span>(X), mu, sigma, theta, p)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;水位变化 (x)&#x27;</span>,fontproperties=<span class="string">&#x27;SimHei&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;大坝流出的水量 (y)&#x27;</span>,fontproperties=<span class="string">&#x27;SimHei&#x27;</span>)</span><br><span class="line">plt.ylim([<span class="number">0</span>, <span class="number">60</span>])</span><br><span class="line">plt.title(<span class="string">&#x27;多项式回归拟合 (lambda = &#123;&#125;)&#x27;</span>.<span class="built_in">format</span>(lmd),fontproperties=<span class="string">&#x27;SimHei&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>train_linear_reg</code>和<code>plot_fit</code>都是已经给出的函数，可以直接调用进行绘图</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231123003802275.png" alt="image-20231123003802275" style="zoom:80%;" /></p><p>然后绘制多项式回归的学习曲线</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">error_train, error_val = lc.learning_curve(X_poly, y, X_poly_val, yval, lmd)</span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(np.arange(m), error_train, np.arange(m), error_val)</span><br><span class="line">plt.title(<span class="string">&#x27;多项式回归学习曲线 (lambda = &#123;&#125;)&#x27;</span>.<span class="built_in">format</span>(lmd),fontproperties=<span class="string">&#x27;SimHei&#x27;</span>)</span><br><span class="line">plt.legend([<span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;cross validate&#x27;</span>])</span><br><span class="line">plt.xlabel(<span class="string">&#x27;训练样本数&#x27;</span>,fontproperties=<span class="string">&#x27;SimHei&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;误差&#x27;</span>,fontproperties=<span class="string">&#x27;SimHei&#x27;</span>)</span><br><span class="line">plt.axis([<span class="number">0</span>, <span class="number">13</span>, <span class="number">0</span>, <span class="number">150</span>])</span><br><span class="line">plt.show()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;多项式回归 (lambda = &#123;&#125;)&#x27;</span>.<span class="built_in">format</span>(lmd))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;# 训练样本数\t训练误差\t\t交叉验证误差&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;  \t&#123;&#125;\t\t&#123;&#125;\t&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i, error_train[i], error_val[i]))</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;程序暂停。按ENTER键继续&#x27;</span>)</span><br></pre></td></tr></table></figure><p>用之前编写的<code>learning_curve</code>函数，计算出<code>error_train, error_val</code>,然后绘制绘图</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231123003938758.png" alt="image-20231123003938758" style="zoom:80%;" /></p><p>可以看出，训练集的误差在训练样本不断增大的情况下，误差都很小，而在验证集上，随着训练样本的增大，误差有明显下降，说明训练集存在高方差的问题，即<strong>过拟合</strong></p><hr><h2 id="测试lambda值"><a href="#测试lambda值" class="headerlink" title="测试lambda值"></a>测试lambda值</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================== 第 8 部分：选择Lambda的验证 =====================</span></span><br><span class="line"><span class="comment"># 您现在将实现validationCurve以在验证集上测试各种lambda值。</span></span><br><span class="line"><span class="comment"># 然后，您将使用此值选择“最佳”的lambda值。</span></span><br><span class="line"></span><br><span class="line">lambda_vec, error_train, error_val = vc.validation_curve(X_poly, y, X_poly_val, yval)</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(lambda_vec, error_train, lambda_vec, error_val)</span><br><span class="line">plt.legend([<span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;cross validate&#x27;</span>])</span><br><span class="line">plt.xlabel(<span class="string">&#x27;lambda&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;误差&#x27;</span>,fontproperties=<span class="string">&#x27;SimHei&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;ex5 完成。按ENTER键退出&#x27;</span>)</span><br></pre></td></tr></table></figure><p>编写<code>validationCurve.py</code>文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> trainLinearReg <span class="keyword">as</span> tlr</span><br><span class="line"><span class="keyword">import</span> linearRegCostFunction <span class="keyword">as</span> lrcf</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validation_curve</span>(<span class="params">X, y, Xval, yval</span>):</span></span><br><span class="line">    <span class="comment"># 选择的 lambda 值（请勿更改）</span></span><br><span class="line">    lambda_vec = np.array([<span class="number">0.</span>, <span class="number">0.001</span>, <span class="number">0.003</span>, <span class="number">0.01</span>, <span class="number">0.03</span>, <span class="number">0.1</span>, <span class="number">0.3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>])</span><br><span class="line">    m=<span class="built_in">len</span>(lambda_vec)</span><br><span class="line">    <span class="comment"># 你需要正确返回这些变量。</span></span><br><span class="line">    error_train = np.zeros(lambda_vec.size)</span><br><span class="line">    error_val = np.zeros(lambda_vec.size)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ===================== 你的代码在这里 =====================</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        lmd = lambda_vec[i]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用当前 lambda 训练线性回归模型</span></span><br><span class="line">        theta = tlr.train_linear_reg(X, y, lmd)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算训练误差</span></span><br><span class="line">        error_train[i], _ = lrcf.linear_reg_cost_function(theta, X, y, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算验证误差</span></span><br><span class="line">        error_val[i], _ = lrcf.linear_reg_cost_function(theta, Xval, yval, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ==========================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lambda_vec, error_train, error_val</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>把不同<code>lambda</code>值对应的训练误差和验证误差都求出来，并绘制曲线图</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231123010316053.png" alt="image-20231123010316053" style="zoom:80%;" /></p><p>可以看见，随着lambda的增大，验证集的误差先较小后增加，而训练集的误差一直在增加，说明适当的lambda的值降低了过拟合程度，而过大的lambda值让函数欠拟合</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.0.应用机器学习的建议</title>
      <link href="/post/45603.html"/>
      <url>/post/45603.html</url>
      
        <content type="html"><![CDATA[<h1 id="应用机器学习的建议"><a href="#应用机器学习的建议" class="headerlink" title="应用机器学习的建议"></a>应用机器学习的建议</h1><h2 id="假设环节"><a href="#假设环节" class="headerlink" title="假设环节"></a>假设环节</h2><p>之前已经介绍过了，在机器学习的过程中，会出现<strong>过拟合</strong>的问题</p><p>那么，该如何判断一个假设函数是过拟合的呢？对于这个简单的例子，我们可以对假设函数$h(x)$进行画图，然后观察图形趋势，但对于特征变量不止一个的这种一般情况，还有像有很多特征变量的问题，想要通过画出假设函数来进行观察，就会变得很难甚至是不可能实现。</p><p>因此，我们需要另一种方法来评估我们的假设函数过拟合检验。</p><p>为了检验算法是否过拟合，我们将数据分成<strong>训练集和测试集</strong>，通常用70%的数据作为训练集，用剩下30%的数据作为测试集。很重要的一点是训练集和测试集均要含有各种类型的数据，通常我们要对数据进行“洗牌”，然后再分成训练集和测试集。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231120071352801.png" alt="image-20231120071352801" style="zoom:67%;" /></p><p>顾名思义，我们在训练集上训练参数theta，然后将theta代入到测试集中观察拟合程度，这样就可以判断是否过拟合</p><p>有两种方式计算误差：</p><ol><li>对于线性回归模型，我们利用测试集数据计算代价函数$J$</li><li>对于逻辑回归模型，可以利用测试数据集来计算代价函数后，在判断预测成功的概率</li></ol><script type="math/tex; mode=display">J_{test}(\theta) = -\frac{1}{m_{test}}\sum_\limits{i=1}^{m_{test}}\log{h_{\theta}(x^{(i)}_{test})}+(1-{y^{(i)}_{test}})\log{h_{\theta}(x^{(i)}_{test})}</script><p><br/></p><hr><h2 id="模型选择"><a href="#模型选择" class="headerlink" title="模型选择"></a>模型选择</h2><p>假设有很多二项式模型，比如$h_\theta(x)=\theta_0+\theta_1x$和$h_\theta(x)=\theta_0+\theta_1x+\theta_2x^2…..$</p><p>显然越高次数的多项式模型越能够适应我们的训练数据集，但是适应训练数据集并不代表着能推广至一般情况，我们应该选择一个更能适应一般情况的模型。我们需要使用<strong>交叉验证集</strong>来帮助选择模型。</p><p>即：使用60%的数据作为<strong>训练集</strong>，使用 20%的数据作为<strong>交叉验证集</strong>，使用20%的数据作为<strong>测试集</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231120072045478.png" alt="image-20231120072045478" style="zoom:80%;" /></p><p>模型选择的方法为：</p><ol><li><p>使用训练集训练出10个模型</p></li><li><p>用10个模型分别对<strong>交叉验证集</strong>计算得出交叉验证<strong>误差</strong>$J_{cv}(\theta)$（代价函数的值）</p></li><li><p>选取代价函数值$J_{cv}(\theta)$最小的模型</p></li><li><p>用步骤3中选出的模型对测试集计算得出推广误差$J_{test}(\theta)$（代价函数的值）</p></li></ol><p><br/></p><p>交叉验证集的作用就是辅助选出适合的模型</p><hr><h2 id="偏差和方差"><a href="#偏差和方差" class="headerlink" title="偏差和方差"></a>偏差和方差</h2><p>当运行一个学习算法时，如果这个算法的表现不理想，那么多半是出现两种情况：</p><ul><li>偏差过大：即欠拟合</li><li>方差过大：即过拟合</li></ul><p>我们在训练模型的时候，肯定需要及时的判断模型是否出现了欠拟合和过拟合的问题，以及如何修改模型，以避免这些问题的出现</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231120072612354.png" alt="image-20231120072612354"></p><p>我们通常会通过将训练集和<strong>交叉验证集的代价函数误差与多项式的次数</strong>绘制在<strong>同一张图表</strong>上来帮助分析</p><p>首先将<strong>横坐标设置拟合函数的次数</strong>，将<strong>纵轴标设置为代价函数的误差</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231120072732214.png" alt="image-20231120072732214"></p><p><strong>Training error:</strong>                               $J_{train}(\theta) = \frac{1}{2m}\sum_\limits{i=1}^{m}(h_{\theta}(x^{(i)})-y^{(i)})^2$</p><p><strong>Cross Validation error:</strong>                $J_{cv}(\theta) = \frac{1}{2m_{cv}}\sum_\limits{i=1}^{m}(h_{\theta}(x^{(i)}_{cv})-y^{(i)}_{cv})^2$</p><ul><li><p>对于训练集，当 $d$ 较小时，模型拟合程度更低，误差较大；随着 $d$ 的增长，拟合程度提高，误差减小。</p></li><li><p>对于交叉验证集，当 $d$ 较小时，模型拟合程度低，误差较大；但是随着 $d$ 的增长，误差呈现先减小后增大的趋势，转折点是我们的模型开始<strong>过拟合</strong>训练数据集的时候。</p></li></ul><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231120073237122.png" alt="image-20231120073237122"></p><p>交叉验证集在d较小和d较大的时候，都会出现误差过大的问题：</p><ul><li>训练集误差和交叉验证集误差近似时：偏差/欠拟合</li><li>交叉验证集误差远大于训练集误差时：方差/过拟合</li></ul><p><br/></p><hr><h2 id="正则化和偏差-方差"><a href="#正则化和偏差-方差" class="headerlink" title="正则化和偏差/方差"></a>正则化和偏差/方差</h2><p>在我们在训练模型的过程中，一般会使用一些正则化方法来防止过拟合。但是我们可能会正则化的程度太高或太小了，即在选择$λ$的值时也需要思考与刚才选择多项式模型次数$d$类似的问题。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231120073355276.png" alt="image-20231120073355276"></p><p>我们选择一系列的想要测试的 $\lambda$ 值，通常是 0-10之间的呈现2倍关系的值（如：$0,0.01,0.02,0.04,0.08,0.15,0.32,0.64,1.28,2.56,5.12,10$共12个）。 我们同样把数据分为训练集、交叉验证集和测试集。</p><p><br/></p><p>和选择多项式模型次数d相似，选择$\lambda$的方法为：</p><ol><li>使用训练集训练出12个不同程度正则化的模型，得到12个$\theta$</li><li>用12个模型分别对交叉验证集计算的出交叉验证误差$J_{train}(\theta)-y$</li><li>选择得出交叉验证误差$J_{train}(\theta)-y$<strong>最小</strong>的模型</li><li>运用步骤3中选出模型对测试集计算得出推广误差，我们也可以同时将训练集和交叉验证集模型的代价函数误差与λ的值绘制在一张图表上：</li></ol><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231120183013857.png" alt="image-20231120183013857" style="zoom:80%;" /></p><ul><li>当 $\lambda$ 较小时，训练集误差较小（过拟合）而交叉验证集误差较大\</li><li>随着 $\lambda$ 的增加，训练集误差不断增加（欠拟合），而交叉验证集误差则是先减小后增加</li></ul><p><br/></p><hr><h2 id="学习曲线"><a href="#学习曲线" class="headerlink" title="学习曲线"></a>学习曲线</h2><p>使用学习曲线来判断某一个学习算法是否处于偏差、方差问题，学习曲线是学习算法的一个很好的<strong>合理检验</strong>（<strong>sanity check</strong>），将<strong>训练集误差和交叉验证集误差作为训练集样本数量（$m$）的函数</strong>绘制的图表。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231120183324042.png" alt="image-20231120183324042"></p><p>即，如果我们有100行数据，我们从1行数据开始，逐渐学习更多行的数据。思想是：当训练较少行数据的时候，训练的模型将能够非常完美地适应较少的训练数据，但是训练出来的模型却不能很好地适应交叉验证集数据或测试集数据。</p><p>所以随着样本数量m的增大，训练集误差是逐渐增加的，而验证集误差在下降，因为得到的模型逐渐拟合</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231120184003839.png" alt="image-20231120184003839"></p><p>如何利用学习曲线识别<strong>高偏差/欠拟合</strong>：作为例子，我们尝试用一条直线来适应下面的数据，可以看出，无论训练集有多么大误差都不会有太大改观：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231120184100908.png" alt="image-20231120184100908"></p><p><br/></p><p>如何利用学习曲线识别高方差/过拟合：假设我们使用一个非常高次的多项式模型，并且正则化非常小，可以看出，当交叉验证集误差远大于训练集误差时，往训练集增加更多数据可以提高模型的效果。</p><p>也就是说在<strong>高方差/过拟合</strong>的情况下，增加更多数据到训练集可能可以提高算法效果。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>高偏差(欠拟合)：</p><ul><li>尝试获得更多的特征</li><li>尝试增加多项式特征</li><li>尝试减少正则化程度λ</li></ul><p><br/></p><p>高方差(过拟合)：</p><ul><li>获得更多的训练样本</li><li>尝试减少特征的数量</li><li>尝试增加正则化程度λ</li></ul><p><br/></p><p>对于神经网络而言，使用较小的神经网络，类似于参数较少的情况，容易导致高偏差和欠拟合，但计算代价较小使用较大的神经网络，类似于参数较多的情况，容易导致高方差和过拟合，虽然计算代价比较大，但是可以通过正则化手段来调整而更加适应数据。<br>    <br/><br>通常选择<strong>较大的神经网络并采用正则化处理</strong>会比采用较小的神经网络效果要好。</p><p>对于神经网络中的隐藏层的层数的选择，通常<strong>从一层开始逐渐增加层数</strong>，为了更好地作选择，可以把数据分为训练集、交叉验证集和测试集，针对不同隐藏层层数的神经网络训练神经网络，然后选择交叉验证集代价最小的神经网络。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.5 ex4：Neural Networks Learning</title>
      <link href="/post/36821.html"/>
      <url>/post/36821.html</url>
      
        <content type="html"><![CDATA[<h1 id="ex4：Neural-Networks-Learning"><a href="#ex4：Neural-Networks-Learning" class="headerlink" title="ex4：Neural Networks Learning"></a>ex4：Neural Networks Learning</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在上一个练习中，您实现了神经网络的前馈传播，并利用我们提供的权重预测了手写数字。在本练习中，您将使用反向传播算法来学习神经网络的参数。</p><p>必要的文件如下：</p><ul><li><code>ex4.py</code> - python脚本，引导你完成练习</li><li><code>ex4data1.mat</code> - 手写数字的训练集</li><li><code>ex4weights.mat</code> - 练习4的神经网络参数</li><li><code>displayData.py</code> - 用于帮助可视化数据集的函数</li><li><code>sigmoid.py</code> - Sigmoid函数</li><li><code>computeNumericalGradient.py</code> - 数值计算梯度的函数 </li><li><code>checkNNGradients.py</code> - 用于检查梯度的函数</li><li><code>debugInitializeWeights.py</code> - 用于初始化权重的函数</li><li><code>predict.py</code> - 神经网络预测函数</li></ul><p>需要完成的文件：</p><ul><li><code>sigmoidGradient.py</code> - 计算Sigmoid函数的梯度</li><li><code>randInitializeWeights.py</code> - 随机初始化权重 </li><li><code>nnCostFunction.py</code>- 神经网络成本函数</li></ul><p><br/></p><hr><h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> scipy.io <span class="keyword">as</span> scio</span><br><span class="line"><span class="keyword">import</span> scipy.optimize <span class="keyword">as</span> opt</span><br><span class="line"><span class="keyword">import</span> displayData <span class="keyword">as</span> dd</span><br><span class="line"><span class="keyword">import</span> nncostfunction <span class="keyword">as</span> ncf</span><br><span class="line"><span class="keyword">import</span> sigmoidgradient <span class="keyword">as</span> sg</span><br><span class="line"><span class="keyword">import</span> randInitializeWeights <span class="keyword">as</span> rinit</span><br><span class="line"><span class="keyword">import</span> checkNNGradients <span class="keyword">as</span> cng</span><br><span class="line"><span class="keyword">import</span> predict <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置本部分练习中要使用的参数</span></span><br><span class="line">input_layer_size = <span class="number">400</span>  <span class="comment"># 20x20 的手写数字图像</span></span><br><span class="line">hidden_layer_size = <span class="number">25</span>  <span class="comment"># 25 个隐藏层单元</span></span><br><span class="line">num_labels = <span class="number">10</span>         <span class="comment"># 10 个标签，从 0 到 9</span></span><br><span class="line">                        <span class="comment"># 注意我们将 &quot;0&quot; 映射为标签 10</span></span><br></pre></td></tr></table></figure><p><br/></p><hr><h2 id="读取和绘图"><a href="#读取和绘图" class="headerlink" title="读取和绘图"></a>读取和绘图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================== 第一部分：加载和可视化数据 =====================</span></span><br><span class="line"><span class="comment"># 本部分练习首先通过加载和可视化数据集开始。</span></span><br><span class="line"><span class="comment"># 你将使用一个包含手写数字的数据集。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载训练数据</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;加载和可视化数据...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">data = scio.loadmat(<span class="string">&#x27;ex4data1.mat&#x27;</span>)</span><br><span class="line">X = data[<span class="string">&#x27;X&#x27;</span>]</span><br><span class="line">y = data[<span class="string">&#x27;y&#x27;</span>].flatten()</span><br><span class="line">m = y.size</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机选择 100 个数据点进行显示</span></span><br><span class="line">rand_indices = np.random.permutation(<span class="built_in">range</span>(m))</span><br><span class="line">selected = X[rand_indices[<span class="number">0</span>:<span class="number">100</span>], :]</span><br><span class="line"></span><br><span class="line">dd.display_data(selected)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;程序暂停。按 ENTER 键继续&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>和ex3练习部分一模一样，效果如下：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231119063305322.png" alt="image-20231119063305322" style="zoom:67%;" /></p><p><br/></p><hr><h2 id="加载参数"><a href="#加载参数" class="headerlink" title="加载参数"></a>加载参数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================== 第二部分：加载参数 =====================</span></span><br><span class="line"><span class="comment"># 在本部分的练习中，我们加载一些预初始化的神经网络参数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;加载保存的神经网络参数...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">data = scio.loadmat(<span class="string">&#x27;ex4weights.mat&#x27;</span>)</span><br><span class="line">theta1 = data[<span class="string">&#x27;Theta1&#x27;</span>]  </span><br><span class="line">theta2 = data[<span class="string">&#x27;Theta2&#x27;</span>]</span><br><span class="line"></span><br><span class="line">nn_params = np.concatenate([theta1.flatten(), theta2.flatten()])</span><br></pre></td></tr></table></figure><p><code>np.concatenate()</code>是是 <code>NumPy</code> 库中用于连接（拼接）数组的函数。它可以沿指定的轴连接两个或多个数组</p><p>这行代码的作用是将两个矩阵 <code>theta1</code> 和 <code>theta2</code> 展平（flatten），然后使用 <code>NumPy</code> 的 <code>concatenate</code> 函数将它们连接成一个一维数组 <code>nn_params</code>。</p><p>这种展平和连接的操作是为了在优化算法中更方便地处理参数。</p><p><br/></p><hr><h2 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h2><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================== 第三部分：计算成本（前向传播） =====================</span></span><br><span class="line"><span class="comment"># 对于神经网络，你应该首先开始实现神经网络的前向传播部分，该部分仅返回成本。你应该完成nncostfunction.py中的代码，以返回成本。</span></span><br><span class="line"><span class="comment"># 在实现前向传播计算成本后，可以通过验证使用固定的调试参数是否得到与我们相同的成本来确认你的实现是否正确。</span></span><br><span class="line"><span class="comment"># 我们建议首先实现不带正则化的前向传播成本，这样你可以更容易进行调试。稍后，在第四部分中，你将实现带正则化的成本。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;使用神经网络进行前向传播...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 权重正则化参数（这里我们将其设置为 0）。</span></span><br><span class="line">lmd = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">cost, grad = ncf.nn_cost_function(nn_params, input_layer_size, hidden_layer_size, num_labels, X, y, lmd)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;使用参数（从ex4weights加载）的成本: &#123;:0.6f&#125;\n(这个值应该约为0.287629)&#x27;</span>.<span class="built_in">format</span>(cost))</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;程序暂停。按 ENTER 键继续&#x27;</span>)</span><br></pre></td></tr></table></figure><p><br/></p><p>接下来需要完成<code>nncostfunction.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sigmoid <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">参数：</span></span><br><span class="line"><span class="string">    nn_params: 一维数组，包含神经网络的所有参数。</span></span><br><span class="line"><span class="string">    input_layer_size: 输入层的大小。</span></span><br><span class="line"><span class="string">    hidden_layer_size: 隐藏层的大小。</span></span><br><span class="line"><span class="string">    num_labels: 输出层的大小。</span></span><br><span class="line"><span class="string">    X: 输入数据，大小为(m, input_layer_size)。</span></span><br><span class="line"><span class="string">    y: 标签，大小为(m,)。</span></span><br><span class="line"><span class="string">    lmd: 正则化参数。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nn_cost_function</span>(<span class="params">nn_params, input_layer_size, hidden_layer_size, num_labels, X, y, lmd</span>):</span></span><br><span class="line">    <span class="comment"># 将nn_params重新调整为参数theta1和theta2，即我们两层神经网络的权重2维数组</span></span><br><span class="line"></span><br><span class="line">    theta1 = nn_params[:hidden_layer_size * (input_layer_size + <span class="number">1</span>)].reshape(hidden_layer_size, input_layer_size + <span class="number">1</span>)</span><br><span class="line">    theta2 = nn_params[hidden_layer_size * (input_layer_size + <span class="number">1</span>):].reshape(num_labels, hidden_layer_size + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    m = y.size</span><br><span class="line"></span><br><span class="line">    <span class="comment">#需要返回以下值</span></span><br><span class="line">    cost = <span class="number">0</span></span><br><span class="line">    theta1_grad = np.zeros(theta1.shape)  <span class="comment"># 25 x 401</span></span><br><span class="line">    theta2_grad = np.zeros(theta2.shape)  <span class="comment"># 10 x 26</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><br/></p><hr><h3 id="前向传播"><a href="#前向传播" class="headerlink" title="前向传播"></a>前向传播</h3><p>根据反向传播的步骤，先进行前向传播</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第1部分：对神经网络进行前向传播，并将成本存储在变量cost中。</span></span><br><span class="line">    <span class="comment"># 在实现第1部分后，你可以通过运行ex4.py来验证你的成本函数计算是否正确。</span></span><br><span class="line">    <span class="comment"># ===================================================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将 X 添加偏置项</span></span><br><span class="line">    a1 = np.c_[np.ones((m, <span class="number">1</span>)), X]</span><br><span class="line">    <span class="comment"># 计算第一层到第二层的输出</span></span><br><span class="line">    z2 = np.dot(a1, theta1.T)</span><br><span class="line">    a2 = sigmoid(z2)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在第二层添加偏置项</span></span><br><span class="line">    a2 = np.c_[np.ones((m, <span class="number">1</span>)), a2]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算第二层到输出层的输出</span></span><br><span class="line">    z3 = np.dot(a2, theta2.T)</span><br><span class="line">    a3 = sigmoid(z3)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#将原始的整数标签 y 转换为独热编码（one-hot encoding）的形式</span></span><br><span class="line">    y_matrix = np.eye(num_labels)[y - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算成本（不包含正则化）</span></span><br><span class="line">    J = np.<span class="built_in">sum</span>(-y_matrix * np.log(a3) - (<span class="number">1</span> - y_matrix) * np.log(<span class="number">1</span> - a3)) / m</span><br></pre></td></tr></table></figure><p>代价函数(不含正则)：</p><script type="math/tex; mode=display">J\left(\theta \right)=-\frac{1}{m}\left[\sum_\limits{i=1}^{m}{y}^{(i)}\log{h_\theta({x}^{(i)})}+\left(1-{y}^{(i)}\right)log\left(1-h_\theta\left({x}^{(i)}\right)\right)\right]+\frac{\lambda}{2m}\sum_\limits{j=1}^{n}{\theta_j}^{2}</script><p>这里需要重点关注的是：<code>y_matrix = np.eye(num_labels)[y - 1]</code></p><p>具体来说：</p><ul><li><code>np.eye(num_labels)</code> 创建一个大小为 <code>(num_labels, num_labels)</code> 的单位矩阵，其中对角线上的元素为1，其余为0。</li><li><code>[y - 1]</code> 使用 <code>y - 1</code> 作为索引，将每个样本的整数标签 <code>y</code> 映射到对应的独热编码向量。</li></ul><p>这样，对于每个样本，原始的整数标签被转换为一个长度为 <code>num_labels</code> 的向量，其中只有标签对应的位置为1，其余位置为0。这个独热编码向量可以用于表示样本属于哪个类别。</p><p>举一个例子来说明独热编码，如果有3个类别（<code>num_labels = 3</code>）：</p><ul><li>原始标签 <code>y = 2</code> 会被转换为独热编码 <code>[0, 1, 0]</code>。</li><li>原始标签 <code>y = 1</code> 会被转换为独热编码 <code>[1, 0, 0]</code>。</li><li>原始标签 <code>y = 3</code> 会被转换为独热编码 <code>[0, 0, 1]</code>。</li></ul><p><br/></p><p>在神经网络:表述中，我们提到过，在分类问题中，神经网络的输出结果应该这种形式：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231113064238209.png" alt="image-20231113064238209"></p><p>使用独热编码，可以将原本大小为(m,1)大小的y数组，扩展到(m,m)大小，每一行都只在其正确结果未知是’1’,其余为0，让矩阵计算非常方便</p><p><br/></p><hr><h3 id="反向传播-1"><a href="#反向传播-1" class="headerlink" title="反向传播"></a>反向传播</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第二部分：实现反向传播算法以计算梯度theta1_grad和theta2_grad。</span></span><br><span class="line">    <span class="comment"># 在theta1_grad和theta2_grad中返回成本函数对theta1和theta2的偏导数。</span></span><br><span class="line">    <span class="comment"># 在实现第二部分后，你可以通过运行checkNNGradients来检查你的实现是否正确。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ======================== 反向传播 ========================</span></span><br><span class="line">    <span class="comment"># 计算误差</span></span><br><span class="line">    delta3 = a3 - y_matrix</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算第二层的误差</span></span><br><span class="line">    delta2 = np.dot(delta3, theta2) * (a2 * (<span class="number">1</span> - a2))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 去除第二层的偏置项</span></span><br><span class="line">    delta2 = delta2[:, <span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算梯度</span></span><br><span class="line">    theta2_grad = np.dot(delta3.T, a2) / m</span><br><span class="line">    theta1_grad = np.dot(delta2.T, a1) / m</span><br></pre></td></tr></table></figure><p>首先，先复习一下反向传播的公式：</p><script type="math/tex; mode=display">\delta^{(l)}=(\Theta^{(l)})^{T}\delta^{(l+1)}\ast g'(z^{(l)})</script><script type="math/tex; mode=display">\frac{\partial J}{\partial \Theta^{(l)}} = \delta^{(l+1)} \cdot a^{(l)T}</script><p>在代码中，实现起来是比较简单的，</p><p><code>delta3 = a3 - y_matrix</code>：最后一层，即输出层的误差delta，直接用预测值减去真实值可求得</p><p><code>delta2 = np.dot(delta3, theta2) * (a2 * (1 - a2))</code>：隐藏层的误差，用$\Theta^{(2)}\delta^3<em>g’(z^{(2)})$可求而对sigmoid函数求导可知，$$g’(x)=x</em>(1-x)$$代入可得$\delta^{(2)}$</p><p><code>delta2 = delta2[:, 1:]</code>：去掉$\delta^{(2)}$的偏置项，这是因为偏置项不与前一层的激活值相连，所以其误差传播不需要乘以权重，简而言之，偏置的项在$a^1$中根本就找不到对应的激活函数</p><p><code>theta1_grad = np.dot(delta2.T, a1) / m</code>：套用公式计算出$\Theta_1$的梯度,然后除以$m$，这是为了对梯度项取平均。在神经网络的训练中，通常使用 $(m)$ 表示训练样本的数量。这里的目的是确保梯度计算<strong>不过于依赖于训练集的规模</strong>。</p><p><br/></p><hr><h3 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第三部分：实现带有成本函数和梯度的正则化。</span></span><br><span class="line">    <span class="comment"># 你可以围绕反向传播的代码来实现这一点。</span></span><br><span class="line">    <span class="comment"># 也就是说，你可以分别计算正则化的梯度，然后将它们添加到第二部分中的theta1_grad和theta2_grad中。</span></span><br><span class="line">    <span class="comment"># ======================== 正则化 ========================</span></span><br><span class="line">    <span class="comment"># 不包含偏置项的参数</span></span><br><span class="line">    theta1_nobias = theta1[:, <span class="number">1</span>:]</span><br><span class="line">    theta2_nobias = theta2[:, <span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算正则化项</span></span><br><span class="line">    regularization = (lmd / (<span class="number">2</span> * m)) * (np.<span class="built_in">sum</span>(theta1_nobias ** <span class="number">2</span>) + np.<span class="built_in">sum</span>(theta2_nobias ** <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加上正则化项的成本</span></span><br><span class="line">    cost = J + regularization</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算正则化项对梯度的贡献</span></span><br><span class="line">    theta1_grad[:, <span class="number">1</span>:] += (lmd / m) * theta1_nobias</span><br><span class="line">    theta2_grad[:, <span class="number">1</span>:] += (lmd / m) * theta2_nobias</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将梯度展开为一维数组</span></span><br><span class="line">    grad = np.concatenate([theta1_grad.flatten(), theta2_grad.flatten()])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cost, grad</span><br></pre></td></tr></table></figure><p>正则化的公式为：</p><script type="math/tex; mode=display">J\left(\theta \right)=-\frac{1}{m}\left[\sum_\limits{i=1}^{m}{y}^{(i)}\log{h_\theta({x}^{(i)})}+\left(1-{y}^{(i)}\right)log\left(1-h_\theta\left({x}^{(i)}\right)\right)\right]+\frac{\lambda}{2m}\sum_\limits{j=1}^{n}{\theta_j}^{2}</script><p>注意：这里的<code>i</code>和<code>j</code>都是从1开始，正则化的时候是不含偏置项的</p><p>梯度下降的正则化公式如下：</p><script type="math/tex; mode=display">D_{ij}^{(l)} :=\frac{1}{m}\Delta_{ij}^{(l)}+\lambda\Theta_{ij}^{(l)}</script><p>实际上，正如同代码一样，这两步是分开进行的，在反向传播中，最后计算梯度的时候就除以了m</p><p>而在正则化中，<code>theta1_grad[:, 1:] += (lmd / m) * theta1_nobias</code>就是对$\Theta$的正则化，这里乘的是$\frac{\lambda}{m}$，而不是公式上的$\lambda$，实际上这是对正则化的缩放，并不违背原理</p><p><br/></p><hr><p>继续运行<code>ex4.py</code>，查看正则化是否正确</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================== 第四部分：实现正则化 =====================</span></span><br><span class="line"><span class="comment"># 一旦你的成本函数实现正确，现在你应该继续实现带有正则化的成本。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;检查成本函数（带有正则化）...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 权重正则化参数（这里我们将其设置为 1）。</span></span><br><span class="line">lmd = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">cost, grad = ncf.nn_cost_function(nn_params, input_layer_size, hidden_layer_size, num_labels, X, y, lmd)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;使用参数（从ex4weights加载）的成本: &#123;:0.6f&#125;\n(这个值应该约为0.383770)&#x27;</span>.<span class="built_in">format</span>(cost))</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;程序暂停。按 ENTER 键继续&#x27;</span>)</span><br></pre></td></tr></table></figure><p>调用写好的<code>nn_cost_function.py</code>，观察结果是否正确</p><p><br/></p><hr><h2 id="Sigmoid梯度"><a href="#Sigmoid梯度" class="headerlink" title="Sigmoid梯度"></a>Sigmoid梯度</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================== 第五部分：Sigmoid梯度 =====================</span></span><br><span class="line"><span class="comment"># 在开始实现神经网络之前，你将首先实现 sigmoid 函数的梯度。你应该完成 sigmoidGradient.py 文件中的代码</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;评估 sigmoid 梯度...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">g = sg.sigmoid_gradient(np.array([-<span class="number">1</span>, -<span class="number">0.5</span>, <span class="number">0</span>, <span class="number">0.5</span>, <span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;在 [-1  -0.5  0  0.5  1] 处评估的 sigmoid 梯度:\n&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(g))</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;程序暂停。按 ENTER 键继续&#x27;</span>)</span><br></pre></td></tr></table></figure><p>编写<code>sigmoid_gradient.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid_gradient</span>(<span class="params">z</span>):</span></span><br><span class="line">    g = np.zeros(z.shape)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 说明：计算 z 中每个值的 sigmoid 函数梯度。</span></span><br><span class="line">    <span class="comment"># 可以使用已导入的 sigmoid 函数。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算 sigmoid 函数的值</span></span><br><span class="line">    s = sigmoid(z)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算梯度</span></span><br><span class="line">    g = s * (<span class="number">1</span> - s)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ===========================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> g</span><br></pre></td></tr></table></figure><p>很简单，已知$g’(x)=x*(1-x)$,代码表示出来即可</p><hr><h2 id="初始化参数"><a href="#初始化参数" class="headerlink" title="初始化参数"></a>初始化参数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================== 第六部分：初始化参数 =====================</span></span><br><span class="line"><span class="comment"># 在本部分的练习中，你将开始实现一个能够对数字进行分类的两层神经网络。你将从实现一个初始化神经网络权重的函数（randInitializeWeights.m）开始。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;初始化神经网络参数...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">initial_theta1 = rinit.rand_initialization(input_layer_size, hidden_layer_size)</span><br><span class="line">initial_theta2 = rinit.rand_initialization(hidden_layer_size, num_labels)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 展开参数</span></span><br><span class="line">initial_nn_params = np.concatenate([initial_theta1.flatten(), initial_theta2.flatten()])</span><br></pre></td></tr></table></figure><p>需要我们编写<code>rand_initialization.py</code>，以实现<code>theta</code>矩阵的初始化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rand_initialization</span>(<span class="params">l_in, l_out</span>):</span></span><br><span class="line">    <span class="comment"># 创建一个初始权重矩阵，包含偏置单元的参数</span></span><br><span class="line">    w = np.zeros((l_out, <span class="number">1</span> + l_in))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 说明：随机初始化 w，打破神经网络训练中的对称性。</span></span><br><span class="line">    <span class="comment"># 注意：w 的第一列对应于偏置单元的参数。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用 np.uniform 随机初始化权重，范围在[-epsilon, epsilon]之间</span></span><br><span class="line">    epsilon_init = <span class="number">0.12</span></span><br><span class="line">    w = np.random.uniform(-epsilon_init, epsilon_init, size=(l_out, <span class="number">1</span> + l_in))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ===========================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> w</span><br></pre></td></tr></table></figure><hr><h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================== 第七部分：训练NN =====================</span></span><br><span class="line"><span class="comment"># 你现在已经实现了训练神经网络所需的所有代码。要训练你的神经网络，我们现在将使用 &#x27;opt.fmin_cg&#x27;。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;训练神经网络... &#x27;</span>)</span><br><span class="line"></span><br><span class="line">lmd = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cost_func</span>(<span class="params">p</span>):</span></span><br><span class="line">    <span class="keyword">return</span> ncf.nn_cost_function(p, input_layer_size, hidden_layer_size, num_labels, X, y, lmd)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grad_func</span>(<span class="params">p</span>):</span></span><br><span class="line">    <span class="keyword">return</span> ncf.nn_cost_function(p, input_layer_size, hidden_layer_size, num_labels, X, y, lmd)[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">nn_params, *unused = opt.fmin_cg(cost_func, fprime=grad_func, x0=nn_params, disp=<span class="literal">True</span>, full_output=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 nn_params 中恢复 theta1 和 theta2</span></span><br><span class="line">theta1 = nn_params[:hidden_layer_size * (input_layer_size + <span class="number">1</span>)].reshape(hidden_layer_size, input_layer_size + <span class="number">1</span>)</span><br><span class="line">theta2 = nn_params[hidden_layer_size * (input_layer_size + <span class="number">1</span>):].reshape(num_labels, hidden_layer_size + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;程序暂停。按 ENTER 键继续&#x27;</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="可视化权重"><a href="#可视化权重" class="headerlink" title="可视化权重"></a>可视化权重</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================== 第十部分：可视化权重 =====================</span></span><br><span class="line"><span class="comment"># 你现在可以通过显示隐藏单元来“可视化”神经网络正在学习什么特征，以查看神经网络学到了什么样的数据特征</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;可视化神经网络...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">dd.display_data(theta1[:, <span class="number">1</span>:])</span><br><span class="line">plt.show()</span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;程序暂停。按 ENTER 键继续&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>是一副模糊的图像：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231119083857840.png" alt="image-20231119083857840" style="zoom:67%;" /></p><hr><h2 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================== 第十一部分：实现预测 =====================</span></span><br><span class="line"><span class="comment"># 在训练完神经网络后，我们想要使用它来预测标签。现在你将实现 &#x27;predict&#x27; 函数，使用神经网络预测训练集的标签。这让你计算训练集准确性。</span></span><br><span class="line"></span><br><span class="line">pred = pd.predict(theta1, theta2, X)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;训练集准确性: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(np.mean(pred == y)*<span class="number">100</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;ex4 完成。按 ENTER 键退出&#x27;</span>)</span><br></pre></td></tr></table></figure><p>训练集准确性: 99.7</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.0.神经网络：学习</title>
      <link href="/post/65281.html"/>
      <url>/post/65281.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="神经网络：学习"><a href="#神经网络：学习" class="headerlink" title="神经网络：学习"></a>神经网络：学习</h1><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>假设神经网络的训练样本有$m$个，每个包含一组输入$x$和一组输出信号$y$，$L$表示神经网络层数，$S_I$表示每层的<strong>神经元</strong>个数($S_l$表示在$l$层的神经元个数)，$S_L$代表最后一层中处理单元的个数。</p><p>将神经网络的分类定义为两种情况：二类分类和多类分类，</p><p>二类分类：$S_L=1, y=0\, or\, 1$表示哪一类；</p><p>$K$类分类：$S_L=k, y_i = 1$表示分到第$i$类；$(k&gt;2)$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231116211336769.png" alt="image-20231116211336769"></p><p>回顾逻辑回归问题中的代价函数：</p><script type="math/tex; mode=display">J\left(\theta \right)=-\frac{1}{m}\left[\sum_\limits{i=1}^{m}{y}^{(i)}\log{h_\theta({x}^{(i)})}+\left(1-{y}^{(i)}\right)log\left(1-h_\theta\left({x}^{(i)}\right)\right)\right]+\frac{\lambda}{2m}\sum_\limits{j=1}^{n}{\theta_j}^{2}</script><p>在逻辑回归中，我们只有一个输出变量，也只有一个因变量$y$，但是在神经网络中，我们可以有很多输出变量</p><p><br/></p><p>而在神经网络中，输出层可以有多个输出，假设输出层的神经元数量为<strong>K</strong>，神经网络的代价函数如下：</p><script type="math/tex; mode=display">J(\Theta) = -\frac{1}{m} \sum\limits_{i=1}^{m} \sum\limits_{k=1}^{K} y_k^{(i)} \log \left(h_\Theta(x^{(i)})_k\right) + \left(1 - y_k^{(i)}\right) \log \left(1 - h_\Theta(x^{(i)})_k\right) + \frac{\lambda}{2m} \sum\limits_{l=1}^{L-1} \sum\limits_{i=1}^{s_l} \sum\limits_{j=1}^{s_{l+1}} \left(\Theta_{ji}^{(l)}\right)^2</script><ul><li>$m$ 是训练样本的数量。</li><li>$(y_k^{(i)})$ 是样本 $(i)$ 对于类别 $(k)$ 的实际标签。</li><li>$(\hat{y}_k^{(i)})$ 是模型对样本 $(i)$ 对于类别 $(k)$ 的预测。</li><li>$(\Theta^{(l)})$ 是第 $(l)$ 层到第 $(l+1)$ 层的权重矩阵。</li><li>$L$ 是神经网络的层数。</li><li>$s_l$ 是第 $(l)$ 层的神经元数量。</li><li>$\lambda$是正则化参数。</li></ul><p>这个看起来复杂很多的代价函数背后的思想还是一样的，我们希望通过代价函数来观察算法预测的结果与真实情况的误差有多大，最后的代价函数是要计算<strong>所有输出层的代价</strong></p><p>唯一不同的是，对于每一行特征，我们都会给出$K$个预测，基本上我们可以利用循环，对每一行特征都预测$K$个不同结果，然后在利用循环在$K$个预测中选择可能性最高的一个，将其与$y$中的实际数据进行比较。</p><p><br/></p><hr><h2 id="反向传播算法"><a href="#反向传播算法" class="headerlink" title="反向传播算法"></a>反向传播算法</h2><p>之前我们在计算神经网络预测结果的时候我们采用了一种正向传播方法，我们从第一层开始正向一层一层进行计算，直到最后一层的$h_{\theta}\left(x\right)$</p><p>在上一个实验：<code>6.5 ex3：Multi-class Classifification and Neural Networks</code>中，就使用了正向传播方法，很轻松的识别出了手写数字，在ex3中，权重矩阵$\theta$是已经被训练好的，实验的时候只需要调用就行，但是，在实际应用中，权重矩阵的参数我们显然是需要自己进行训练的，这就引出了<strong>反向传播算法</strong></p><p><br/></p><p>BP（反向传播）的主要目的是通过调整神经网络的权重和偏差，使网络在训练数据上的预测更接近实际标签，从而最小化代价函数。代价函数是衡量网络输出与实际标签之间差异的指标，BP通过<strong>梯度下降</strong>的方式降低这个差异。</p><p>既然BP是通过梯度下降来降低这个差异，那么需要先求代价函数$J(\Theta)$的偏导数$\frac{\partial}{\partial\Theta^{(l)}_{ij}}J\left(\Theta\right)$</p><p>举例来说明反向传播算法：假设我们的训练集只有一个样本$\left({x}^{(1)},{y}^{(1)}\right)$，我们的神经网络是一个四层的神经网络，如图：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231116223513082.png" alt="image-20231116223513082"></p><p><br/></p><hr><h3 id="随机初始化"><a href="#随机初始化" class="headerlink" title="随机初始化"></a>随机初始化</h3><p>任何优化算法都需要一些初始的参数。到目前为止我们都是初始所有参数为0，这样的初始方法对于逻辑回归来说是可行的，但是对于神经网络来说是不可行的。如果我们令所有的初始参数都为0，这将意味着我们第二层的所有激活单元都会有相同的值。同理，如果我们初始所有的参数都为一个非0的数，结果也是一样的。</p><p>我们通常假设初始参数为正负$ε$之间的随机值，假设我们要随机初始一个尺寸为10×11的参数矩阵，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">epsilon = <span class="number">0.01</span></span><br><span class="line">theta = np.random.uniform(low=-epsilon, high=epsilon, size=(<span class="number">10</span>, <span class="number">11</span>))</span><br></pre></td></tr></table></figure><p><br/></p><hr><h3 id="前向传播"><a href="#前向传播" class="headerlink" title="前向传播"></a>前向传播</h3><p>先用前向传播算法算出代价$J(\Theta)$：</p><p>神经网络的正向传播计算如下：</p><ol><li><p>输入层（第1层）：<br>$[ a^{(1)} = x^{(1)} ]$</p></li><li><p>隐藏层1（第2层）：<br>$[ z^{(2)} = \Theta^{(1)}a^{(1)} ]$<br>$[ a^{(2)} = g(z^{(2)}) ]$</p><p>其中，$(g)$ 是激活函数，$(\Theta^{(1)})$ 是连接输入层和隐藏层1的权重矩阵。</p></li><li><p>隐藏层2（第3层）：<br>$[ z^{(3)} = \Theta^{(2)}a^{(2)} ]$<br>$[ a^{(3)} = g(z^{(3)}) ]$</p><p>其中，$(\Theta^{(2)})$ 是连接隐藏层1和隐藏层2的权重矩阵。</p></li><li><p>输出层（第4层）：<br>$[ z^{(4)} = \Theta^{(3)}a^{(3)} ]$<br>$[ a^{(4)} = h_\Theta(x^{(1)}) = g(z^{(4)}) ]$</p><p>其中，$(\Theta^{(3)})$ 是连接隐藏层2和输出层的权重矩阵，$(h_\Theta(x^{(1)}))$ 是神经网络的输出。</p></li></ol><p><br/></p><hr><h3 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h3><p>接下来，使用反向传播算法，首先，我们定义误差项为</p><script type="math/tex; mode=display">\delta^{(L)} = \frac{\partial J}{\partial z^{(L)}}</script><p>其中$z^{(L)}$是输出层的净输入。通过链式法则，我们可以将$\delta^{(L)}$传播到前一层，形成对每个参数的偏导数。这样，我们可以使用梯度下降等优化算法来调整网络参数，以最小化损失函数</p><p>而输出层的误差显然是：$\delta^{(4)}=a^{(4)}-y$</p><p>证明如下：</p><p>首先，我们有输出层的激活值 $(a^{(4)})$ 和损失函数 $(J)$ 之间的关系。在分类问题中，常用的损失函数是交叉熵损失函数。假设我们的网络是针对二分类问题，输出层使用 $sigmoid$ 激活函数，那么交叉熵损失函数可以表示为：</p><script type="math/tex; mode=display">J(y, a^{(4)}) = - y \log(a^{(4)}) - (1 - y) \log(1 - a^{(4)})</script><p>其中，$(y)$ 是实际标签（0或1），$a^{(4)}$ 是输出层的激活值。</p><p>接下来，我们来计算输出层激活值 $(a^{(4)})$ 对净输入值 $(z^{(4)})$ 的偏导数。假设输出层使用 $sigmoid$ 激活函数，有 $(a^{(4)}) = g(z^{(4)}))$，其中 $(g(\cdot))$ 是 $sigmoid$ 函数。$sigmoid$ 函数的导数可以表示为 </p><script type="math/tex; mode=display">(g'(z^{(4)}) = a^{(4)} \cdot (1 - a^{(4)}))。</script><p>应用链式法则：</p><script type="math/tex; mode=display">\frac{\partial J}{\partial z^{(4)}} = \frac{\partial J}{\partial a^{(4)}} \cdot \frac{\partial a^{(4)}}{\partial z^{(4)}}</script><p>将损失函数对激活值的偏导数代入：</p><script type="math/tex; mode=display">\frac{\partial J}{\partial z^{(4)}} = -(\frac{y}{a^{(4)}} - \frac{(1-y)}{(1-a^{(4)})}) \cdot a^{(4)} \cdot (1 - a^{(4)})</script><p>化简上式：</p><script type="math/tex; mode=display">\frac{\partial J}{\partial z^{(4)}} = a^{(4)} - y</script><p>这个结果表示了输出层误差项与实际标签之间的差异，与损失函数对于输出层净输入值的偏导数是一致的。</p><p><br/></p><hr><p>然后计算上一层的误差项 ($\delta^{(3)}$)：</p><script type="math/tex; mode=display">\delta^{(3)} = \frac{\partial J}{\partial z^{(3)}}</script><p>使用链式法则，将 $(\frac{\partial J}{\partial z^{(3)}})$ 分解为两部分：</p><script type="math/tex; mode=display">\frac{\partial J}{\partial z^{(3)}} = \frac{\partial J}{\partial a^{(3)}} \cdot \frac{\partial a^{(3)}}{\partial z^{(3)}}</script><p>考虑激活函数的导数：</p><script type="math/tex; mode=display">\frac{\partial a^{(3)}}{\partial z^{(3)}} = g'\left(z^{(3)}\right)</script><p>将上述结果代入步骤2：</p><script type="math/tex; mode=display">\delta^{(3)} = \frac{\partial J}{\partial a^{(3)}} \cdot g'\left(z^{(3)}\right)</script><p><br/></p><hr><p>重点是计算$\frac{\partial J}{\partial a^{(3)}}$项：推论如下：</p><p>根据链式法则，有：</p><script type="math/tex; mode=display">\frac{\partial J}{\partial a^{(3)}} = \frac{\partial J}{\partial z^{(4)}} \cdot \frac{\partial z^{(4)}}{\partial a^{(3)}}</script><p>其中，$(z^{(4)})$ 是输出层的净输入值，而 $(a^{(3)})$ 是输出层的激活值。</p><p>我们知道 $\frac{\partial J}{\partial z^{(4)}} = \delta^{(4)}$，根据之前的讨论。接下来，我们需要计算 ($\frac{\partial z^{(4)}}{\partial a^{(3)}}$)，在一般的神经网络中，输出层的净输入值 ($z^{(4)}$) 与前一层的激活值 ($a^{(3)}$) 之间有以下关系：</p><script type="math/tex; mode=display"> z^{(4)} = \Theta^{(3)} \cdot a^{(3)}</script><p>其中，$(\Theta^{(3)})$ 是连接输出层和前一隐藏层的权重矩阵。对上式关于 $(a^{(3)})$ 求偏导数，得到：</p><script type="math/tex; mode=display">\frac{\partial z^{(4)}}{\partial a^{(3)}} = \Theta^{(3)}</script><p>现在，将这两个结果代入链式法则的表达式：</p><script type="math/tex; mode=display"> \frac{\partial J}{\partial a^{(3)}} = \delta^{(4)} \cdot \left(\Theta^{(3)}\right)^T</script><p>这就得到了</p><script type="math/tex; mode=display">\frac{\partial J}{\partial a^{(3)}} = \left(\Theta^{(3)}\right)^T \cdot \delta^{(4)}</script><p>这个结果表明，损失函数对于前一层的激活值的偏导数可以通过将输出层误差项与权重矩阵的转置相乘得到。这是误差反向传播算法中计算梯度的一部分</p><p> <br/></p><p>代入上述结果：</p><script type="math/tex; mode=display">\delta^{(3)} = \left(\Theta^{(3)}\right)^T \cdot \delta^{(4)} \cdot g'\left(z^{(3)}\right)</script><p><br/></p><hr><h3 id="计算梯度"><a href="#计算梯度" class="headerlink" title="计算梯度"></a>计算梯度</h3><p>通过上述方法可以算出所有误差的表达式：</p><script type="math/tex; mode=display">\delta^{(2)}=(\Theta^{(2)})^{T}\delta^{(3)}\ast g'(z^{(2)})</script><p>$\delta^{(1)}=0$   因为输入层是输入变量，不存在误差，我们有了所有的误差的表达式后，便可以计算权重矩阵的梯度</p><p><br/></p><p>权重矩阵梯度的具体推导：</p><p>假设我们有一个神经网络，其中 $(a^{(l)})$ 是第 $(l)$ 层的激活值（包括输入层），$(\Theta^{(l)})$ 是连接第 $(l)$ 层和第 $(l+1)$ 层的权重矩阵，$(\delta^{(l+1)})$ 是第 $(l+1)$ 层的误差项。</p><p>激活值和净输入的关系为：$(a^{(l+1)} = g(z^{(l+1)}))$</p><p>其中$，(g(\cdot))$ 是激活函数，$(z^{(l+1)})$ 是第 $(l+1)$ 层的<strong>净输入</strong></p><p>我们知道误差项的定义是：</p><script type="math/tex; mode=display">\delta^{(l+1)} = \frac{\partial J}{\partial z^{(l+1)}}</script><p>现在，我们来计算损失函数对于第 $(l)$ 层的权重矩阵 $(\Theta^{(l)})$ 的偏导数，即<strong>梯度</strong>。使用链式法则：</p><script type="math/tex; mode=display">\frac{\partial J}{\partial \Theta^{(l)}} = \frac{\partial J}{\partial z^{(l+1)}} \cdot \frac{\partial z^{(l+1)}}{\partial \Theta^{(l)}}</script><p>我们知道 $(\frac{\partial J}{\partial z^{(l+1)}} = \delta^{(l+1)})$，然后考虑 $(z^{(l+1)})$ 与权重矩阵的关系：</p><script type="math/tex; mode=display">z^{(l+1)} = \Theta^{(l)} \cdot a^{(l)}</script><p>对上式对 $(\Theta^{(l)})$ 求偏导数得到：</p><script type="math/tex; mode=display">\frac{\partial z^{(l+1)}}{\partial \Theta^{(l)}} = a^{(l)}</script><p>现在，将上述结果代入梯度计算的表达式：</p><script type="math/tex; mode=display">\frac{\partial J}{\partial \Theta^{(l)}} = \delta^{(l+1)} \cdot \frac{\partial z^{(l+1)}}{\partial \Theta^{(l)}} = \delta^{(l+1)} \cdot a^{(l)T}</script><p>最终，我们得到了权重矩阵的梯度计算公式：</p><script type="math/tex; mode=display">\frac{\partial J}{\partial \Theta^{(l)}} = \delta^{(l+1)} \cdot a^{(l)T}</script><p>对于偏置的梯度：</p><script type="math/tex; mode=display">\frac{\partial J}{\partial \Theta^{(l)}} = \delta^{(l+1)}</script><p>这个公式表示了损失函数对于第 $(l)$ 层权重矩阵的偏导数，是反向传播算法中梯度计算的关键步骤之一。</p><p><br/></p><hr><h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><p>首先将梯度简写为$\Delta_{ij}^{(l)}$，第 $l$  层的第 $i$ 个激活单元受到第 $j$ 个参数影响而导致的误差。</p><script type="math/tex; mode=display">\frac{\partial J}{\partial \Theta^{(l)}} = \delta^{(l+1)}_i \cdot a^{(l)T}_j=\Delta^{(l)}</script><p>换句话说，$(\delta^{(l+1)} \cdot a^{(l)T})$ 是一个矩阵，其中第 $(i)$ 行、第 $(j)$ 列的元素就是 $(\Delta_{ij}^{(l)})$。这个矩阵表示了损失函数对于权重矩阵的梯度，用于更新权重以减小损失。</p><p>在求出了$\Delta_{ij}^{(l)}$之后，我们便可以计算代价函数的偏导数了，计算方法如下：</p><p>$ D_{ij}^{(l)} :=\frac{1}{m}\Delta_{ij}^{(l)}+\lambda\Theta_{ij}^{(l)}$              ${if}\; j \neq  0$</p><p>$ D_{ij}^{(l)} :=\frac{1}{m}\Delta_{ij}^{(l)}$                             ${if}\; j = 0$</p><p>在神经网络的训练中，我们通过梯度下降算法来不断调整网络中的权重，使得网络的输出更接近实际值。为了防止过拟合，通常在损失函数中加入<strong>正则化项</strong>。</p><p>这里的公式是在计算正则化项的梯度，用于更新权重时的调整。让我们逐步解释：</p><ol><li><p><strong>$\Delta_{ij}^{(l)}:$</strong> 这是神经网络中权重矩阵 $\Theta^{(l)}$的梯度项。它表示损失函数对于权重的影响，是梯度下降算法的关键。</p></li><li><p><strong>$\frac{1}{m}$:</strong> </p></li><li><p><strong>$\lambda$:</strong> 这是正则化参数，它控制正则化项的强度。如果 $(\lambda)$ 较大，那么正则化的影响就会更显著。</p></li><li><p><strong>$\Theta_{ij}^{(l)}$:</strong> 这是权重矩阵中的具体权重值。</p></li></ol><p>现在，整个公式的含义是，我们通过将权重的梯度项取平均，然后加上正则化项，来计算最终用于更新权重的梯度。这个过程旨在<strong>防止过拟合</strong>，通过对权重的大小进行调整，以使模型更<strong>一般化</strong></p><p><br/></p><hr><h3 id="梯度检验"><a href="#梯度检验" class="headerlink" title="梯度检验"></a>梯度检验</h3><p>我们对一个较为复杂的模型（例如神经网络）使用梯度下降算法时，可能会存在一些不容易察觉的错误，意味着，虽然代价看上去在不断减小，但最终的结果可能并不是最优解。</p><p>为了避免这样的问题，我们采取一种叫做梯度的数值检验（<strong>Numerical Gradient Checking</strong>）方法。这种方法的思想是通过估计梯度值来检验我们计算的导数值是否真的是我们要求的。</p><p>对梯度的估计采用的方法是在代价函数上沿着切线的方向选择离两个非常近的点然后计算两个点的平均值用以估计梯度。即对于某个特定的 $\theta$，我们计算出在 $\theta$-$\varepsilon $ 处和 $\theta$+$\varepsilon $ 的代价值（$\varepsilon $是一个非常小的值，通常选取 0.001），然后求两个代价的平均，用以估计在 $\theta$ 处的代价值。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231118041044629.png" alt="image-20231118041044629"></p><p>梯度检验是一种验证数值计算中梯度计算是否正确的技术。在机器学习中，特别是在神经网络训练中，梯度是优化算法（如梯度下降）的关键部分。通过梯度检验，可以验证你的梯度计算是否正确，以确保你的模型在学习过程中能够正确地更新参数。</p><ol><li><p><strong>计算数值梯度：</strong> 对于每个参数 $(\theta_i)$，通过微小的变化 $(\epsilon)$ 来计算数值梯度。数值梯度的计算方式是：</p><script type="math/tex; mode=display">\text{num-grad}_i = \frac{J(\theta_1, \theta_2, ..., \theta_i + \epsilon, ..., \theta_n) - J(\theta_1, \theta_2, ..., \theta_i - \epsilon, ..., \theta_n)}{2\epsilon}</script><p>其中，$(J)$ 是损失函数，$(\theta_i)$ 是第 $(i)$ 个参数。</p></li><li><p><strong>计算反向传播梯度：</strong> 使用反向传播算法计算损失函数对于每个参数的梯度。</p></li><li><p><strong>比较：</strong> 将数值梯度与反向传播梯度进行比较。如果两者非常接近，那么可以认为梯度计算是正确的。</p></li></ol><p><br/></p><p>梯度检验是一种相对慢速但非常强大的调试工具。在实际应用中，梯度检验通常只在开发和调试阶段使用，因为它相<strong>对于反向传播来说计算量较大</strong>，不适合在大规模数据上进行频繁的计算。当然，梯度检验也有一些局限性，例如对于非连续、非凸或计算复杂的损失函数可能不太适用。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>反向传播（Backpropagation，简称BP）是一种用于训练神经网络的优化算法。以下是反向传播算法包含的主要步骤：</p><ol><li><p><strong>初始化参数：</strong> 随机初始化神经网络的权重和偏置。</p></li><li><p><strong>正向传播：</strong> 使用当前的参数进行正向传播，计算网络的输出。每一层的激活值  $(a^{(l)} )$ 可以通过应用激活函数到该层的净输入值  $(z^{(l)} )$ 而得到。</p><script type="math/tex; mode=display">z^{(l)} = \Theta^{(l-1)} a^{(l-1)} + b^{(l-1)}</script><script type="math/tex; mode=display"> a^{(l)} = g(z^{(l)})</script><p>其中， $(\Theta^{(l-1)} )$ 是连接第  $(l-1 )$ 层和第  $(l )$ 层的权重矩阵， $(b^{(l-1)} )$ 是偏置。</p></li><li><p><strong>计算损失：</strong> 使用网络的输出和实际标签计算损失函数。</p><script type="math/tex; mode=display"> J = \text{cost}(a^{(L)}, y)</script><p>其中， $(L )$ 是输出层的索引， $(a^{(L)} )$ 是输出层的激活值， $(y )$ 是实际标签。</p></li><li><p><strong>反向传播：</strong> 通过反向传播算法计算每一层的误差项  ($\delta^{(l)}$ )。误差项的计算方式取决于激活函数的选择和损失函数的形式。</p><script type="math/tex; mode=display">\delta^{(L)} = \frac{\partial J}{\partial z^{(L)}}</script><script type="math/tex; mode=display">\delta^{(l)} = \left(\Theta^{(l)}\right)^T \delta^{(l+1)} \ast g'\left(z^{(l)}\right)</script></li></ol><ol><li><p><strong>计算梯度：</strong> 利用误差项  $(\delta^{(l)} )$ 计算损失函数对于参数的偏导数，即梯度。</p><script type="math/tex; mode=display">\frac{\partial J}{\partial \Theta^{(l)}} = a^{(l-1)} \cdot \delta^{(l)T}</script></li><li><p><strong>正则化梯度</strong>： </p><script type="math/tex; mode=display">D_{ij}^{(l)} :=\frac{1}{m}\Delta_{ij}^{(l)}+\lambda\Theta_{ij}^{(l)}</script></li><li><p><strong>梯度下降更新参数：</strong> 使用梯度下降或其他优化算法，根据计算得到的梯度更新网络的参数。</p><script type="math/tex; mode=display">\Theta^{(l)} = \Theta^{(l)} - \alpha \frac{\partial J}{\partial \Theta^{(l)}}</script><p>其中， $(\alpha )$ 是学习率，用于控制更新步长。</p></li><li><p><strong>重复：</strong> 重复步骤 2-7，直到损失函数收敛或达到预定的迭代次数。</p></li></ol><p>这些步骤组成了反向传播算法的基本流程，用于训练神经网络。反向传播通过不断地调整网络参数，使得模型逐渐学到数据中的模式，从而提高模型的性能。</p><p><br/></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.5 ex3：Multi-class Classifification and Neural Networks</title>
      <link href="/post/18106.html"/>
      <url>/post/18106.html</url>
      
        <content type="html"><![CDATA[<h1 id="ex3：Multi-class-Classifification-and-Neural-Networks"><a href="#ex3：Multi-class-Classifification-and-Neural-Networks" class="headerlink" title="ex3：Multi-class Classifification and Neural Networks"></a>ex3：Multi-class Classifification and Neural Networks</h1><h2 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在本练习中，您将使用逻辑回归和神经网络来识别手写数字(从0到9)。如今，手写数字的自动识别已得到广泛应用-从识别邮件信封上的邮政编码(邮政编码)到识别银行支票上的金额。本练习将向您展示如何将所学方法用于这项分类任务。</p><p>在练习的第一部分，您将扩展之前的逻辑回归实施方法，并将其应用于”单对全”分类。</p><p>必要的文件如下：</p><ul><li><code>ex3.py</code>-引导您完成练习的<code>Python</code>文件</li><li><code>ex3data1.mat</code> -前半部分练习的数据集</li><li><code>sigmoid.py</code>-计算$sigmoid$函数</li><li><code>displayData.py</code>-展示图像</li></ul><p>需要完成的文件：</p><ul><li><p><code>predictOneVsAll.py</code>- 使用一对所有多类别分类器进行预测</p></li><li><p><code>oneVsAll.py</code> - 训练一对所有多类别分类器</p></li><li><code>lrCostFunction.py</code>-$logistic$回归成本函数</li></ul><p><br/></p><hr><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt   </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> scipy.io <span class="keyword">as</span> scio   </span><br><span class="line"><span class="keyword">import</span> lrCostFunction <span class="keyword">as</span> lCF  </span><br><span class="line"><span class="keyword">import</span> oneVsAll <span class="keyword">as</span> ova</span><br><span class="line"><span class="keyword">import</span> predictOneVsAll <span class="keyword">as</span> pova</span><br><span class="line"><span class="keyword">import</span> displayData <span class="keyword">as</span> dd</span><br></pre></td></tr></table></figure><p><code>loadmat</code>函数是SciPy库中<code>scipy.io</code>模块中的一个函数，用于加载MATLAB文件（.mat）中的数据。它允许你读取MATLAB文件中的变量，并将其存储在Python字典中。以下是关于<code>loadmat</code>函数的一些重要信息：</p><p><code>scipy.io.loadmat(file_name, mdict=None, appendmat=True, **kwargs)</code></p><ul><li><code>file_name</code>: 字符串，表示MATLAB文件的路径。</li><li><code>mdict</code>: 可选参数，如果提供了一个字典，MATLAB文件中的变量将被存储在这个字典中。</li><li><code>appendmat</code>: 可选参数，如果为True（默认值），则MATLAB文件的.mat扩展名将被附加到<code>file_name</code>中，如果没有的话。</li><li><code>**kwargs</code>: 其他可选参数，可以用于控制MATLAB文件加载的行为。</li></ul><p><code>loadmat</code>函数返回一个<strong>字典</strong>，其中包含MATLAB文件中的所有变量。字典的键是<code>MATLAB</code>变量的名称，而相应的值是包含变量数据的<code>NumPy</code>数组或其他适当的<code>Python</code>对象。</p><p><br/></p><hr><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 设置本部分练习所需的参数</span></span><br><span class="line">input_layer_size = <span class="number">400</span>  <span class="comment"># 输入层大小，即20x20像素的手写数字图像</span></span><br><span class="line">num_labels = <span class="number">10</span>         <span class="comment"># 类别数量，从0到9</span></span><br><span class="line">                        <span class="comment"># 注意我们将数字 &quot;0&quot; 映射到类别编号 10      </span></span><br><span class="line">    </span><br><span class="line">data = scio.loadmat(<span class="string">&#x27;ex3data1.mat&#x27;</span>)   <span class="comment">#用loadmat载入数据</span></span><br><span class="line">X = data[<span class="string">&#x27;X&#x27;</span>]  </span><br><span class="line">y = data[<span class="string">&#x27;y&#x27;</span>].flatten()</span><br><span class="line">m = y.size</span><br></pre></td></tr></table></figure><p>数据集<code>ex3data1.mat</code>包含了<code>5000</code>个训练示例，每个示例都是一个<code>20x20</code>像素的数字灰度图像。每个像素由一个浮点数表示，代表该位置的灰度强度。为了进行机器学习模型的训练，这些图像被展开成了一个<code>400</code>维的向量。</p><p>因此，数据矩阵<code>X</code>是一个大小为<code>5000x400</code> 的矩阵，其中每一行都代表一个手写数字图像的训练示例。</p><p>而矩阵<code>y</code>是一个大小为<code>5000</code>的一维向量，是数字1到10之间的整数，表示有10种类别，对应于每个训练示例代表的手写数字(0,9)，类别10对应的数字0，原来是应该是5000x1的矩阵，<code>flatten</code>之后就变为了1维向量</p><p>简单来说，每个训练示例都是一个20x20的图像，被展开成一个包含400个元素的向量。这样的表示方式使得图像可以作为机器学习算法的输入。每个元素对应于图像中的一个像素，其值表示该像素的灰度强度。</p><p><br/></p><hr><h3 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Randomly select 100 data points to display</span></span><br><span class="line">rand_indices = np.random.permutation(<span class="built_in">range</span>(m))</span><br><span class="line">selected = X[rand_indices[<span class="number">0</span>:<span class="number">100</span>], :]</span><br><span class="line"></span><br><span class="line">dd.display_data(selected)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>这段代码的作用是从训练集 <code>X</code> 中随机选择100个数据点，并将它们展示出来，display_data.py是初始时自带的，不需要我们编写,只需要调用即可</p><p><code>np.random.permutation(range(m))</code> ：生成一个包含0到m-1的随机排列，其中 <code>m</code> 是训练集中样本的数量</p><p><code>rand_indices[0:100]</code> ：选择排列的前100个索引，即从0到99</p><p>图像如下：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231115055129570.png" alt="image-20231115055129570" style="zoom:80%;" /></p><p><br/></p><hr><h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><p>编写<code>lrCostFunction.py</code>文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sigmoid <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lr_cost_function</span>(<span class="params">theta, X, y, lmd</span>):</span></span><br><span class="line">    parameters = theta.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化grad数组来存储每个参数的梯度</span></span><br><span class="line">    grad = np.zeros(parameters)</span><br><span class="line"></span><br><span class="line">    pos = y @ np.log(sigmoid(X @ theta))  <span class="comment"># 代价函数的前半段</span></span><br><span class="line">    <span class="comment"># 添加小常数，代价函数的后半段</span></span><br><span class="line">    neg = (<span class="number">1</span> - y) @ np.log(<span class="number">1</span> - sigmoid(X @ theta) + <span class="number">1e-15</span>)</span><br><span class="line">    reg = (lmd / (<span class="number">2</span> * <span class="built_in">len</span>(X))) * np.<span class="built_in">sum</span>(np.power(theta[<span class="number">1</span>:], <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    cost = ((-np.<span class="built_in">sum</span>(pos + neg))) / (<span class="built_in">len</span>(X)) + reg  <span class="comment"># 算出代价</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cost</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient</span>(<span class="params">theta, X, y, learning_rate</span>):</span></span><br><span class="line">    m = <span class="built_in">len</span>(y)</span><br><span class="line">    h = sigmoid(X @ theta)</span><br><span class="line">    grad = (<span class="number">1</span> / m) * (X.T @ (h - y))</span><br><span class="line">    grad[<span class="number">1</span>:] += (learning_rate / m) * theta[<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">return</span> grad</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>函数的内容和ex2练习中的正则化函数完全相同，具体解释请参见<code>ex2:logistic regression</code>，这里只是算出了第一次梯度下降的梯度，作为后面高级优化的参数</p><p><br/></p><hr><h3 id="分类器"><a href="#分类器" class="headerlink" title="分类器"></a>分类器</h3><p>编写<code>oneVsAll.py</code>，要求实现多类别逻辑回归的训练，具体来说，使用一对多（one-vs-all）的方法来训练多个二元逻辑回归分类器，每个分类器用于预测一个类别是否为正例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lrCostFunction <span class="keyword">as</span> lcf</span><br><span class="line"><span class="keyword">from</span> sigmoid <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> minimize</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">one_vs_all</span>(<span class="params">X, y, num_labels, learning_rate</span>):</span></span><br><span class="line">    <span class="comment">#m,n分别是X的行和列的数目,实际上是(5000,400)</span></span><br><span class="line">    m, n = X.shape</span><br><span class="line">    <span class="comment">#创建一个矩阵 all_theta，用于存储每个类别的权重参数,算上偏置项，大小为(10,401)</span></span><br><span class="line">    all_theta = np.zeros((num_labels, n + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在 X 前添加一列，表示偏置项</span></span><br><span class="line">    X = np.c_[np.ones((m, <span class="number">1</span>)), X]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, num_labels + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 将标签转换为二元标签，表示当前类别和其他类别</span></span><br><span class="line">            binary_labels = np.array([<span class="number">1</span> <span class="keyword">if</span> item == i <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> item <span class="keyword">in</span> y])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 初始化权重，大小为401</span></span><br><span class="line">            initial_theta = np.zeros(n + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 使用梯度下降来训练分类器</span></span><br><span class="line">            result = minimize(lcf.lr_cost_function, initial_theta, args=(X, binary_labels, learning_rate), method=<span class="string">&#x27;BFGS&#x27;</span>,jac=lcf.gradient)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 将训练好的权重存储在结果矩阵中</span></span><br><span class="line">            all_theta[i - <span class="number">1</span>, :] = result.x</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> all_theta</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><br/></p><p>详细解释一下：</p><ul><li><p><code>np.c_</code>()是<code>numpy</code>的连接函数，表示连接括号里面的数组或矩阵，这里，<code>np.ones((m, 1))</code> 创建了一个列向量，所有元素都是 1，表示偏置项。然后，<code>np.c_</code> 将这列向量与特征矩阵 <code>X</code> 进行按列连接，形成一个新的特征矩阵，其中第一列是全 1 的列。</p><p>所以，最终的 <code>X</code> 矩阵包含了原始特征矩阵 <code>X</code> 的所有列，并在最左侧添加了一列偏置项。这是逻辑回归中常见的预处理步骤，以便更好地进行模型训练。此时X矩阵的大小为(5000,401)</p></li><li><p><code>binary_labels = np.array([1 if item == i else 0 for item in y])</code>:这是一个列表推导式，它遍历 <code>y</code> 中的每个元素 <code>item</code>，然后根据条件 <code>item == i</code> 返回 <code>1</code> 或 <code>0</code>，作用如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">假设此时i=6</span></span><br><span class="line"><span class="string">操作前：    操作后</span></span><br><span class="line"><span class="string">[1,2,3    [0,0,0</span></span><br><span class="line"><span class="string"> 4,5,6     0,0,1 </span></span><br><span class="line"><span class="string"> 7,8,9]    0,0,0]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p><br/></p><p>经过分类后，变成了简单的二元分类的逻辑回归问题，在每次循环中的大小和<code>y</code>的大小一致，为(10,401)</p></li><li><p><code>initial_theta = np.zeros(n + 1)</code>：用于存储每个类别的权重参数。每一行对应一个类别，每一列对应一个特征（包括偏置项）</p></li><li><p><code>result = minimize(lcf.lr_cost_function, initial_theta, args=(X, binary_labels, learning_rate), method=&#39;BFGS&#39;,jac=lcf.gradient)</code>这行代码使用 BFGS 算法最小化目标函数 <code>lcf.lr_cost_function</code></p><ul><li><strong><code>lcf.lr_cost_function</code>：</strong>这是目标函数，即要最小化的函数</li><li><strong><code>initial_theta</code>：</strong>是优化过程的初始猜测值</li><li><strong><code>args=(X, binary_labels, learning_rate)</code></strong>：这是一个元组，包含传递给目标函数 <code>lcf.lr_cost_function</code> 的额外参数。在这里，包括特征矩阵 <code>X</code>、二元标签 <code>binary_labels</code> 和学习率 <code>learning_rate</code></li><li><strong><code>method=&#39;BFGS&#39;</code>：</strong>这是选择优化算法的参数。在这里，选择了 BFGS 算法</li><li><strong><code>jac=lcf.gradient</code>：</strong>这是目标函数的梯度函数。在这里，<code>lcf.gradient</code> 是计算逻辑回归代价函数梯度的函数。提供梯度信息可以<strong>加速优化过程</strong></li><li>最终，<code>minimize</code> 函数返回一个对象 <code>result</code>，其中包含有关优化结果的信息，如最小化的目标值、最小值对应的参数等。<code>result</code>是一个可以通过 <code>result.x</code> 获取最小化目标函数时的参数值矩阵，里面就是最优的<code>theta</code>矩阵，其大小和<code>initial_theta</code>一样</li></ul></li><li><p><code>all_theta[i - 1, :] = result.x</code>，将将针对当前类别 <code>i</code> 训练得到的权重参数存储在 <code>all_theta</code> 矩阵的相应行中，<code>result.x</code>的大小为401，最后的<code>all_theta</code>矩阵的大小为(10,401)，每一行对应每个数组的权重参数</p></li></ul><p><br/></p><p>回到<code>ex3.py</code>中来，调用分类器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lmd = <span class="number">0.1</span>   <span class="comment">#学习率为0.1</span></span><br><span class="line">all_theta = ova.one_vs_all(X, y, num_labels, lmd)</span><br></pre></td></tr></table></figure><p>得到<code>all_theta</code>，一个大小为(10,401)的权重矩阵</p><p><br/></p><hr><h3 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h3><p>编写<code>predictOneVsAll.py</code>，对结果进行预测</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sigmoid  <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># all_theta:包含每个类别的权重参数的矩阵,大小为(10,401)</span></span><br><span class="line"><span class="comment"># X:待预测的样本特征矩阵，大小为(5000,400)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict_one_vs_all</span>(<span class="params">all_theta, X</span>):</span></span><br><span class="line">   <span class="comment"># 样本数量</span></span><br><span class="line">    m = X.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化预测向量</span></span><br><span class="line">    p = np.zeros(m)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在 X 前添加一列，表示偏置项</span></span><br><span class="line">    X = np.c_[np.ones(m), X]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用学习到的权重进行预测</span></span><br><span class="line">    predictions = sigmoid(X @ all_theta.T)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 选择每一行中最大值的索引，即预测的类别</span></span><br><span class="line">    p = (np.argmax(predictions, axis=<span class="number">1</span>))  <span class="comment"># 加1是因为 Python 中索引是从0开始的，而类别是从1开始的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p><code>predictions = sigmoid(X @ all_theta.T)</code>,因为<code>X@all_theta.T</code>会产生一个(5000,10)的矩阵,经过<code>sigmoid</code>变换之后，每一行的内容，就是该图像为某数字的概率的集合，假设第1行，第3列为0.64，说明第1个图像，为数字3的概率为0.64，即64%</p></li><li><p><code>p = (np.argmax(predictions, axis=1) + 1</code>) ：<code>np.argmax</code> 函数返回沿指定轴（在这里是轴1，即每行）的最大值的<strong>索引</strong>。即直接找出，每一行最大的值，所对应的列是什么</p><p>对于 <code>predictions</code> 矩阵，这将返回每个样本对应的预测概率最大的类别的<strong>索引</strong>。由于类别编号是从 1 开始的，所以将上一步得到的索引值加上 1，最后每一行的值为概率最大的值所在的列再加1，返回的<code>p</code>最后的大小为(5000,)</p></li></ul><p><br/></p><p>回到<code>ex3.py</code>中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pred = pova.predict_one_vs_all(all_theta, X)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Training set accuracy: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(np.mean(pred == y)*<span class="number">100</span>))</span><br></pre></td></tr></table></figure><p>调用<code>predict_one_vs_all</code>函数，得到了<code>pred</code>数组，然后直接和正确答案<code>y</code>对比，得到最后的准确率，准确率应该是96.43%</p><p><br/></p><hr><h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>在本练习的前一部分，您实施了多类逻辑回归来识别手写数字。然而,逻辑回归不能形成更复杂的假设，因为它只是一种线性分类器。</p><p>在这部分练习中，您将使用与之前相同的训练集，建立一个神经网络来识别手写数字。神经网络将能够表示形成非线性推理的复杂模型。您将使用我们已经训练过的神经网络的参数。你们的目标是实现前馈传播算法，使用我们的权重进行预测。</p><p>必要的文件如下：</p><p><code>ex3_nn.py</code>-引导您完成练习的<code>Python</code>文件</p><p><code>ex3data1.mat</code> -练习的数据集</p><p><code>ex3weights.mat</code>-神经网络练习的初始权重</p><p><code>sigmoid.py</code>-计算$sigmoid$函数</p><p><code>displayData.py</code>-展示图像</p><p><br/></p><p>需要完成的文件：</p><ul><li><code>predict.py</code>-神经网络预测函数</li></ul><p><br/></p><hr><p>神经网络如图2所示。它有3层—输入层、隐藏层和输出层。回想一下，我们的输入是数字图像的像素值。由于图像大小为20×20,因此我们有400个输入层单元(不包括额外的偏置单元，该单元总是输出+1)。与之前一样，  训练数据将被加载到变量X和y中。</p><p>我们为您提供了一组已经训练过的网络参数$\theta_1,\theta_2$。这些参数存储在<code>ex3weights.mat</code>中，并将由<code>ex3_nn.py</code>加载到Theta1和Theta2中。参数的尺寸适合第二层有25个单元和10个输出单元(对应10个数字类别)的神经网络。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231116020346330.png" alt="image-20231116020346330" style="zoom:67%;" /></p><p><br/></p><hr><h3 id="导入并绘图"><a href="#导入并绘图" class="headerlink" title="导入并绘图"></a>导入并绘图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> scipy.io <span class="keyword">as</span> scio</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> displayData <span class="keyword">as</span> dd</span><br><span class="line"><span class="keyword">import</span> predict <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置本部分练习所需的参数</span></span><br><span class="line">input_layer_size = <span class="number">400</span>  <span class="comment"># 输入层大小，即20x20像素的手写数字图像</span></span><br><span class="line">hidden_layer_size = <span class="number">25</span>  <span class="comment"># 隐藏层大小，包含25个神经元</span></span><br><span class="line">num_labels = <span class="number">10</span>         <span class="comment"># 类别数量，从0到9</span></span><br><span class="line">                        <span class="comment"># 注意我们将数字 &quot;0&quot; 映射到类别编号 10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Load Training Data</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Loading and Visualizing Data ...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">data = scio.loadmat(<span class="string">&#x27;ex3data1.mat&#x27;</span>)</span><br><span class="line">X = data[<span class="string">&#x27;X&#x27;</span>]</span><br><span class="line">y = data[<span class="string">&#x27;y&#x27;</span>].flatten()</span><br><span class="line">m = y.size</span><br><span class="line"></span><br><span class="line"><span class="comment"># Randomly select 100 data points to display</span></span><br><span class="line">rand_indices = np.random.permutation(<span class="built_in">range</span>(m))</span><br><span class="line">selected = X[rand_indices[<span class="number">0</span>:<span class="number">100</span>], :]</span><br><span class="line"></span><br><span class="line">dd.display_data(selected)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;Program paused. Press ENTER to continue&#x27;</span>)</span><br></pre></td></tr></table></figure><p>和逻辑回归的写法一致</p><p><br/></p><hr><h3 id="预测-1"><a href="#预测-1" class="headerlink" title="预测"></a>预测</h3><p>载入已经训练好的权重矩阵<code>theta1</code>和<code>theta2</code></p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = scio.loadmat(<span class="string">&#x27;ex3weights.mat&#x27;</span>)</span><br><span class="line">theta1 = data[<span class="string">&#x27;Theta1&#x27;</span>]</span><br><span class="line">theta2 = data[<span class="string">&#x27;Theta2&#x27;</span>]</span><br></pre></td></tr></table></figure><p>最主要的是编写<code>predict.py</code>，返回神经网络的预测结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sigmoid <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span>(<span class="params">theta1, theta2, X</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用训练好的神经网络参数进行预测。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">    - theta1: numpy array,大小为(25,401)</span></span><br><span class="line"><span class="string">      第一层的权重参数。</span></span><br><span class="line"><span class="string">    - theta2: numpy array,大小为(10,26)</span></span><br><span class="line"><span class="string">      第二层的权重参数。</span></span><br><span class="line"><span class="string">    - X: numpy array,大小为(5000,400)</span></span><br><span class="line"><span class="string">      待预测的样本特征矩阵。每行对应一个样本，每列对应一个特征。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    - p: numpy array</span></span><br><span class="line"><span class="string">      包含每个样本预测的类别的一维数组。类别编号从1开始。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 增加偏置项</span></span><br><span class="line">    m = X.shape[<span class="number">0</span>]</span><br><span class="line">    X = np.c_[np.ones((m, <span class="number">1</span>)), X]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算第一层到第二层的激活值</span></span><br><span class="line">    a1 = X</span><br><span class="line">    z2 = a1 @ theta1.T</span><br><span class="line">    a2 = sigmoid(z2)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在 a2 前添加偏置项</span></span><br><span class="line">    a2 = np.c_[np.ones((m, <span class="number">1</span>)), a2]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算第二层到输出层的激活值</span></span><br><span class="line">    z3 = a2 @ theta2.T</span><br><span class="line">    a3 = sigmoid(z3)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 选择每一行中最大值的索引，即预测的类别</span></span><br><span class="line">    p = np.argmax(a3, axis=<span class="number">1</span>) + <span class="number">1</span>  <span class="comment"># 加1是因为 Python 中索引是从0开始的，而类别是从1开始的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>回到<code>ex3_nn.py</code>中调用<code>predict</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pred = pd.predict(theta1, theta2, X)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Training set accuracy: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(np.mean(pred == y)*<span class="number">100</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果应该是97.52%</p><p><br/></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.0.神经网络：表述</title>
      <link href="/post/40324.html"/>
      <url>/post/40324.html</url>
      
        <content type="html"><![CDATA[<h1 id="神经网络：表述"><a href="#神经网络：表述" class="headerlink" title="神经网络：表述"></a>神经网络：表述</h1><h2 id="非线性假设"><a href="#非线性假设" class="headerlink" title="非线性假设"></a>非线性假设</h2><p>无论是线性回归还是逻辑回归都有这样一个缺点，即：当特征太多时，计算的负荷会非常大</p><p>比如像下图中的分类问题：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231112174731819.png" alt="image-20231112174731819"></p><p>假设我们有非常多的特征，例如大于100个变量，我们希望用这100个特征来构建一个非线性的多项式模型，结果将是数量非常惊人的特征组合</p><p>即便我们只采用两两特征的组合$(x_1x_2+x_1x_3+x_1x_4+…+x_2x_3+x_2x_4+…+x_{99}x_{100})$，我们也会有接近5000个组合而成的特征。这对于一般的逻辑回归来说需要计算的特征太多了。</p><p>普通的逻辑回归模型，不能有效地处理这么多的特征，这时候我们需要<strong>神经网络</strong></p><p><br/></p><hr><h2 id="模型表示"><a href="#模型表示" class="headerlink" title="模型表示"></a>模型表示</h2><p>神经网络模型建立在很多神经元之上，每一个神经元又是一个个学习模型。这些神经元（也叫激活单元）采纳一些特征作为输出，并且根据本身的模型提供一个输出</p><p>下图是一个以逻辑回归模型作为自身学习模型的神经元示例，在神经网络中，参数又可被成为权重（<strong>weight</strong>）</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231112215955015.png" alt="image-20231112215955015"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231113053036479.png" alt="image-20231113053036479" style="zoom:67%;" /></p><p>以下是神经元的主要功能和组成部分：</p><ul><li><p><strong>输入（Input）：</strong> 神经元接收来自其他神经元或外部环境的输入。这些输入通常是由权重加权的特征值。图中的$x_1,x_2,x_3$就是输入</p></li><li><p><strong>权重（Weight）：</strong> 每个输入都有一个相关的权重$\theta_1,\theta_2,\theta_3$。这些权重表示每个特征对神经元输出的影响程度。</p></li><li><p><strong>偏置（Bias）：</strong> 除了输入和权重之外，神经元还有一个偏置项$x_0$，它对输出的影响独立于输入。而$\theta_0$是偏执项的权重</p></li><li><p><strong>激活函数（Activation Function）：</strong> 逻辑回归使用逻辑函数（也称为Sigmoid函数），将输入的加权和与偏置相加，并将结果压缩到(0, 1)的范围内。</p></li><li><p><strong>输出（Output）：</strong> 神经元的最终输出是通过激活函数处理后的结果。这个输出将作为下一层神经元的输入或是整个神经网络的最终输出，具体取决于神经网络的结构和任务。在逻辑回归模型中，输出为：$h_\theta\left( x \right)=\frac{1}{1+{e^{-\theta^TX }}}$</p></li></ul><p><br/></p><hr><p> 神经网络模型是许多逻辑单元按照不同层级组织起来的网络，每一层的输出变量都是下一层的输入变量。Layer 1 成为输入层（<strong>Input Layer</strong>），Layer 2 成为隐藏层（<strong>Hidden Layers</strong>），Layer 3称为输出层（<strong>Output Layer</strong>）。为每一层都增加一个偏差单位（<strong>bias unit</strong>）：</p><p><br/></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231112221617306.png" alt="image-20231112221617306" style="zoom:80%;" /></p><p>其中$x_1$, $x_2$, $x_3$是<strong>输入单元</strong>，我们将原始数据输入给它们。$a_1$, $a_2$, $a_3$是<strong>中间单元</strong>，它们负责将数据进行处理，然后呈递到下一层。最后是<strong>输出单元</strong>，它负责计算${h_\theta}\left( x \right)$</p><p><br/></p><p>下面引入一些标记法来帮助描述模型：</p><p>$a_{i}^{\left( j \right)}$ 代表第$j$ 层的第 $i$ 个激活单元。</p><p>${\theta ^{\left( j \right)}}$代表从第 $j$ 层映射到第$ j+1$ 层时的<strong>权重矩阵</strong>，其尺寸为：以第 $j+1$层的激活单元数量为<strong>行数</strong>，以第 $j$ 层的激活单元数加一为列数的<strong>矩阵</strong>。即为$(n_{j+1} \times (n_j+1))$大小</p><ul><li>权重矩阵$\theta^{(1)}$的维度将是 ($n_{\text{2}} \times (n_{\text{1}} + 1)$)。即为$3\times 4$的矩阵，这里加一是因为通常会在输入中添加一个偏置项（bias），用于调整隐藏层节点的阈值。</li><li>权重矩阵$\theta^{(2)}$的维度是 ($n_{\text{3}} \times (n_{\text{2}} + 1)$)。即为$1\times 4$的矩阵大小</li></ul><p><br/></p><p>权重矩阵的<strong>行</strong>，是取决于$j+1$层的激活单元数量$n_{j+1}$，这是因为权重矩阵的每一行对应于连接到下一层的一个激活单元（神经元）。权重矩阵$\begin{bmatrix}<br>    \theta_{1n} \\<br>    \theta_{2n}\\<br>    \theta_{3n}\\<br>…<br>\end{bmatrix}<br>$的每一行都会和输入的特征矩阵$[x_1,x_2,x_3…]$做点积，从而形成新的激活单元</p><p><br/></p><p>权重矩阵的<strong>列</strong>，是取决于$j$层的激活单元数量$n_j+1$，这是因为，列的数量，直接对应的是每一行权重的数量，之所以要加1，因为要加上偏置$x_0=1$,自然每一行就多了一个权重$\theta_0$要计算</p><p><br/></p><div class="note primary flat"><p>一定要多联想之前学过的回归知识，线性回归和逻辑回归的时候，都会插入为数值’1’的列作为$x_0$，最后的<code>theta</code>数组也都是从$\theta_0$开始的</p></div><p><br/></p><p>对于上图所示的模型，激活单元和输出分别表达为：</p><p>$a_{1}^{(2)}=g(\Theta _{10}^{(1)}x_{0}+\Theta _{11}^{(1)}x_{1}+\Theta _{12}^{(1)}x_{2}+\Theta _{13}^{(1)}x_{3})$</p><p>$a_{2}^{(2)}=g(\Theta _{20}^{(1)}x_{0}+\Theta _{21}^{(1)}x_{1}+\Theta _{22}^{(1)}x_{2}+\Theta _{23}^{(1)}x_{3})$</p><p>$a_{3}^{(2)}=g(\Theta _{30}^{(1)}x_{0}+\Theta _{31}^{(1)}x_{1}+\Theta _{32}^{(1)}x_{2}+\Theta _{33}^{(1)}x_{3})$</p><p>$h_{\Theta}(x)=g(\Theta _{10}^{(2)}a_{0}^{(2)}+\Theta _{11}^{(2)}a_{1}^{(2)}+\Theta _{12}^{(2)}a_{2}^{(2)}+\Theta _{13}^{(2)}a_{3}^{(2)})$</p><p><br/></p><p>为了更好了了解<strong>Neuron Networks</strong>的工作原理，先把例子左半部分遮住：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231113063730232.png" alt="image-20231113063730232"></p><p>右半部分其实就是以$a_0, a_1, a_2, a_3$, 按照<strong>逻辑回归</strong>的方式输出$h_\theta(x)$：</p><script type="math/tex; mode=display">h_{\Theta}(x)=g(\Theta _{10}^{(2)}a_{0}^{(2)}+\Theta _{11}^{(2)}a_{1}^{(2)}+\Theta _{12}^{(2)}a_{2}^{(2)}+\Theta _{13}^{(2)}a_{3}^{(2)})</script><p>其中，$g(x)$就是sigmoid函数，只不过我们把<strong>逻辑回归</strong>中的输入向量$\left[ x_1\sim {x_3} \right]$ 变成了中间层的$\left[ a_1^{(2)}\sim a_3^{(2)} \right]$, 即:  $h_{\Theta}(x)=g(\Theta _{10}^{(2)}a_{0}^{(2)}+\Theta _{11}^{(2)}a_{1}^{(2)}+\Theta _{12}^{(2)}a_{2}^{(2)}+\Theta _{13}^{(2)}a_{3}^{(2)})$ </p><p>我们可以把$a_0, a_1, a_2, a_3$看成更为高级的特征值，也就是$x_0, x_1, x_2, x_3$的进化体，并且它们是由 $x$与$\theta$决定的，因为是梯度下降的，所以$a$是变化的，并且变得越来越厉害，所以这些更高级的特征值远比仅仅将 $x^3$之类的多项式作为特征值厉害，也能更好的预测新数据。</p><p>这就是神经网络相比于逻辑回归和线性回归的优势。</p><p><br/></p><div class="note danger flat"><p>这里需要重点说明一下，和线性回归最大的区别在于，线性回归可以我们清晰的知道，每一个$\theta$所对应的特征是什么，比如$\theta_1$是拟合$x_1$的，$\theta_2$是拟合$x_2^2$的</p><p>但是在神经网络中，通常无法直接解释每一个权重对应的具体含义，比如$\theta_1$是$3\times 4$的矩阵，一共有12个权重$\theta_{ij}$，我们<strong>根本不知道</strong>每一个权重所影响特征多项式具体是什么，就算$a_{1}^{(2)}$和$a_{2}^{(2)}$的输入特征虽然是一样的，但是其权重是未知的，所以结果也不会一样，这也是深度学习模型被称为“<strong>黑箱模型</strong>”的一个原因</p></div><p><br/></p><p>把$x$, $\theta$, $a$ 分别用矩阵表示</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231113063314755.png" alt="image-20231113063314755"></p><p>可以得到$\theta \cdot X=a$ ，把这样从左到右的算法称为<strong>前向传播算法</strong>( <strong>FORWARD PROPAGATION</strong> )</p><p><br/></p><hr><h2 id="多类分类"><a href="#多类分类" class="headerlink" title="多类分类"></a>多类分类</h2><p>当我们有不止两种分类时（也就是$y=1,2,3….$），比如以下这种情况，该怎么办？如果我们要训练一个神经网络算法来识别路人、汽车、摩托车和卡车，在输出层我们应该有4个值。例如，第一个值为1或0用于预测是否是行人，第二个值用于判断是否为汽车。</p><p>输入向量$x$有三个维度，两个中间层，输出层4个神经元分别用来表示4类，也就是每一个数据在输出层都会出现${\left[ a\text{ }b\text{ }c\text{ }d \right]^{T}}$，且$a,b,c,d$中仅有一个为1，表示当前类。下面是该神经网络的可能结构示例：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231113064222930.png" alt="image-20231113064222930"></p><p>神经网络算法的输出结果为四种可能情形之一：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231113064238209.png" alt="image-20231113064238209"></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.5 ex2:logistic regression</title>
      <link href="/post/13139.html"/>
      <url>/post/13139.html</url>
      
        <content type="html"><![CDATA[<h1 id="ex2-logistic-regression"><a href="#ex2-logistic-regression" class="headerlink" title="ex2:logistic regression"></a>ex2:logistic regression</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在这部分练习中，您将建立一个逻辑回归模型来预测学生是否被大学录取。</p><p>假设您是一所大学的管理者，您想根据两次考试的成绩来确定每位申请人的录取几率。您有以前申请者的历史数据，可以用作逻辑回归的训练集。对于每个训练示例，您都有申请人的两次考试成绩和录取决定。</p><p>您的任务是建立一个分类模型，根据这两次考试的分数估算申请人的录取概率。</p><p>必要的文件如下：</p><ul><li><p><code>ex2.py</code>-引导您完成练习的<code>Python</code>文件</p></li><li><p><code>ex2data1.txt</code> -前半部分练习的数据集</p></li></ul><p>需要完成的部分：</p><ul><li><code>sigmoid.py</code>-计算$sigmoid$函数</li><li><code>costFunction.py</code>-$logistic$回归成本函数</li><li><code>predict.py</code>-逻辑回归预测函数</li></ul><p><br/></p><hr><h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> scipy.optimize <span class="keyword">as</span> opt</span><br><span class="line"><span class="keyword">import</span> costFunction <span class="keyword">as</span> cf</span><br><span class="line"><span class="keyword">import</span> predict <span class="keyword">as</span> predict</span><br><span class="line"><span class="keyword">from</span> sigmoid <span class="keyword">import</span> </span><br></pre></td></tr></table></figure><p>SciPy（Scientific Python）是一个用于科学计算的库，而 <code>scipy.optimize</code> 模块则提供了各种优化算法。</p><p><br/></p><hr><h2 id="读取并绘图"><a href="#读取并绘图" class="headerlink" title="读取并绘图"></a>读取并绘图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data=pd.read_csv(<span class="string">&#x27;ex2data1.txt&#x27;</span>,header=<span class="literal">None</span>,names=[<span class="string">&#x27;exam1&#x27;</span>,<span class="string">&#x27;exam2&#x27;</span>,<span class="string">&#x27;label&#x27;</span>])</span><br></pre></td></tr></table></figure><p>原始数据有3列，分别是命名为<code>exam1</code>列，<code>exam2</code>列和<code>label</code>列，<code>label</code>列的数据是0或者1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pos = data[data[<span class="string">&#x27;label&#x27;</span>] == <span class="number">1</span>]</span><br><span class="line">neg = data[data[<span class="string">&#x27;label&#x27;</span>] == <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>绘图的难点在于要根据<code>label</code>值，绘制不同形状的散点，<code>Pandas</code>的对象可以直接根据布尔值来进行提取，通过判断<code>label</code>值，就可以将<code>data</code>数据根据<code>label</code>分为<code>pos</code>和<code>neg</code>两堆</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对于正类别</span></span><br><span class="line">plt.plot(pos[<span class="string">&#x27;exam1&#x27;</span>], pos[<span class="string">&#x27;exam2&#x27;</span>], <span class="string">&#x27;b+&#x27;</span>, label=<span class="string">&#x27;Admitted&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于负类别</span></span><br><span class="line">plt.plot(neg[<span class="string">&#x27;exam1&#x27;</span>], neg[<span class="string">&#x27;exam2&#x27;</span>], <span class="string">&#x27;rx&#x27;</span>, label=<span class="string">&#x27;Not Admitted&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">&#x27;Exam 1 score&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Exam 2 score&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>通过<code>plot</code>函数分别画出<code>pos</code>和<code>neg</code>的图像</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231110223001509.png" alt="image-20231110223001509" style="zoom:80%;" /></p><p><br/></p><hr><h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.insert(<span class="number">0</span>,<span class="string">&#x27;ones&#x27;</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>依旧是先在第一列插入0，作为$x_0$列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">col=data.shape[<span class="number">1</span>]  <span class="comment">#col就是data的列</span></span><br><span class="line">X = data.iloc[:, <span class="number">0</span>:col-<span class="number">1</span>]</span><br><span class="line">y = data.iloc[:, col-<span class="number">1</span>]</span><br><span class="line">initial_theta = np.zeros(X.shape[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>初始化<code>theta</code>数组，<code>X</code>数据由<code>data</code>的前3列构成，<code>y</code>则由最后一列构成</p><p><br/></p><p>接下来需要编写<code>sigmoid.py</code>，实现sigmoid函数的计算</p><script type="math/tex; mode=display">g\left( z \right)=\frac{1}{1+{e^{-z}}}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span>(<span class="params">z</span>):</span></span><br><span class="line">    g = <span class="number">1</span>/(<span class="number">1</span>+np.exp(-z))</span><br><span class="line">    <span class="keyword">return</span> g</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>np.exp()</code> 是 <code>NumPy</code> 库中的指数函数，用于计算给定输入数组的每个元素的指数值</p><p><br/></p><p>然后编写<code>costFunction.py</code>文件，用于计算起始时的代价<code>cost</code>和梯度<code>grad</code></p><script type="math/tex; mode=display">Cost\left( {h_\theta}\left( x \right),y \right)=-\frac{1}{m}\sum\limits_{i=1}^{m}{[y^{(i)}\log \left( {h_\theta}\left( x^{(i)} \right) \right)+\left( 1-{y^{(i)}} \right)\log \left( 1-{h_\theta}\left( x^{(i)} \right) \right)]}</script><script type="math/tex; mode=display">{\theta_j}:={\theta_j}-\alpha \frac{1}{m}\sum\limits_{i=1}^{m}{({h_\theta}(x^{(i)})-{y^{(i)}}){x_j}^{(i)}}</script><p>将$h_\theta x$用<code>sigmoid</code>函数计算出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sigmoid <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cost_function</span>(<span class="params">theta, X, y</span>):</span></span><br><span class="line">     pos = y@np.log(sigmoid(X @ theta))    <span class="comment">#代价函数的前半段</span></span><br><span class="line">     <span class="comment"># 添加小常数，代价函数的后半段</span></span><br><span class="line">     neg = (<span class="number">1</span> - y)@np.log(<span class="number">1</span> - sigmoid(X@theta) + <span class="number">1e-15</span>) </span><br><span class="line">     cost= -np.<span class="built_in">sum</span>(pos + neg) / (<span class="built_in">len</span>(X))    <span class="comment">#算出代价</span></span><br><span class="line">       </span><br><span class="line">     <span class="keyword">return</span> cost</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient</span>(<span class="params">theta, X, y</span>):</span></span><br><span class="line">    <span class="comment">#获取参数数量  </span></span><br><span class="line">    m=<span class="built_in">len</span>(y)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#初始化grad数组来存储每个参数的梯度</span></span><br><span class="line">    grad = np.zeros(m)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算模型预测与实际标签之间的误差</span></span><br><span class="line">    error = sigmoid(X @ theta) - y</span><br><span class="line">    </span><br><span class="line">    grad = (<span class="number">1</span> / m) * (X.T @ error)  <span class="comment"># 计算梯度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> grad</span><br></pre></td></tr></table></figure><p>在计算<code>neg</code>的时候，为了避免<code>log</code>函数里面出现0，添加了<code>1e-15</code>这个极小常数</p><p>这里并没有更新<code>grad</code>，因为只需要算出初始化的梯度就行了</p><p><br/></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cost = cf.cost_function(initial_theta, X, y)</span><br><span class="line">grad=  cf.gradient(initial_theta, X, y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Cost at initial theta (zeros): <span class="subst">&#123;cost&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Gradient at initial theta (zeros):<span class="subst">&#123;grad&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在<code>ex2.py</code>中调用函数求出<code>cost</code>和<code>grad</code>并打印出来,结果符合预期</p><p><br/></p><hr><h2 id="高级优化"><a href="#高级优化" class="headerlink" title="高级优化"></a>高级优化</h2><p>接下来，使用<code>scipy</code>库中的<code>opt.fmin_bfgs</code>函数，来实现梯度下降中的<code>bfgs</code>算法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cost_func</span>(<span class="params">t</span>):</span></span><br><span class="line">    <span class="keyword">return</span> cf.cost_function(t, X, y)</span><br><span class="line"></span><br><span class="line">theta, cost, *unused = opt.fmin_bfgs(f=cost_func, x0=initial_theta,full_output=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(cost)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Expected cost (approx): 0.203&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(theta)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Expected Theta (approx): \n-25.161\n0.206\n0.201&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在代码中，<code>cost_func</code> 和 <code>grad_func</code> 都接受一个参数 <code>t</code>，该参数是一个包含所有优化变量的数组。这种形式的好处是可以满足 <code>scipy.optimize.fmin_bfgs</code> 函数对目标函数和梯度函数的<strong>单参数要求</strong>。</p><p>这里没有提供<code>fprime</code>，函数使用近似值，仍然可以得到正确答案</p><p>最后将最优参数赋值给 <code>theta</code>，最优值赋值给 <code>cost</code>。 <code>*unused</code> 部分用于接收 <code>opt.fmin_bfgs</code> 返回的其他信息，但在这里我们没有使用它。</p><p><br/></p><p>最后利用得到的最优参数<code>theta</code>绘制回归曲线</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从20到100，步长为1</span></span><br><span class="line">plotting_x1 = np.arange(<span class="number">20</span>,<span class="number">100</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># x1和x2，要把其中一个看成是y</span></span><br><span class="line">plotting_h1 = ( - theta[<span class="number">0</span>] - theta[<span class="number">1</span>] * plotting_x1) / theta[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.plot(plotting_x1, plotting_h1, <span class="string">&#x27;y&#x27;</span>, label=<span class="string">&#x27;Prediction&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><br/></p><p>在逻辑回归中，决策边界是由模型的预测结果决定的，而模型的预测结果通过 sigmoid 函数进行变换，使其落在 (0, 1) 之间。因此，决策边界在逻辑回归中实际上是 sigmoid 函数的输出为 0.5 的地方。</p><p>对于线性决策边界，它满足以下条件：</p><script type="math/tex; mode=display">\theta_0 + \theta_1 \cdot x_1 + \theta_2 \cdot x_2 = 0</script><p>在这个公式中，($x_1$) 和 ($x_2$) 是特征，($\theta_0, \theta_1, \theta_2$) 是模型的参数。这个线性方程的解决方案就是决策边界。</p><p>如果我们将上面的方程表示为 ($x_2 = f(x_1)$)，那么就可以使用上面的代码来画出这个线性决策边界。这里，我们通过解这个线性方程来表示决策边界。</p><p>对于 sigmoid 函数的决策边界，确实是通过设置 ($sigmoid(\theta^T \cdot X) = 0.5$) 来获得，但这是在参数空间（$\theta$） 空间中，而不是特征空间（($x$) 空间）中</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231111020607578.png" alt="image-20231111020607578" style="zoom:80%;" /></p><hr><p>预测一下exam1为45分，exam为85分的录取概率</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">prob = sigmoid(np.array([<span class="number">1</span>, <span class="number">45</span>, <span class="number">85</span>])@(theta))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;For a student with scores 45 and 85, we predict an admission probability of &#123;prob&#125;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Expected value : 0.775 +/- 0.002&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果为0.776，即有77.6%的概率被录取</p><p><br/></p><p>最后检测一下通过参数$\theta$预测的准确度，首先编写<code>predict.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span>(<span class="params">theta, X</span>):</span></span><br><span class="line">    m = X.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    probability = sigmoid(X @ theta.T)</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">1</span> <span class="keyword">if</span> x &gt;= <span class="number">0.5</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> probability]</span><br></pre></td></tr></table></figure><p>逻辑很简单，如果算出来的<code>probability</code>大于等于0.5，那么就直接返回1，如果小于0.5，返回0</p><p>在<code>ex2.py</code>中调用<code>predict.py</code>中的<code>predict</code>函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = predict.predict(theta, X)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Train accuracy: <span class="subst">&#123;np.mean(y == p) * <span class="number">100</span>&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Expected accuracy (approx): 89.0&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>np.mean(y == p) * 100</code>: 计算预测准确度。这里通过 <code>y == p</code> 创建一个布尔数组，表示每个样本的真实标签是否与预测标签相等。<code>np.mean</code> 函数会把<code>True</code>看做是1，计算这个布尔数组中 <code>True</code> 的比例，即正确预测的样本占总样本的比例。乘以 100 就得到了准确度的百分比。</p><p><br/></p><hr><h2 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h2><p>正则化的逻辑回归的代价函数为：</p><script type="math/tex; mode=display">Cost = -\frac{1}{m}\sum_{i=1}^{m}[y^{(i)}\log(h_\theta(x^{(i)})) + (1 - y^{(i)})\log(1 - h_\theta(x^{(i)}))] + \frac{\lambda}{2m}\sum_{j=1}^{n}\theta_j^2</script><p>正则化的梯度下降的公式为：</p><script type="math/tex; mode=display">\theta_0 := \theta_0 - a\frac{1}{m}\sum_{i=1}^{m}(h_\theta(x^{(i)}) - y^{(i)})x_0^{(i)}</script><script type="math/tex; mode=display">\theta_j := \theta_j - a\left[\frac{1}{m}\sum_{i=1}^{m}(h_\theta(x^{(i)}) - y^{(i)})x_j^{(i)} + \frac{\lambda}{m}\theta_j\right]</script><p>所以只需要在<code>costFunciton.py</code>文件的基础上，将正则项加入运算即可</p><p>代价函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cost_function_reg</span>(<span class="params">theta, X, y, lmd</span>):</span></span><br><span class="line">    <span class="comment">#获取训练样本的数量</span></span><br><span class="line">    m = <span class="built_in">len</span>(y)   </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化grad数组来存储每个参数的梯度</span></span><br><span class="line">    grad = np.zeros(m)</span><br><span class="line">    pos = y @ np.log(sigmoid(X @ theta))  <span class="comment"># 代价函数的前半段</span></span><br><span class="line">    <span class="comment"># 添加小常数，代价函数的后半段</span></span><br><span class="line">    neg = (<span class="number">1</span> - y) @ np.log(<span class="number">1</span> - sigmoid(X @ theta) + <span class="number">1e-15</span>)</span><br><span class="line">    <span class="comment">#正则项，lmd就是lambda参数</span></span><br><span class="line">    reg = (lmd / (<span class="number">2</span> * m)) * np.<span class="built_in">sum</span>(np.power(theta[<span class="number">1</span>:], <span class="number">2</span>))</span><br><span class="line">    </span><br><span class="line">    cost = ((-np.<span class="built_in">sum</span>(pos + neg)))/m+reg  <span class="comment"># 算出代价</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cost</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>梯度下降</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient</span>(<span class="params">theta, X, y, lmd</span>):</span></span><br><span class="line">    m = <span class="built_in">len</span>(y)   <span class="comment">#获取训练样本的数量</span></span><br><span class="line">    grad = np.zeros(m)</span><br><span class="line"></span><br><span class="line">    error = sigmoid(X @ theta) - y  <span class="comment">#误差</span></span><br><span class="line"></span><br><span class="line">    grad = (<span class="number">1</span> / m) * (X.T @ error)  <span class="comment"># 计算梯度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 正则化项，注意grad[1:]是不包括偏置项的</span></span><br><span class="line">    grad[<span class="number">1</span>:] += (lmd / m) * theta[<span class="number">1</span>:]  <span class="comment">#加上正则化项的梯度</span></span><br><span class="line">    <span class="keyword">return</span> grad</span><br></pre></td></tr></table></figure><p><code>grad[1:]</code>: 这是<code>NumPy</code>中的数组切片操作，表示取 <code>grad</code> 数组的从索引1开始的所有元素（即，除了第一个元素以外的所有元素），因为正则化是默认不处理$\theta_0$的</p><p><code>+=</code>: 这是增量赋值操作符，表示将右侧的值加到左侧的变量上。这里将 <code>(learning_rate / m) * theta[1:]</code> 的值加到 <code>grad[1:]</code> 上。</p><p><code>(learning_rate / m) * theta[1:]</code>: 这是一个向量化的操作。它对 <code>theta</code> 中索引从1开始的所有元素应用了学习率和正则化项的操作。这样，一次性对整个向量进行了更新，而不需要显式地使用循环。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.0.正则化</title>
      <link href="/post/25133.html"/>
      <url>/post/25133.html</url>
      
        <content type="html"><![CDATA[<h1 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h1><h2 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h2><p>在机器学习中，过拟合是指模型在训练数据上表现得太好，以至于在未见过的新数据上表现不佳的现象。</p><p>如果我们有非常多的特征，我们通过学习得到的假设可能能够非常好地适应训练集（代价函数可能几乎为0），但是可能会不能推广到新的数据。</p><p>以线性回归中的房价预测为例：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231111225534535.png" alt="image-20231111225534535"></p><p>图1是一个线性模型，<strong>欠拟合</strong>，即不能很好地适应训练集</p><p>图3是一个四次方模型，过于强调拟合原始数据，而丢失了算法的本质：<strong>预测新数据</strong>，可以看出，若给出一个新的值使之预测，它将表现的很差，是<strong>过拟合</strong>，虽然能非常好地适应我们的训练集但在新输入变量进行预测时可能会效果不好</p><p>图2是一个二次模型，很好的拟合了数据集</p><p><br/></p><hr><p>分类问题中也存在这样的问题：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231111230248600.png" alt="image-20231111230248600"></p><p>就以多项式理解，$x$ 的次数越高，拟合的越好，但相应的预测的能力就可能变差。</p><p>显然图1是欠拟合，图2正好，而图3是过拟合</p><p><br/></p><p>处理过拟合的问题有以下几种方法：</p><ol><li><strong>正则化：</strong> 保留所有的特征，但是减少参数的大小。以惩罚模型的复杂性</li><li><strong>特征选择：</strong>丢弃一些不能帮助我们正确预测的特征。可以是手工选择保留哪些特征，或者使用一些模型选择的算法来帮忙（例如<strong>PCA</strong>）</li><li><strong>交叉验证：</strong> 使用交叉验证来评估模型的性能，确保模型在不同的数据子集上都表现良好，而不仅仅是在训练数据上。</li><li><strong>增加训练数据：</strong> 提供更多的训练数据可以帮助模型更好地学到数据的真实分布，减少过拟合的风险。</li></ol><p><br/></p><hr><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>在房价问题的线性回归中，发生过拟合时，选择的模型是：</p><script type="math/tex; mode=display">{h_\theta}(x) = \theta_{0} + \theta_{1}x_{1} + \theta_{2}x_{2}^2 + \theta_{3}x_{3}^3 + \theta_{4}x_{4}^4</script><p>正是这些高次项导致了过拟合的产生，所以如果能让这些高次项的系数接近于0的话，解决过拟合的问题</p><p>所以要做的就是在一定程度上减小这些参数$\theta $ 的值，这就是<strong>正则化</strong>的基本思想。如果我们希望减小 ${\theta_{3}}$ 和 ${\theta_{4}}$ 的大小，我们可以通过修改代价函数并对 ${\theta_{3}}$ 和 ${\theta_{4}}$ 进行一定的<strong>惩罚</strong>来实现。</p><p> 修改后的代价函数如下：</p><script type="math/tex; mode=display">cost=\frac{1}{2m}\sum\limits_{i=1}^m{(h_{\theta}( x^{(i)})-y^{(i)})}^2 + 1000\theta_3^2 + 1000\theta_4^2</script><p>优化算法的目标是最小化整个代价函数，因此，为了最小化整个代价函数，算法倾向于选择较小的 $\theta_3$ 和 $\theta_4$，以降低正则化项的值。</p><p>通过这样的代价函数选择出的${\theta_{3}}$和${\theta_{4}}$ 对预测结果的影响就比之前要小许多，假如我们有非常多的特征，我们并不知道其中哪些特征我们要惩罚，我们将对所有的特征进行惩罚，并且让代价函数最优化的软件来选择这些惩罚的程度。这样的结果是得到了一个较为简单的能防止过拟合问题的假设：</p><script type="math/tex; mode=display">J(\theta) = \frac{1}{2m}\sum_{i=1}^{m}{\left(h_{\theta}(x^{(i)}) - y^{(i)}+{\lambda}\sum_{j=1}^{n}{\theta_j^2}\right)^2}</script><p>为了引入正则化，我们添加了一个正则化项，通常是模型参数的平方和，其中 $\lambda$ 是正则化参数，用于控制正则化的强度， $n$ 是模型的参数数量。</p><p>注：根据惯例，不对${\theta_{0}}$ 进行惩罚。经过正则化处理的模型与原模型的可能对比如下图所示：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231112000945984.png" alt="image-20231112000945984"></p><p>正则化参数$\lambda$ 过大：则会把所有的参数都最小化了，导致模型变成 ${h_\theta}\left( x \right)={\theta_{0}}$，也就是上图中红色直线所示的情况，造成欠拟合。</p><p><br/></p><hr><h2 id="正则化线性回归"><a href="#正则化线性回归" class="headerlink" title="正则化线性回归"></a>正则化线性回归</h2><p>对于线性回归的求解，我们之前推导了两种学习算法：一种基于梯度下降，一种基于正规方程。</p><p>正则化线性回归的代价函数为：</p><script type="math/tex; mode=display">J(\theta) = \frac{1}{2m}\sum_{i=1}^{m} \left( (h_\theta(x^{(i)}) - y^{(i)})^2 + \lambda \sum_{j=1}^{n}\theta_j^2 \right)</script><p>如果我们要使用梯度下降法令这个代价函数最小化，因为我们未对$\theta_0$进行正则化，所以梯度下降算法将分两种情形：</p><script type="math/tex; mode=display">\theta_0 := \theta_0 - a\frac{1}{m}\sum_{i=1}^{m}(h_\theta(x^{(i)}) - y^{(i)})x_0^{(i)}</script><script type="math/tex; mode=display">\theta_j := \theta_j - a\left[\frac{1}{m}\sum_{i=1}^{m}(h_\theta(x^{(i)}) - y^{(i)})x_j^{(i)} + \frac{\lambda}{m}\theta_j\right]</script><p>对上面的算法中$ j=1,2,…,n$ 时的更新式子进行调整可得：</p><script type="math/tex; mode=display"> \theta_j := \theta_j(1 - a\frac{\lambda}{m}) - a\frac{1}{m}\sum_{i=1}^{m}(h_\theta(x^{(i)}) - y^{(i)})x_j^{(i)}</script><p>可以看出，正则化线性回归的梯度下降算法的变化在于，每次都在原有算法更新规则的基础上令$\theta $值减少了一个额外的值。</p><p><br/></p><hr><h2 id="正则化逻辑回归"><a href="#正则化逻辑回归" class="headerlink" title="正则化逻辑回归"></a>正则化逻辑回归</h2><p>逻辑回归的代价函数为：</p><script type="math/tex; mode=display">Cost\left( {h_\theta}\left( x \right),y \right)=-\frac{1}{m}\sum\limits_{i=1}^{m}{[y^{(i)}\log \left( {h_\theta}\left( x^{(i)} \right) \right)+\left( 1-{y^{(i)}} \right)\log \left( 1-{h_\theta}\left( x^{(i)} \right) \right)]}</script><p>同样对于逻辑回归，我们也给代价函数增加一个正则化的表达式，得到代价函数：</p><script type="math/tex; mode=display">Cost = -\frac{1}{m}\sum_{i=1}^{m}[y^{(i)}\log(h_\theta(x^{(i)})) + (1 - y^{(i)})\log(1 - h_\theta(x^{(i)}))] + \frac{\lambda}{2m}\sum_{j=1}^{n}\theta_j^2</script><p>要最小化该代价函数，通过求导，得出梯度下降算法为：</p><script type="math/tex; mode=display">\theta_0 := \theta_0 - a\frac{1}{m}\sum_{i=1}^{m}(h_\theta(x^{(i)}) - y^{(i)})x_0^{(i)}</script><script type="math/tex; mode=display">\theta_j := \theta_j - a\left[\frac{1}{m}\sum_{i=1}^{m}(h_\theta(x^{(i)}) - y^{(i)})x_j^{(i)} + \frac{\lambda}{m}\theta_j\right]</script><p>看上去同线性回归一样，但是知道 ${h_\theta}\left( x \right)=g\left( {\theta^T}X \right)$，所以与线性回归不同。</p><p><br/></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.逻辑回归</title>
      <link href="/post/62980.html"/>
      <url>/post/62980.html</url>
      
        <content type="html"><![CDATA[<h1 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h1><h2 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h2><p>分类问题中，预测的变量 $y$ 是离散的值(0or1)，我们将学习一种叫做<strong>逻辑回归</strong> (<strong>Logistic Regression</strong>) 的算法，这是目前最流行使用最广泛的一种学习算法。</p><p>将因变量可能属于的两个类分别称为负向类（<strong>negative class</strong>）和正向类（<strong>positive class</strong>），则因变量$y\in { 0,1 \\}$ ，其中 0 表示负向类，1 表示正向类。</p><p>比如对乳腺癌肿瘤种类的预测：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231109204436065.png" alt="image-20231109204436065"></p><p>可以用<strong>线性回归</strong>的方法求出适合数据的一条直线</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231109211838342.png" alt="image-20231109211838342"></p><p>根据线性回归模型我们只能预测连续的值，然而对于分类问题，我们需要输出0或1，我们可以预测：</p><ul><li><p>${h_\theta}\left( x \right)&gt;=0.5$时，预测 $y=1$。</p></li><li><p>${h_\theta}\left( x \right)&lt;0.5$时，预测 $y=0$ 。</p></li></ul><p><br/></p><p>对于上图所示的数据，这样的一个线性模型似乎能很好地完成分类任务。假使又观测到一个非常大尺寸的恶性肿瘤，将其作为实例加入到训练集中来，这将获得一条新的直线。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231109211910162.png" alt="image-20231109211910162"></p><p>这时，再使用0.5作为阀值来预测肿瘤是良性还是恶性便不合适了。可以看出，线性回归模型，因为其预测的值可以超越<code>[0,1]</code>的范围，并<strong>不适合解决</strong>这样的问题。</p><p><br/></p><p>此外，如果我们要用线性回归算法来解决一个分类问题，对于分类， $y$ 取值为 0 或者1，但如果使用的是线性回归，那么假设函数的输出值可能远大于 1，或者远小于0，即使所有训练样本的标签  $y$ 都等于 0 或 1</p><p>尽管标签应该最后取值是0 或者1，但是如果算法得到的值远大于1或者远小于0的话，就会感觉很奇怪。所以我们在接下来的要研究的算法就叫做<strong>逻辑回归算法</strong>，这个算法的性质是：它的输出值永远在0到 1 之间。</p><p><br/></p><hr><h2 id="假设陈述"><a href="#假设陈述" class="headerlink" title="假设陈述"></a>假设陈述</h2><p>引入一个新的模型，<strong>逻辑回归</strong>，该模型的输出变量范围始终在0和1之间。<br>逻辑回归模型的假设是： $h_\theta \left( x \right)=g\left(\theta^{T}X \right)$<br>其中：<br>$X$ 代表特征向量<br>$g$ 代表逻辑函数（<strong>logistic function</strong>)是一个常用的逻辑函数为<strong>S</strong>形函数（<strong>Sigmoid function</strong>），公式为：</p><script type="math/tex; mode=display">g\left( z \right)=\frac{1}{1+{e^{-z}}}</script><p>该函数的图像为：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231109212532866.png" alt="image-20231109212532866"></p><p>合起来，我们得到逻辑回归模型的假设：</p><script type="math/tex; mode=display">h_\theta\left( x \right)=\frac{1}{1+{e^{-\theta^TX }}}</script><p>$h_\theta \left( x \right)$的作用是，对于给定的输入变量，根据选择的参数计算输出变量=1的<strong>概率</strong></p><p>例如，如果对于给定的$x$，通过已经确定的参数计算得出$h_\theta \left( x \right)=0.7$，则表示有70%的几率$y$为正向类，相应地$y$为负向类的几率为30%</p><p><br/></p><hr><h2 id="决策边界"><a href="#决策边界" class="headerlink" title="决策边界"></a>决策边界</h2><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231109212532866.png" alt="image-20231109212532866"></p><p>在逻辑回归中，我们预测：</p><ul><li><p>${h_\theta}\left( x \right)&gt;=0.5$时，预测 $y=1$。</p></li><li><p>${h_\theta}\left( x \right)&lt;0.5$时，预测 $y=0$ 。</p></li></ul><p>据上面绘制出的 <strong>S</strong> 形函数图像，我们知道当</p><ul><li><p>$z=0$ 时 $g(z)=0.5$</p></li><li><p>$z&gt;0$ 时 $g(z)&gt;0.5$</p></li><li><p>$z&lt;0$ 时 $g(z)&lt;0.5$</p></li></ul><p>又 $z={\theta^{T}}x$ ，即：</p><ul><li>${\theta^{T}}x&gt;=0$  时，预测 $y=1$</li><li>${\theta^{T}}x&lt;0$  时，预测 $y=0$</li></ul><p><br/></p><p>现在假设我们有一个模型：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231110044359628.png" alt="image-20231110044359628"></p><p>可以用${h_\theta}\left( x \right)=g\left( {\theta_0}+{\theta_1}{x_1}+{\theta_{2}}{x_{2}} \right)$作为模型的分界线，并且参数$\theta$ 是向量[-3 1 1]，则当$-3+{x_1}+{x_2} \geq 0$，即${x_1}+{x_2} \geq 3$时，模型将预测 $y=1$。</p><p>我们可以绘制直线${x_1}+{x_2} = 3$，这条线便是我们模型的分界线，将预测为1的区域和预测为 0的区域分隔开</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231110044624799.png" alt="image-20231110044624799"></p><p>可以用非常复杂的模型来适应非常复杂形状的判定边界</p><p><br/><br/></p><hr><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>对于<strong>线性回归</strong>模型，定义的代价函数是所有模型误差的平方和。</p><script type="math/tex; mode=display">J(θ_0,θ_1)=\frac{1}{2m}\sum\limits_{i=1}^m(h_θ(x^{(i)})−y^{(i)})^2</script><p>理论上来说，也可以对逻辑回归模型沿用这个定义，但是问题在于，当我们将${h_\theta}\left( x \right)=\frac{1}{1+{e^{-\theta^{T}x}}}$带入到这样定义了的代价函数中时，我们得到的代价函数将是一个<strong>非凸函数</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231110045753697.png" alt="image-20231110045753697"></p><p>这意味着我们的代价函数有许多<strong>局部最小值</strong>，这将影响梯度下降算法寻找全局最小值</p><p>所以为了避免这个问题，重新定义逻辑回归的代价函数为：$J\left( \theta  \right)=\frac{1}{m}\sum\limits_{i=1}^m{Cost\left( {h_\theta}\left( x^{\left( i \right)} \right),y^{\left( i \right)} \right)}$，其中：</p><script type="math/tex; mode=display">Cost(h_{\theta}(x),y) =\begin{cases} -log\left( {h_\theta}\left( x \right) \right)  & \text{if }y=1 \\-log\left( 1-{h_\theta}\left( x \right) \right), & \text{if }y=0\end{cases}</script><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231110050411633.png" alt="image-20231110050411633" style="zoom:80%;" /></p><p>这样构建的$Cost\left( {h_\theta}\left( x \right),y \right)$函数的特点是：</p><ul><li><p>当实际的  $y=1$ 且${h_\theta}\left( x \right)$也为 1 时代价为 0，当 $y=1$ 但${h_\theta}\left( x \right)$不为1时误差随着${h_\theta}\left( x \right)$变小而变大</p></li><li><p>当实际的 $y=0$ 且${h_\theta}\left( x \right)$也为 0 时代价为 0，当$y=0$ 但${h_\theta}\left( x \right)$不为 0时误差随着 ${h_\theta}\left( x \right)$的变大而变大</p></li></ul><p><br/></p><p>可以合并$Cost\left( {h_\theta}\left( x \right),y \right)$：</p><script type="math/tex; mode=display">Cost\left( {h_\theta}\left( x \right),y \right)=-y\times log\left( {h_\theta}\left( x \right) \right)-(1-y)\times log\left( 1-{h_\theta}\left( x \right) \right)</script><p>即，逻辑回归的代价函数：</p><script type="math/tex; mode=display">Cost\left( {h_\theta}\left( x \right),y \right)=-\frac{1}{m}\sum\limits_{i=1}^{m}{[y^{(i)}\log \left( {h_\theta}\left( x^{(i)} \right) \right)+\left( 1-{y^{(i)}} \right)\log \left( 1-{h_\theta}\left( x^{(i)} \right) \right)]}</script><p><br/></p><hr><h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><p>为了找出让$Cost\left( {h_\theta}\left( x \right),y \right)$最小的$\theta$ 参数，需要使用梯度下降法</p><p>即：</p><script type="math/tex; mode=display">\theta_j:=\theta_j-\alpha\frac{\partial{J(θ_0,θ_1)}}{\partial{\theta_j}}</script><p>而</p><script type="math/tex; mode=display">J\left( \theta  \right)=-\frac{1}{m}\sum\limits_{i=1}^{m}{[{y^{(i)}}\log \left( {h_\theta}\left( {x^{(i)}} \right) \right)+\left( 1-{y^{(i)}} \right)\log \left( 1-{h_\theta}\left( {x^{(i)}} \right) \right)]}</script><p>对$J\left( \theta  \right)$求偏导数，结果是：（数学推导过程略）</p><script type="math/tex; mode=display">\frac{\partial }{\partial \theta _j}J(\theta)=\frac{1}{m}{\sum_{i=1}^m(( h_\theta (x^{(i)}})-y^{(i)})\cdot x^{(i)})</script><p>那么，梯度下降法的公式为：</p><script type="math/tex; mode=display">{\theta_j}:={\theta_j}-\alpha \frac{1}{m}\sum\limits_{i=1}^{m}{({h_\theta}(x^{(i)})-{y^{(i)}}){x_j}^{(i)}}</script><p>和线性回归梯度下降一模一样，但是线性回归和逻辑回归不是同一个算法，因为假设函数是不一样的</p><ul><li>对于线性回归的假设函数：${h_\theta}\left( x \right)={\theta^T}X={\theta_0}{x_0}+{\theta_1}{x_1}+{\theta_2}{x_2}+…+{\theta_n}{x_n}$</li><li>对于逻辑函数假设函数：${h_\theta}\left( x \right)=\frac{1}{1+{e^{-{\theta^T}X}}}$</li></ul><p><br/></p><hr><h2 id="高级优化"><a href="#高级优化" class="headerlink" title="高级优化"></a>高级优化</h2><p>梯度下降并不是我们可以使用的唯一算法，还有其他一些算法，更高级、更复杂。如果能用这些方法来计算代价函数$J\left( \theta  \right)$和偏导数项$\frac{\partial }{\partial {\theta_j}}J\left( \theta  \right)$两个项的话，那么这些算法就是为我们优化代价函数的不同方法，<strong>共轭梯度法 BFGS</strong> (<strong>变尺度法</strong>) 和<strong>L-BFGS</strong> (<strong>限制变尺度法</strong>) 就是其中一些更高级的优化算法，它们需要有一种方法来计算 $J\left( \theta  \right)$，以及需要一种方法计算导数项，然后使用比梯度下降更复杂的算法来最小化代价函数</p><div class="note primary flat"><p>并不需要知道这些算法的细节，只要会需要使用就行</p></div><p><br/></p><p>在<code>python</code>中，如果想使用<code>BFGS</code>算法求解优化问题，需要先导入<code>scipy</code>库</p><p><code>SciPy</code>是一个开源的<code>Python</code>算法库和数学工具包。它基于<code>Numpy</code>，用于数学、科学、工程学等领域。包含的模块有最优化、线性代数、积分、插值、特殊函数、快速傅里叶变换、信号处理和图像处理、常微分方程求解和其他科学与工程中常用的计算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scipy.optimize <span class="keyword">as</span> opt</span><br></pre></td></tr></table></figure><p>这里导入<code>scipy</code>中<code>opt</code>模块，然后介绍一下<code>opt</code>中的<code>fmin_bfgs</code>函数</p><p><code>opt.fmin_bfgs(f, fprime, x0, maxiter, full_output, disp,args,gtol,norm，epsilon，callback,retall)</code></p><ul><li><code>f</code>：这是你要最小化的目标函数，函数只能有一个参数</li><li><code>fprime</code>：这是目标函数的梯度，也就是导数。如果你没有提供，那么函数会使用<strong>近似值</strong>。</li><li><code>x0</code>：这是参数的初始猜测值</li><li><code>maxiter</code>：这是最大迭代次数，即算法尝试找到最小值的步数。</li><li><code>full_output</code>：如果为True，则<strong>返回所有输出结果</strong>，包括最优解、最小值、梯度的最小值、逆Hessian矩阵、函数调用次数、梯度调用次数、警告标志以及每次迭代的结果列表。</li><li><code>disp</code>：如果为True，则打印收敛信息。</li><li><code>args</code>：这是传递给<code>f</code>和<code>fprime</code>的额外参数。</li><li><code>gtol</code>：这是梯度范数的阈值，如果梯度范数小于这个值，那么算法就会停止。</li><li><code>norm</code>：这是用于计算梯度范数的范数的阶数。</li><li><code>epsilon</code>：如果<code>fprime</code>是近似的，那么这个值就是步长。</li><li><code>callback</code>：这是一个可选的用户提供的函数，每次迭代后都会被调用。调用的形式是<code>callback(xk)</code>，其中<code>xk</code>是当前的参数向量。</li><li><code>retall</code>：如果为True，则返回每次迭代的结果列表。</li></ul><p><br/></p><p>实例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theta, cost, *unused = opt.fmin_bfgs(f=cost_func, x0=initial_theta, maxiter=<span class="number">400</span>, full_output=<span class="literal">True</span>, disp=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><p><code>f=cost_func</code>：最小化的目标函数名字叫<code>cost_func</code>，需要实现写好目标函数</p></li><li><p><code>x0=initial_theta</code>：这是参数的初始猜测值<code>initial_theta</code></p></li><li><p><code>maxiter=400</code>：这是最大迭代次数，即算法尝试找到最小值的步数。</p></li><li><p><code>full_output=True</code>：如果为True，则返回所有输出结果，包括最优解、最小值、梯度的最小值、逆Hessian矩阵、函数调用次数、梯度调用次数、警告标志以及每次迭代的结果列表。</p></li><li><p><code>disp=False</code>：如果为True，则打印收敛信息。</p><p><br/></p></li></ul><p>返回值<code>theta, cost, *unused</code>是一个元组，其中：</p><ul><li><code>theta</code>是最小化函数的参数$\theta$，即最优解。</li><li><code>cost</code>是最小值，即目标函数在最优解处的值。</li><li><code>*unused</code>是其他返回值，包括梯度的最小值、逆Hessian矩阵、函数调用次数、梯度调用次数、警告标志以及每次迭代的结果列表。由于不需要这些值，所以可以使用<code>*unused</code>来忽略它们。</li></ul><p><br/></p><hr><h2 id="多类分类"><a href="#多类分类" class="headerlink" title="多类分类"></a>多类分类</h2><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231111132059537.png" alt="image-20231111132059537"></p><p>现在有一个训练集，好比上图表示的有3个类别，我们用三角形表示 $y=1$，方框表示$y=2$，叉叉表示 $y=3$。我们下面要做的就是使用一个训练集，将其分成3个二元分类问题。</p><p>如下图所示的那样，要拟合出一个合适的分类器。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231111132505789.png" alt="image-20231111132505789"></p><p>方法是先将两个类看做是同一个类，这样问题就变成了二元分类问题，可以求出决策边界，然后重复此方法，画出多个决策边界，从而选出拟合质量最好的边界</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.5 ex1:linear regression</title>
      <link href="/post/62884.html"/>
      <url>/post/62884.html</url>
      
        <content type="html"><![CDATA[<h1 id="ex1-linear-regression"><a href="#ex1-linear-regression" class="headerlink" title="ex1:linear regression"></a>ex1:linear regression</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在这部分练习中，您将使用一个变量进行线性回归，以预测一辆餐车的利润。假设您是一家餐饮连锁店的首席执行官，正在考虑在不同城市开设新的分店。该连锁店已在多个城市拥有餐车，您也掌握了这些城市的利润和人口数据。</p><p>必要的文件如下：</p><ul><li><code>ex1.py</code>-引导您完成练习的<code>Python</code>文件</li><li><code>ex1data1.txt</code> -单变量线性回归的数据集</li><li><code>computeCost.py</code>-计算线性回归成本的函数</li><li><code>gradientDescent.py</code>-运行梯度下降的函数</li></ul><p><br/></p><hr><h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> LogNorm</span><br><span class="line"><span class="keyword">from</span> computeCost <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gradientDescent <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure><p>在<code>Python</code>中，<code>from computeCost import *</code>是一种导入语句，用于从<code>computeCost</code>模块导入所有的公共对象（例如函数、类、变量等）。这意味着你可以直接使用这些对象，而无需通过模块名来引用它们。</p><p>例如，假设<code>computeCost</code>模块中有一个函数<code>compute_cost()</code>，那么你可以直接调用<code>compute_cost()</code>，而不需要写成<code>computeCost.compute_cost()</code></p><p><br/></p><hr><h2 id="读取并绘图"><a href="#读取并绘图" class="headerlink" title="读取并绘图"></a>读取并绘图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data=pd.read_csv(<span class="string">&#x27;ex1data1.txt&#x27;</span>,header=<span class="literal">None</span>,names=[<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;y&#x27;</span>])</span><br><span class="line">plt.plot(data[<span class="string">&#x27;x&#x27;</span>],data[<span class="string">&#x27;y&#x27;</span>],<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><code>pd.read_csv</code>函数表示：读取<code>ex1data1.txt</code>这个文件，<code>header=None</code>表示第一行是数据，而不是列名，<code>names=[&#39;x&#39;,&#39;y&#39;]</code>意味着<code>DataFrame</code>将有两列，第一列的列名是<code>x</code>，第二列的列名是<code>y</code>。</p><p><code>plt.plot</code>函数表示，横轴的数据是<code>data</code>中名字叫<code>x</code>的列，纵轴的数据是<code>data</code>中名字叫<code>y</code>的列，散点的标记是<code>x</code>图案</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231109044138469.png" alt="image-20231109044138469" style="zoom: 80%;" /></p><p><br/></p><hr><h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><h3 id="插入-x-0-参数列"><a href="#插入-x-0-参数列" class="headerlink" title="插入$x_0$参数列"></a>插入$x_0$参数列</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.insert(<span class="number">0</span>,<span class="string">&#x27;one&#x27;</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>在<code>data</code>的第<code>1</code>列，插入元素为<code>1</code>的列，并且把这列的名字命名为<code>one</code></p><p>在多变量线性回归这一节的开头，解释了原因：</p><blockquote><p>多元线性回归时的映射$h$被表述为：</p><script type="math/tex; mode=display">h_{\boldsymbol{\theta}}(x)=\theta_0+\theta_1x_1+\theta_2x_2+\cdots+\theta_nx_n\\</script><p>这个公式中有$n+1$个参数和$n$个变量，为了表述的方便，我们会在样本中新增一个特征量记为$x_0^{(i)}=1,(i=1,2,\cdots,n)$，则公式转化为：</p><script type="math/tex; mode=display">h_{\theta} \left( x \right)={\theta_{0}}{x_{0}}+{\theta_{1}}{x_{1}}+{\theta_{2}}{x_{2}}+...+{\theta_{n}}{x_{n}}</script><p>在此情况下只需要定义这样的两个向量：</p><script type="math/tex; mode=display">\boldsymbol{x}=\begin{bmatrix} x_0 \\ x_1 \\ x_2 \\ \vdots \\ x_n \end{bmatrix}\in\mathbb{R}^{n+1}, \boldsymbol{\theta}=\begin{bmatrix} \theta_0 \\ \theta_1 \\ \theta_2 \\ \vdots \\ \theta_n \end{bmatrix}\in\mathbb{R}^{n+1}\\</script><p>就可以将前面的映射表述为<strong>向量内积</strong>的形式：</p><script type="math/tex; mode=display">h_{\boldsymbol{\theta}}(\boldsymbol{x})=\boldsymbol{\theta}^T\boldsymbol{x}\\</script></blockquote><p>插入$x_0=1$的列，可以将$h_{\boldsymbol{\theta}}$变为向量内积的形式，便于$\theta$的计算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(data.head()) </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    one   x        y</span></span><br><span class="line"><span class="string">0    1  6.1101  17.5920</span></span><br><span class="line"><span class="string">1    1  5.5277   9.1302</span></span><br><span class="line"><span class="string">2    1  8.5186  13.6620</span></span><br><span class="line"><span class="string">3    1  7.0032  11.8540</span></span><br><span class="line"><span class="string">4    1  5.8598   6.8233</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>展示<code>data</code>的前5行，看一下是否是我们所设置的那样，可以看到有3列，名字分别是<code>one</code>，<code>x</code>，<code>y</code></p><p><br/></p><hr><h3 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">col=data.shape[<span class="number">1</span>]</span><br><span class="line">X=data.iloc[:,<span class="number">0</span>:col-<span class="number">1</span>]</span><br><span class="line">y=data.iloc[:,col-<span class="number">1</span>]</span><br><span class="line">theta=np.zeros(col-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><code>data.shape[1]</code>表示的是<code>data</code>列的数量，赋值给<code>col</code>，实际上是3</p><p>接下来使用了<code>Pandas</code>的<code>iloc</code>函数的切片语法</p><ul><li><code>X</code>：表示<code>data</code>的前两列，即$x_0$和$x_1$的数据</li><li><code>y</code>：表示<code>data</code>的最后一列，即最后的<code>y</code>的数据</li><li><code>theta</code>：使用<code>numpy</code>中的<code>zeros</code>函数，初始化成了<code>[0,0]</code>形式，数量和<code>x</code>的个数肯定是相等的</li></ul><p><br/></p><p>接下来，编写<code>computeCost.py</code>文件中的<code>compute_cost(X, y, theta)</code>函数，计算代价</p><p>代价函数的计算公式是：</p><script type="math/tex; mode=display">J(θ_0,θ_1)=\frac{1}{2m}\sum\limits_{i=1}^m(h_θ(x^i)−y^i)^2</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_cost</span>(<span class="params">X, y, theta</span>):</span></span><br><span class="line">    <span class="comment"># Initialize some useful values</span></span><br><span class="line">    inner = np.power(((X @ theta) - y), <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> np.<span class="built_in">sum</span>(inner) / (<span class="number">2</span> * <span class="built_in">len</span>(X))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>X</code>是一个$(n,2)$的数组，<code>y</code>是一个$(n,1)$的数组，<code>thetas</code>是一个$(2,)$的数组，<code>X @ theta</code>就表示了$h_{\boldsymbol{\theta}}(\boldsymbol{x})=\boldsymbol{\theta}^T\boldsymbol{x}$，其中<code>@</code>的意思是要用矩阵乘法，而不是元素乘法，<code>X @ theta</code>会让<code>X</code>中的每一行都和<code>theta</code>中元素做点积，即计算结果是一个$(n,1)$的数组</p><p><code>np.power</code>是幂的计算函数，参数为2，意味求$h_{\boldsymbol{\theta}}(\boldsymbol{x})-y$的二次幂，因为是数组的运算，所以把数组中每个元素都变为其二次幂的形式</p><p><code>np.sum</code>将数组中每个元素全部都相加在一起，最后除以2倍<code>X</code>数组的元素个数，即为$\frac{1}{2m}$</p><p><br/></p><p>再回到<code>ex1.py</code>文件中来，将之前写的<code>X</code>，<code>y</code>，<code>theta</code>代入到<code>compute_cost</code>函数中去</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(compute_cost(X, y, theta))</span><br><span class="line"><span class="comment">#结果是32.07  </span></span><br></pre></td></tr></table></figure><p>完全符合预期</p><hr><h3 id="梯度下降-1"><a href="#梯度下降-1" class="headerlink" title="梯度下降"></a>梯度下降</h3><p>在编写梯度下降函数之前，先设置参数，这里吧迭代次数<code>iterations</code>设置成1500次，学习率<code>alpha</code>设置为0.01</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iterations = <span class="number">1500</span></span><br><span class="line">alpha = <span class="number">0.01</span></span><br></pre></td></tr></table></figure><p><br/></p><hr><p>再编写<code>gradient_descent.py</code>中的<code>gradient_descent(X, y, theta, alpha, iters)</code>函数，完成梯度下降功能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient_descent</span>(<span class="params">X, y, theta, alpha, iters</span>):</span></span><br><span class="line">    m = <span class="built_in">len</span>(y)</span><br><span class="line">    cost = np.zeros(iters)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 迭代</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(iters):</span><br><span class="line">        <span class="comment"># 预测</span></span><br><span class="line">        y_pred = X @ theta</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算误差</span></span><br><span class="line">        error = y_pred - y</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算代价</span></span><br><span class="line">        cost[i] = compute_cost(X, y, theta)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 更新每个参数</span></span><br><span class="line">        theta -= (alpha / m) * (X.T @ error)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> theta, cost</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>设置一个大小为<code>iters</code>的数组<code>cos</code>，用来记录每次迭代<code>theta</code>所产生的代价</p><p>在一个执行<code>iters</code>(1500)次的循环中，</p><ul><li><code>y_pred</code>表示模型的预测值即$h_{\boldsymbol{\theta}}(\boldsymbol{x})=\boldsymbol{\theta}^T\boldsymbol{x}$</li><li><code>error</code>表示模型和真实值的误差： $\boldsymbol{\theta}^T\boldsymbol{x}- y$</li><li><code>cost[i] = compute_cost(X, y, theta)</code>：将每次<code>theta</code>的参数代入代价函数中计算代价</li><li><code>theta -= (alpha / m) * (X.T @ error)</code>：这里直接就是矩阵之间的减法，对应元素会直接相减，体现了矢量化的思想</li></ul><p>梯度下降的公式</p><blockquote><script type="math/tex; mode=display">\theta_j:=\theta_j-\alpha\frac{\partial{J(θ_0,θ_1)}}{\partial{\theta_j}}</script><p>其中</p><script type="math/tex; mode=display">\frac{\partial }{\partial \theta _j}J(\theta_0,\theta_1)=\frac{1}{m}{\sum_{i=1}^m(( h_\theta (x^{(i)}})-y^{(i)})\cdot x^{(i)})</script><p>即</p><script type="math/tex; mode=display">\theta_j:=\theta_j-\alpha\frac{1}{m}{\sum_{i=1}^m(( h_\theta (x^{(i)}})-y^{(i)})\cdot x^{(i)})</script></blockquote><p>最后返回一个<code>theta</code>数组和一个<code>cost</code>数组，<code>theta</code>里面的$\theta$值就是梯度下降1500次过后的$\theta$</p><p><br/></p><hr><p>回到<code>ex1.py</code>中，接下来调用<code>gradient_descent</code>函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">theta,cost= gradient_descent(X, y, theta, alpha, iterations)</span><br><span class="line"><span class="built_in">print</span>(theta)</span><br><span class="line"><span class="comment">#[-3.63029144  1.16636235]</span></span><br></pre></td></tr></table></figure><p>输出<code>theta</code>，结果符合预期</p><p><br/></p><p>再根据梯度下降后的theta数组，绘制拟合曲线</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pred=X@theta.T   <span class="comment">#根据x值预测出的y值</span></span><br><span class="line">plt.plot(data[<span class="string">&#x27;x&#x27;</span>], pred,<span class="string">&#x27;r&#x27;</span>,label=<span class="string">&#x27;Linear Regression&#x27;</span>) </span><br><span class="line">plt.ylabel(<span class="string">&#x27;Profit&#x27;</span>)  <span class="comment">#设置y轴名称</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;Population&#x27;</span>)   <span class="comment">#设置x轴名称</span></span><br><span class="line">plt.title(<span class="string">&#x27;Profit and Population&#x27;</span>) <span class="comment"># 设置标题</span></span><br><span class="line">plt.legend()  <span class="comment">#展示图例</span></span><br><span class="line">plt.show()  <span class="comment">#展示图像</span></span><br></pre></td></tr></table></figure><p>把预测值$h_{\boldsymbol{\theta}}(\boldsymbol{x})=\boldsymbol{\theta}^T\boldsymbol{x}$插入到<code>data</code>的第4列中去，这样做是因为，<code>Pandas</code>的<code>plot</code>函数必须要使用<code>Pandas</code>对象中的列作为参数</p><p><code>plot</code>函数将名称为<code>x</code>的列作为横轴，把<code>pred</code>作为纵轴，曲线命名为Linear Regression，颜色为红色，绘制图像</p><p>设置x，y轴的名称，图像标题，展示图例，展示图像后：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231109060851904.png" alt="image-20231109060851904" style="zoom:80%;" /></p><p><br/></p><hr><p>再展示<code>cost</code>数组的内容，将梯度下降的内容展示出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(np.arange(<span class="number">1500</span>),cost)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>把0~1500的连续值设置为x轴，把cost的值设置为y轴，绘制并展示图像</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231109060229598.png" alt="image-20231109060229598" style="zoom:67%;" /></p><p>可以看到，经过1500次的迭代，代价<code>cost</code>在逐渐接近0，说明拟合效果很好</p><p><br/></p><hr><p>最后我们解决一下实际问题，预测一下Population为35000的城市，利润有多少？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">predict=np.array[<span class="number">1</span>,<span class="number">3.5</span>]@theta  </span><br><span class="line"><span class="built_in">print</span>(predict*<span class="number">10000</span>)</span><br><span class="line"><span class="comment">#结果是4519.768</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.多变量线性回归</title>
      <link href="/post/58393.html"/>
      <url>/post/58393.html</url>
      
        <content type="html"><![CDATA[<h1 id="多变量线性回归"><a href="#多变量线性回归" class="headerlink" title="多变量线性回归"></a>多变量线性回归</h1><h2 id="多维特征"><a href="#多维特征" class="headerlink" title="多维特征"></a>多维特征</h2><h3 id="表示方法"><a href="#表示方法" class="headerlink" title="表示方法"></a>表示方法</h3><p>目前为止，我们探讨了单变量/特征的回归模型，现在我们对房价模型增加更多的特征，例如房间数楼层等，构成一个含有多个变量的模型，模型中的特征为$\left( {x_{1}},{x_{2}},…,{x_{n}} \right)$。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231024201227475.png" alt="image-20231024201227475"></p><p>增添更多特征后，我们引入一系列新的注释：</p><p>$n$代表特征的数量</p><p>$x^{(i)}$代表第$i$个训练实例，是特征矩阵中的第$i$行</p><p>比方说，上图的${x}^{(2)}\text{=}\begin{bmatrix} 1416\\ 3\\ 2\\ 40 \end{bmatrix}$</p><p>$x_j^{(i)}$ 代表特征矩阵中第 $i$ 行的第 $j$ 个特征，也就是第 $i$ 个训练实例的第 $j$ 个特征。</p><p>如上图的$x_{2}^{\left( 2 \right)}=3,x_{3}^{\left( 2 \right)}=2$</p><p><br/></p><p>于是多元线性回归时的映射$h$被表述为：</p><script type="math/tex; mode=display">h_{\boldsymbol{\theta}}(x)=\theta_0+\theta_1x_1+\theta_2x_2+\cdots+\theta_nx_n\\</script><p>这个公式中有$n+1$个参数和$n$个变量，为了表述的方便，我们会在样本中新增一个特征量记为$x_0^{(i)}=1,(i=1,2,\cdots,n)$，则公式转化为：</p><script type="math/tex; mode=display">h_{\theta} \left( x \right)={\theta_{0}}{x_{0}}+{\theta_{1}}{x_{1}}+{\theta_{2}}{x_{2}}+...+{\theta_{n}}{x_{n}}</script><p>在此情况下只需要定义这样的两个向量：</p><script type="math/tex; mode=display">\boldsymbol{x}=\begin{bmatrix} x_0 \\ x_1 \\ x_2 \\ \vdots \\ x_n \end{bmatrix}\in\mathbb{R}^{n+1}, \boldsymbol{\theta}=\begin{bmatrix} \theta_0 \\ \theta_1 \\ \theta_2 \\ \vdots \\ \theta_n \end{bmatrix}\in\mathbb{R}^{n+1}\\</script><p>就可以将前面的映射表述为<strong>向量内积</strong>的形式：</p><script type="math/tex; mode=display">h_{\boldsymbol{\theta}}(\boldsymbol{x})=\boldsymbol{\theta}^T\boldsymbol{x}\\</script><p>这也就是多元线性回归(Multivariate linear regression)的一般形式。我们同样也可以定义在多元线性回归下的代价函数：</p><script type="math/tex; mode=display">J(\boldsymbol{\theta})=J(\theta_0,\theta_1,\cdots,\theta_n)=\frac{1}{2m}\sum_{i=1}^m(h_{\boldsymbol{\theta}}(x^{(i)})-y^{(i)})^2\\</script><p>于是可以写出多元线性回归情况下的梯度下降方法：</p><script type="math/tex; mode=display">\theta_j:=\theta_j-\alpha\frac{1}{m}\sum_{i=1}^m(h_{\boldsymbol{\theta}}(x^{(i)})-y^{(i)})x_j^{(i)}\\</script><hr><h3 id="特征缩放"><a href="#特征缩放" class="headerlink" title="特征缩放"></a>特征缩放</h3><p>面对多维特征问题的时候，我们要保证这些特征都具有相近的尺度，这将帮助梯度下降算法更快地收敛</p><p>以房价问题为例，假设我们使用两个特征，房屋的尺寸和房间的数量，尺寸的值为 0-2000平方英尺，而房间数量的值则是0-5，以两个参数分别为横纵坐标，绘制代价函数的等高线图，图像会显得很扁，梯度下降算法需要<strong>非常多次的迭代</strong>才能收敛。</p><p>一般来说就是<strong>将所有特征都约束到[-1,1]区间之内</strong>，这样可以使得梯度下降的时候每个特征对于梯度的贡献量相近从而使得梯度下降的时候在空间中的路径相对比较平直，加快梯度下降的速度。</p><p>有的时候还会在此基础上进行<strong>均值标准化</strong>，就是将每个变量都减去样本均值然后再归一化（除以样本最大值与最小值之间的差）到相同区间内（注意不要对  $x_0$ 进行这样的操作）：</p><script type="math/tex; mode=display">x_j:=\frac{x_j-\mu_j}{\max x_j-\min x_j}\\</script><hr><h3 id="学习率"><a href="#学习率" class="headerlink" title="学习率"></a>学习率</h3><p>学习率的设置影响梯度下降的效率</p><ul><li>学习率太小——梯度下降太慢</li><li>学习率太大——代价函数可能不收敛甚至发散</li></ul><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231025204905664.png" alt="image-20231025204905664" style="zoom:67%;" /></p><p>检查梯度下降算法是否正常收敛的典型方法：</p><ul><li>在训练过程中绘制代价函数-迭代次数曲线，当该曲线进入比较<strong>平坦</strong>的阶段的时候就说明梯度下降基本已经收敛</li><li>设置自动收敛测试：如果一次迭代中代价函数的变化率小于$10^{-3}$就自动判定为已经收敛。【但是这个阈值的选取比较困难</li></ul><hr><h3 id="特征和多项式回归"><a href="#特征和多项式回归" class="headerlink" title="特征和多项式回归"></a>特征和多项式回归</h3><p>有时候可以将特征融合起来，组成一个新的特征，比如在房价问题中，房屋的临街宽度和纵向深度都是特征，可以组合成一个新的特征——面积</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231025185221693.png" alt="image-20231025185221693"></p><p>$h_{\theta}\left( x \right)={\theta_{0}}+{\theta_{1}}\times{frontage}+{\theta_{2}}\times{depth}$</p><p>${x_{1}}=frontage$(临街宽度)，${x_{2}}=depth$（纵向深度），$x=frontage*depth=area$（面积），则：${h_{\theta}}\left( x \right)={\theta_{0}}+{\theta_{1}}x$。 </p><p>到目前为止，我们假设的学习算法都是：$h_{\theta}\left( x \right)={\theta_0}+{\theta_1}x$  的形式，其图形都是一条直线，线性回归并不适用于所有数据，有时我们需要曲线来适应我们的数据，比如：</p><p>抛物线模型：$h_{\theta}\left( x \right)={\theta_{0}}+{\theta_{1}}{x_{1}}+{\theta_{2}}{x_{2}^2}$</p><p>或者三次方模型： $h_{\theta}\left( x \right)={\theta_{0}}+{\theta_{1}}{x_{1}}+{\theta_{2}}{x_{2}^2}+{\theta_{3}}{x_{3}^3}$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231025190321289.png" alt="image-20231025190321289"></p><p>通常我们需要先观察数据然后再决定准备尝试怎样的模型。 另外，我们可以令：</p><p>${x_2}=x_2^2,x_3=x_3^3$，从而将模型转化为线性回归模型。</p><p>根据函数图形特性，我们还可以使：</p><p>${h_\theta}(x)={\theta_0}\text{+}{\theta_1}(size)+{\theta_2}{(size)^2}$</p><p>或者：</p><p>${h_\theta}(x)={\theta_0}\text{+}{\theta _1}(size)+{\theta _2}\sqrt{size}$</p><p>注：如果我们采用多项式回归模型，在运行梯度下降算法前，<strong>特征缩放</strong>非常有必要。</p><hr><h2 id="正规方程"><a href="#正规方程" class="headerlink" title="正规方程"></a>正规方程</h2><p>到目前为止，我们都在使用梯度下降算法，但是对于某些线性回归问题，正规方程方法是更好的解决方案。</p><p>正规方程是通过求解下面的方程来找出使得代价函数最小的参数的：$\frac{\partial}{\partial{\theta_{j}}}J\left( {\theta_{j}} \right)=0$ 。 假设我们的训练集特征矩阵为 $X$（包含了 $x_0=1$）并且我们的训练集结果为向量 $y$ </p><p>在多组训练样本下上面方程可以扩展为向量方程：</p><script type="math/tex; mode=display">\boldsymbol{y}=\boldsymbol{X}\boldsymbol{\theta}\\</script><p>那么可以写出这个方程的正规方程解（不需要特征缩放）为：</p><script type="math/tex; mode=display"> \quad\boldsymbol{X}^T\boldsymbol{y}=\boldsymbol{X}^T\boldsymbol{X}\boldsymbol{\theta}\\\Rightarrow\boldsymbol{\theta}=(\boldsymbol{X}^T\boldsymbol{X})^{-1}\boldsymbol{X}^T\boldsymbol{y}</script><p>这里的设计矩阵 $X$ 实际上就是把输入特征转置以后叠放在一起：</p><script type="math/tex; mode=display">\boldsymbol{X}=\begin{bmatrix} (\boldsymbol{x}^{(1)})^T \\ (\boldsymbol{x}^{(2)})^T \\ \vdots \\ (\boldsymbol{x}^{(m)})^T \end{bmatrix}\in\mathbb{R}^{m\times(n+1)}, \text{where   }\boldsymbol{x}^{(i)}=\begin{bmatrix} x_0^{(i)} \\ x_1^{(i)} \\ \vdots \\ x_n^{(i)} \end{bmatrix}\in\mathbb{R}^{n+1}\\</script><p>以下表示数据为例：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231025201807578.png" alt="image-20231025201807578"></p><p>可以直接运用正规方程法求解参数：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231025202240868.png" alt="image-20231025202240868"></p><p>结果会是一个 $4×1$的 $\theta$ 矩阵</p><p>注：对于那些不可逆的矩阵（通常是因为特征之间不独立，如同时包含英尺为单位的尺寸和米为单位的尺寸两个特征，也有可能是特征数量大于训练集的数量），正规方程方法是不能用的。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>梯度下降与正规方程的比较：</p><div class="table-container"><table><thead><tr><th>梯度下降</th><th>正规方程</th></tr></thead><tbody><tr><td>需要选择学习率$\alpha$</td><td>不需要</td></tr><tr><td>需要多次迭代</td><td>一次运算得出</td></tr><tr><td>当特征数量$n$大时也能较好适用</td><td>需要计算${\left( {X^T}X \right)}^{-1}$ 如果特征数量$n$较大则运算代价大，因为矩阵逆的计算时间复杂度为$O\left( {n^3} \right)$，通常来说当$n$小于10000 时还是可以接受的</td></tr><tr><td>适用于各种类型的模型</td><td>只适用于线性模型，不适合逻辑回归模型等其他模型</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.单变量线性回归</title>
      <link href="/post/53740.html"/>
      <url>/post/53740.html</url>
      
        <content type="html"><![CDATA[<h1 id="单变量线性回归"><a href="#单变量线性回归" class="headerlink" title="单变量线性回归"></a>单变量线性回归</h1><h2 id="模型表示"><a href="#模型表示" class="headerlink" title="模型表示"></a>模型表示</h2><p><strong>监督学习</strong>：对于每个数据来说，给出了正确的答案。在监督学习中，我们有一个给定的数据，叫做<strong>训练集training set</strong></p><p>这里进行举例说明：这个例子是预测住房价格的，我们要使用一个数据集，数据集包含俄勒冈州波特兰市的住房价格。在这里，根据不同房屋尺寸所售出的价格，画出数据集</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231020235119310.png" alt="image-20231020235119310"></p><p>更具体来说，这是一个<strong>回归问题</strong>。回归一词指的是，我们根据之前的数据预测出一个准确的输出值，对于这个例子就是<strong>价格</strong></p><hr><p>以之前的房屋交易问题为例，假使我们回归问题的训练集（<strong>Training Set</strong>）如下表所示：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231020235250002.png" alt="image-20231020235250002"></p><p>我们将要用来描述这个回归问题的标记如下:</p><p>$m $ 代表训练集中实例的数量</p><p>$x $  代表特征/输入变量</p><p>$y $  代表目标变量/输出变量</p><p>$(x,y) $  代表训练集中的实例</p><p>$(x^{(i)},y^{(i)}) $  代表第$i$ 个观察实例</p><p>$h $  代表学习算法的解决方案或函数也称为假设（<strong>hypothesis</strong>）</p><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231020235732019.png" alt="image-20231020235732019"></p><p>这就是一个监督学习算法的工作方式</p><ol><li>先把训练集喂给一个学习算法，使之输出一个函数，通常表示为小写$ h$ 表示</li><li>$h$表示一个函数，输入是房屋尺寸大小，可以$ h $根据输入的$ x$值来得出$ y$ 值，$y$ 值对应房子的价格，因此，$h$ 是一个从$x$ 到$ y $的<strong>函数映射</strong>。</li></ol><p>因而，要解决房价预测问题，我们实际上是要将训练集“喂”给我们的学习算法，进而学习得到一个假设$h$，然后将我们要预测的房屋的尺寸作为输入变量输入给$h$，预测出该房屋的交易价格作为输出变量输出为结果</p><p>在这个过程中，选择的学习算法对最终效果至关重要，一种可能的表达方式为：$h_\theta \left( x \right)=\theta_{0} + \theta_{1}x$，因为只含有一个特征/输入变量，因此这样的问题叫作<strong>单变量线性回归问题</strong>。</p><hr><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231020235250002.png" alt="image-20231020235250002"></p><p>在线性回归中我们有一个像这样的训练集，$m$代表了训练样本的数量，比如 $m = 47$。而我们的假设函数，也就是用来进行预测的函数，是这样的线性函数形式：$h_\theta \left( x \right)=\theta_{0}+\theta_{1}x$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231109030408762.png" alt="image-20231109030408762" style="zoom:67%;" /></p><p>图中的红线代表的就是$h_\theta \left( x \right)=\theta_{0}+\theta_{1}x$这一条拟合曲线，那么，现在要做的便是为我们的模型选择合适的<strong>参数</strong>$\theta_{0}$ 和$ θ_1$，在房价问题这个例子中：$\theta_{0}$指的是直线在$y$ 轴上的截距，$\theta_{1}$指的是直线的斜率</p><hr><p>$ θ_1$和$ θ_0$参数直接决定了拟合直线相对于我们的训练集的准确程度，模型所预测的值与训练集中实际值之间的差距就是<strong>建模误差</strong></p><p>（下图中黑线是我们得到的直线，×代表原本的数据，蓝线则代表了误差）</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231021002300917.png" alt="image-20231021002300917"></p><p>我们的目标便是选择出可以使得<strong>建模误差的平方和</strong>能够最小的模型参数。 即使得代价函数最小。</p><p>将以下函数称为<strong>代价函数</strong>，也叫做<strong>平方误差函数</strong></p><script type="math/tex; mode=display">J(θ_0,θ_1)=\frac{1}{2m}\sum\limits_{i=1}^m(h_θ(x^{(i)})−y^{(i)})^2</script><p>之所以要求出误差的平方和，是因为误差平方代价函数，对于大多数问题，特别是回归问题，都是一个合理的选择。</p><p>当$J(θ_0,θ_1)$最小的时候，说明我们得到的直线和原本的数据拟合的效果最好,就可以近似的把$h_\theta \left( x \right)=\theta_{0} + \theta_{1}x$当做拟合算法，通过$x$来预测$y$的值了</p><p>特别说明一下，这里将最后的平方和除以$2m$，只是为了之后的求导方便</p><p>总结一下：</p><p>算法函数$h_\theta \left( x \right)=\theta_{0}+\theta_{1}x$是一条<strong>拟合曲线</strong>，可近似的根据房屋面积($x$)<strong>预测</strong>房价($y$)，而<strong>代价函数</strong>($J(\theta_0,\theta_1)$)是评估$h_\theta \left( x \right)$拟合效果的<strong>指标</strong>，代价函数的函数值越低，说明代价越小，即$h_\theta \left( x \right)$拟合的效果好，所以$\theta_0,\theta_1$的取值应该尽可能的使代价函数($J(\theta_0,\theta_1)$)小，这就涉及到函数的<strong>最小值问题</strong></p><hr><h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><p>可以用梯度下降法求函数的最小值问题</p><p>它的思路很简单，想象在山顶放了一个球，一松手它就会顺着山坡最陡峭的地方滚落到谷底：</p><p><img src="https://picx.zhimg.com/v2-b722c2fca0ea2c1bc71975dd965d0c97_b.webp" alt="动图"></p><hr><h3 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h3><p>首先需要学习<a href="https://www.nightswatch.icu/post/1182.html">梯度的概念</a>，学习之后，再学梯度下降法</p><p>先从最简单的凸函数$f(x)=x^2$开始讲起。假设起点在$x_0=10$处，也就是将球放在$x_0=10$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231021040700955.png" alt="image-20231021040700955" style="zoom:67%;" /></p><p>那么，此时的梯度是1维向量，数值为该点的导数：</p><script type="math/tex; mode=display">\nabla f(x_0)=f'(x_0)i=f'(x_0)=2x|_{x_0=10}=20</script><p>这是在$x$ 轴上的向量，它指向函数值增长最快的方向</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231021040912407.png" alt="image-20231021040912407" style="zoom:67%;" /></p><p>将$x_0$也看作 1 维向量$(x_0)$，通过和$-\nabla f(x_0)$相加，可以将之向$-\nabla f(x_0)$移动一段距离得到新的向量$(x_1)$：</p><script type="math/tex; mode=display">x_1=x_0-\eta\nabla f(x_0)</script><p>其中$\alpha$称为步长，通过它可以控制移动的距离，本节设$\eta=0.2$，那么：$x_1=10-0.2×20=6$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231021041432473.png" alt="image-20231021041432473" style="zoom:80%;" /></p><p>小球就下降到了$x_1=6$的位置</p><p>如果继续迭代，不断的计算小球当前位置的梯度，并用公式$x_1=x_0-\eta\nabla f(x_0)$，选择小球的横坐标</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231021041634400.png" alt="image-20231021041634400" style="zoom:67%;" /></p><p>球就会逼近最低点，重复上述过程到第 10 次，小球基本上就到了最低点，即有$x_{10}\approx 0$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typorav2-aa03253883db6239bbdaa9db3ee6fcf5_720w.webp" alt="动图"></p><p>如果将每次的梯度的模长列出来，可以看到是在不断减小的，因此这种方法称为<strong>梯度下降法</strong>：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231021041908623.png" alt="image-20231021041908623"></p><p>这也比较好理解，当最终趋向于 0 时有：</p><script type="math/tex; mode=display">||\nabla f||=0\implies\nabla f=0\implies f'(x)=0\\</script><hr><p>三维上的梯度下降法</p><p>假设函数为：$f(\boldsymbol{x})=x_1^2+2x_2^2\$</p><p>图像和等高线如下：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231021042130227.png" alt="image-20231021042130227"></p><p>设初始点$\boldsymbol{x}_0=(-3.5,-3.5)$，此时梯度为：</p><script type="math/tex; mode=display">\nabla f(\boldsymbol{x}_0)=(\frac{\partial f(\boldsymbol{x}_0)}{\partial x_1},\frac{\partial f(\boldsymbol{x}_0)}{\partial x_2})=(2x_1, 4x_2)\Big |_{x_1=-3.5,x_2=-3.5}=(-7, -14)\\</script><p>令步长$\eta=0.1$，那么下一个点为：</p><script type="math/tex; mode=display">\begin{aligned}     \boldsymbol{x}_1         &=\boldsymbol{x}_0-\eta\nabla f(\boldsymbol{x}_0)\\         &=(-3.5,-3.5)-0.1\times(-7,-14)=(-2.8,-2.1) \end{aligned} \\</script><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231021042249358.png" alt="image-20231021042249358" style="zoom:80%;" /></p><p>如此迭代20次后：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typorav2-3d870db979e5a2a07434448bc5100737_720w.webp" alt="动图"></p><p>即找到了最小值</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>结合之前的模型和代价函数，我们将梯度下降公式$\boldsymbol{x}_1         =\boldsymbol{x}_0-\eta\nabla f(\boldsymbol{x}_0)$，带入到我们之前的的代价函数$J(θ_0,θ_1)$中去，可以得到</p><script type="math/tex; mode=display">\theta_j:=\theta_j-\alpha\frac{\partial{J(θ_0,θ_1)}}{\partial{\theta_j}}</script><p>具体描述：对$θ$赋值，使得$J(θ)$按照梯度下降最快的方向进行，一直迭代下去，最终得到局部最小值。</p><p>学习率(步长)：$α$是学习率，它决定了我们沿着能让代价函数下降程度最大的方向向下迈出的步子有多大。</p><ul><li>学习率太小：收敛速度慢需要很长的时间才会到达全局最低点</li><li>学习率太大：可能越过最低点，甚至可能无法收敛</li></ul><p>别忘了之前的学习算法是$h_\theta \left( x \right)=\theta_{0} + \theta_{1}x$</p><p>对我们之前的线性回归问题运用梯度下降法，关键在于求出代价函数的导数，即：</p><script type="math/tex; mode=display">\begin{align} \frac{\partial J(\theta_0,\theta_1)}{\partial\theta_j}&=\frac{\partial}{\partial\theta_j}\frac{1}{2m}\sum_{i=1}^m(h(x^{(i)})-y^{(i)})^2\\ &=\frac{1}{2m}\sum_{i=1}^m\frac{\partial}{\partial\theta_j}(\theta_0+\theta_1x^{(i)}-y^{(i)})^2\\ \end{align}\\</script><p>当$j=0$时：</p><script type="math/tex; mode=display">\frac{\partial }{\partial \theta _j}J(\theta_0,\theta_1)=\frac{1}{m}{\sum_{i=1}^m( h_\theta (x^{(i)}})-y^{(i)})</script><p>当$j=1$时：</p><script type="math/tex; mode=display">\frac{\partial }{\partial \theta _j}J(\theta_0,\theta_1)=\frac{1}{m}{\sum_{i=1}^m(( h_\theta (x^{i)}})-y^{(i)})\cdot x^{(i)})</script><p>注意观察，在这个多元函数中，我们是对$\theta_0$和$\theta_1$求偏导，$x$和$y$都是固定的值，而$\theta_0$和$\theta_1$的值注意要<strong>同时</strong>进行更新</p><p>则算法改写成：</p><p><strong>Repeat {</strong></p><p>​                ${\theta_0}:={\theta_0}-a\frac{1}{m}\sum\limits_{i=1}^{m}{ \left({h_{\theta }}(x^{(i)})-{y^{(i)}} \right)}$</p><p>​                ${\theta_1}:={\theta_1}-a\frac{1}{m}\sum\limits_{i=1}^{m}{\left( \left({h_{\theta }}({x^{(i)}})-{y^{(i)}} \right)\cdot {x^{(i)}} \right)}$</p><p>​               <strong>}</strong></p><p>这种算法也被称为批量梯度下降。实际上，在机器学习中，通常不太会给算法起名字，但这个名字”<strong>批量梯度下降</strong>”，指的是在梯度下降的每一步中，我们都用到了所有的训练样本，在梯度下降中，在计算微分求导项时，我们需要进行求和运算，所以，在每一个单独的梯度下降中，我们最终都要计算这样一个东西，这个项需要对所有$m$个训练样本求和。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15.0.OCR扫描</title>
      <link href="/post/48866.html"/>
      <url>/post/48866.html</url>
      
        <content type="html"><![CDATA[<h1 id="OCR扫描"><a href="#OCR扫描" class="headerlink" title="OCR扫描"></a>OCR扫描</h1><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>图像文字识别应用所作的事是，从一张给定的图片中识别文字。这比从一份扫描文档中识别文字要复杂的多。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231201084832059.png" alt="image-20231201084832059"></p><p>为了完成这样的工作，需要采取如下步骤：</p><ol><li>文字侦测（<strong>Text detection</strong>）——将图片上的文字与其他环境对象分离开来</li><li>字符切分（<strong>Character segmentation</strong>）——将文字分割成一个个单一的字符</li><li>字符分类（<strong>Character classification</strong>）——确定每一个字符是什么</li></ol><p>可以用任务流程图来表达这个问题，每一项任务可以由一个单独的小队来负责解决：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typora610fffb413d8d577882d6345c166a9fb.png" alt=""></p><hr><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>滑动窗口是一项用来从图像中抽取对象的技术。假使我们需要在一张图片中识别行人，首先要做的是用许多固定尺寸的图片来训练一个能够准确识别行人的模型。然后我们用之前训练识别行人的模型时所采用的图片尺寸在我们要进行行人识别的图片上进行剪裁，然后将剪裁得到的切片交给模型，让模型判断是否为行人，然后在图片上<strong>滑动剪裁区域</strong>重新进行剪裁，将新剪裁的切片也交给模型进行判断，如此循环直至将图片全部检测完。</p><p>一旦完成后，我们按比例放大剪裁的区域，再以新的尺寸对图片进行剪裁，将新剪裁的切片按比例缩小至模型所采纳的尺寸，交给模型进行判断，如此循环。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231201084909868.png" alt="image-20231201084909868"></p><p>文字侦测阶段：滑动窗口技术也被用于文字识别，首先训练模型能够区分字符与非字符，然后，运用滑动窗口技术识别字符，一旦完成了字符的识别，我们将识别得出的区域进行一些扩展，然后将重叠的区域进行合并。接着我们以宽高比作为过滤条件，过滤掉高度比宽度更大的区域（认为单词的长度通常比高度要大）。下图中绿色的区域是经过这些步骤后被认为是文字的区域，而红色的区域是被忽略的</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231201084923684.png" alt="image-20231201084923684"></p><p>下一步是训练一个模型来完成将文字分割成一个个字符的任务，需要的训练集由单个字符的图片和两个相连字符之间的图片来训练模型</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231201084949349.png" alt="image-20231201084949349"></p><p>字符切分阶段：模型训练完后，我们仍然是使用滑动窗口技术来进行字符识别。</p><p>最后一个阶段是字符分类阶段，利用神经网络、支持向量机或者逻辑回归算法训练一个分类器即可。</p><hr><h2 id="获取大量数据"><a href="#获取大量数据" class="headerlink" title="获取大量数据"></a>获取大量数据</h2><p>如果我们的模型是低方差的，那么获得更多的数据用于训练模型，是能够有更好的效果的。问题在于，我们怎样获得数据，数据不总是可以直接获得的，我们有可能需要人工地创造一些数据。</p><p>以我们的文字识别应用为例，我们可以字体网站下载各种字体，然后利用这些不同的字体配上各种不同的随机背景图片创造出一些用于训练的实例，这让我们能够获得一个无限大的训练集。这是从零开始创造实例。</p><p>另一种方法是，利用已有的数据，然后对其进行修改，例如将已有的字符图片进行一些扭曲、旋转、模糊处理。只要我们认为实际数据有可能和经过这样处理后的数据类似，我们便可以用这样的方法来创造大量的数据。</p><hr><h2 id="上限分析"><a href="#上限分析" class="headerlink" title="上限分析"></a>上限分析</h2><p>在机器学习的应用中，我们通常需要通过几个步骤才能进行最终的预测，我们如何能够知道哪一部分最值得我们花时间和精力去改善呢？这个问题可以通过上限分析来回答。</p><p>回到我们的文字识别应用中，我们的流程图如下：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typora55d41ee748680a62e755d6aa5b95b53c.png" alt=""></p><p>流程图中每一部分的输出都是下一部分的输入，上限分析中，我们选取一部分，手工提供100%正确的输出结果，然后看应用的整体效果提升了多少。假使我们的例子中总体效果为72%的正确率。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231201085153594.png" alt="image-20231201085153594" style="zoom:80%;" /></p><p>如果我们令文字侦测部分输出的结果100%正确，发现系统的总体效果从72%提高到了89%。这意味着我们很可能会希望投入时间精力来提高我们的文字侦测部分。</p><p>接着我们手动选择数据，让字符切分输出的结果100%正确，发现系统的总体效果只提升了1%，这意味着，我们的字符切分部分可能已经足够好了。</p><p>最后我们手工选择数据，让字符分类输出的结果100%正确，系统的总体效果又提升了10%，这意味着我们可能也会应该投入更多的时间和精力来提高应用的总体表现。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14.0.大规模机器学习</title>
      <link href="/post/9245.html"/>
      <url>/post/9245.html</url>
      
        <content type="html"><![CDATA[<h1 id="大规模机器学习"><a href="#大规模机器学习" class="headerlink" title="大规模机器学习"></a>大规模机器学习</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>大规模的机器学习（Large-Scale Machine Learning）指的是在处理<strong>庞大规模数据集或在复杂模型</strong>中应用机器学习算法的领域。这涉及到处理大量的样本、特征和/或模型参数，通常需要高度并行化、分布式计算和优化算法以应对计算和存储的挑战。</p><p>如果我们有一个低方差的模型，增加数据集的规模可以帮助你获得更好的结果。我们应该怎样应对一个有1000万条记录的训练集？</p><p>以线性回归模型为例，每一次梯度下降迭代，我们都需要计算训练集的误差的平方和，如果我们的学习算法需要有20次迭代，这便已经是非常大的计算代价。</p><p>首先应该做的事是去检查一个这么大规模的训练集是否真的必要，也许我们只用1000个训练集也能获得较好的效果，我们可以绘制学习曲线来帮助判断。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231201083213425.png" alt="image-20231201083213425"></p><hr><h2 id="随机梯度下降"><a href="#随机梯度下降" class="headerlink" title="随机梯度下降"></a>随机梯度下降</h2><p>如果我们一定需要一个大规模的训练集，我们可以尝试使用<strong>随机梯度下降法</strong>来代替批量梯度下降法。</p><p>随机梯度下降是一种优化算法，用于训练机器学习模型，特别是在大规模数据集上。与批量梯度下降（Batch Gradient Descent）一次性使用整个训练集的所有样本相比，SGD每次迭代只使用一个随机选择的样本来计算梯度和更新模型参数</p><p>SGD的主要思想是通过随机选择一个样本来估计整个训练数据的梯度，然后利用该梯度来更新模型参数。这样的更新是基于单个样本的，因此计算速度相对较快。然而，由于每次迭代的梯度估计都是基于单个样本的，导致参数的更新比较嘈杂，使得收敛路径较为不规律。</p><p>在随机梯度下降法中，我们定义代价函数为一个单一训练实例的代价：</p><script type="math/tex; mode=display">cost(  \theta, ( {x}^{(i)} , {y}^{(i)} )  ) = \frac{1}{2}\left( {h}_{\theta}({x}^{(i)}\right)-{y}^ )^{2}</script><p><strong>随机</strong>梯度下降算法为：首先对训练集随机“洗牌”，然后：</p><script type="math/tex; mode=display">\theta_{i+1} = \theta_i - \alpha \left(h_{\theta}\left(x^{(i)}\right)-{y}^{(i)} \right){x_j}^{(i)}</script><p>其中：</p><ul><li>($\theta_i$) 是第 ($i$) 次迭代后的模型参数。</li><li>($\alpha$) 是学习率，控制每次迭代中参数更新的步长。</li><li>($J(\theta_i; x^{(i)}, y^{(i)})$) 是损失函数，表示模型在样本 ($x^{(i)}$) 上的损失。</li></ul><p>SGD的主要优势在于它能够处理大规模数据集，因为每次迭代只需要处理一个样本。此外，SGD的更新过程对于<strong>在线学习</strong>是很有用的，模型可以逐步地适应新的数据。</p><p>然而，由于更新的不规律性，SGD可能会在接近最优解时震荡，甚至可能略过最优解。为了解决这个问题，通常会采用一些变种，如<strong>小批量梯度下降</strong>，它每次迭代使用一个小的样本集合来估计梯度，从而在计算效率和更新稳定性之间取得一种平衡。</p><hr><h2 id="小批量梯度下降"><a href="#小批量梯度下降" class="headerlink" title="小批量梯度下降"></a>小批量梯度下降</h2><p>小批量梯度下降（Mini-Batch Gradient Descent）是梯度下降算法的一种变种，它介于随机梯度下降（SGD）和批量梯度下降（Batch GD）之间。在小批量梯度下降中，每次迭代不再使用整个训练数据集，而是随机选择一个小的样本集合（称为”小批量”或”mini-batch”），然后使用这个小批量来计算梯度和更新模型参数</p><p>每计算常数$b$次训练实例，便更新一次参数  $$ 。</p><p> <strong>Repeat</strong> {</p><p> <strong>for</strong> $i = 1:m${</p><p> ​       $\theta:={\theta}_j-\alpha\frac{1}{b}\sum_\limits{k=i}^{i+b-1}\left( h_{\theta}\left(x^{(k)}\right)-{y}^{(k)} \right){x_j}^{(k)}$      </p><p>​       (<strong>for</strong> $j=0:n$)</p><p>​      $ i +=10 $   </p><p> ​     }<br> }</p><p>通常我们会令 $b$ 在 2-100 之间。这样做的好处在于，我们可以用向量化的方式来循环 $b$个训练实例，如果我们用的线性代数函数库比较好，能够支持平行处理，那么算法的总体表现将不受影响（与随机梯度下降相同）。</p><p>小批量梯度下降的主要优势在于它综合了<strong>随机梯度下降和批量梯度下降的优点</strong>。与随机梯度下降相比，小批量梯度下降的梯度估计更为稳定，因为它考虑了小批量内的多个样本；与批量梯度下降相比，小批量梯度下降具有更高的计算效率，因为它不需要处理整个数据集。</p><hr><h2 id="随机梯度下降收敛"><a href="#随机梯度下降收敛" class="headerlink" title="随机梯度下降收敛"></a>随机梯度下降收敛</h2><p>在批量梯度下降中，我们可以令代价函数$J$为迭代次数的函数，绘制图表，根据图表来判断梯度下降是否收敛。但是，在大规模的训练集的情况下，这是不现实的，因为计算代价太大了。</p><p>在随机梯度下降中，我们在每一次更新 $$ 之前都计算一次代价，然后每$x$次迭代后，求出这$x$次对训练实例计算代价的平均值，然后绘制这些平均值与$x$次迭代的次数之间的函数图表。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231201084133609.png" alt="image-20231201084133609"></p><p>当我们绘制这样的图表时，可能会得到一个颠簸不平但是不会明显减少的函数图像（如上面左下图中蓝线所示）。我们可以增加$α$来使得函数更加平缓，也许便能看出下降的趋势了（如上面左下图中红线所示）；或者可能函数图表仍然是颠簸不平且不下降的（如洋红色线所示），那么我们的模型本身可能存在一些错误。</p><p>如果我们得到的曲线如上面右下方所示，不断地上升，那么我们可能会需要选择一个较小的学习率$α$。</p><p>我们也可以令学习率随着迭代次数的增加而减小，例如令：</p><script type="math/tex; mode=display">\alpha = \frac{const1}{iterationNumber + const2}</script><p>随着我们不断地靠近全局最小值，通过减小学习率，我们迫使算法收敛而非在最小值附近徘徊。但是通常我们不需要这样做便能有非常好的效果了，对$α$进行调整所耗费的计算通常不值得</p><hr><h2 id="在线学习"><a href="#在线学习" class="headerlink" title="在线学习"></a>在线学习</h2><p>在线学习（Online Learning）是一种机器学习的范式，其中模型能够逐步地从新的数据样本中进行学习，而不需要事先将整个训练数据集加载到内存中。与传统的批量学习（Batch Learning）不同，其中模型在整个数据集上进行训练，在线学习的模型能够根据即时接收到的数据<strong>动态地更新</strong>自身。</p><p>假设我们正在构建一个在线推荐系统，这个系统需要根据用户的历史行为和实时反馈来不断调整推荐的商品。</p><p><strong>传统批量学习的方法：</strong></p><p>在传统的批量学习中，我们可能会定期（比如每天或每周）使用整个历史数据集进行模型训练，然后将训练好的模型应用到实时推荐中。</p><p><strong>在线学习的方法：</strong></p><p>在在线学习中，我们可以采用增量学习的方式，即模型从每个新的用户行为中学到一些东西，并即时地更新推荐模型。例如，用户在网站上浏览商品、点击链接、购买商品等行为都可以作为新的数据进入模型。</p><p>只要网站在运行过程中，就可以利用随机梯度下降法从用户的点击中获取 $\left(x,y\right)$ 作为数据来训练$\theta$</p><script type="math/tex; mode=display">\theta:={\theta}_j-\alpha\left( h_{\theta}\left(x\right)-y \right){x_j}</script><p>一旦对一个数据的学习完成了，我们便可以丢弃该数据，不需要再存储它了。这种方式的好处在于，我们的算法可以很好的适应用户的倾向性，算法可以针对用户的当前行为不断地更新模型以适应该用户</p><p>这样，推荐系统能够随着用户行为的变化动态地调整自己，而不必等到整个数据集重新训练。这种实时性和个性化是在线学习的优势之一，特别适用于需要快速适应变化和提供个性化服务的场景。</p><hr><h2 id="映射化简和数据并行"><a href="#映射化简和数据并行" class="headerlink" title="映射化简和数据并行"></a>映射化简和数据并行</h2><p>映射化简和数据并行对于大规模机器学习问题而言是非常重要的概念。之前提到，如果我们用批量梯度下降算法来求解大规模数据集的最优解，我们需要对整个训练集进行循环，计算偏导数和代价，再求和，计算代价非常大。如果我们能够将我们的数据集分配给不多台计算机，让每一台计算机处理数据集的一个<strong>子集</strong>，然后我们将计所的结果汇总在求和。这样的方法叫做<strong>映射简化</strong></p><p>具体而言，如果任何学习算法能够表达为，对训练集的函数的求和，那么便能将这个任务分配给多台计算机（或者同一台计算机的不同<strong>CPU</strong> 核心），以达到加速处理的目的。</p><p>例如，我们有400个训练实例，我们可以将批量梯度下降的求和任务分配给4台计算机进行处理：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231201084704030.png" alt="image-20231201084704030"></p><p>很多高级的线性代数函数库已经能够利用多核<strong>CPU</strong>的多个核心来并行地处理矩阵运算，这也是算法的向量化实现如此重要的缘故（比调用循环快）。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13.5 ex8:anomaly detection and recommendation</title>
      <link href="/post/29242.html"/>
      <url>/post/29242.html</url>
      
        <content type="html"><![CDATA[<h1 id="ex8-anomaly-detection-and-recommendation"><a href="#ex8-anomaly-detection-and-recommendation" class="headerlink" title="ex8:anomaly detection and recommendation"></a>ex8:anomaly detection and recommendation</h1><h2 id="异常检测"><a href="#异常检测" class="headerlink" title="异常检测"></a>异常检测</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在这个练习中，您将实现异常检测算法并将其应用于检测网络上的故障服务器</p><p>必要的文件：</p><ul><li><code>ex8.py</code> - 用于练习第一部分的Python脚本</li><li><code>ex8data1.mat</code> - 用于异常检测的第一个示例数据集 </li><li><code>ex8data2.mat</code> - 用于异常检测的第二个示例数据集</li><li><code>multivariateGaussian.py</code> - 计算高斯分布的概率密度函数</li><li><code>visualizeFit.py</code> - 高斯分布和数据集的二维图</li></ul><p>需要补充的文件：</p><ul><li><code>estimateGaussian.py</code> - 估算带有对角协方差矩阵的高斯分布的参数</li><li><code>selectThreshold.py</code> - 为异常检测找到阈值</li></ul><hr><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> scipy.io <span class="keyword">as</span> scio</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入自定义模块</span></span><br><span class="line"><span class="keyword">import</span> estimateGaussian <span class="keyword">as</span> eg</span><br><span class="line"><span class="keyword">import</span> multivariateGaussian <span class="keyword">as</span> mvg</span><br><span class="line"><span class="keyword">import</span> visualizeFit <span class="keyword">as</span> vf</span><br><span class="line"><span class="keyword">import</span> selectThreshold <span class="keyword">as</span> st</span><br></pre></td></tr></table></figure><hr><h3 id="载入并绘图"><a href="#载入并绘图" class="headerlink" title="载入并绘图"></a>载入并绘图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================== 第 1 部分：加载示例数据集 =====================</span></span><br><span class="line"><span class="comment"># 通过使用一个小型易于可视化的数据集开始本练习。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 我们的示例案例包括多台机器上两个网络服务器统计信息：</span></span><br><span class="line"><span class="comment"># 每台机器的延迟和吞吐量。这个练习将帮助我们找到可能存在故障（或非常快速）的机器</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;正在可视化用于异常检测的示例数据集.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下命令加载数据集。现在，您的环境中应该有变量X、Xval、yval。</span></span><br><span class="line">data = scio.loadmat(<span class="string">&#x27;ex8data1.mat&#x27;</span>)</span><br><span class="line">X = data[<span class="string">&#x27;X&#x27;</span>]</span><br><span class="line">Xval = data[<span class="string">&#x27;Xval&#x27;</span>]</span><br><span class="line">yval = data[<span class="string">&#x27;yval&#x27;</span>].flatten()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化示例数据集</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=<span class="string">&#x27;b&#x27;</span>, marker=<span class="string">&#x27;x&#x27;</span>, s=<span class="number">15</span>, linewidth=<span class="number">1</span>)</span><br><span class="line">plt.axis([<span class="number">0</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">30</span>])</span><br><span class="line">plt.xlabel(<span class="string">&#x27;延迟（ms）&#x27;</span>,fontproperties=<span class="string">&#x27;SimHei&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;吞吐量（mb/s）&#x27;</span>,fontproperties=<span class="string">&#x27;SimHei&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;程序暂停。按回车键继续&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231201014157144.png" alt="image-20231201014157144" style="zoom:80%;" /></p><hr><h3 id="高斯拟合"><a href="#高斯拟合" class="headerlink" title="高斯拟合"></a>高斯拟合</h3><p>首先编写高斯拟合的python文件：<code>estimateGaussian.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">estimate_gaussian</span>(<span class="params">X</span>):</span></span><br><span class="line">    <span class="comment"># 有用的变量</span></span><br><span class="line">    m, n = X.shape</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 你应该正确返回这些值</span></span><br><span class="line">    mu = np.zeros(n)</span><br><span class="line">    sigma2 = np.zeros(n)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ===================== 你的代码在这里 =====================</span></span><br><span class="line">    <span class="comment"># 说明: 计算数据的均值和方差</span></span><br><span class="line">    <span class="comment">#      具体来说，mu[i] 应该包含第 i 个特征的均值，</span></span><br><span class="line">    <span class="comment">#      sigma2[i] 应该包含第 i 个特征的方差</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        mu[i]=np.<span class="built_in">sum</span>(X[:,i])/m</span><br><span class="line">        sigma2[i]=np.<span class="built_in">sum</span>((X[:,i]-mu[i])**<span class="number">2</span>)/m</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ==========================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mu, sigma2</span><br></pre></td></tr></table></figure><p>找到$\sigma$和$\mu^2$，然后代入已经写好的<code>multivariate_gaussian</code>函数中，直接算出概率<code>p</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================== 第 2 部分：估算数据集统计信息 =====================</span></span><br><span class="line"><span class="comment"># 对于本练习，我们假设数据集服从高斯分布。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 首先估算我们假设的高斯分布的参数，</span></span><br><span class="line"><span class="comment"># 然后计算每个点的概率，然后可视化</span></span><br><span class="line"><span class="comment"># 整体分布以及每个点在该分布中的位置</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;正在可视化高斯拟合.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 估算 mu 和 sigma2</span></span><br><span class="line">mu, sigma2 = eg.estimate_gaussian(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回X中每个数据点（行）的多元正态分布密度</span></span><br><span class="line">p = mvg.multivariate_gaussian(X, mu, sigma2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化拟合</span></span><br><span class="line">vf.visualize_fit(X, mu, sigma2)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;延迟（ms）&#x27;</span>,fontproperties=<span class="string">&#x27;SimHei&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;吞吐量（mb/s）&#x27;</span>,fontproperties=<span class="string">&#x27;SimHei&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;程序暂停。按回车键继续&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231201014619751.png" alt="image-20231201014619751" style="zoom:67%;" /></p><hr><h3 id="查找异常值"><a href="#查找异常值" class="headerlink" title="查找异常值"></a>查找异常值</h3><p>完成<code>selectThreshold.py</code>函数，根据概率<code>pval</code>和真实值<code>yval</code>，找出最佳的$\epsilon$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_threshold</span>(<span class="params">yval, pval</span>):</span></span><br><span class="line">    f1 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 你必须正确返回这些值</span></span><br><span class="line">    best_eps = <span class="number">0</span></span><br><span class="line">    best_f1 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> epsilon <span class="keyword">in</span> np.linspace(np.<span class="built_in">min</span>(pval), np.<span class="built_in">max</span>(pval), num=<span class="number">1001</span>):</span><br><span class="line">        <span class="comment"># ===================== 你的代码在这里 =====================</span></span><br><span class="line">        <span class="comment"># 说明: 计算选择 epsilon 作为阈值的 F1 分数，并将值放入 F1。</span></span><br><span class="line">        <span class="comment">#       循环结束时，代码将比较此 epsilon 选择的 F1 分数，</span></span><br><span class="line">        <span class="comment">#       如果它优于当前选择的 epsilon，则将其设置为最佳 epsilon。</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment"># 注意: 您可以使用 predictions = pval &lt; epsilon 来获取二进制向量，</span></span><br><span class="line">        <span class="comment">#       其中 False(0) 表示非异常值，True(1) 表示异常值</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment"># 计算真正例（True Positives）</span></span><br><span class="line">        tp = np.<span class="built_in">sum</span>((yval == <span class="number">1</span>) &amp; (pval &lt; epsilon))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算假正例（False Positives）</span></span><br><span class="line">        fp = np.<span class="built_in">sum</span>((yval == <span class="number">0</span>) &amp; (pval &lt; epsilon))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算假负例（False Negatives）</span></span><br><span class="line">        fn = np.<span class="built_in">sum</span>((yval == <span class="number">1</span>) &amp; (pval &gt;= epsilon))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算精确度（Precision）和召回率（Recall）</span></span><br><span class="line">        precision = tp / (tp + fp) <span class="keyword">if</span> (tp + fp) &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        recall = tp / (tp + fn) <span class="keyword">if</span> (tp + fn) &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算 F1 分数</span></span><br><span class="line">        f1 = <span class="number">2</span> * precision * recall / (precision + recall) <span class="keyword">if</span> (precision + recall) &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># ==========================================================</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> f1 &gt; best_f1:</span><br><span class="line">            best_f1 = f1</span><br><span class="line">            best_eps = epsilon</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> best_eps, best_f1</span><br></pre></td></tr></table></figure><p>直接用<code>np.sum((yval == 1) &amp; (pval &lt; epsilon))</code>的语法，让两个布尔数组进行与操作，然后相加，就可以得到真正例<code>tp</code>，非常精妙</p><p>回到<code>ex8.py</code>中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================== 第 3 部分：查找异常值 =====================</span></span><br><span class="line"><span class="comment"># 现在，您将使用交叉验证集找到一个合适的 epsilon 阈值，</span></span><br><span class="line"><span class="comment"># 给定估算的高斯分布的概率</span></span><br><span class="line"></span><br><span class="line">pval = mvg.multivariate_gaussian(Xval, mu, sigma2)</span><br><span class="line"></span><br><span class="line">epsilon, f1 = st.select_threshold(yval, pval)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;使用交叉验证找到的最佳 epsilon 值：&#123;:0.4e&#125;&#x27;</span>.<span class="built_in">format</span>(epsilon))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;交叉验证集上的最佳 F1 值：&#123;:0.6f&#125;&#x27;</span>.<span class="built_in">format</span>(f1))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;(您应该看到 epsilon 约为 8.99e-05，F1 约为 0.875)&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在训练集中找到并绘制异常值</span></span><br><span class="line">outliers = np.where(p &lt; epsilon)</span><br><span class="line">plt.scatter(X[outliers, <span class="number">0</span>], X[outliers, <span class="number">1</span>], marker=<span class="string">&#x27;o&#x27;</span>, facecolors=<span class="string">&#x27;none&#x27;</span>, edgecolors=<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;程序暂停。按回车键继续&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231201015032314.png" alt="image-20231201015032314" style="zoom:80%;" /></p><hr><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>最后使用之前写的代码，代入数据集2中进行测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================== 第 4 部分：多维异常值 =====================</span></span><br><span class="line"><span class="comment"># 现在，我们将使用前一部分的代码并将其应用于一个更难的问题，</span></span><br><span class="line"><span class="comment"># 其中更多的特征描述每个数据点，只有一些特征指示一个点是否是异常值。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载第二个数据集。</span></span><br><span class="line">data = scio.loadmat(<span class="string">&#x27;ex8data2.mat&#x27;</span>)</span><br><span class="line">X = data[<span class="string">&#x27;X&#x27;</span>]</span><br><span class="line">Xval = data[<span class="string">&#x27;Xval&#x27;</span>]</span><br><span class="line">yval = data[<span class="string">&#x27;yval&#x27;</span>].flatten()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对较大的数据集应用相同的步骤</span></span><br><span class="line">mu, sigma2 = eg.estimate_gaussian(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练集</span></span><br><span class="line">p = mvg.multivariate_gaussian(X, mu, sigma2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 交叉验证集</span></span><br><span class="line">pval = mvg.multivariate_gaussian(Xval, mu, sigma2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到最佳阈值</span></span><br><span class="line">epsilon, f1 = st.select_threshold(yval, pval)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;使用交叉验证找到的最佳 epsilon 值：&#123;:0.4e&#125;&#x27;</span>.<span class="built_in">format</span>(epsilon))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;交叉验证集上的最佳 F1 值：&#123;:0.6f&#125;&#x27;</span>.<span class="built_in">format</span>(f1))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;发现的异常值数量：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(np.<span class="built_in">sum</span>(np.less(p, epsilon))))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;(您应该看到 epsilon 约为 1.38e-18，F1 约为 0.615，以及 117 个异常值)&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;ex8 完成。按回车键退出&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>np.less(p, epsilon)</code>: 这部分代码使用NumPy库中的<code>np.less()</code>函数，它会逐元素比较数组<code>p</code>中的每个元素是否小于<code>epsilon</code>。这将生成一个布尔值的数组，其中<code>True</code>表示对应位置的元素小于<code>epsilon</code>，<code>False</code>表示大于或等于<code>epsilon</code>。</p><hr><h2 id="推荐系统"><a href="#推荐系统" class="headerlink" title="推荐系统"></a>推荐系统</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>在第二部分中，您将使用协同过滤构建电影推荐系统</p><p>必要的文件：</p><ul><li><code>ex8_cofi.py</code> - 用于练习第二部分的Python脚本</li><li><code>ex8 movies.mat</code> - 电影评论数据集 </li><li><code>ex8 movieParams.mat</code> - 用于调试的参数</li><li><code>checkCostFunction.py</code> - 协同过滤的梯度</li><li><code>loadMovieList.py</code> - 将电影列表加载到单元数组中 </li><li><code>movie_ids.txt</code> - 电影列表 </li><li><code>normalizeRatings.py</code> - 协同过滤的均值归一化</li><li><code>computeNumericalGradient.py</code> - 数值计算梯度</li></ul><p>需要补充的文件：</p><ul><li><code>cofiCostFunc.py</code> - 实现协同过滤的成本函数</li></ul><hr><h3 id="导入-1"><a href="#导入-1" class="headerlink" title="导入"></a>导入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> scipy.io <span class="keyword">as</span> scio</span><br><span class="line"><span class="keyword">import</span> scipy.optimize <span class="keyword">as</span> opt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入自定义模块</span></span><br><span class="line"><span class="keyword">import</span> cofiCostFunction <span class="keyword">as</span> ccf</span><br><span class="line"><span class="keyword">import</span> checkCostFunction <span class="keyword">as</span> cf</span><br><span class="line"><span class="keyword">import</span> loadMovieList <span class="keyword">as</span> lm</span><br><span class="line"><span class="keyword">import</span> normalizeRatings <span class="keyword">as</span> nr</span><br></pre></td></tr></table></figure><hr><h3 id="载入并绘图-1"><a href="#载入并绘图-1" class="headerlink" title="载入并绘图"></a>载入并绘图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================== 第 1 部分：加载电影评分数据集 =====================</span></span><br><span class="line"><span class="comment"># 我们将首先加载电影评分数据集，以了解数据的结构</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;加载电影评分数据集.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载数据</span></span><br><span class="line">data = scio.loadmat(<span class="string">&#x27;ex8_movies.mat&#x27;</span>)</span><br><span class="line">Y = data[<span class="string">&#x27;Y&#x27;</span>]</span><br><span class="line">R = data[<span class="string">&#x27;R&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Y 是一个 1682 x 943 的 2 维 ndarray，包含 1682 部电影在 943 个用户上的评分（1-5）</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># R 是一个 1682 x 943 的 2 维 ndarray，其中 R[i, j] = 1 当且仅当用户 j 给电影 i 打了分</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从矩阵中，我们可以计算出诸如平均评分之类的统计信息。</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;电影 0（Toy Story）的平均评分: &#123;:0.6f&#125;/5&#x27;</span>.<span class="built_in">format</span>(np.mean(Y[<span class="number">0</span>, np.where(R[<span class="number">0</span>] == <span class="number">1</span>)])))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们可以通过使用 plt.imshow 来可视化评分矩阵</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.imshow(Y)</span><br><span class="line">plt.colorbar()</span><br><span class="line">plt.xlabel(<span class="string">&#x27;用户&#x27;</span>,fontproperties=<span class="string">&#x27;SimHei&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;电影&#x27;</span>,fontproperties=<span class="string">&#x27;SimHei&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;程序暂停。按回车键继续&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231201030452789.png" alt="image-20231201030452789" style="zoom:67%;" /></p><hr><h3 id="成本函数"><a href="#成本函数" class="headerlink" title="成本函数"></a>成本函数</h3><p>需要完成成本函数<code>cofiCostFunc.py</code>文件</p><script type="math/tex; mode=display">J(x^{(1)},...x^{(n_m)},\theta^{(1)},...,\theta^{(n_u)})=\frac{1}{2}\sum_{(i:j):r(i,j)=1}((\theta^{(j)})^Tx^{(i)}-y^{(i,j)})^2+\frac{\lambda}{2}\sum_{i=1}^{n_m}\sum_{k=1}^{n}(x_k^{(j)})^2+\frac{\lambda}{2}\sum_{j=1}^{n_u}\sum_{k=1}^{n}(\theta_k^{(j)})^2</script><script type="math/tex; mode=display">x_k^{(i)}:=x_k^{(i)}-\alpha\left(\sum_{j:r(i,j)=1}((\theta^{(j)})^Tx^{(i)}-y^{(i,j)}\theta_k^{j}+\lambda x_k^{(i)}\right)</script><script type="math/tex; mode=display">\theta_k^{(i)}:=\theta_k^{(i)}-\alpha\left(\sum_{i:r(i,j)=1}((\theta^{(j)})^Tx^{(i)}-y^{(i,j)}x_k^{(i)}+\lambda \theta_k^{(j)}\right)</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cofi_cost_function</span>(<span class="params">params, Y, R, num_users, num_movies, num_features, lmd</span>):</span></span><br><span class="line">    X = params[<span class="number">0</span>:num_movies * num_features].reshape((num_movies, num_features))</span><br><span class="line">    theta = params[num_movies * num_features:].reshape((num_users, num_features))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 你需要正确设置以下值。</span></span><br><span class="line">    cost = <span class="number">0</span></span><br><span class="line">    X_grad = np.zeros(X.shape)</span><br><span class="line">    theta_grad = np.zeros(theta.shape)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ===================== 你的代码在这里 =====================</span></span><br><span class="line">    <span class="comment"># 说明: 计算协同过滤的成本函数和梯度。</span></span><br><span class="line">    <span class="comment"># 具体来说，你应该首先实现成本函数（不带正则化），并确保它匹配我们的成本。</span></span><br><span class="line">    <span class="comment"># 之后，你应该实现梯度并使用 checkCostFunction 例程来检查梯度是否正确。</span></span><br><span class="line">    <span class="comment"># 最后，你应该实现正则化。</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># 注意:   X - num_movies x num_features 的电影特征矩阵</span></span><br><span class="line">    <span class="comment">#        theta - num_users x num_features 的用户特征矩阵</span></span><br><span class="line">    <span class="comment">#        Y - num_movies x num_users 的用户对电影的评分矩阵</span></span><br><span class="line">    <span class="comment">#        R - num_movies x num_users 矩阵，其中 R[i, j] = 1 表示第 i 部电影被第 j 个用户评分</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># 你应该正确设置以下变量</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#        X_grad - num_movies x num_features 的矩阵，包含对 X 的每个元素的偏导数</span></span><br><span class="line">    <span class="comment">#        theta_grad - num_users x num_features 的矩阵，包含对 theta 的每个元素的偏导数</span></span><br><span class="line">    error = (X @ theta.T - Y) * R</span><br><span class="line">    cost = <span class="number">0.5</span> * np.<span class="built_in">sum</span>(error ** <span class="number">2</span>) + <span class="number">0.5</span> * lmd * (np.<span class="built_in">sum</span>(theta ** <span class="number">2</span>) + np.<span class="built_in">sum</span>(X ** <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算 X_grad 和 theta_grad</span></span><br><span class="line">    X_grad = error @ theta + lmd * X</span><br><span class="line">    theta_grad = error.T @ X + lmd * theta</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ==========================================================</span></span><br><span class="line"></span><br><span class="line">    grad = np.concatenate((X_grad.flatten(), theta_grad.flatten()))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cost, grad</span><br></pre></td></tr></table></figure><p>回到<code>ex8_cofi.py</code>文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================== 第 2 部分：协同过滤成本函数 =====================</span></span><br><span class="line"><span class="comment"># 现在，你将实现协同过滤的成本函数。</span></span><br><span class="line"><span class="comment"># 为了帮助你调试成本函数，我们已经提供了我们在其上训练的一组权重。</span></span><br><span class="line"><span class="comment"># 具体来说，你应该在 cofiCostFunc.py 中完成代码以返回成本。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载预先训练的权重（X、theta、num_users、num_movies、num_features）</span></span><br><span class="line">data = scio.loadmat(<span class="string">&#x27;ex8_movieParams.mat&#x27;</span>)</span><br><span class="line">X = data[<span class="string">&#x27;X&#x27;</span>]</span><br><span class="line">theta = data[<span class="string">&#x27;Theta&#x27;</span>]</span><br><span class="line">num_users = data[<span class="string">&#x27;num_users&#x27;</span>]</span><br><span class="line">num_movies = data[<span class="string">&#x27;num_movies&#x27;</span>]</span><br><span class="line">num_features = data[<span class="string">&#x27;num_features&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 减小数据集的大小以加快运行速度</span></span><br><span class="line">num_users = <span class="number">4</span></span><br><span class="line">num_movies = <span class="number">5</span></span><br><span class="line">num_features = <span class="number">3</span></span><br><span class="line">X = X[<span class="number">0</span>:num_movies, <span class="number">0</span>:num_features]</span><br><span class="line">theta = theta[<span class="number">0</span>:num_users, <span class="number">0</span>:num_features]</span><br><span class="line">Y = Y[<span class="number">0</span>:num_movies, <span class="number">0</span>:num_users]</span><br><span class="line">R = R[<span class="number">0</span>:num_movies, <span class="number">0</span>:num_users]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算成本函数</span></span><br><span class="line">cost, grad = ccf.cofi_cost_function(np.concatenate((X.flatten(), theta.flatten())), Y, R, num_users, num_movies, num_features, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;加载参数的成本: &#123;:0.2f&#125;\n(这个值应该约为 22.22)&#x27;</span>.<span class="built_in">format</span>(cost))</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;程序暂停。按回车键继续&#x27;</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================== 第 4 部分：协同过滤成本正则化 =====================</span></span><br><span class="line"><span class="comment"># 现在，你应该为协同过滤的成本函数实现正则化。</span></span><br><span class="line"><span class="comment"># 你可以通过将正则化的成本添加到原始成本计算中来实现它。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算成本函数</span></span><br><span class="line">cost, _ = ccf.cofi_cost_function(np.concatenate((X.flatten(), theta.flatten())), Y, R, num_users, num_movies, num_features, <span class="number">1.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;加载参数的成本（lambda = 1.5）: &#123;:0.2f&#125;\n&#x27;</span></span><br><span class="line">      <span class="string">&#x27;(这个值应该约为 31.34)&#x27;</span>.<span class="built_in">format</span>(cost))</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;程序暂停。按回车键继续&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ===================== 第 5 部分：协同过滤梯度正则化 =====================</span></span><br><span class="line"><span class="comment"># 一旦你的成本与我们的匹配，你应该继续实现梯度的正则化。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;检查梯度（带正则化）...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过运行 check_cost_function 来检查梯度</span></span><br><span class="line">cf.check_cost_function(<span class="number">1.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;程序暂停。按回车键继续&#x27;</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="新用户打分"><a href="#新用户打分" class="headerlink" title="新用户打分"></a>新用户打分</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================== 第 6 部分：为新用户输入评分 =====================</span></span><br><span class="line"><span class="comment"># 在训练协同过滤模型之前，我们将首先添加与我们刚观察到的新用户相对应的评分。</span></span><br><span class="line"><span class="comment"># 代码的这一部分还将允许你为数据集中的电影输入你自己的评分！</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">movie_list = lm.load_movie_list()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化我的评分</span></span><br><span class="line">my_ratings = np.zeros(<span class="built_in">len</span>(movie_list))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查文件 movie_ids.txt 获取我们数据集中每部电影的 id</span></span><br><span class="line"><span class="comment"># 例如，Toy Story (1995) 的 ID 为 0，所以要给它评分 &quot;4&quot;，你可以设置</span></span><br><span class="line">my_ratings[<span class="number">0</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者假设不喜欢 Silence of the Lambs (1991)，你可以设置</span></span><br><span class="line">my_ratings[<span class="number">97</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们已经选择了一些我们喜欢/不喜欢的电影，我们给出的评分如下：</span></span><br><span class="line">my_ratings[<span class="number">6</span>] = <span class="number">3</span></span><br><span class="line">my_ratings[<span class="number">11</span>] = <span class="number">5</span></span><br><span class="line">my_ratings[<span class="number">53</span>] = <span class="number">4</span></span><br><span class="line">my_ratings[<span class="number">63</span>] = <span class="number">5</span></span><br><span class="line">my_ratings[<span class="number">65</span>] = <span class="number">3</span></span><br><span class="line">my_ratings[<span class="number">68</span>] = <span class="number">5</span></span><br><span class="line">my_ratings[<span class="number">182</span>] = <span class="number">4</span></span><br><span class="line">my_ratings[<span class="number">225</span>] = <span class="number">5</span></span><br><span class="line">my_ratings[<span class="number">354</span>] = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;新用户的评分:\n&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(my_ratings.size):</span><br><span class="line">    <span class="keyword">if</span> my_ratings[i] &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;对 &#123;&#125; 评分为 &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(movie_list[i], my_ratings[i]))</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;程序暂停。按回车键继续&#x27;</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="学习评分"><a href="#学习评分" class="headerlink" title="学习评分"></a>学习评分</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================== 第 7 部分：学习电影评分 =====================</span></span><br><span class="line"><span class="comment"># 现在，你将在包含 1682 部电影和 943 个用户的电影评分数据集上训练协同过滤模型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;训练协同过滤...\n&#x27;</span></span><br><span class="line">      <span class="string">&#x27;(这可能需要 1 ~ 2 分钟)&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载数据</span></span><br><span class="line">data = scio.loadmat(<span class="string">&#x27;ex8_movies.mat&#x27;</span>)</span><br><span class="line">Y = data[<span class="string">&#x27;Y&#x27;</span>]</span><br><span class="line">R = data[<span class="string">&#x27;R&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Y 是一个 1682x943 的矩阵，包含 943 个用户对 1682 部电影的评分（1-5）</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># R 是一个 1682x943 的矩阵，其中 R[i,j] = 1 当且仅当用户 j 给电影 i 打了分</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将我们自己的评分添加到数据矩阵中</span></span><br><span class="line">Y = np.c_[my_ratings, Y]</span><br><span class="line">R = np.c_[(my_ratings != <span class="number">0</span>), R]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 规范化评分</span></span><br><span class="line">Ynorm, Ymean = nr.normalize_ratings(Y, R)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有用的值</span></span><br><span class="line">num_users = Y.shape[<span class="number">1</span>]</span><br><span class="line">num_movies = Y.shape[<span class="number">0</span>]</span><br><span class="line">num_features = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置初始参数（theta、X）</span></span><br><span class="line">X = np.random.randn(num_movies, num_features)</span><br><span class="line">theta = np.random.randn(num_users, num_features)</span><br><span class="line"></span><br><span class="line">initial_params = np.concatenate([X.flatten(), theta.flatten()])</span><br><span class="line"></span><br><span class="line">lmd = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cost_func</span>(<span class="params">p</span>):</span></span><br><span class="line">    <span class="keyword">return</span> ccf.cofi_cost_function(p, Ynorm, R, num_users, num_movies, num_features, lmd)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grad_func</span>(<span class="params">p</span>):</span></span><br><span class="line">    <span class="keyword">return</span> ccf.cofi_cost_function(p, Ynorm, R, num_users, num_movies, num_features, lmd)[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">theta, *unused = opt.fmin_cg(cost_func, fprime=grad_func, x0=initial_params, maxiter=<span class="number">100</span>, disp=<span class="literal">False</span>, full_output=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将返回的 theta 展开回 U 和 W</span></span><br><span class="line">X = theta[<span class="number">0</span>:num_movies * num_features].reshape((num_movies, num_features))</span><br><span class="line">theta = theta[num_movies * num_features:].reshape((num_users, num_features))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;推荐系统学习完成&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(theta)</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;程序暂停。按回车键继续&#x27;</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="推荐电影"><a href="#推荐电影" class="headerlink" title="推荐电影"></a>推荐电影</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================== 第 8 部分：为你推荐 =====================</span></span><br><span class="line"><span class="comment"># 在训练模型之后，你现在可以通过计算预测矩阵来进行推荐。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">p = np.dot(X, theta.T)</span><br><span class="line">my_predictions = p[:, <span class="number">0</span>] + Ymean</span><br><span class="line"></span><br><span class="line">indices = np.argsort(my_predictions)[::-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n为你推荐的前 10 部电影:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    j = indices[i]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;预测评分 &#123;:0.1f&#125; 给电影 &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(my_predictions[j], movie_list[j]))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n原始评分:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(my_ratings.size):</span><br><span class="line">    <span class="keyword">if</span> my_ratings[i] &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;对 &#123;&#125; 评分为 &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(movie_list[i], my_ratings[i]))</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;ex8_cofi 完成。按回车键退出&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13.0.推荐系统</title>
      <link href="/post/48693.html"/>
      <url>/post/48693.html</url>
      
        <content type="html"><![CDATA[<h1 id="推荐系统"><a href="#推荐系统" class="headerlink" title="推荐系统"></a>推荐系统</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>机器学习中的推荐系统是一种利用算法和模型来预测用户对特定项目的兴趣程度，并向用户推荐可能感兴趣的项目的系统。推荐系统在许多在线平台上都得到了广泛应用，例如电子商务网站、社交媒体平台、音乐和视频流媒体服务等。</p><p>推荐系统的主要目标是提供个性化的推荐，以提高用户体验，增加用户对平台的参与度，并帮助用户发现新的有趣内容。有两种主要类型的推荐系统：<strong>协同过滤和内容过滤</strong>。</p><p>从一个例子开始定义推荐系统的问题。</p><p>假使我们是一个电影供应商，我们有 5 部电影和 4 个用户，我们要求用户为电影打分。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231130132735836.png" alt="image-20231130132735836"></p><p>前三部电影是爱情片，后两部则是动作片，我们可以看出<strong>Alice</strong>和<strong>Bob</strong>似乎更倾向与爱情片， 而 <strong>Carol</strong> 和 <strong>Dave</strong> 似乎更倾向与动作片。并且没有一个用户给所有的电影都打过分。我们希望构建一个算法来<strong>预测</strong>他们每个人可能会给他们没看过的电影打多少分，并以此作为推荐的依据。</p><p>下面引入一些标记：</p><ul><li>$n_u$ 代表用户的数量</li><li>$n_m$ 代表电影的数量</li><li>$r(i, j)$ 如果用户j给电影 $i$ 评过分则 $r(i,j)=1$</li><li>$y^{(i, j)}$ 代表用户 $j$ 给电影$i$的评分</li><li>$m_j$代表用户 $j$ 评过分的电影的总数</li></ul><hr><h2 id="内容过滤"><a href="#内容过滤" class="headerlink" title="内容过滤"></a>内容过滤</h2><p>这种方法利用<strong>项目的特征</strong>和用户的偏好之间的匹配来进行推荐。内容过滤系统会考虑项目的属性，例如关键词、主题或其他描述性特征，然后将这些特征与用户过去的行为或偏好进行匹配。</p><p>在一个基于内容的推荐系统算法中，我们假设对于我们希望推荐的东西有一些数据，这些数据是有关这些东西的特征。</p><p>在我们的例子中，我们可以假设每部电影都有两个特征，如$x_1$代表电影的<strong>浪漫程度</strong>，$x_2$ 代表电影的<strong>动作程度</strong>。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231130132744985.png" alt="image-20231130132744985"></p><p>则每部电影都有一个特征向量，如$x^{(1)}$是第一部电影的特征向量为$[0.9,0]$</p><p>下面我们要基于这些特征来构建一个推荐系统算法。假设我们采用线性回归模型，我们可以针对每一个用户都训练一个线性回归模型，如$\theta ^{(1)}$是第一个用户的模型的参数。</p><p>于是，我们有：</p><ul><li><p>$\theta^{(j)}$用户 $j$ 的参数向量</p></li><li><p>$x^{(i)}$电影 $i$ 的特征向量</p></li><li><p>对于用户 $j$ 和电影 $i$，我们预测评分为：$(\theta^{(j)})^T x^{(i)}$</p></li></ul><p>比如alice是用户1，假设其$\theta^{(1)}=[0,5,0]$，而$x^{(3)}=[1,0.99,0]$，用$(\theta^{(1)})^T x^{(3)}=4.95$，所以预测其对第三部电影评分为4.95分</p><p>代价函数：针对用户 $j$，该线性回归模型的代价为预测误差的平方和，加上正则化项：</p><script type="math/tex; mode=display">\min_{\theta (j)}\frac{1}{2}\sum_{i:r(i,j)=1}\left((\theta^{(j)})^Tx^{(i)}-y^{(i,j)}\right)^2+\frac{\lambda}{2}\left(\theta_{k}^{(j)}\right)^2</script><p>其中 $i:r(i,j)$表示我们只计算那些用户 $j$ 评过分的电影。在一般的线性回归模型中，误差项和正则项应该都是乘以$1/2m$，在这里我们将$m$去掉。并且我们不对方差项$\theta_0$进行正则化处理。</p><p>上面的代价函数只是针对一个用户的，为了学习所有用户，我们将<strong>所有用户的代价函数</strong>求和：</p><script type="math/tex; mode=display">\min_{\theta^{(1)},...,\theta^{(n_u)}} \frac{1}{2}\sum_{j=1}^{n_u}\sum_{i:r(i,j)=1}\left((\theta^{(j)})^Tx^{(i)}-y^{(i,j)}\right)^2+\frac{\lambda}{2}\sum_{j=1}^{n_u}\sum_{k=1}^{n}(\theta_k^{(j)})^2</script><p>用梯度下降法求最优解：</p><script type="math/tex; mode=display">\theta_k^{(j)}:=\theta_k^{(j)}-\alpha\left(\sum_{i:r(i,j)=1}((\theta^{(j)})^Tx^{(i)}-y^{(i,j)})x_{k}^{(i)}+\lambda\theta_k^{(j)}\right) \quad (\text{for} \, k\neq 0)</script><hr><h2 id="协同过滤"><a href="#协同过滤" class="headerlink" title="协同过滤"></a>协同过滤</h2><p>定义：<strong>协同过滤</strong>是推荐系统中一种常见的技术，它基于用户之间的相似性或项目之间的相似性来进行推荐。这种方法利用用户和项目的历史行为或偏好信息，通过<strong>比较用户或项目之间的相似性</strong>，预测用户可能感兴趣的项目或向用户推荐可能喜欢的其他用户。</p><p>在之前的基于内容的推荐系统中，对于每一部电影，我们都掌握了可用的特征，使用这些特征训练出了每一个用户的参数。相反地，如果我们拥有用户的参数，我们可以学习得出电影的特征</p><script type="math/tex; mode=display">\mathop{min}\limits_{x^{(1)},...,x^{(n_m)}}\frac{1}{2}\sum_{i=1}^{n_m}\sum_{j{r(i,j)=1}}((\theta^{(j)})^Tx^{(i)}-y^{(i,j)})^2+\frac{\lambda}{2}\sum_{i=1}^{n_m}\sum_{k=1}^{n}(x_k^{(i)})^2</script><p>但是如果我们既没有用户的参数，也没有电影的特征，这两种方法都不可行了，而<strong>协同过滤算法</strong>可以同时学习这两者。</p><p>我们的优化目标便改为同时针对$x$和$\theta$进行。</p><script type="math/tex; mode=display">J(x^{(1)},...x^{(n_m)},\theta^{(1)},...,\theta^{(n_u)})=\frac{1}{2}\sum_{(i:j):r(i,j)=1}((\theta^{(j)})^Tx^{(i)}-y^{(i,j)})^2+\frac{\lambda}{2}\sum_{i=1}^{n_m}\sum_{k=1}^{n}(x_k^{(j)})^2+\frac{\lambda}{2}\sum_{j=1}^{n_u}\sum_{k=1}^{n}(\theta_k^{(j)})^2</script><p>对代价函数求偏导数的结果如下：</p><script type="math/tex; mode=display">x_k^{(i)}:=x_k^{(i)}-\alpha\left(\sum_{j:r(i,j)=1}((\theta^{(j)})^Tx^{(i)}-y^{(i,j)}\theta_k^{j}+\lambda x_k^{(i)}\right)</script><script type="math/tex; mode=display">\theta_k^{(i)}:=\theta_k^{(i)}-\alpha\left(\sum_{i:r(i,j)=1}((\theta^{(j)})^Tx^{(i)}-y^{(i,j)}x_k^{(i)}+\lambda \theta_k^{(j)}\right)</script><p>注：在协同过滤从算法中，我们通常不使用$x_0=1$的截距项，如果需要的话，算法会自动学得。</p><p>协同过滤算法使用步骤如下：</p><ol><li><p>初始 $x^{(1)},x^{(1)},…x^{(nm)},\ \theta^{(1)},\theta^{(2)},…,\theta^{(n_u)}$为一些随机小值</p></li><li><p>使用梯度下降算法最小化代价函数</p></li><li><p>在训练完算法后，我们预测$(\theta^{(j)})^Tx^{(i)}$为用户 $j$ 给电影 $i$ 的评分</p></li></ol><p>通过这个学习过程获得的特征矩阵包含了有关电影的重要数据，这些数据不总是人能读懂的，但是我们可以用这些数据作为给用户推荐电影的依据。</p><p>例如，如果一位用户正在观看电影 $x^{(i)}$，我们可以寻找另一部电影$x^{(j)}$，依据两部电影的特征向量之间的距离$\left| {x}^{(i)}-{x}^{(j)} \right|$的大小。</p><hr><h2 id="低秩矩阵分解"><a href="#低秩矩阵分解" class="headerlink" title="低秩矩阵分解"></a>低秩矩阵分解</h2><p><strong>低秩矩阵分解</strong>（Low Rank Matrix Factorization）是一种矩阵分解技术，常被应用于推荐系统和数据降维等领域。其核心思想是将<strong>一个大矩阵表示为两个或多个较小维度</strong>的矩阵的乘积，这些小矩阵通常被称为因子矩阵。低秩表示意味着这些因子矩阵的秩（rank）相对较小。</p><p>在推荐系统中，低秩矩阵分解主要用于学习用户和物品之间的潜在关系。通过将用户-物品评分矩阵分解为<strong>用户因子矩阵和物品因子矩阵</strong>，可以学习到用户和物品的隐藏特征，从而进行个性化的推荐。</p><p>举例说明：</p><p>我们有关于五部电影的数据集，我将要做的是，将这些用户的电影评分，进行分组并存到一个矩阵中。</p><p>我们有五部电影，以及四位用户，那么 这个矩阵 $Y$ 就是一个5行4列的矩阵，它将这些电影的用户评分数据都存在矩阵里：</p><div class="table-container"><table><thead><tr><th><strong>Movie</strong></th><th><strong>Alice (1)</strong></th><th><strong>Bob (2)</strong></th><th><strong>Carol (3)</strong></th><th><strong>Dave (4)</strong></th></tr></thead><tbody><tr><td>Love at last</td><td>5</td><td>5</td><td>0</td><td>0</td></tr><tr><td>Romance forever</td><td>5</td><td>?</td><td>?</td><td>0</td></tr><tr><td>Cute puppies of love</td><td>?</td><td>4</td><td>0</td><td>?</td></tr><tr><td>Nonstop car chases</td><td>0</td><td>0</td><td>5</td><td>4</td></tr><tr><td>Swords vs. karate</td><td>0</td><td>0</td><td>5</td><td>?</td></tr></tbody></table></div><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231130145917739.png" alt="image-20231130145917739"></p><p>那么用户-物品评分矩阵可以表示为：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231130150006503.png" alt="image-20231130150006503"></p><p>这矩阵可以被分解为<strong>物品因子矩阵和用户因子矩阵</strong>，分别是：$X=\left [ \begin{matrix}<br>x^{(1)} \\<br>x^{(2)}\\<br>\cdot\cdot\cdot\\<br>x^{(n)}\\<br>\end{matrix} \right ]$以及$\Theta=\left [ \begin{matrix}<br>\theta^{(1)^T} \\<br>\theta^{(2)^T}\\<br>\cdot\cdot\cdot\\<br>\theta^{(n)^T}\\<br>\end{matrix} \right ]$</p><p>其中，$X$的每一行表示一个物品的潜在特征，$\Theta$的每一行表示一个用户的潜在特征。矩阵$\Theta^T X$的乘积近似等于原始评分矩阵</p><p>低秩矩阵分解的优点之一是它能够处理数据的稀疏性，即使用户只对很少的物品进行了评分，也能够进行有效的推荐。此外，低秩矩阵分解还可以通过学习潜在特征来发现用户和物品之间的关系，从而提高推荐的准确性。</p><hr><h2 id="均值归一化"><a href="#均值归一化" class="headerlink" title="均值归一化"></a>均值归一化</h2><p>让我们来看下面的用户评分数据：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231130150953401.png" alt="image-20231130150953401"></p><p>如果我们新增一个用户 <strong>Eve</strong>，并且 <strong>Eve</strong> 没有为任何电影评分，那么我们以什么为依据为<strong>Eve</strong>推荐电影呢？</p><p>直接用协同过滤计算，结果会是Eve对电影的评分都为0，这样无法给eve推荐</p><p>我们首先需要对结果 $Y $矩阵进行均值归一化处理，将每一个用户对某一部电影的评分减去所有用户对该电影评分的平均值：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231130151008327.png" alt="image-20231130151008327"></p><p>然后我们利用这个新的 $Y$ 矩阵来训练算法。<br>如果我们要用新训练出的算法来预测评分，则需要将平均值重新加回去，预测$(\theta^{(j)})^T x^{(i)}+\mu_i$，对于<strong>Eve</strong>，我们的新模型会认为她给每部电影的评分都是该电影的平均分。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12.0.异常检测</title>
      <link href="/post/59772.html"/>
      <url>/post/59772.html</url>
      
        <content type="html"><![CDATA[<h1 id="异常检测"><a href="#异常检测" class="headerlink" title="异常检测"></a>异常检测</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>异常检测（Anomaly Detection）是机器学习中的一种任务，其目标是识别数据中的异常或不寻常的行为、实例或模式。这种异常通常是与正常行为显著不同的数据点，可能表示潜在的问题、异常事件或者有趣的情况。</p><p>举一个例子说明：假想你是一个飞机引擎制造商，当你生产的飞机引擎从生产线上流出时，你需要进行<strong>QA</strong>(质量控制测试)，而作为这个测试的一部分，你测量了飞机引擎的一些<strong>特征变量</strong>，比如引擎运转时产生的热量，或者引擎的振动等等。</p><p>这样一来，你就有了一个<strong>数据集</strong>，从$x^{(1)}$到$x^{(m)}$，如果你生产了$m$个引擎的话，你将这些数据绘制成图表，看起来就是如图所示：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231129103217520.png" alt="image-20231129103217520"></p><p>这里的每个点、每个叉，都是<strong>无标签数据</strong>。假设后来有一天，你有一个新的飞机引擎从生产线上流出，而你的新飞机引擎有特征变量$x_{test}$。</p><p>所谓的异常检测问题就是：我们希望知道这个新的飞机引擎是否有某种<strong>异常</strong>，或者说，我们希望判断这个引擎是否需要进一步测试。因为，如果它看起来像一个正常的引擎，那么我们可以直接将它运送到客户那里，而不需要进一步的测试。</p><p>给定数据集 $x^{(1)},x^{(2)},..,x^{(m)}$，我们假使数据集是正常的，我们希望知道新的数据 $x_{test}$ 是不是异常的，即这个测试数据不属于该组数据的几率如何。我们所构建的模型应该能根据该测试数据的位置告诉我们其属于一组数据的可能性 $p(x)$。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231129104244108.png" alt="image-20231129104244108"></p><p>上图中，在蓝色圈内的数据属于该组数据的可能性较高，而越是偏远的数据，其属于该组数据的可能性就越低。</p><p>这种方法称为密度估计，表达如下：</p><script type="math/tex; mode=display">if \quad p(x)\begin{cases}< \varepsilon & anomaly \\> =\varepsilon & normal\end{cases}</script><p>模型$p(x)$ 为我们其属于一组数据的可能性，通过$p(x) &lt; \varepsilon$检测非正常用户。</p><hr><h2 id="高斯分布"><a href="#高斯分布" class="headerlink" title="高斯分布"></a>高斯分布</h2><p>高斯分布，也称为正态分布或钟形曲线，是概率论和统计学中最重要的分布之一。高斯分布的定义如下：</p><p>对于一个一维随机变量 (X)，其服从高斯分布，记作 ($X \sim \mathcal{N}(\mu, \sigma^2)$)，其中：</p><ul><li>($\mu$) 是分布的均值，决定曲线的位置：$\mu=\frac{1}{m}\sum\limits_{i=1}^{m}x^{(i)}$</li><li>($\sigma^2$) 是方差，决定曲线的宽度：$\sigma^2=\frac{1}{m}\sum\limits_{i=1}^{m}(x^{(i)}-\mu)^2$</li></ul><p>概率密度函数表示为：</p><script type="math/tex; mode=display">f(x | \mu, \sigma^2) = \frac{1}{\sqrt{2\pi\sigma^2}} \exp\left(-\frac{(x - \mu)^2}{2\sigma^2}\right)</script><p>这个函数描述了随机变量 ($X$) 取某个特定值的概率，曲线呈钟形，且在均值处取得最大值。标准正态分布是均值 ($\mu = 0$)，方差 ($\sigma^2 = 1$) 的高斯分布。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231129105200319.png" alt="image-20231129105200319" style="zoom: 25%;" /></p><p>注：机器学习中对于方差我们通常只除以$m$而非统计学中的$(m-1)$。这里顺便提一下，在实际使用中，到底是选择使用$1/m$还是$1/(m-1)$其实区别很小，只要你有一个还算大的训练集，在机器学习领域大部分人更习惯使用$1/m$这个版本的公式</p><hr><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ol><li><p><strong>数据准备：</strong></p><ul><li>收集并准备要进行异常检测的数据集。</li></ul></li><li><p><strong>选择特征：</strong></p><ul><li>选择用于建模的特征。通常，这些特征应该能够很好地描述正常数据的模式。</li></ul></li><li><p><strong>建模正常数据：</strong></p><ul><li>使用高斯分布（或者是多元高斯分布）对正常数据进行建模。计算特征的均值$\mu$ 和方差  $\sigma^2$</li></ul></li><li><p><strong>计算概率密度函数：</strong></p><ul><li><p>对于每个样本，使用建模得到的均值和方差计算其在高斯分布中的概率密度函数值。对于一元高斯分布，使用： $p(x)=\prod\limits_{j=1}^np(x_j;\mu_j,\sigma_j^2)=\prod\limits_{j=1}^1\frac{1}{\sqrt{2\pi}\sigma_j}exp(-\frac{(x_j-\mu_j)^2}{2\sigma_j^2})$</p></li><li><p>下图是一个由两个特征的训练集，以及特征的分布情况：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraba47767a11ba39a23898b9f1a5a57cc5.png" alt=""></p></li></ul></li><li><p><strong>设定阈值：</strong></p><ul><li>选择一个适当的阈值，该阈值将用于决定哪些样本被认为是异常。通常，可以使用交叉验证或其他评估方法来选择最佳的阈值。</li></ul></li><li><p><strong>检测异常：</strong></p><ul><li>对于每个样本，比较其概率密度函数值与设定的阈值。如果概率密度函数值低于阈值，将该样本标记为异常，当$p(x) &lt; \varepsilon$时，为异常。</li></ul></li><li><p><strong>评估性能：</strong></p><ul><li>当我们开发一个异常检测系统时，我们从带标记（异常或正常）的数据着手，我们从其中选择一部分正常数据用于构建训练集，然后用剩下的正常数据和异常数据混合的数据构成<strong>交叉检验集和测试集</strong></li><li><p>具体的评价方法如下：</p><ol><li><p>根据测试集数据，我们估计特征的平均值和方差并构建$p(x)$函数</p></li><li><p>对交叉检验集，我们尝试使用<strong>不同的$\varepsilon$值</strong>作为阀值，并预测数据是否异常，根据$F1$值或者查准率与查全率的比例来选择 $\varepsilon$</p></li><li><p>选出 $\varepsilon$ 后，针对测试集进行预测，计算异常检验系统的$F1$值，或者查准率与查全率之比</p></li></ol></li></ul></li></ol><hr><h2 id="异常检测与监督学习对比"><a href="#异常检测与监督学习对比" class="headerlink" title="异常检测与监督学习对比"></a>异常检测与监督学习对比</h2><p>之前我们构建的异常检测系统也使用了带标记的数据，与监督学习有些相似，下面的对比有助于选择采用监督学习还是异常检测：</p><div class="table-container"><table><thead><tr><th><strong>特征</strong></th><th><strong>异常检测</strong></th><th><strong>监督学习</strong></th></tr></thead><tbody><tr><td><strong>目标</strong></td><td>发现数据中的异常模式，通常关注少量异常实例</td><td>分类预测目标变量的类别，关注整体数据分布</td></tr><tr><td><strong>数据需求</strong></td><td>正常数据通常占多数，异常数据较少</td><td>包含已标记的训练数据，涵盖各个类别</td></tr><tr><td><strong>标签</strong></td><td>大多数情况下，数据集中只有正常样本，无异常标签</td><td>所有样本都有已知的类别标签</td></tr><tr><td><strong>算法输入</strong></td><td>正常模型的参数（均值、方差等）</td><td>特征和标签（训练数据的输入和输出）</td></tr><tr><td><strong>算法输出</strong></td><td>标记异常样本或异常概率</td><td>预测目标变量的类别</td></tr><tr><td><strong>适用场景</strong></td><td><strong>异常数据相对较少</strong>，难以获得大量异常标签</td><td><strong>大量</strong>已标记的训练数据，目标类别的分布相对均衡</td></tr><tr><td><strong>样本平衡</strong></td><td>不平衡，正常数据占多数</td><td>可能是平衡的，如果类别不平衡可能需要额外处理</td></tr><tr><td><strong>模型评估</strong></td><td>使用异常检测指标如精确度、召回率等</td><td>使用分类指标如准确度、召回率、精确度等</td></tr></tbody></table></div><hr><h2 id="选择特征"><a href="#选择特征" class="headerlink" title="选择特征"></a>选择特征</h2><p>异常检测假设特征符合高斯分布，如果数据的分布不是高斯分布，异常检测算法也能够工作，但是最好还是将数据转换成高斯分布，例如使用对数函数：$x= log(x+c)$，其中 $c$ 为非负常数； 或者 $x=x^c$，$c$为 0-1 之间的一个分数，等方法。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231129112257059.png" alt="image-20231129112257059"></p><p>误差分析：</p><p>一个常见的问题是一些异常的数据可能也会有较高的$p(x)$值，因而被算法认为是正常的。这种情况下误差分析能够帮助我们，我们可以分析那些被算法错误预测为正常的数据，观察能否找出一些问题。我们可能能从问题中发现我们需要<strong>增加一些新的特征</strong>，增加这些新特征后获得的新算法能够帮助我们更好地进行异常检测。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231129113900576.png" alt="image-20231129113900576"></p><p>例如，在检测数据中心的计算机状况的例子中，我们可以用<strong>CPU</strong>负载与网络通信量的比例作为一个新的特征，如果该值异常地大，便有可能意味着该服务器是陷入了一些问题中。</p><hr><h2 id="多元高斯分布"><a href="#多元高斯分布" class="headerlink" title="多元高斯分布"></a>多元高斯分布</h2><p>假使我们有两个相关的特征，而且这两个特征的值域范围比较宽，这种情况下，一般的高斯分布模型可能不能很好地识别异常数据。其原因在于，一般的高斯分布模型尝试的是去同时抓住两个特征的偏差，因此创造出一个比较大的判定边界。</p><p>下图中是两个相关特征，洋红色的线（根据ε的不同其范围可大可小）是一般的高斯分布模型获得的判定边界，很明显绿色的<strong>X</strong>所代表的数据点很可能是异常值，但是其$p(x)$值却仍然在正常范围内。多元高斯分布将创建像图中蓝色曲线所示的判定边界。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231129114827564.png" alt="image-20231129114827564"></p><p>为了解决这个问题，我们需要利用多元的高斯分布，定义如下：</p><p>多元高斯分布（Multivariate Gaussian Distribution）是用于描述多维随机变量的概率分布。它是一种对多变<strong>量同时进行建模</strong>的方法，考虑了各个变量之间的<strong>协方差</strong>关系。</p><p>在一般的高斯分布模型中，我们计算 $p(x)$ 的方法是：<br>通过分别计算每个特征对应的几率然后将其累乘起来，而在多元高斯分布模型中，我们将构建特征的<strong>协方差矩阵</strong>，用所有的特征一起来计算 $p(x)$。</p><ol><li><p><strong>收集数据：</strong></p><ul><li>收集包含多个特征的多维数据。</li></ul></li><li><p><strong>选择特征：</strong></p><ul><li>选择用于建模的特征。</li></ul></li><li><p><strong>估计均值和协方差：</strong></p><ul><li>计算每个特征的均值 ($\mu_i$) 和特征之间的协方差 ($\Sigma_{ij}$)。</li><li>对于一个包含 (m) 个样本的数据集，均值计算如下：<br> $\mu_i = \frac{1}{m} \sum_{j=1}^{m} x_{ij}$ </li><li>协方差矩阵计算如下：<br> $\Sigma_{ij} = \frac{1}{m} \sum_{k=1}^{m} (x_{ik} - \mu_i)(x_{jk} - \mu_j)$ </li></ul></li><li><p><strong>建模多元高斯分布：</strong></p><ul><li>使用估计得到的均值向量和协方差矩阵建模多元高斯分布。</li></ul></li><li><p><strong>计算概率密度函数：</strong></p><ul><li><p>对于一个新的样本 ($\mathbf{x}$)，使用多元高斯分布的概率密度函数计算其概率：</p><script type="math/tex; mode=display">f(\mathbf{x} | \boldsymbol{\mu}, \boldsymbol{\Sigma}) = \frac{1}{(2\pi)^{n/2}|\boldsymbol{\Sigma}|^{1/2}} \exp\left(-\frac{1}{2} (\mathbf{x} - \boldsymbol{\mu})^T \boldsymbol{\Sigma}^{-1} (\mathbf{x} - \boldsymbol{\mu})\right)</script></li><li><p>($\mathbf{x}$) 是一个 $n$维向量，表示一个随机样本。</p></li><li><p>($\boldsymbol{\mu}$) 是一个 $n$维均值向量。</p></li><li><p>($\boldsymbol{\Sigma}$) 是一个 ($n \times n$) 的协方差矩阵。</p></li></ul></li></ol><p>$\Sigma^{-1}$ 是逆矩阵，下面我们来看看协方差矩阵是如何影响模型的：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231129115855720.png" alt="image-20231129115855720"></p><p>上图是5个不同的模型，从左往右依次分析：</p><ol><li><p>是一个一般的高斯分布模型</p></li><li><p>通过协方差矩阵，令特征1拥有较小的偏差，同时保持特征2的偏差</p></li><li><p>通过协方差矩阵，令特征2拥有较大的偏差，同时保持特征1的偏差</p></li><li><p>通过协方差矩阵，在不改变两个特征的原有偏差的基础上，增加两者之间的正相关性</p></li><li><p>通过协方差矩阵，在不改变两个特征的原有偏差的基础上，增加两者之间的负相关性</p></li></ol><p>多元高斯分布模型与原高斯分布模型的关系：</p><p>可以证明的是，原本的高斯分布模型是多元高斯分布模型的一个子集，即像上图中的第1、2、3，3个例子所示，如果协方差矩阵只在对角线的单位上有非零的值时，即为原本的高斯分布模型了。</p><p>原高斯分布模型和多元高斯分布模型的比较：</p><div class="table-container"><table><thead><tr><th><strong>征</strong></th><th><strong>原高斯分布模型（一元高斯）</strong></th><th><strong>多元高斯分布模型</strong></th></tr></thead><tbody><tr><td><strong>维度</strong></td><td>一维（单变量）</td><td>多维（多变量）</td></tr><tr><td><strong>模型参数</strong></td><td>均值 <em>μ</em>、方差$\sigma^2$</td><td>均值向量 $\boldsymbol{\mu}$、协方差矩阵 $\boldsymbol{\Sigma}$</td></tr><tr><td><strong>概率密度函数</strong></td><td>$\frac{1}{\sqrt{2\pi\sigma^2}} \exp\left(-\frac{(x - \mu)^2}{2\sigma^2}\right)$</td><td>$\frac{1}{(2\pi)^{n/2}\boldsymbol{</td><td>\Sigma</td><td>}^{1/2}} \exp\left(-\frac{1}{2} (\mathbf{x} - \boldsymbol{\mu})^T \boldsymbol{\Sigma}^{-1} (\mathbf{x} - \boldsymbol{\mu})\right)$</td></tr><tr><td><strong>建模</strong></td><td>单一变量（一维数据）</td><td>多变量（多维数据）</td></tr><tr><td><strong>变量之间关系</strong></td><td>假设变量之间独立</td><td>考虑变量之间协方差关系</td></tr><tr><td><strong>适用性</strong></td><td>通常适用于一维数据集</td><td>适用于多维数据集，能更全面地捕捉变量之间的相关性</td></tr><tr><td><strong>应用场景</strong></td><td>计算代价低，能适应大规模的特征</td><td>必须要有 $m&gt;n$，不然的话协方差矩阵$\Sigma$不可逆的，通常需要 $m&gt;10n$ 另外特征冗余也会导致协方差矩阵不可逆</td></tr></tbody></table></div><hr>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11.5 ex7：k-means and PCA</title>
      <link href="/post/30433.html"/>
      <url>/post/30433.html</url>
      
        <content type="html"><![CDATA[<h1 id="ex7：k-means-and-PCA"><a href="#ex7：k-means-and-PCA" class="headerlink" title="ex7：k-means and PCA"></a>ex7：k-means and PCA</h1><h2 id="前半"><a href="#前半" class="headerlink" title="前半"></a>前半</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在这个练习中，你将实现K均值算法并将其用于图像压缩。首先，你将在一个2D示例数据集上开始，这将帮助你直观地了解K均值算法的工作原理。之后，你将使用K均值算法进行图像压缩，通过将图像中出现的颜色数量减少到仅包含那些在该图像中最常见的颜色。在这一部分的练习中，你将使用ex7.m。</p><p>必要的文件如下：</p><ul><li><code>ex7.py</code> - 用于K均值算法第一练习的Python脚本</li><li><code>ex7data2.mat</code> - K均值算法的示例数据集</li><li><code>bird_small.png</code>- 示例图像 </li><li><code>displayData.py</code> - 显示存储在矩阵中的2D数据的函数</li><li><code>plotDataPoints.py</code>- K均值聚类中质心的初始化函数</li><li><code>plotProgresskMeans.py</code>- 绘制K均值每一步的函数</li><li><code>runkMeans.py</code> - 运行K均值算法</li></ul><p>需要完成的文件：</p><ul><li><code>findClosestCentroids.py</code>- 寻找最接近的质心（在K均值中使用）</li><li><code>computeCentroids.py</code>- 计算质心均值（在K均值中使用）</li><li><code>kMeansInitCentroids.py</code> - K均值聚类的质心初始化</li></ul><hr><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> scipy.io <span class="keyword">as</span> scio</span><br><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">from</span> skimage.util <span class="keyword">import</span> img_as_float</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> runkMeans <span class="keyword">as</span> km</span><br><span class="line"><span class="keyword">import</span> findClosestCentroids <span class="keyword">as</span> fc</span><br><span class="line"><span class="keyword">import</span> computeCentroids <span class="keyword">as</span> cc</span><br><span class="line"><span class="keyword">import</span> kMeansInitCentroids <span class="keyword">as</span> kmic</span><br></pre></td></tr></table></figure><p>Scikit-image（skimage）是一个基于SciPy库的图像处理库，提供了一系列用于图像处理的工具和算法。它包含了许多常用的图像处理任务的实现，如图像过滤、边缘检测、形态学操作、图像变换等。</p><hr><h3 id="寻找质心"><a href="#寻找质心" class="headerlink" title="寻找质心"></a>寻找质心</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================== 第1部分: 寻找最近的质心 =====================</span></span><br><span class="line"><span class="comment"># 为了帮助实现K均值算法，我们将学习算法分为两个函数 -- find_closest_centroids 和 compute_centroids。</span></span><br><span class="line"><span class="comment"># 在这一部分，你应该完成 findClosestCentroids.py 中的代码。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;寻找最近的质心。&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 载入将要使用的示例数据集</span></span><br><span class="line">data = scio.loadmat(<span class="string">&#x27;ex7data2.mat&#x27;</span>)</span><br><span class="line">X = data[<span class="string">&#x27;X&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择一组初始质心</span></span><br><span class="line">k = <span class="number">3</span>  <span class="comment"># 三个质心</span></span><br><span class="line">initial_centroids = np.array([[<span class="number">3</span>, <span class="number">3</span>], [<span class="number">6</span>, <span class="number">2</span>], [<span class="number">8</span>, <span class="number">5</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用初始质心找到示例的最近质心</span></span><br><span class="line">idx = fc.find_closest_centroids(X, initial_centroids)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;前3个示例的最近质心：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(idx[<span class="number">0</span>:<span class="number">3</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;(应分别为0, 2, 1的最近质心)&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;程序暂停。按回车键继续&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这里需要完成<code>findClosestCentroids.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_closest_centroids</span>(<span class="params">X, centroids</span>):</span></span><br><span class="line">    K = centroids.shape[<span class="number">0</span>]</span><br><span class="line">    m = X.shape[<span class="number">0</span>]</span><br><span class="line">    idx = np.zeros(m)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="comment"># 计算欧几里得距离的平方，避免使用平方根以提高效率</span></span><br><span class="line">        distances_squared = np.<span class="built_in">sum</span>((X[i] - centroids) ** <span class="number">2</span>, axis=<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 找到最近的质心的索引</span></span><br><span class="line">        closest_centroid_index = np.argmin(distances_squared)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将索引存储在idx中</span></span><br><span class="line">        idx[i] = closest_centroid_index</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> idx</span><br></pre></td></tr></table></figure><p>虽然<code>centroids</code>是一个$(3 \times 2)$的数组，而<code>X[i]</code>是一个一维的数组，但是两者之间依然可以加减，<code>X[i]</code>会复制成3列，然后减去<code>centroids</code>，这是<code>numpy</code>的特性：<strong>广播运算</strong></p><p>指定<code>axis=1</code>，在<code>numpy</code>，是指定行的运算，结果即是数据点到质心之间距离的平方，<code>distances_squared</code>是一个一维数组</p><p>最后使用 <code>np.argmin</code>函数，找出数组中最小值的索引，放入到<code>idx</code>中</p><hr><h3 id="移动质心"><a href="#移动质心" class="headerlink" title="移动质心"></a>移动质心</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================== 第2部分: 计算均值 =====================</span></span><br><span class="line"><span class="comment"># 在实现最近质心函数后，你现在应该完成 compute_centroids 函数。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;计算质心均值。&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据上一部分找到的最近质心计算均值。</span></span><br><span class="line">centroids = cc.compute_centroids(X, idx, k)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;在找到最近质心后计算的质心： \n&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(centroids))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;应为&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[[ 2.428301 3.157924 ]&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; [ 5.813503 2.633656 ]&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; [ 7.119387 3.616684 ]]&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;程序暂停。按回车键继续&#x27;</span>)</span><br></pre></td></tr></table></figure><p>完成<code>compute_centroids</code> 函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_centroids</span>(<span class="params">X, idx, K</span>):</span></span><br><span class="line">    <span class="comment"># 有用的值</span></span><br><span class="line">    (m, n) = X.shape</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 你需要正确返回以下变量。</span></span><br><span class="line">    centroids = np.zeros((K, n))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ===================== 你的代码在这里 =====================</span></span><br><span class="line">    <span class="comment"># 遍历每个质心，计算属于它的所有点的平均值。</span></span><br><span class="line">    <span class="comment"># 具体而言，行向量 centroids[i] 应包含分配给质心 i 的数据点的平均值。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(K):</span><br><span class="line">        <span class="comment"># 找到属于质心 i 的所有数据点的索引</span></span><br><span class="line">        points_in_cluster = (idx == i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> np.<span class="built_in">any</span>(points_in_cluster):  <span class="comment"># 检查簇是否非空</span></span><br><span class="line">            <span class="comment"># 计算这些数据点的平均值，并将结果存储在 centroids[i] 中</span></span><br><span class="line">            centroids[i] = np.mean(X[points_in_cluster], axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ==========================================================</span></span><br><span class="line">    <span class="keyword">return</span> centroids</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里需要遍历每个质心，计算属于它的所有点的平均值。</p><p>在for循环中，<code>points_in_cluster = (idx == i)</code>会得到一个大小和<code>idx</code>一样的布尔数组</p><p><code>centroids[i] = np.mean(X[points_in_cluster], axis=0)</code>，则将布尔数组作为索引，成功地找到了每个质心对应的数据点，而将其他的数据点置为0，这一个方法在逻辑回归和SVM中已经用过多次</p><p>最后指定<code>axis=0</code>，即指定按列运算，算出<code>x,y</code>坐标的均值，得到质心移动的位置</p><hr><h3 id="K均值聚类"><a href="#K均值聚类" class="headerlink" title="K均值聚类"></a>K均值聚类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================== 第3部分: K均值聚类 =====================</span></span><br><span class="line"><span class="comment"># 在完成 compute_centroids 和 find_closest_centroids 两个函数后，你将拥有运行</span></span><br><span class="line"><span class="comment"># K均值算法所需的所有部分。在这一部分，你将在我们提供的示例数据集上运行K均值算法。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;在示例数据集上运行K均值聚类。&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 载入示例数据集</span></span><br><span class="line">data = scio.loadmat(<span class="string">&#x27;ex7data2.mat&#x27;</span>)</span><br><span class="line">X = data[<span class="string">&#x27;X&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行K均值算法的设置</span></span><br><span class="line">K = <span class="number">3</span></span><br><span class="line">max_iters = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了一致性，这里我们设置质心为特定的值</span></span><br><span class="line"><span class="comment"># 但在实际中，你可能想要自动生成它们，例如通过</span></span><br><span class="line"><span class="comment"># 将它们设置为随机示例（如在 kMeansInitCentroids 中所示）。</span></span><br><span class="line">initial_centroids = np.array([[<span class="number">3</span>, <span class="number">3</span>], [<span class="number">6</span>, <span class="number">2</span>], [<span class="number">8</span>, <span class="number">5</span>]])</span><br><span class="line"><span class="comment"># 运行K均值算法。结尾的 &#x27;True&#x27; 告诉我们的函数绘制</span></span><br><span class="line"><span class="comment"># K均值算法的进展</span></span><br><span class="line">centroids, idx = km.run_kmeans(X, initial_centroids, max_iters, <span class="literal">True</span>)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;K均值完成。&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;程序暂停。按回车键继续&#x27;</span>)</span><br></pre></td></tr></table></figure><p>使用K均值聚类，画出质心移动的图像</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231128061033509.png" alt="image-20231128061033509" style="zoom:67%;" /></p><hr><h3 id="图像的聚类"><a href="#图像的聚类" class="headerlink" title="图像的聚类"></a>图像的聚类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================== 第4部分: 对像素进行K均值聚类 =====================</span></span><br><span class="line"><span class="comment"># 在这个练习中，你将使用K均值对图像进行压缩。为此，</span></span><br><span class="line"><span class="comment"># 你将首先对图像中像素的颜色运行K均值，然后将每个像素映射到</span></span><br><span class="line"><span class="comment"># 最近的质心。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;在图像的像素上运行K均值聚类。&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 载入一张鸟的图像</span></span><br><span class="line">image = io.imread(<span class="string">&#x27;bird_small.png&#x27;</span>)</span><br><span class="line">image = img_as_float(image)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 图像的尺寸</span></span><br><span class="line">img_shape = image.shape</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将图像重塑为Nx3矩阵，其中N = 像素的数量。</span></span><br><span class="line"><span class="comment"># 每行将包含红、绿和蓝像素值</span></span><br><span class="line"><span class="comment"># 这给我们提供了我们将在K均值上使用的数据集矩阵X。</span></span><br><span class="line"></span><br><span class="line">X = image.reshape(img_shape[<span class="number">0</span>] * img_shape[<span class="number">1</span>], <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在这个数据上运行你的K均值算法</span></span><br><span class="line"><span class="comment"># 你应该在这里尝试不同的K值和max_iters值</span></span><br><span class="line">K = <span class="number">16</span></span><br><span class="line">max_iters = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在使用K均值时，随机初始化质心是很重要的。</span></span><br><span class="line"><span class="comment"># 你应该在继续之前完成 kMeansInitCentroids.py 中的代码</span></span><br><span class="line">initial_centroids = kmic.kmeans_init_centroids(X, K)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行K均值</span></span><br><span class="line">centroids, idx = km.run_kmeans(X, initial_centroids, max_iters, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;K均值完成。&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;程序暂停。按回车键继续&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这里需要完成<code>kMeansInitCentroids.py</code>随机初始化质心的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kmeans_init_centroids</span>(<span class="params">X, K</span>):</span></span><br><span class="line">    <span class="comment"># 你需要正确返回这个值</span></span><br><span class="line">    centroids = np.zeros((K, X.shape[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ===================== 你的代码在这里 =====================</span></span><br><span class="line">    <span class="comment"># 将 centroids 设置为从数据集 X 中随机选择的示例</span></span><br><span class="line">    <span class="comment"># 你可以使用 np.random.choice 函数来实现</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从数据集中随机选择 K 个索引</span></span><br><span class="line">    random_indices = np.random.choice(X.shape[<span class="number">0</span>], K, replace=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用选定的索引获取相应的示例并将其赋值给 centroids</span></span><br><span class="line">    centroids = X[random_indices]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ==========================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> centroids</span><br></pre></td></tr></table></figure><p> <code>random_indices = np.random.choice(X.shape[0], K, replace=False)</code>的意思是：从 <code>0</code> 到 <code>X.shape[0] - 1</code> 的范围中，随机选择 <code>K</code> 个不重复的整数，用于初始化 K-Means 算法的质心。这样确保了初始化的质心是不同的样本点。</p><hr><h3 id="压缩图像"><a href="#压缩图像" class="headerlink" title="压缩图像"></a>压缩图像</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================== 第 5 部分: 图像压缩 =====================</span></span><br><span class="line"><span class="comment"># 在这个练习的这一部分，你将使用 K-Means 的聚类结果来压缩一张图像。</span></span><br><span class="line"><span class="comment"># 为了实现这一目标，我们首先找到每个示例所属的最近簇。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;将 K-Means 应用于图像压缩。&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到最近的簇成员</span></span><br><span class="line">idx = fc.find_closest_centroids(X, centroids)</span><br><span class="line"><span class="built_in">print</span>(idx)</span><br><span class="line">idx = np.array(idx, dtype=<span class="built_in">int</span>)</span><br><span class="line"><span class="built_in">print</span>(idx)</span><br><span class="line"><span class="comment"># 本质上，我们现在已经用 idx 表示了图像 X，</span></span><br><span class="line"><span class="comment"># 接下来，我们可以通过将每个像素（由其在 idx 中的索引指定）映射到质心值来恢复图像</span></span><br><span class="line">X_recovered = centroids[idx]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将恢复的图像重塑为正确的尺寸</span></span><br><span class="line">X_recovered = np.reshape(X_recovered, (img_shape[<span class="number">0</span>], img_shape[<span class="number">1</span>], <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">plt.imshow(image)</span><br><span class="line">plt.title(<span class="string">&#x27;Original&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">plt.imshow(X_recovered)</span><br><span class="line">plt.title(<span class="string">&#x27;Compressed, with &#123;&#125; colors&#x27;</span>.<span class="built_in">format</span>(K))</span><br><span class="line">plt.show()</span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;练习 7 完成。按 ENTER 键退出&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出图像</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231128062534585.png" alt="image-20231128062534585"></p><hr><h2 id="后半"><a href="#后半" class="headerlink" title="后半"></a>后半</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>在这个练习中，你将使用主成分分析（PCA）进行降维操作。你将首先尝试使用一个2D示例数据集，以便直观地理解PCA的工作原理，然后将其应用于一个包含5000张人脸图像的较大数据集。 </p><p>必要的文件：</p><p><code>ex7_pca.m</code> - 用于主成分分析（PCA）第二练习的Python脚本</p><p><code>ex7data1.mat</code> - PCA的示例数据集</p><p><code>ex7faces.mat</code> - 人脸数据集</p><p><code>feature_normalize.py</code>-特征归一化</p><p>需要补充的文件</p><p><code>pca.py</code> - 执行主成分分析</p><p><code>projectData.py</code>- 将数据集投影到较低维度的空间</p><p><code>recoverData.py</code> - 从投影中恢复原始数据</p><hr><h3 id="导入-1"><a href="#导入-1" class="headerlink" title="导入"></a>导入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入需要的库</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt  <span class="comment"># 用于绘图</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  <span class="comment"># 用于数学运算</span></span><br><span class="line"><span class="keyword">import</span> scipy.io <span class="keyword">as</span> scio  <span class="comment"># 用于读取MATLAB文件</span></span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D  <span class="comment"># 用于3D绘图</span></span><br><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io  <span class="comment"># 用于图像处理</span></span><br><span class="line"><span class="keyword">from</span> skimage.util <span class="keyword">import</span> img_as_float  <span class="comment"># 用于图像处理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> featureNormalize <span class="keyword">as</span> fn  <span class="comment"># 导入特征归一化模块</span></span><br><span class="line"><span class="keyword">import</span> pca <span class="keyword">as</span> pca  <span class="comment"># 导入主成分分析模块</span></span><br><span class="line"><span class="keyword">import</span> runkMeans <span class="keyword">as</span> rk  <span class="comment"># 导入K均值聚类模块</span></span><br><span class="line"><span class="keyword">import</span> projectData <span class="keyword">as</span> pd  <span class="comment"># 导入数据投影模块</span></span><br><span class="line"><span class="keyword">import</span> recoverData <span class="keyword">as</span> rd  <span class="comment"># 导入数据恢复模块</span></span><br><span class="line"><span class="keyword">import</span> displayData <span class="keyword">as</span> disp  <span class="comment"># 导入数据可视化模块</span></span><br><span class="line"><span class="keyword">import</span> kMeansInitCentroids <span class="keyword">as</span> kmic  <span class="comment"># 导入K均值聚类初始化质心模块</span></span><br><span class="line"><span class="keyword">import</span> runkMeans <span class="keyword">as</span> km  <span class="comment"># 导入K均值聚类模块</span></span><br></pre></td></tr></table></figure><hr><h3 id="载入并绘图"><a href="#载入并绘图" class="headerlink" title="载入并绘图"></a>载入并绘图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================== 第1部分: 载入示例数据集 =====================</span></span><br><span class="line"><span class="comment"># 通过使用一个小型数据集进行练习，该数据集易于可视化</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;可视化主成分分析示例数据集.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面的命令加载数据集</span></span><br><span class="line">data = scio.loadmat(<span class="string">&#x27;ex7data1.mat&#x27;</span>)</span><br><span class="line">X = data[<span class="string">&#x27;X&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化示例数据集</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], facecolors=<span class="string">&#x27;none&#x27;</span>, edgecolors=<span class="string">&#x27;b&#x27;</span>, s=<span class="number">20</span>)</span><br><span class="line">plt.axis(<span class="string">&#x27;equal&#x27;</span>)</span><br><span class="line">plt.axis([<span class="number">0.5</span>, <span class="number">6.5</span>, <span class="number">2</span>, <span class="number">8</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;程序暂停。按回车键继续&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231128083330996.png" alt="image-20231128083330996" style="zoom:67%;" /></p><hr><h3 id="主成分分析"><a href="#主成分分析" class="headerlink" title="主成分分析"></a>主成分分析</h3><p>编写PCA的函数，根据PCA的公式：</p><script type="math/tex; mode=display">\text{Cov} =\dfrac {1}{m}\sum^{n}_{i=1}\left( x^{(i)}\right) \left( x^{(i)}\right) ^{T}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> scipy</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pca</span>(<span class="params">X</span>):</span></span><br><span class="line">    <span class="comment"># 有用的值</span></span><br><span class="line">    (m, n) = X.shape</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 你需要正确返回以下变量。</span></span><br><span class="line">    U = np.zeros(n)</span><br><span class="line">    S = np.zeros(n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Sigma = (<span class="number">1</span> / m) * X.T @ X</span><br><span class="line">    <span class="comment"># 使用SVD计算特征向量和特征值</span></span><br><span class="line">    U, S, _ = scipy.linalg.svd(Sigma)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> U, S</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>回到<code>ex7_pca.py</code>文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================== 第2部分: 主成分分析 =====================</span></span><br><span class="line"><span class="comment"># 实现主成分分析（PCA）降维技术。首先需要对X进行归一化,你应该完成pca.py</span></span><br><span class="line">X_norm, mu, sigma = fn.feature_normalize(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行PCA</span></span><br><span class="line">U, S = pca.pca(X_norm)</span><br><span class="line"></span><br><span class="line">rk.draw_line(mu, mu + <span class="number">1.5</span> * S[<span class="number">0</span>] * U[:, <span class="number">0</span>])</span><br><span class="line">rk.draw_line(mu, mu + <span class="number">1.5</span> * S[<span class="number">1</span>] * U[:, <span class="number">1</span>])</span><br><span class="line">plt.show()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最大特征向量: \nU[:, 0] = &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(U[:, <span class="number">0</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;预期结果应为 [-0.707107 -0.707107]&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;程序暂停。按回车键继续&#x27;</span>)</span><br></pre></td></tr></table></figure><p>输出图片：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231128085737767.png" alt="image-20231128085737767" style="zoom:67%;" /></p><hr><h3 id="数据降维"><a href="#数据降维" class="headerlink" title="数据降维"></a>数据降维</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================== 第3部分: 数据降维 =====================</span></span><br><span class="line"><span class="comment"># 实现投影步骤，将数据映射到前k个特征向量</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;在示例数据集上进行降维.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制归一化后的数据集（从PCA返回）</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.scatter(X_norm[:, <span class="number">0</span>], X_norm[:, <span class="number">1</span>], facecolors=<span class="string">&#x27;none&#x27;</span>, edgecolors=<span class="string">&#x27;b&#x27;</span>, s=<span class="number">20</span>)</span><br><span class="line">plt.axis(<span class="string">&#x27;equal&#x27;</span>)</span><br><span class="line">plt.axis([-<span class="number">4</span>, <span class="number">3</span>, -<span class="number">4</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据投影到K=1维</span></span><br><span class="line">K = <span class="number">1</span></span><br><span class="line">Z = pd.project_data(X_norm, U, K)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第一个示例的投影: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(Z[<span class="number">0</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;(此值应约为1.481274)&#x27;</span>)</span><br></pre></td></tr></table></figure><p>先归一化，然后编写<code>project_data</code>函数，对数据进行降维</p><script type="math/tex; mode=display">z^{(i)}=U^{T}_{reduce}\times x^{(i)}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">project_data</span>(<span class="params">X, U, K</span>):</span></span><br><span class="line">    <span class="comment"># 你需要正确返回以下变量。</span></span><br><span class="line">    Z = np.zeros((X.shape[<span class="number">0</span>], K))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ===================== 你的代码在这里 =====================</span></span><br><span class="line">    <span class="comment"># 说明: 使用U中的前K个特征向量（前K列）计算数据的投影。</span></span><br><span class="line">    <span class="comment">#       对于第i个示例 X[i]，对第k个特征向量的投影如下：</span></span><br><span class="line">    <span class="comment">#           x = X[i, :].T</span></span><br><span class="line">    <span class="comment">#           projection_k = x.T @ U[:, k]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(X.shape[<span class="number">0</span>]):</span><br><span class="line">        x = X[i, :].reshape(X.shape[<span class="number">1</span>], <span class="number">1</span>)</span><br><span class="line">        Z[i, :] = (U[:, :K].T@x).flatten()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ==========================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Z</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>x = X[i, :].reshape(X.shape[1], 1)</code>：这行代码将数据矩阵 <code>X</code> 中的第 i 行提取出来，并将其转换为列向量 </p><p><code>Z[i, :] = (x.T @ U[:, :K]).flatten()</code>：这行代码执行以下操作：</p><ul><li><code>(U[:, :K].T@x)</code>：将 <code>x</code> 与前 K 个主成分进行内积运算，得到投影后的列向量。这个操作实际上就是将数据投影到前 K 个主成分上。</li><li><code>.flatten()</code>：将投影后的列向量展平成一维数组。</li><li><code>Z[i, :] = ...</code>：将得到的一维数组存储在矩阵 <code>Z</code> 的第 <code>i</code> 行中，表示第 <code>i</code> 个样本在前 K 个主成分上的投影。</li></ul><hr><h3 id="数据复原"><a href="#数据复原" class="headerlink" title="数据复原"></a>数据复原</h3><p>编写<code>recover_data.py</code>，将降维后的数据还原</p><p>$z=U^{T}_{reduce}x$，相反的方程为：$x_{appox}=U_{reduce}\cdot z$,$x_{appox}\approx x$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recover_data</span>(<span class="params">Z, U, K</span>):</span></span><br><span class="line">    <span class="comment"># 初始化一个全零矩阵用于存储恢复后的数据</span></span><br><span class="line">    X_rec = np.zeros((Z.shape[<span class="number">0</span>], U.shape[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ===================== 你的代码在这里 =====================</span></span><br><span class="line">    <span class="comment"># 说明: 使用U中的前K个特征向量（前K列）在原始空间中计算数据的近似。</span></span><br><span class="line">    <span class="comment">#       对于第i个示例 Z[i]，对于维度j的近似恢复数据如下：</span></span><br><span class="line">    <span class="comment">#           v = Z[i, :].T</span></span><br><span class="line">    <span class="comment">#           recovered_j = v.T @ U[j, :K].T</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历每个样本</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Z.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="comment"># 获取第i个样本在主成分空间上的投影向量</span></span><br><span class="line">        v = Z[i, :].reshape(Z.shape[<span class="number">1</span>], <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历每个维度，进行近似恢复</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(U.shape[<span class="number">0</span>]):</span><br><span class="line">            <span class="comment"># 计算第i个样本在维度j上的近似恢复数据</span></span><br><span class="line">            X_rec[i, j] = (v.T @ U[j, :K].T).flatten()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ==========================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> X_rec</span><br></pre></td></tr></table></figure><p>回到<code>ex7_pca.py</code>文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">er_data(Z, U, K)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第一个示例的近似值: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(X_rec[<span class="number">0</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;(此值应约为 [-1.047419 -1.047419])&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制连接投影点与原始点的线条</span></span><br><span class="line">plt.scatter(X_rec[:, <span class="number">0</span>], X_rec[:, <span class="number">1</span>], facecolors=<span class="string">&#x27;none&#x27;</span>, edgecolors=<span class="string">&#x27;r&#x27;</span>, s=<span class="number">20</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(X_norm.shape[<span class="number">0</span>]):</span><br><span class="line">    rk.draw_line(X_norm[i], X_rec[i])</span><br><span class="line">plt.figure()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231128091415842.png" alt="image-20231128091415842" style="zoom:67%;" /></p><hr><h3 id="导入面部数据"><a href="#导入面部数据" class="headerlink" title="导入面部数据"></a>导入面部数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================== 第4部分: 载入和可视化面部数据 =====================</span></span><br><span class="line"><span class="comment"># 首先加载和可视化数据集</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;加载面部数据集.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载面部数据集</span></span><br><span class="line">data = scio.loadmat(<span class="string">&#x27;ex7faces.mat&#x27;</span>)</span><br><span class="line">X = data[<span class="string">&#x27;X&#x27;</span>]</span><br><span class="line"></span><br><span class="line">disp.display_data(X[<span class="number">0</span>:<span class="number">100</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;程序暂停。按回车键继续&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231128091642007.png" alt="image-20231128091642007" style="zoom:80%;" /></p><hr><h3 id="面部数据PCA"><a href="#面部数据PCA" class="headerlink" title="面部数据PCA"></a>面部数据PCA</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================== 第5部分: 在面部数据上运行PCA =====================</span></span><br><span class="line"><span class="comment"># 运行PCA并可视化结果，这里是特征脸</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;在面部数据集上运行PCA。\n(可能需要一两分钟...)&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在运行PCA之前，首先通过减去每个特征的均值来归一化X</span></span><br><span class="line">X_norm, mu, sigma = fn.feature_normalize(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行PCA</span></span><br><span class="line">U, S = pca.pca(X_norm)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化前36个特征向量</span></span><br><span class="line">disp.display_data(U[:, <span class="number">0</span>:<span class="number">36</span>].T)</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;程序暂停。按回车键继续&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231128091752689.png" alt="image-20231128091752689" style="zoom:67%;" /></p><hr><h3 id="面部数据降维"><a href="#面部数据降维" class="headerlink" title="面部数据降维"></a>面部数据降维</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================== 第6部分: 面部数据的降维 =====================</span></span><br><span class="line"><span class="comment"># 使用前k个特征向量将图像投影到特征空间</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;对面部数据进行降维.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">K = <span class="number">100</span></span><br><span class="line">Z = pd.project_data(X_norm, U, K)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;投影数据Z的形状为: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(Z.shape))</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;程序暂停。按回车键继续&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可视化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================== 第7部分: PCA降维后的面部可视化 =====================</span></span><br><span class="line"><span class="comment"># 将图像投影到特征空间的前K个特征向量，并仅使用这些K个维度进行可视化</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;可视化投影后（降维后）的面部图像.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">K = <span class="number">100</span></span><br><span class="line">X_rec = rd.recover_data(Z, U, K)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示归一化数据</span></span><br><span class="line">disp.display_data(X_norm[<span class="number">0</span>:<span class="number">100</span>])</span><br><span class="line">plt.title(<span class="string">&#x27;原始面部图像&#x27;</span>,fontproperties=<span class="string">&#x27;SimHei&#x27;</span>)</span><br><span class="line">plt.axis(<span class="string">&#x27;equal&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示仅使用k个特征向量重建的数据</span></span><br><span class="line">disp.display_data(X_rec[<span class="number">0</span>:<span class="number">100</span>])</span><br><span class="line">plt.title(<span class="string">&#x27;恢复后的面部图像&#x27;</span>,fontproperties=<span class="string">&#x27;SimHei&#x27;</span>)</span><br><span class="line">plt.axis(<span class="string">&#x27;equal&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;程序暂停。按回车键继续&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231128092247941.png" alt="image-20231128092247941"></p><hr><h3 id="PCA可视化"><a href="#PCA可视化" class="headerlink" title="PCA可视化"></a>PCA可视化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================== 第8(a)部分: 使用PCA进行可视化 =====================</span></span><br><span class="line"><span class="comment"># PCA的一个有用应用是用它来可视化高维数据。在上一个K-Means练习中，</span></span><br><span class="line"><span class="comment"># 在图像的3D像素颜色上运行K-Means。首先在3D中可视化这个输出，</span></span><br><span class="line"><span class="comment"># 然后应用PCA获得2D的可视化。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新加载上一个练习中的图像并在其上运行K-Means</span></span><br><span class="line"><span class="comment"># 为了使其正常工作，您需要首先完成K-Means作业</span></span><br><span class="line">image = io.imread(<span class="string">&#x27;bird_small.png&#x27;</span>)</span><br><span class="line">image = img_as_float(image)</span><br><span class="line"></span><br><span class="line">img_shape = image.shape</span><br><span class="line"></span><br><span class="line">X = image.reshape((img_shape[<span class="number">0</span>] * img_shape[<span class="number">1</span>], <span class="number">3</span>))</span><br><span class="line">K = <span class="number">16</span></span><br><span class="line">max_iters = <span class="number">10</span></span><br><span class="line">initial_centroids = kmic.kmeans_init_centroids(X, K)</span><br><span class="line">centroids, idx = km.run_kmeans(X, initial_centroids, max_iters, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机选择1000个索引进行可视化</span></span><br><span class="line">selected = np.random.randint(X.shape[<span class="number">0</span>], size=<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在3D中可视化数据和质心成员关系</span></span><br><span class="line">cm = plt.cm.get_cmap(<span class="string">&#x27;RdYlBu&#x27;</span>)</span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>, projection=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line">ax.scatter(X[selected, <span class="number">0</span>], X[selected, <span class="number">1</span>], X[selected, <span class="number">2</span>], c=idx[selected].astype(np.float64), s=<span class="number">15</span>, cmap=cm, vmin=<span class="number">0</span>, vmax=K)</span><br><span class="line">plt.title(<span class="string">&#x27;3D中绘制的像素数据集。颜色表示质心成员关系&#x27;</span>,fontproperties=<span class="string">&#x27;SimHei&#x27;</span>)</span><br><span class="line">plt.figure()</span><br><span class="line">plt.show()</span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;程序暂停。按回车键继续&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231128092510688.png" alt="image-20231128092510688"></p><hr><p>转为2D</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================== 第8(b)部分: 使用PCA进行可视化 =====================</span></span><br><span class="line"><span class="comment"># 使用PCA将此点云投影到2D进行可视化</span></span><br><span class="line"></span><br><span class="line">X_norm, mu, sigma = fn.feature_normalize(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行PCA并将数据投影到2D</span></span><br><span class="line">U, S = pca.pca(X_norm)</span><br><span class="line">Z = pd.project_data(X_norm, U, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在2D中绘制</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.scatter(Z[selected, <span class="number">0</span>], Z[selected, <span class="number">1</span>], c=idx[selected].astype(np.float64), s=<span class="number">15</span>, cmap=cm)</span><br><span class="line">plt.title(<span class="string">&#x27;使用PCA进行降维可视化的像素数据集&#x27;</span>,fontproperties=<span class="string">&#x27;SimHei&#x27;</span>)</span><br><span class="line">plt.figure()</span><br><span class="line">plt.show()</span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;ex7_pca 完成。按回车键退出&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231128092559613.png" alt="image-20231128092559613" style="zoom:80%;" /></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11.0.无监督学习</title>
      <link href="/post/59772.html"/>
      <url>/post/59772.html</url>
      
        <content type="html"><![CDATA[<h1 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>无监督学习</strong>是一种机器学习方法，其目标是从数据中发现模式、结构或关系，而不需要预先标记的目标变量。与监督学习不同，无监督学习不依赖于已知输出的训练数据。在无监督学习中，算法尝试从输入数据中提取信息，探索数据的内在结构，或者执行某种形式的聚类、降维、关联规则挖掘等任务。</p><ul><li><strong>聚类(Clustering):</strong> 将数据分成不同的组，使得同一组内的数据相似度较高，而不同组之间的相似度较低。</li><li><strong>降维(Dimensionality Reduction):</strong> 减少数据的维度，保留最重要的特征，以便更好地理解数据或加速后续的学习算法。</li><li><strong>异常检测(Anomaly Detection):</strong> 发现与大多数数据不同的异常数据点。</li><li><strong>关联规则挖掘(Association Rule Mining):</strong> 寻找数据集中项目之间的关联关系，例如购物篮分析</li><li><strong>生成模型(Generative Models):</strong> 学习数据的概率分布，以生成新的与训练数据相似的样本</li></ul><hr><h2 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>在一个典型的监督学习中，我们有一个有标签的训练集，我们的目标是找到能够区分正样本和负样本的决策边界，在这里的监督学习中，我们有一系列标签，我们需要据此拟合一个假设函数。与此不同的是，在非监督学习中，我们的数据没有附带任何标签，我们拿到的数据就是这样的：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231125151753657.png" alt="image-20231125151753657"></p><p>在这里有一系列点，却没有标签。因此，我们的训练集可以写成只有$x^{(1)}$,$x^{(2)}$…..一直到$x^{(m)}$。我们没有任何标签$y$。</p><p>我们可能需要某种算法帮助我们寻找一种结构。图上的数据看起来可以分成两个分开的点集（称为簇），一个能够找到我圈出的这些点集的算法，就被称为<strong>聚类算法</strong>。</p><p><strong>聚类算法</strong>是一类无监督学习算法，其主要目标是将数据集中的样本分成不同的组，每个组内的样本相似度较高，而不同组之间的相似度较低。这样的分组通常称为簇（Cluster）。聚类算法旨在发现数据中的内在结构，帮助我们理解数据并进行有效的数据分析。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231125160358944.png" alt="image-20231125160358944"></p><p>聚类算法可以应用到：市场分割，社交网络，计算机集群，天文数据分析等领域</p><hr><h3 id="K-均值算法"><a href="#K-均值算法" class="headerlink" title="K-均值算法"></a>K-均值算法</h3><p>K均值聚类（K-Means Clustering）是一种常用的聚类算法，属于无监督学习的范畴。该算法的目标是将数据集划分成K个不同的簇，每个簇内的样本点与簇中心（cluster center）的距离最小。簇中心是簇内所有样本点的平均值</p><p>K-均值算法的步骤为：</p><ol><li><strong>选择簇的数量K：</strong> 首先，需要指定要形成的簇的数量$K$。</li><li><strong>初始化簇中心：</strong> 随机选择$K$个样本作为初始簇中心，或者通过其他方法初始化。</li><li><strong>分配样本到簇：</strong> 对每个样本，计算其与各个簇中心的距离，将样本分配给距离最近的簇。</li><li><strong>更新簇中心：</strong> 对每个簇，计算簇内所有样本的平均值，将该平均值作为新的簇中心。</li><li><strong>重复步骤3和步骤4：</strong> 重复执行分配样本到簇和更新簇中心的步骤，直到满足停止条件，例如簇中心不再发生显著变化或达到最大迭代次数。</li></ol><p>下面是一个聚类示例：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraff1db77ec2e83b592bbe1c4153586120.jpg" alt=""></p><p>迭代 1 次</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraacdb3ac44f1fe61ff3b5a77d5a4895a1.jpg" alt=""></p><p>迭代 3 次</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typorafe6dd7acf1a1eddcd09da362ecdf976f.jpg" alt=""></p><p>迭代 10 次</p><p>用$μ^1$,$μ^2$,…,$μ^k$ 来表示聚类中心，用$c^{(1)}$,$c^{(2)}$,…,$c^{(m)}$来存储与第$i$个实例数据最近的聚类中心的索引，<strong>K-均值</strong>算法的伪代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Repeat &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> to m</span><br><span class="line"></span><br><span class="line">c(i) := index (form <span class="number">1</span> to K) of cluster centroid closest to x(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span> to K</span><br><span class="line"></span><br><span class="line">μk := average (mean) of points assigned to cluster k</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法分为两个步骤，第一个<strong>for</strong>循环是赋值步骤，即：对于每一个样例$i$，计算其应该属于的类。第二个<strong>for</strong>循环是聚类中心的移动，即：对于每一个类$K$，重新计算该类的质心。</p><hr><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>K-均值最小化问题，是要最小化所有的数据点与其所关联的聚类中心点之间的距离之和，因此<br>K-均值的代价函数（又称<strong>畸变函数</strong> <strong>Distortion function</strong>）为：</p><script type="math/tex; mode=display"> J(c^{(1)}, \ldots, c^{(m)}, \mu_1, \ldots, \mu_K) = \frac{1}{m} \sum_{i=1}^{m} \|X^{(i)} - \mu_{c^{(i)}}\|^2</script><p>其中$\mu_{c^{(i)}}$代表与$x^{(i)}$最近的聚类中心点。</p><p>我们的的优化目标便是找出使得代价函数最小的 $c^{(1)}$,$c^{(2)}$,…,$c^{(m)}$和$μ^1$,$μ^2$,…,$μ^k$，目标函数 ( $J$ ) 的含义是所有簇内样本点到其簇中心的距离平方和的总和。K均值聚类的优化目标就是找到一组簇中心，使得这个目标函数最小化。</p><p>K均值算法通过迭代执行两个步骤来优化这个目标：</p><ol><li><p><strong>簇分配步骤（Assign Step）：</strong> 将每个样本点分配给距离最近的簇中心。</p></li><li><p><strong>簇更新步骤（Update Step）：</strong> 更新每个簇的中心，计算簇内所有样本的平均值。</p></li></ol><p>这两个步骤交替进行，直到簇中心不再发生显著变化或达到最大迭代次数。在每次迭代后，目标函数 ( $J$ ) 都应该减小，这表示簇内样本点与簇中心之间的平方距离和在减小，从而更好地达到了聚类的效果。</p><hr><h3 id="随机初始化"><a href="#随机初始化" class="headerlink" title="随机初始化"></a>随机初始化</h3><p>运行K-均值算法的之前，我们首先要随机初始化所有的聚类中心点，下面介绍怎样做：</p><ol><li><p>我们应该选择$K&lt;m$，即聚类中心点的个数要小于所有训练集实例的数量</p></li><li><p>随机选择$K$个训练实例，然后令$K$个聚类中心分别与这$K$个训练实例相等</p></li></ol><p><strong>K-均值</strong>的一个问题在于，它有可能会停留在一个局部最小值处，而这取决于初始化的情况。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231125162715663.png" alt="image-20231125162715663"></p><p>为了解决这个问题，我们通常需要<strong>多次运行**</strong>K-均值<strong>算法，每一次都重新进行随机初始化，最后再比较多次运行</strong>K-均值**的结果，选择代价函数最小的结果。这种方法在$K$较小的时候（2—10）还是可行的，但是如果$K$较大，这么做也可能不会有明显地改善。</p><hr><h2 id="降维"><a href="#降维" class="headerlink" title="降维"></a>降维</h2><h3 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h3><p>降维：指通过<strong>减少数据的特征维度</strong>，从而保留数据关键信息的过程。在实际应用中，数据集往往包含大量的特征，而其中一些特征可能是冗余的、噪音的，或者不太重要的。通过降维，我们可以剔除这些不必要的信息，从而达到简化数据、提高模型性能的目的。</p><p>将数据从二维降至一维：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231127193533848.png" alt="image-20231127193533848" style="zoom:80%;" /></p><p>假设我们未知两个的特征：$x_1$:长度：用厘米表示；$x_2$：是用英寸表示同一物体的长度。</p><p>现在的问题的是，两种仪器对同一个东西测量的结果不完全相等（由于误差、精度等），而将两者都作为特征有些重复，因而，我们希望将这个<strong>二维的数据降至一维</strong>。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231127194457054.png" alt="image-20231127194457054" style="zoom:80%;" /></p><p>我们画出一条直线，降每个点都<strong>投影到直线</strong>上，观察投影点在直线上的位置，就将数据从二维降到了一维：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231127194711194.png" alt="image-20231127194711194" style="zoom:80%;" /></p><p>将数据从三维降至二维：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231127194829271.png" alt="image-20231127194829271"></p><p>过程是与上面类似的，我们将三维向量投射到一个二维的平面上，强迫使得所有的数据都在同一个平面上，降至二维的特征向量。</p><p>这样的处理过程可以被用于把任何维度的数据降到任何想要的维度，例如将1000维的特征降至100维。</p><hr><h3 id="主成分分析-PCA"><a href="#主成分分析-PCA" class="headerlink" title="主成分分析(PCA)"></a>主成分分析(PCA)</h3><p>主成分分析（Principal Component Analysis，PCA）是一种常用的降维技术，通过线性变换将原始数据映射到一个新的坐标系中，使得在新坐标系中数据的方差分布被最大化。这样，通过保留最重要的特征，PCA可以实现数据的降维。</p><p>在<strong>PCA</strong>中，我们要做的是找到一个方向向量（<strong>Vector direction</strong>），当我们把所有的数据都投射到该向量上时，我们希望投射平均均方误差能尽可能地小。方向向量是一个经过原点的向量，而投射误差是从特征向量向该方向向量作<strong>垂线</strong>的长度。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231127211838019.png" alt="image-20231127211838019" style="zoom: 50%;" /></p><p>目标是找到向量$u^{(1)}$,$u^{(2)}$,…,$u^{(k)}$使得总的投射误差最小</p><p>主成分分析与线性回归是两种不同的算法。主成分分析最小化的是投射误差，而线性回归尝试的是最小化预测误差。线性回归的目的是预测结果，而主成分分析不作任何预测</p><hr><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>假设要利用PCA将数据从$n$维降低到$k$维</p><p>当执行主成分分析（PCA）时，具体的步骤可以如下：</p><ol><li><p><strong>均值归一化：</strong></p><ul><li>对每个特征减去该特征的均值，使得每个特征的均值为零。</li></ul><script type="math/tex; mode=display"> X_{\text{centered}} = X - \bar{X}</script><p>其中，$(X)$ 是原始数据矩阵，$(\bar{X})$ 是每个特征的均值向量，。如果特征是在不同的数量级上，我们还需要将其除以标准差 $σ^2$</p></li><li><p><strong>计算协方差矩阵：</strong></p><ul><li>计算中心化后的数据的协方差矩阵。</li></ul><script type="math/tex; mode=display">\text{Cov} =\dfrac {1}{m}\sum^{n}_{i=1}\left( x^{(i)}\right) \left( x^{(i)}\right) ^{T}</script><p>其中，($m$) 是样本数。</p></li><li><p><strong>计算特征值和特征向量：</strong></p><ul><li>对协方差矩阵进行特征值分解。</li></ul><script type="math/tex; mode=display">\text{Cov} \times V = \lambda \times V</script><p>其中，($\lambda$) 是特征值组成的对角矩阵，($V$) 是特征向量组成的矩阵。</p></li><li><p><strong>选择主成分：</strong></p><ul><li>特征值表示数据在特征向量方向上的方差，选择特征值较大的前 ($k$) 个特征向量作为主成分。</li></ul><script type="math/tex; mode=display">\text{Top-k U} = \text{first } k \text{ columns of } V</script></li></ol><ol><li><p><strong>构建投影矩阵：</strong></p><ul><li>将选择的主成分组成一个投影矩阵。</li></ul><script type="math/tex; mode=display">U_{reduce} = \begin{bmatrix} | & | & | \\ u^{(1)} & u^{(2)} & \ldots \\ | & | & | \end{bmatrix}</script><p>其中，$u^{(1)}$、$u^{(2)}$ 等是选择的主成分。对于一个 $n×n$维度的矩阵，上式中的$U$是一个具有与数据之间最小投射误差的方向向量构成的矩阵。如果我们希望将数据从$n$维降至$k$维，我们只需要从$U$中选取前$k$个向量，获得一个$n×k$维度的矩阵，我们用$U_{reduce}$表示</p></li><li><p><strong>降维：</strong></p><ul><li>将原始数据乘以投影矩阵，将数据映射到新的低维空间。</li></ul><script type="math/tex; mode=display">z^{(i)}=U^{T}_{reduce}\times x^{(i)}</script><p>其中$x$是$n×1$维的，因此结果为$k×1$维度。</p></li></ol><p>这样，通过选择最重要的主成分，PCA实现了在保留尽可能多的信息的同时降低数据的维度。这对于减少特征的冗余性和去除噪声，以及在某些情况下提高模型性能都是有益的。</p><p>在<code>Python</code>中，使用<code>U, S, V = scipy.linalg.svd(sigma)</code>，<code>sigma</code>就是协方差矩阵<code>Cov</code></p><p>$U$的列是$AA^T$的特征向量，称为左奇异向量。$S$是奇异值组成特征向量，$V$是右奇异向量矩阵$A^TA$的转置。你可以根据需要选择保留多少个主成分，例如，只取前$k$个奇异值对应的左右奇异向量，以实现降维。</p><hr><h3 id="选择主成分的数量"><a href="#选择主成分的数量" class="headerlink" title="选择主成分的数量"></a>选择主成分的数量</h3><p>主要成分分析(PCA)的优化目标是减少投射的平均均方误差：</p><script type="math/tex; mode=display">\dfrac {1}{m}\sum^{m}_{i=1}\left\| x^{\left( i\right) }\right\| ^{2}</script><p>我们希望在平均均方误差与训练集方差的比例尽可能小的情况下选择尽可能小的$k$值。</p><p>如果我们希望这个比例小于1%，就意味着原本数据的偏差有99%都保留下来了，如果我们选择保留95%的偏差，便能非常显著地降低模型中特征的维度了。</p><p>可以通过特征矩阵来选择K，在<code>python</code>调用<code>U, S, V = np.linalg.svd(sigma)</code>中得到了S这个特征值数组，我们可以使用这个数组来计算平均均方误差与训练集方差的比例：</p><script type="math/tex; mode=display">\dfrac {\dfrac {1}{m}\sum^{m}_{i=1}\left\| x^{\left( i\right) }-x^{\left( i\right) }_{approx}\right\| ^{2}}{\dfrac {1}{m}\sum^{m}_{i=1}\left\| x^{(i)}\right\| ^{2}}=1-\dfrac {\Sigma^{k}_{i=1}S_{i}}{\Sigma^{m}_{i=1}S_{i}}\leq 1\%</script><p>$i$慢慢减小，刚好满足条件的$i$，就是选择的$k$值</p><hr><h3 id="应用建议"><a href="#应用建议" class="headerlink" title="应用建议"></a>应用建议</h3><p>一个常见<strong>错误</strong>使用主要成分分析的情况是，将其用于<strong>减少过拟合</strong>（减少了特征的数量）。这样做非常不好，不如尝试<strong>正则化处理</strong>。原因在于主要成分分析只是近似地丢弃掉一些特征，它并不考虑任何与结果变量有关的信息，因此可能会丢失非常重要的特征。然而当我们进行正则化处理时，会考虑到结果变量，不会丢掉重要的数据。</p><p>另一个常见的错误是，默认地将主要成分分析作为学习过程中的一部分，这虽然很多时候有效果，最好还是<strong>从所有原始特征</strong>开始，只在有必要的时候（算法运行太慢或者占用太多内存）才考虑采用主要成分分析。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10.5 ex6：SVM</title>
      <link href="/post/1111.html"/>
      <url>/post/1111.html</url>
      
        <content type="html"><![CDATA[<h1 id="ex6：SVM"><a href="#ex6：SVM" class="headerlink" title="ex6：SVM"></a>ex6：SVM</h1><h2 id="前半"><a href="#前半" class="headerlink" title="前半"></a>前半</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在这个练习的前半部分，您将使用支持向量机（SVM）处理各种示例的2D数据集。通过对这些数据集进行实验，您将更好地理解支持向量机的工作原理以及如何在支持向量机中使用高斯核。在练习的后半部分，您将使用支持向量机构建一个垃圾邮件分类器。</p><p>前半部分文件：</p><ul><li><strong><code>ex6.py</code></strong> - 这是Octave/MATLAB脚本，用于处理练习的前半部分。</li><li><strong><code>ex6data1.mat</code></strong> - 示例数据集1。</li><li><strong><code>ex6data2.mat</code></strong> - 示例数据集2。</li><li><strong><code>ex6data3.mat</code></strong> - 示例数据集3。</li><li><strong><code>svmTrain.py</code></strong> - SVM训练函数。</li><li><strong><code>svmPredict.py</code></strong> - SVM预测函数。</li><li><strong><code>visualizeBoundaryLinear.py</code></strong> - 绘制线性边界的函数。</li><li><strong><code>visualizeBoundary.py</code></strong> - 绘制非线性边界的函数。</li><li><strong><code>linearKernel.py</code></strong> - SVM的线性核函数。</li></ul><p>需要自己补充的文件：</p><ul><li><strong><code>gaussianKernel.py</code></strong> - SVM的高斯核函数</li><li><p><strong><code>dataset3Params.py</code></strong> - 用于数据集3的参数</p></li><li><p><strong><code>plotData.py</code></strong> - 绘制2D数据的函数。</p></li></ul><hr><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> scipy.io <span class="keyword">as</span> scio</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"><span class="keyword">import</span> plotData <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> visualizeBoundary <span class="keyword">as</span> vb</span><br><span class="line"><span class="keyword">import</span> gaussianKernel <span class="keyword">as</span> gk</span><br></pre></td></tr></table></figure><p><code>from sklearn import svm</code> 表示从 scikit-learn 库中导入支持向量机（SVM）相关的模块或类</p><hr><h3 id="加载并绘图"><a href="#加载并绘图" class="headerlink" title="加载并绘图"></a>加载并绘图</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================== Part 1: Loading and Visualizing Data =====================</span></span><br><span class="line"><span class="comment"># 通过首先加载和可视化数据集来开始练习。</span></span><br><span class="line"><span class="comment"># 下面的代码将把数据集加载到你的环境中并绘制数据。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Loading and Visualizing data ... &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从ex6data1加载数据：</span></span><br><span class="line">data = scio.loadmat(<span class="string">&#x27;ex6data1.mat&#x27;</span>)</span><br><span class="line">X = data[<span class="string">&#x27;X&#x27;</span>]</span><br><span class="line">y = data[<span class="string">&#x27;y&#x27;</span>].flatten()</span><br><span class="line">m = y.size</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制训练数据</span></span><br><span class="line">pd.plot_data(X, y)</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;Program paused. Press ENTER to continue&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这里需要写绘图文件<code>plotData.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_data</span>(<span class="params">X, y</span>):</span></span><br><span class="line">    plt.figure()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Plot the positive and negative examples</span></span><br><span class="line">    positive_indices = (y == <span class="number">1</span>)</span><br><span class="line">    negative_indices = (y == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    plt.scatter(X[positive_indices][:, <span class="number">0</span>], X[positive_indices][:, <span class="number">1</span>], marker=<span class="string">&#x27;+&#x27;</span>, c=<span class="string">&#x27;b&#x27;</span>, label=<span class="string">&#x27;Positive&#x27;</span>)</span><br><span class="line">    plt.scatter(X[negative_indices][:, <span class="number">0</span>], X[negative_indices][:, <span class="number">1</span>], marker=<span class="string">&#x27;o&#x27;</span>, c=<span class="string">&#x27;r&#x27;</span>, label=<span class="string">&#x27;Negative&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set labels and title</span></span><br><span class="line">    plt.xlabel(<span class="string">&#x27;Feature 1&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;Feature 2&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;Scatter plot of training data&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Display legend</span></span><br><span class="line">    plt.legend()</span><br></pre></td></tr></table></figure><p><code>positive_indices</code> 和 <code>negative_indices</code> 是通过布尔条件来筛选出正例和负例的索引。在这里，<code>y</code> 是包含标签的数组，通常是 0 或 1。</p><ul><li><code>positive_indices</code> 是一个布尔数组，其中对应于 <code>y</code> 中值为 1 的位置为 <code>True</code>，其余位置为 <code>False</code>。</li><li><code>negative_indices</code> 是一个布尔数组，其中对应于 <code>y</code> 中值为 0 的位置为 <code>True</code>，其余位置为 <code>False</code>。</li></ul><p>这两个数组可以用来从特征数组 <code>X</code> 中提取正例和负例的数据点。例如，<code>X[positive_indices]</code> 将给出所有正例对应的特征数据，而 <code>X[negative_indices]</code> 将给出所有负例对应的特征数据。</p><p>画出的图：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231124194309275.png" alt="image-20231124194309275" style="zoom:67%;" /></p><hr><h3 id="训练SVM"><a href="#训练SVM" class="headerlink" title="训练SVM"></a>训练SVM</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================== Part 2: Training Linear SVM =====================</span></span><br><span class="line"><span class="comment"># 下面的代码将在数据集上训练一个线性SVM，并绘制学到的决策边界。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Training Linear SVM&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 你应该尝试改变下面的C值，看看决策边界如何变化（例如，尝试C = 1000）</span></span><br><span class="line"></span><br><span class="line">c = <span class="number">1000</span></span><br><span class="line">clf = svm.SVC(C=c, kernel=<span class="string">&#x27;linear&#x27;</span>, tol=<span class="number">1e-3</span>)</span><br><span class="line">clf.fit(X, y)</span><br><span class="line"></span><br><span class="line">pd.plot_data(X, y)</span><br><span class="line">vb.visualize_boundary(clf, X, <span class="number">0</span>, <span class="number">4.5</span>, <span class="number">1.5</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;Program paused. Press ENTER to continue&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>clf=svm.SVC(C=c, kernel=&#39;linear&#39;, tol=1e-3)</code>参数的意义是：</p><ul><li><p><strong>C：float，默认=1.0</strong>，惩罚项的倒数。较小的 <code>C</code> 会导致更宽松的决策边界，而较大的 <code>C</code> 会导致更严格的决策边界。在训练过程中，<code>C</code> 控制错误分类的惩罚，即对错误分类的惩罚越大，模型越倾向于尽量正确分类每个样本。这里设置为1000</p></li><li><p><strong>kernel：string，默认=’rbf’</strong>，这里设置为线性核</p><p>核函数的类型。常用的核函数有：</p><ul><li><code>&#39;linear&#39;</code>：线性核</li><li><code>&#39;poly&#39;</code>：多项式核</li><li><code>&#39;rbf&#39;</code>（默认）：径向基函数（高斯核）</li><li><code>&#39;sigmoid&#39;</code>：Sigmoid核</li></ul></li><li><p><strong>tol：float，默认=1e-3</strong>，容忍停止标准。训练迭代过程中的收敛容忍度。</p></li><li><p><strong>clf</strong>：训练后的支持向量分类器。这个对象可以用于对新样本进行分类</p></li></ul><p><code>clf.fit(X, y)</code> 是支持向量机（SVM）分类器中用于训练模型的方法。在这个方法调用之后，模型会根据提供的训练数据 <code>X</code> 和对应的标签 <code>y</code> 进行学习，以找到一个最佳的决策边界（或超平面），以区分不同类别的样本。</p><p>例如，在线性核函数的情况下，<code>clf.fit(X, y)</code> 将学习一个线性决策边界，使得在特征空间中不同类别的样本被尽可能正确地划分。学习过程中，模型会根据训练数据调整参数，其中最重要的参数之一是 <code>C</code>，它控制了错误分类的惩罚。</p><p>训练完成后，模型就可以用于对新的未见过的样本进行分类，通过调用 <code>clf.predict(new_data)</code> 方法，其中 <code>new_data</code> 是新样本的特征</p><p><code>visualize_boundary</code>函数是已经给出的，只需要直接调用</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231124194427328.png" alt="image-20231124194427328" style="zoom: 80%;" /></p><hr><h3 id="高斯核函数"><a href="#高斯核函数" class="headerlink" title="高斯核函数"></a>高斯核函数</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================== Part 3: Implementing Gaussian Kernel =====================</span></span><br><span class="line"><span class="comment"># 现在你将实现高斯核函数以用于SVM。你现在应该完成gaussianKernel.py中的代码。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Evaluating the Gaussian Kernel&#x27;</span>)</span><br><span class="line"></span><br><span class="line">x1 = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line">x2 = np.array([<span class="number">0</span>, <span class="number">4</span>, -<span class="number">1</span>])</span><br><span class="line">sigma = <span class="number">2</span></span><br><span class="line">sim = gk.gaussian_kernel(x1, x2, sigma)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Gaussian kernel between x1 = [1, 2, 1], x2 = [0, 4, -1], sigma = &#123;&#125; : &#123;:0.6f&#125;\n&#x27;</span></span><br><span class="line">      <span class="string">&#x27;(for sigma = 2, this value should be about 0.324652&#x27;</span>.<span class="built_in">format</span>(sigma, sim))</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;Program paused. Press ENTER to continue&#x27;</span>)</span><br></pre></td></tr></table></figure><p>编写高斯核函数，完成<code>gaussianKernel.py</code></p><script type="math/tex; mode=display">K(x, y) = \exp\left(-\frac{\|x-y\|^2}{2\sigma^2}\right)</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gaussian_kernel</span>(<span class="params">x1, x2, sigma</span>):</span></span><br><span class="line">    x1 = x1.flatten()</span><br><span class="line">    x2 = x2.flatten()</span><br><span class="line"></span><br><span class="line">    sim = <span class="number">0</span></span><br><span class="line">    x=-np.<span class="built_in">sum</span>(np.power((x1-x2),<span class="number">2</span>))/(<span class="number">2</span>*np.power(sigma,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    sim=np.exp(x)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ==========================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sim</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="加载新数据并绘图"><a href="#加载新数据并绘图" class="headerlink" title="加载新数据并绘图"></a>加载新数据并绘图</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================== Part 4: Visualizing Dataset 2 =====================</span></span><br><span class="line"><span class="comment"># 下面的代码将加载下一个数据集到你的环境中，并绘制数据</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Loading and Visualizing Data ...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从ex6data1加载数据：</span></span><br><span class="line">data = scio.loadmat(<span class="string">&#x27;ex6data2.mat&#x27;</span>)</span><br><span class="line">X = data[<span class="string">&#x27;X&#x27;</span>]</span><br><span class="line">y = data[<span class="string">&#x27;y&#x27;</span>].flatten()</span><br><span class="line">m = y.size</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制训练数据</span></span><br><span class="line">pd.plot_data(X, y)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;Program paused. Press ENTER to continue&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231124200116446.png" alt="image-20231124200116446" style="zoom:67%;" /></p><hr><h3 id="训练SVM-RBF"><a href="#训练SVM-RBF" class="headerlink" title="训练SVM(RBF)"></a>训练SVM(RBF)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================== Part 5: Training SVM with RBF Kernel (Dataset 2) =====================</span></span><br><span class="line"><span class="comment"># 在你实现了核函数之后，我们现在可以使用它来训练SVM分类器</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Training SVM with RBF (Gaussian) Kernel (this may take 1 to 2 minutes) ...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">c = <span class="number">1</span></span><br><span class="line">sigma = <span class="number">0.1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gaussian_kernel</span>(<span class="params">x_1, x_2</span>):</span></span><br><span class="line">    n1 = x_1.shape[<span class="number">0</span>]</span><br><span class="line">    n2 = x_2.shape[<span class="number">0</span>]</span><br><span class="line">    result = np.zeros((n1, n2))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n1):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n2):</span><br><span class="line">            result[i, j] = gk.gaussian_kernel(x_1[i], x_2[j], sigma)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">clf = svm.SVC(C=c, kernel=gaussian_kernel)</span><br><span class="line"><span class="comment">#clf = svm.SVC(C=c, kernel=&#x27;rbf&#x27;, gamma=np.power(sigma, -2))</span></span><br><span class="line">clf.fit(X, y)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Training complete!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pd.plot_data(X, y)</span><br><span class="line">vb.visualize_boundary(clf, X, <span class="number">0</span>, <span class="number">1</span>, <span class="number">.4</span>, <span class="number">1.0</span>)</span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;Program paused. Press ENTER to continue&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这里是根据高斯核函数的定义，直接手写了一个高斯核函数出来，也可以直接用<code>clf = svm.SVC(C=c, kernel=&#39;rbf&#39;, gamma=np.power(sigma, -2))</code>调用高斯核函数</p><p>决策边界如下：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231124200752177.png" alt="image-20231124200752177" style="zoom:67%;" /></p><hr><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>最后加载一个新的数据集，测试一下高斯核函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================== Part 6: Visualizing Dataset 3 =====================</span></span><br><span class="line"><span class="comment"># 下面的代码将加载下一个数据集到你的环境中，并绘制数据</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Loading and Visualizing Data ...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从ex6data3加载数据：</span></span><br><span class="line">data = scio.loadmat(<span class="string">&#x27;ex6data3.mat&#x27;</span>)</span><br><span class="line">X = data[<span class="string">&#x27;X&#x27;</span>]</span><br><span class="line">y = data[<span class="string">&#x27;y&#x27;</span>].flatten()</span><br><span class="line">m = y.size</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制训练数据</span></span><br><span class="line">pd.plot_data(X, y)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;Program paused. Press ENTER to continue&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ===================== Part 7: Visualizing Dataset 3 =====================</span></span><br><span class="line"></span><br><span class="line">clf = svm.SVC(C=c, kernel=<span class="string">&#x27;rbf&#x27;</span>, gamma=np.power(sigma, -<span class="number">2</span>))</span><br><span class="line">clf.fit(X, y)</span><br><span class="line"></span><br><span class="line">pd.plot_data(X, y)</span><br><span class="line">vb.visualize_boundary(clf, X, -<span class="number">.5</span>, <span class="number">.3</span>, -<span class="number">.8</span>, <span class="number">.6</span>)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;ex6 Finished. Press ENTER to exit&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231124201101203.png" alt="image-20231124201101203" style="zoom:80%;" /></p><hr><h2 id="后半"><a href="#后半" class="headerlink" title="后半"></a>后半</h2><p>后半部分文件：</p><ul><li><code>ex6 spam.py</code> - Python脚本，用于练习的后半部分 </li><li><code>spamTrain.mat</code> - 垃圾邮件训练集 </li><li><code>spamTest.mat</code> - 垃圾邮件测试集 </li><li><code>emailSample1.txt</code> - 样本电子邮件1 </li><li><code>emailSample2.txt</code> - 样本电子邮件2 </li><li><code>spamSample1.txt</code> - 样本垃圾邮件1 </li><li><code>spamSample2.txt</code> - 样本垃圾邮件2 </li><li><code>vocab.txt</code> - 词汇表 </li><li><code>getVocabList.py</code> - 载入词汇表 </li><li><code>porterStemmer.py</code> - 词干提取函数 </li><li><code>readFile.py</code> - 将文件读入字符字符串 </li></ul><p>需要补充的文件：</p><ul><li><p><code>processEmail.py</code> - 电子邮件预处理</p></li><li><p><code>emailFeatures.py</code> - 从电子邮件中提取特征</p></li></ul><hr><h3 id="导入-1"><a href="#导入-1" class="headerlink" title="导入"></a>导入</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> scipy.io <span class="keyword">as</span> scio</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> processEmail <span class="keyword">as</span> pe</span><br><span class="line"><span class="keyword">import</span> emailFeatures <span class="keyword">as</span> ef</span><br></pre></td></tr></table></figure><hr><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================== 第 1 部分：电子邮件预处理 =====================</span></span><br><span class="line"><span class="comment"># 为了使用SVM将电子邮件分类为垃圾邮件和非垃圾邮件，您首先需要将每封电子邮件转换为特征向量。</span></span><br><span class="line"><span class="comment"># 在这一部分，您将实现每封电子邮件的预处理步骤。</span></span><br><span class="line"><span class="comment"># 您应该完成processEmail.py中的代码，以生成给定电子邮件的单词索引向量。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;正在预处理示例电子邮件（emailSample1.txt）...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">file_contents = <span class="built_in">open</span>(<span class="string">&#x27;emailSample1.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>).read()</span><br><span class="line">word_indices = pe.process_email(file_contents)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印统计信息</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;单词索引：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(word_indices)</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;程序暂停。按回车键继续&#x27;</span>)</span><br></pre></td></tr></table></figure><p>完成<code>processEmail.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> nltk</span><br><span class="line"><span class="keyword">import</span> nltk.stem.porter</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_email</span>(<span class="params">email_contents</span>):</span></span><br><span class="line">    vocab_list = get_vocab_list()</span><br><span class="line"></span><br><span class="line">    word_indices = np.array([], dtype=np.int64)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ===================== 预处理电子邮件 =====================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将整个电子邮件内容转换为小写</span></span><br><span class="line">    email_contents = email_contents.lower()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 移除HTML标签</span></span><br><span class="line">    email_contents = re.sub(<span class="string">&#x27;&lt;[^&lt;&gt;]+&gt;&#x27;</span>, <span class="string">&#x27; &#x27;</span>, email_contents)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将所有数字替换为字符串&#x27;number&#x27;</span></span><br><span class="line">    email_contents = re.sub(<span class="string">&#x27;[0-9]+&#x27;</span>, <span class="string">&#x27;number&#x27;</span>, email_contents)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将所有以http或https://开头的字符串替换为&#x27;httpaddr&#x27;</span></span><br><span class="line">    email_contents = re.sub(<span class="string">&#x27;(http|https)://[^\s]*&#x27;</span>, <span class="string">&#x27;httpaddr&#x27;</span>, email_contents)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 含有&#x27;@&#x27;的字符串被视为电子邮件 --&gt; &#x27;emailaddr&#x27;</span></span><br><span class="line">    email_contents = re.sub(<span class="string">&#x27;[^\s]+@[^\s]+&#x27;</span>, <span class="string">&#x27;emailaddr&#x27;</span>, email_contents)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将&#x27;$&#x27;符号替换为&#x27;dollar&#x27;</span></span><br><span class="line">    email_contents = re.sub(<span class="string">&#x27;[$]+&#x27;</span>, <span class="string">&#x27;dollar&#x27;</span>, email_contents)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ===================== 分词电子邮件 =====================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出处理后的电子邮件</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;==== 处理后的电子邮件 ====&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用NLTK库的词干提取器</span></span><br><span class="line">    stemmer = nltk.stem.porter.PorterStemmer()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用正则表达式分割电子邮件文本</span></span><br><span class="line">    tokens = re.split(<span class="string">&#x27;[@$/#.-:&amp;*+=\[\]?!()&#123;\&#125;,\&#x27;\&quot;&gt;_&lt;;% ]&#x27;</span>, email_contents)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> token <span class="keyword">in</span> tokens:</span><br><span class="line">        <span class="comment"># 移除非字母数字字符</span></span><br><span class="line">        token = re.sub(<span class="string">&#x27;[^a-zA-Z0-9]&#x27;</span>, <span class="string">&#x27;&#x27;</span>, token)</span><br><span class="line">        <span class="comment"># 对单词进行词干提取</span></span><br><span class="line">        token = stemmer.stem(token)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(token) &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># ===================== 你的代码在这里 =====================</span></span><br><span class="line">        <span class="comment"># 说明：填写此函数以将单词的索引添加到word_indices数组中，</span></span><br><span class="line">        <span class="comment">#      如果它在词汇表中存在。在此代码点，你已经获得了</span></span><br><span class="line">        <span class="comment">#      来自电子邮件的词干单词，保存在变量token中。</span></span><br><span class="line">        <span class="comment">#      你应该在vocab_list中查找token。如果匹配存在，</span></span><br><span class="line">        <span class="comment">#      你应该将该单词的索引添加到word_indices数组中。</span></span><br><span class="line">        <span class="comment">#      具体而言，如果token == &#x27;action&#x27;，那么你应该在vocab_list中查找</span></span><br><span class="line">        <span class="comment">#      &#x27;action&#x27;的位置。例如，如果vocab_list[18] == &#x27;action&#x27;，</span></span><br><span class="line">        <span class="comment">#      那么你应该将18添加到word_indices数组中。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># ==========================================================</span></span><br><span class="line">        <span class="keyword">if</span> token <span class="keyword">in</span> vocab_list.values():</span><br><span class="line">            <span class="comment"># 通过迭代查找单词的位置</span></span><br><span class="line">            <span class="keyword">for</span> key, value <span class="keyword">in</span> vocab_list.items():</span><br><span class="line">                <span class="keyword">if</span> value == token:</span><br><span class="line">                    index = key</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 将位置添加到word_indices数组中</span></span><br><span class="line">            word_indices = np.append(word_indices, index)</span><br><span class="line">        <span class="built_in">print</span>(token)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;==================&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> word_indices</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_vocab_list</span>():</span></span><br><span class="line">    vocab_dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;vocab.txt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            (val, key) = line.split()</span><br><span class="line">            vocab_dict[<span class="built_in">int</span>(val)] = key</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> vocab_dict</span><br></pre></td></tr></table></figure><p>这里的<code>vocab_list</code>会返回一个字典，先利用字典的<code>values</code>方法判断<code>token</code>是否在字典里面，如果在，就遍历字典，找到对应的<code>key</code>，然后记录下<code>key</code>，保存为<code>Index</code>，用<code>append</code>方法添加新<code>word_indices</code>数组里面去</p><hr><h3 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================== 第 2 部分：特征提取 =====================</span></span><br><span class="line"><span class="comment"># 现在，您将把每封电子邮件转换为R^n中的特征向量。</span></span><br><span class="line"><span class="comment"># 您应该完成emailFeatures.py中的代码，以生成给定邮件的特征向量。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;从示例电子邮件（emailSample1.txt）中提取特征...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取特征</span></span><br><span class="line">features = ef.email_features(word_indices)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印统计信息</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;特征向量的长度：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(features.size))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;非零条目的数量：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(np.flatnonzero(features).size))</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;程序暂停。按回车键继续&#x27;</span>)</span><br></pre></td></tr></table></figure><p>编写<code>emailFeatures.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">email_features</span>(<span class="params">word_indices</span>):</span></span><br><span class="line">    <span class="comment"># 词典中的总单词数</span></span><br><span class="line">    n = <span class="number">1899</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 你需要正确返回以下变量。</span></span><br><span class="line">    <span class="comment"># 由于numpy数组的索引从0开始，为了与单词索引对齐，我们创建大小为n + 1的数组</span></span><br><span class="line">    features = np.zeros(n + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ===================== 你的代码在这里 =====================</span></span><br><span class="line">    <span class="comment"># 说明：填写此函数以返回给定电子邮件（word_indices）的特征向量。</span></span><br><span class="line">    <span class="comment">#      为了更容易处理电子邮件，我们已经对每封电子邮件进行了预处理，</span></span><br><span class="line">    <span class="comment">#      并将电子邮件中的每个单词转换为固定词典中的索引（共1899个单词）。</span></span><br><span class="line">    <span class="comment">#      变量word_indices包含发生在一封电子邮件中的单词的索引列表。</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#      具体而言，如果一封电子邮件的文本如下：</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#         The quick brown fox jumped over the lazy dog.</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#      那么，这个文本的word_indices向量可能如下所示：</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#         60  100   33  44  10      53  60  58  5</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#      在这里，我们已将每个单词映射到一个数字，例如：</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#         the     --  60</span></span><br><span class="line">    <span class="comment">#         quick   --  100</span></span><br><span class="line">    <span class="comment">#         ...</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#      你的任务是获取一个这样的word_indices向量并构建一个二进制特征向量，</span></span><br><span class="line">    <span class="comment">#      该向量指示一个特定的单词是否在电子邮件中出现。也就是说，当单词i</span></span><br><span class="line">    <span class="comment">#      出现在电子邮件中时，features[i] = 1。具体而言，如果单词&#x27;the&#x27;</span></span><br><span class="line">    <span class="comment">#      （假设索引为60）出现在电子邮件中，则features[60] = 1。该特征向量应该如下所示：</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#      features = [0, 0, 0, 0, 1, 0, 0, 0, ... 0, 0, 0, 1, ... 0, 0, 0, 1, 0]</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># 遍历word_indices，将features中对应的位置置为1</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> word_indices:</span><br><span class="line">        features[index] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ==========================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> features</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>遍历<code>word_indices</code>，遇到特征词，变为<code>1</code>即可</p><hr><h3 id="线性SVM"><a href="#线性SVM" class="headerlink" title="线性SVM"></a>线性SVM</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================== 第 3 部分：用于垃圾邮件分类的线性SVM训练 =====================</span></span><br><span class="line"><span class="comment"># 在这一部分，您将训练一个线性分类器，以确定一封电子邮件是否是垃圾邮件。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载垃圾邮件数据集</span></span><br><span class="line"><span class="comment"># 您将在您的环境中有X，y</span></span><br><span class="line">data = scio.loadmat(<span class="string">&#x27;spamTrain.mat&#x27;</span>)</span><br><span class="line">X = data[<span class="string">&#x27;X&#x27;</span>]</span><br><span class="line">y = data[<span class="string">&#x27;y&#x27;</span>].flatten()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;训练线性SVM（垃圾邮件分类）&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;（可能需要1到2分钟）&#x27;</span>)</span><br><span class="line"></span><br><span class="line">c = <span class="number">0.1</span></span><br><span class="line">clf = svm.SVC(C=c, kernel=<span class="string">&#x27;linear&#x27;</span>)</span><br><span class="line">clf.fit(X, y)</span><br><span class="line"></span><br><span class="line">p = clf.predict(X)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;训练准确率：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(np.mean(p == y) * <span class="number">100</span>))</span><br></pre></td></tr></table></figure><p>用线性SVM进行分类</p><hr><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================== 第 4 部分：测试垃圾邮件分类 =====================</span></span><br><span class="line"><span class="comment"># 在训练分类器之后，我们可以在测试集上进行评估。</span></span><br><span class="line"><span class="comment"># 我们在spamTest.mat中包含了一个测试集</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载测试数据集</span></span><br><span class="line">data = scio.loadmat(<span class="string">&#x27;spamTest.mat&#x27;</span>)</span><br><span class="line">Xtest = data[<span class="string">&#x27;Xtest&#x27;</span>]</span><br><span class="line">ytest = data[<span class="string">&#x27;ytest&#x27;</span>].flatten()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;在测试集上评估经过训练的线性SVM...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = clf.predict(Xtest)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;测试准确率：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(np.mean(p == ytest) * <span class="number">100</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;程序暂停。按回车键继续&#x27;</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="查看预测因子"><a href="#查看预测因子" class="headerlink" title="查看预测因子"></a>查看预测因子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================== 第 5 部分：垃圾邮件的前几个预测因子 =====================</span></span><br><span class="line"><span class="comment"># 由于我们训练的模型是一个线性SVM，我们可以检查模型学到的权重w，</span></span><br><span class="line"><span class="comment"># 以更好地了解它是如何确定一封电子邮件是否为垃圾邮件的。</span></span><br><span class="line"><span class="comment"># 以下代码找到分类器中权重最高的单词。非正式地说，分类器</span></span><br><span class="line"><span class="comment"># 认为这些单词最有可能是垃圾邮件的指标。</span></span><br><span class="line"></span><br><span class="line">vocab_list = pe.get_vocab_list()</span><br><span class="line">indices = np.argsort(clf.coef_).flatten()[::-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(indices)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">15</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125; (&#123;:0.6f&#125;)&#x27;</span>.<span class="built_in">format</span>(vocab_list[indices[i]], clf.coef_.flatten()[indices[i]]))</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;ex6_spam 完成。按回车键退出&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>ndices = np.argsort(clf.coef_).flatten()[::-1]</code></p><ul><li><code>clf.coef_</code>: 这是训练后模型的权重矩阵。对于线性 SVM，每个特征都有一个相关联的权重。</li><li><code>np.argsort(clf.coef_)</code>: 这一步是对权重进行排序，返回的是排序后的索引。在默认情况下，<code>argsort</code> 返回的是从小到大排列的索引。由于我们关心权重最高的单词，我们需要将索引按照权重的降序排列，因此我们使用 <code>[::-1]</code> 对数组进行逆序。</li><li><code>flatten()</code>: 这一步是将排序后的索引数组扁平化，将其变为一维数组。在这里，我们希望得到一个简单的一维数组，以便后续的处理。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10.0.支持向量机</title>
      <link href="/post/3076.html"/>
      <url>/post/3076.html</url>
      
        <content type="html"><![CDATA[<h1 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h1><h2 id="直觉理解"><a href="#直觉理解" class="headerlink" title="直觉理解"></a>直觉理解</h2><h3 id="硬间隔"><a href="#硬间隔" class="headerlink" title="硬间隔"></a>硬间隔</h3><p>具体而言，如果你考察这样一个数据集，其中有正样本，也有负样本，可以看到这个数据集是线性可分的。我的意思是，存在一条直线把正负样本分开。当然有多条不同的直线，可以把正样本和负样本完全分开。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231123195040322.png" alt="image-20231123195040322" style="zoom: 33%;" /></p><p>那么该如何选择哪一条直线来划分数据？</p><p>从直觉来说，应该在数据中间画一条直线，如下图所示：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231123195301005.png" alt="image-20231123195301005" style="zoom:67%;" /></p><p>在这种画法中，两类数据中所有的点，都与这条线保持了一定的距离，这个距离起到了缓冲区的作用，当这个距离足够大时，分类结果的可信度也就足够高了，把这个缓冲区称为：<strong>间隔</strong></p><p>间隔距离体现了两类数据的差异大小，间隔的正中，就是<strong>决策边界</strong>，寻找最佳决策边界线的问题可以转化为求解两类数据的最大间隔问题</p><p>而当有新数据需要判断时，根据新数据处于决策边界的相对位置，就可以进行分类</p><p><br/></p><p>假设决策边界的超平面公式为：</p><script type="math/tex; mode=display">w_1x_1+w_2x_2+b=0</script><p>然后我们平移决策边界，由于平移过程中一定会经过数据的点，而上下最先接触到的点决定了间隔距离，我们称之为<strong>支持向量</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231123200906685.png" alt="image-20231123200906685" style="zoom: 50%;" /></p><p>其上下边界的方程式为：</p><script type="math/tex; mode=display">w_1x_1+w_2x_2+b=c\\w_1x_1+w_2x_2+b=-c</script><p>等式两边同时除以c</p><script type="math/tex; mode=display">\frac{w_1}{c}x_1+\frac{w_2}{c}x_2+\frac{b}{c}=1\\\frac{w_1}{c}x_1+\frac{w_2}{c}x_2+\frac{b}{c}=-1</script><p>因为c是常数，实际上可以直接写成</p><script type="math/tex; mode=display">w_1x_1+w_2x_2+b=1\\w_1x_1+w_2x_2+b=0\\w_1x_1+w_2x_2+b=-1</script><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231123201545930.png" alt="image-20231123201545930" style="zoom: 50%;" /></p><p><br/></p><p>这种间隔称之为<strong>硬间隔</strong>，具体定义如下：</p><p>硬间隔（Hard Margin）是指在支持向量机（SVM）中，对于线性可分的数据集，找到一个能够完美分隔两个类别的决策边界，使得每个训练样本都正确分类，且离决策边界的距离（间隔）最大。硬间隔 SVM 被用于处理线性可分的情况。</p><p>硬间隔的目标是使得决策边界两侧的支持向量到决策边界的距离（间隔）最大化，以确保对于未见过的样本，有更大的容错空间，从而提高模型的泛化性能。这个最大间隔的决策边界通常位于支持向量之间，这也解释了为什么这个方法叫做“硬间隔”，因为它对于训练数据的分类是非常严格的。</p><p><br/></p><hr><h3 id="软间隔"><a href="#软间隔" class="headerlink" title="软间隔"></a>软间隔</h3><p>假如初始数据发生了如下变化：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231123204118475.png" alt="image-20231123204118475" style="zoom: 50%;" /></p><p>那么按照硬间隔的划分方法，实际上会这个样子：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231123204328493.png" alt="image-20231123204328493" style="zoom:50%;" /></p><p>这显然不对，当有很多异常值的时候，硬间隔就会变得非常难找，所以需要引入损失函数<code>cost</code>的概念</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231123205223017.png" alt="image-20231123205223017" style="zoom:50%;" /></p><p>问题就转换为了，考虑损失的情况下，如何最大化间隔，而这种情况下的间隔，称为软间隔</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231123211025447.png" alt="image-20231123211025447" style="zoom: 50%;" /></p><p>具体定义如下：</p><p><strong>软间隔</strong>（Soft Margin）是指在支持向量机（SVM）中，对于一些非线性可分或受到噪声干扰的数据集，允许在寻找决策边界时有一些样本被误分类或距离决策边界的间隔不满足硬间隔的条件。软间隔 SVM 的目标是在最大化间隔的同时，允许一些样本违反间隔的要求，以提高模型的鲁棒性。</p><p>软间隔的主要思想是在寻找决策边界时，允许一些样本出现在决策边界的错误一侧或距离边界较近，以更好地适应现实中可能存在的噪声或异常点。这使得软间隔 SVM 在处理线性不可分的数据或受到噪声干扰的情况下更具有鲁棒性。</p><p><br/></p><hr><h2 id="优化目标"><a href="#优化目标" class="headerlink" title="优化目标"></a>优化目标</h2><h3 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h3><p>从逻辑回归开始，通过一点一点展示，得到软间隔中的代价函数$cost$</p><p>首先，逻辑回归的图像和$sigmoid$函数如下图所示：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231109212532866.png" alt="image-20231109212532866"></p><script type="math/tex; mode=display">h_\theta(x)=\frac{1}{1+e^{-\theta^Tx}}</script><p>$y=1$的情况下，我们希望预测值$h_\theta(x)\approx 1$，此时$\theta^Tx\gg0$</p><p>$y=0$的情况下，我们希望预测值$h_\theta(x)\approx 0$，此时$\theta^Tx\ll0$</p><p><br/></p><p>进一步观察逻辑回归的代价函数：</p><script type="math/tex; mode=display">Cost\left( {h_\theta}\left( x \right),y \right)=-ylog {\frac{1}{1+e^{-\theta^Tx}}}-(1-y)log\left( 1-\frac{1}{1+e^{-\theta^Tx}}\right)+\frac{\lambda}{2m}\sum_{j=1}^{n}\theta_j^2</script><p>$y=1$时，$log {\frac{1}{1+e^{-\theta^Tx}}}$图像如下：</p><div class="table-container"><table><thead><tr><th><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231123234246303.png" alt="image-20231123234246303" style="zoom: 80%;" /></th><th><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231123235229263.png" alt="image-20231123235229263" style="zoom: 67%;" /></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p><br/></p><p>可以观察到，当$\theta^Tx&gt;1$时，代价就已经很小了，在SVM中，我们把这条曲线近似为两条直线取$\theta^Tx=1$的点，将右边的所有值都看做是1</p><p>这里我们直接代入软间隔去直观的理解一下为什么要分成两段</p><p>当$\theta^Tx&gt;1$时，如图所示：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231124033036249.png" alt="image-20231124033036249" style="zoom: 50%;" /></p><p>此时数据相当于都在下面虚线以下，所以代价直接看做是0，对决策边界根本没有影响</p><p><br/></p><p>当$\theta^Tx&lt;1$时，说明数据点突破了决策边界，在不断的远离负超平面，所以代价越来越大</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231124033251675.png" alt="image-20231124033251675" style="zoom:50%;" /></p><p>$y=0$时，代价函数$cost$图像如下：</p><div class="table-container"><table><thead><tr><th><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231124012410475.png" alt="image-20231124012410475"></th><th><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231124012454189.png" alt="image-20231124012454189" style="zoom: 80%;" /></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>可以观察到，当$\theta^Tx&lt;-1$时，代价就已经很小了，在SVM中，我们把这条曲线近似为两条直线，取$\theta^Tx=-1$的点，将左边的所有值都看做是-1</p><p><br/></p><p>联系之前提到的软间隔，显然当$\theta^Tx&lt;-1$或者$\theta^Tx&gt;1$的时候，数据点离决策边界较远，对决策边界的影响较弱，通过这样的设计，SVM 在优化过程中<strong>更加关注</strong>对那些<strong>接近决策边界</strong>的支持向量，即那些对于分类决策起到<strong>关键作用</strong>的样本。</p><p>这也是为什么在代价函数中使用两段线段的原因，以强调对于分类决策边界附近的支持向量的敏感性。这有助于建立一个在最大化分类间隔的同时，对分类错误的<strong>敏感度</strong>更强的分类器。</p><p><br/></p><hr><p>接下来简化代价函数：</p><script type="math/tex; mode=display">Cost\left( {h_\theta}\left( x \right),y \right)=-\frac{1}{m}\sum_{i=1}^{m}-ylog {\frac{1}{1+e^{-\theta^Tx}}}-(1-y)log\left( 1-\frac{1}{1+e^{-\theta^Tx}}\right)+\frac{\lambda}{2m}\sum_{j=1}^{n}\theta_j^2</script><p>用$cost$替换掉刚才的曲线，除去$1/m$这一项，当然，这仅仅是由于人们使用支持向量机时，对比于逻辑回归而言，<strong>不同的习惯</strong>所致，正则化系数也能简化，只保留$\frac{1}{2}$，去掉$m$和$\lambda$</p><p>在支持向量机（SVM）中，使用参数 <em>C</em> 来代替逻辑回归中正则化参数$\lambda$类似的作用。它控制了在训练数据的拟合与模型正则化项之间的权衡。</p><p>简化后公式如下：</p><script type="math/tex; mode=display">Cost\left( {h_\theta}\left( x \right),y \right)=C\sum\limits_{i=1}^{m}{[y^{(i)}cost_1(\theta^Tx^{(i)}) +\left( 1-{y^{(i)}} \right)cost_0(\theta^Tx^{(i)})]}+\frac{1}{2}\sum_{j=1}^{n}\theta_j^2</script><p>C的作用和$\lambda$的正好相反，C越大，即代表的是$\lambda$越小，更容易过拟合，而C越小，说明容易欠拟合</p><p><br/></p><hr><h2 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h2><p>SVM最广泛的应用的分类问题，而某些数据在低维度下很难进行分类，遇到这种情况时，需要考虑对数据进行升维，从而使数据易于分类</p><div class="table-container"><table><thead><tr><th><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231124033922069.png" alt="image-20231124033922069" style="zoom:50%;" /></th><th><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231124033958950.png" alt="image-20231124033958950" style="zoom:50%;" /></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>但是数据升维转换需要明确的维度转换函数，以及更多的存储要求，会大大增加程序的负担，为了避免将数据升维，可以直接使用核函数进行运算</p><p><br/></p><p><strong>核函数</strong>（Kernel Function）是支持向量机（SVM）中的一个关键概念。在 SVM 中，核函数用于将输入特征<strong>映射</strong>到高维空间，从而使得原始特征空间中的非线性问题能够在高维空间中变得线性可分。</p><p>核函数的主要作用是通过计算两个样本在高维空间中的相似性（内积）来替代在原始特征空间中的显式计算。这使得我们可以在高维空间中进行计算，而无需显式地知道或计算高维空间中的特征向量。核函数在 SVM 中的使用使得模型更加灵活，可以处理非线性的决策边界</p><p>常见的核函数有：</p><ol><li><strong>线性核函数（Linear Kernel）：</strong> $K(x, y) = x^Ty$，对应于原始特征空间。</li><li><strong>多项式核函数（Polynomial Kernel）：</strong> $K(x, y) = (x^Ty + c)^d$，引入了多项式的高阶项。</li><li><strong>高斯径向基函数核（Gaussian Radial Basis Function Kernel，RBF）：</strong> $(K(x, y) = \exp\left(-\frac{|x-y|^2}{2\sigma^2}\right))$，引入了高斯分布的概念。</li><li><strong>Sigmoid核函数（Sigmoid Kernel）：</strong> $K(x, y) = \tanh(\alpha x^Ty + c)$，模拟神经网络的激活函数。</li></ol><p>核函数的选择通常取决于数据的性质和问题的要求。正确选择核函数可以显著提高 SVM 模型的性能。</p><p><br/></p><p>这里介绍一下<strong>高斯核函数</strong>：</p><p>高斯径向基函数核（Gaussian Radial Basis Function Kernel，RBF Kernel）是支持向量机中常用的核函数之一。它的表达式如下：</p><script type="math/tex; mode=display">K(x, y) = \exp\left(-\frac{\|x-y\|^2}{2\sigma^2}\right)</script><p>其中：</p><ul><li>$( K(x, y) )$ 是样本 ( $x$ ) 和 ( $y$ ) 之间的内积，表示它们在高维空间中的相似性。</li><li>$( |x-y| )$ 表示样本 ( $x$ ) 和 ( $y$ ) 之间的欧几里德距离。</li><li>$(\sigma)$ 是控制高斯分布宽度的参数。</li></ul><p>高斯径向基函数核的主要思想是将样本映射到一个无穷维的高维空间，并通过高斯分布来衡量它们之间的相似性。在这个高维空间中，样本之间的内积可以被计算，而不需要显式计算高维空间中的特征向量。这使得 SVM 在处理非线性问题时更为灵活。</p><p>关键点解释：</p><ol><li><strong>相似性度量：</strong> 如果两个样本 ( x ) 和 ( y ) 在原始特征空间中相似，它们在高维空间中的内积将更接近1，表现为高斯核函数的值更接近1，反之亦然。</li><li><strong>参数 ( $\sigma$ )：</strong> 参数 ( $\sigma$ ) 控制了高斯分布的宽度。较小的 ( $\sigma$ ) 使得高斯分布更加尖锐，更强调相邻样本之间的相似性；较大的 ( $\sigma$ ) 使得高斯分布更加平滑，更强调整体样本之间的相似性。</li><li><strong>非线性决策边界：</strong> 高斯径向基函数核允许 SVM 学习复杂的非线性决策边界，因为它可以通过内积的方式在高维空间中捕捉非线性关系。</li></ol><p><br/></p><hr><p>接下来将说明如何具体的使用核函数来输入特征<strong>映射</strong>到高维空间中去</p><p>回顾我们之前讨论过可以使用高级数的多项式模型来解决无法用直线进行分隔的分类问题：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231124034655472.png" alt="image-20231124034655472"></p><p>为了获得上图所示的判定边界，我们的模型可能是$(\theta_0 + \theta_1 x_1 + \theta_2 x_2 + \theta_3 x_1 x_2 + \theta_4 x_1^2 + \theta_5 x_2^2 + \ldots) $的形式。</p><p>我们可以用一系列的新的特征$f$来替换模型中的每一项。例如令：<br>$\ f_1 = x_1, f_2 = x_2, f_3 = x_1 x_2, f_4 = x_1^2,f_5 = x_2^2, \ldots $得到$h_θ(x)={\theta _{1}}f_1+{\theta _2}f_2+…+{\theta_n}f_n$。</p><p><br/></p><p>然而，除了对原有的特征进行组合以外，有的方法来构造$f_1,f_2,f_3$，我们可以利用<strong>核函数</strong>来计算出新的特征。</p><p>给定一个训练样本$x$，我们利用$x$的各个特征与我们预先选定的<strong>地标</strong>(<strong>landmarks</strong>)$l^{(1)},l^{(2)},l^{(3)}$的近似程度来选取新的特征$f_1,f_2,f_3$。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231124034708629.png" alt="image-20231124034708629"></p><p>这里的地标通常指的是一组特定的点，这些点被选择用于<strong>构建新的特征</strong>，从而将数据映射到更高维度的空间。这个过程有时称为<strong>特征映射</strong>。</p><p>具体来说，在使用核函数的情况下，我们选择一组地标，通常是从训练集中选择的数据点，作为新特征的基础。对于每个训练样本，我们计算它与地标之间的<strong>相似性</strong>，然后利用这些相似性值构建新的特征。这样，原始的特征空间被映射到一个更高维度的空间，使得在高维空间中的数据更容易被线性分离。</p><p><br/></p><p>例如：$ f_1 = \text{similarity}(x,l^{(1)}) = e\left(-\frac{||x-l^{(1)}||^2}{2 \sigma^2}\right) $</p><p>其中：$ | x - l^{(1)} |^2 = \sum_{j=1}^n (x_j - l_j^{(1)})^2 $，为实例$x$中所有特征与地标$l^{(1)}$之间的距离的和。上例中的$similarity(x,l^{(1)})$就是核函数，具体而言，这里是一个<strong>高斯核函数</strong>(<strong>Gaussian Kernel</strong>)</p><p><br/></p><p>如果一个训练样本$x$与地标$l$之间的距离近似于0，则新特征 $f$近似于$e^{-0}=1$，如果训练样本$x$与地标$l$之间距离较远，则$f$近似于$e^{-(一个较大的数)}=0$。</p><p>在下图中，当样本处于洋红色的点位置处，因为其离$l^{(1)}$更近，但是离$l^{(2)}$和$l^{(3)}$较远，因此$f_1$接近1，而$f_2$,$f_3$接近0。因此$h_θ(x)=θ_0+θ_1f_1+θ_2f_2+θ_1f_3&gt;0$，因此预测$y=1$。同理可以求出，对于离$l^{(2)}$较近的绿色点，也预测$y=1$，但是对于蓝绿色的点，因为其离三个地标都较远，预测$y=0$。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231124035207734.png" alt="image-20231124035207734"></p><p>这样，图中红色的封闭曲线所表示的范围，便是我们依据一个单一的训练样本和我们选取的地标所得出的判定边界，在预测时，我们采用的特征不是训练样本本身的特征，而是通过核函数计算出的<strong>新特征</strong>$f_1,f_2,f_3$</p><p><br/></p><hr><p>那么该如何选取地标？</p><p>通常是根据训练集的数量选择地标的数量，即如果训练集中有$m$个样本，则我们选取$m$个地标，并且令:$l^{(1)}=x^{(1)},l^{(2)}=x^{(2)},…..,l^{(m)}=x^{(m)}$。这样做的好处在于：现在我们得到的新特征是建立在原有特征与训练集中所有其他特征之间距离的基础之上的，即：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231124035414470.png" alt="image-20231124035414470"></p><p>下面我们将核函数运用到支持向量机中，修改我们的支持向量机假设为：</p><ul><li>给定$x$，计算新特征$f$，当$θ^Tf&gt;=0$ 时，预测 $y=1$，否则反之。 </li></ul><p>相应地修改代价函数为：$\sum{_{j=1}^{n=m}}\theta _j^2=\theta^T\theta $，</p><script type="math/tex; mode=display">\text{cost} = \min  C\sum\limits_{i=1}^{m}{[y^{(i)}cost_1(\theta^Tf^{(i)}) +\left( 1-{y^{(i)}} \right)cost_0(\theta^Tf^{(i)})]}+\frac{1}{2}\sum_{j=1}^{n=m}\theta_j^2</script><p>在具体实施过程中，我们还需要对最后的正则化项进行些微调整，在计算$\sum{_{j=1}^{n=m}}\theta _j^2={\theta^T}\theta $时，我们用$θ^TMθ$代替$θ^Tθ$，其中$M$是根据我们选择的核函数而不同的一个矩阵。这样做的原因是为了简化计算。</p><p>理论上讲，我们也可以在逻辑回归中使用核函数，但是上面使用 $M$来简化计算的方法不适用与逻辑回归，因此计算将非常耗费时间。</p><p>在此，我们不介绍最小化支持向量机的代价函数的方法，你可以使用现有的软件包（如<strong>liblinear</strong>,<strong>libsvm</strong>等）。在使用这些软件包最小化我们的代价函数之前，我们通常需要编写核函数，并且如果我们使用高斯核函数，那么在使用之前进行特征缩放是非常必要的。</p><p>另外，支持向量机也可以不使用核函数，不使用核函数又称为<strong>线性核函数</strong>(<strong>linear kernel</strong>)，当我们不采用非常复杂的函数，或者我们的训练集特征非常多而样本非常少的时候，可以采用这种不带核函数的支持向量机</p><p><br/></p><p>下面是支持向量机的两个参数$C$和$\sigma$的影响：</p><p>$C=1/\lambda$</p><ul><li><p>$C$ 较大时，相当于$\lambda$较小，可能会导致过拟合，高方差；</p></li><li><p>$C$ 较小时，相当于$\lambda$较大，可能会导致低拟合，高偏差；</p></li></ul><p>高斯核函数 $e\left(-\frac{||x-l^{(1)}||^2}{2 \sigma^2}\right)$</p><ul><li><p>$\sigma$较大时，可能会导致低方差，高偏差；</p></li><li><p>$\sigma$较小时，可能会导致低偏差，高方差。</p></li></ul><p><br/></p><hr><h2 id="多类分类问题"><a href="#多类分类问题" class="headerlink" title="多类分类问题"></a>多类分类问题</h2><p>假设我们利用之前介绍的一对多方法来解决一个多类分类问题。如果一共有$k$个类，则我们需要$k$个模型，以及$k$个参数向量$$。我们同样也可以训练$k$个支持向量机来解决多类分类问题。但是大多数支持向量机软件包都有内置的多类分类功能，我们只要直接使用即可。</p><p>尽管你不去写你自己的<strong>SVM</strong>的优化软件，但是你也需要做几件事：</p><p>1、是提出参数$C$的选择。我们在之前的视频中讨论过误差/方差在这方面的性质。</p><p>2、你也需要选择内核参数或你想要使用的相似函数，其中一个选择是：我们选择不需要任何内核参数，没有内核参数的理念，也叫线性核函数。因此，如果有人说他使用了线性核的<strong>SVM</strong>（支持向量机），这就意味这他使用了不带有核函数的<strong>SVM</strong>（支持向量机）</p><p><br/></p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="table-container"><table><thead><tr><th>场景</th><th>逻辑回归</th><th>支持向量机（SVM）</th><th>神经网络</th></tr></thead><tbody><tr><td>特征数 (n) 较大，(m) 较小</td><td>适用，训练速度相对较快</td><td>不适用</td><td>适用，训练速度可能较慢</td></tr><tr><td>(n) 较小，(m) 在 10-10000 之间</td><td>适用，尤其是不带核函数的 SVM</td><td>适用</td><td>适用，但可能有更快的选择</td></tr><tr><td>(n) 较小，(m) 大于50000</td><td>适用，训练速度相对较快</td><td>不适用</td><td>适用，但训练可能较慢</td></tr></tbody></table></div><p><strong>说明：</strong></p><ol><li>对于小规模数据集，特别是当特征数量较大时，逻辑回归或不带核函数的 SVM 是常用的选择，因为它们的训练速度相对较快。</li><li>当面对中等规模数据集，特别是特征数量较小，可以尝试使用高斯核函数的 SVM。</li><li>对于复杂的非线性函数拟合，或者存在大量数据和特征的情况，神经网络可能是一个有效的选择，但训练时间可能较长。</li><li>对于大规模数据集，支持向量机通常是比较高效的选择，尤其是在使用不同的核函数时。</li></ol><p><br/></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.机器学习绪论</title>
      <link href="/post/20569.html"/>
      <url>/post/20569.html</url>
      
        <content type="html"><![CDATA[<h1 id="机器学习绪论"><a href="#机器学习绪论" class="headerlink" title="机器学习绪论"></a>机器学习绪论</h1><h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><p>监督学习是一种机器学习的方法，它的目的是训练一个模型，使其能够根据输入数据预测输出数据。监督学习需要使用一些已经标注了输出数据的输入数据作为训练集，例如图片和对应的标签，或者文本和对应的类别。</p><p>通过学习训练集中的数据，监督学习模型可以找到输入和输出之间的关系，从而对新的输入数据进行分类或回归。监督学习有很多应用场景，例如图像识别、垃圾邮件过滤、情感分析等。</p><p>监督学习可以分为两种类型：<strong>分类和回归</strong></p><hr><h3 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h3><p>分类是指将输入数据分配到有限个离散的类别中，例如判断一封邮件是垃圾邮件还是正常邮件。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231020165441843.png" alt="image-20231020165441843"></p><hr><h3 id="回归问题"><a href="#回归问题" class="headerlink" title="回归问题"></a>回归问题</h3><p>回归是指将输入数据映射到一个连续的数值上，例如预测房价或股票价格。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231020165420187.png" alt="image-20231020165420187"></p><p>监督学习的模型有很多种，例如神经网络、支持向量机、决策树、逻辑回归等。不同的模型有不同的优缺点和适用场景，选择合适的模型需要考虑数据的特征、规模、分布等因素。</p><hr><h2 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h2><p>无监督学习是一种机器学习的方法，它的目的是在没有标签或目标的情况下，从数据中发现隐藏的结构或模式。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231020170623480.png" alt="image-20231020170623480"></p><p>无监督学习有很多应用场景，例如数据聚类、降维、异常检测、推荐系统等</p><p><strong>聚类</strong>是一种机器学习的方法，它可以把相似的数据分成不同的组，每个组叫做一个簇。聚类的目的是让同一个簇里的数据对象的相似性尽可能大，同时不在同一个簇中的数据对象的差异性也尽可能地大。聚类可以用来分析数据的结构、模式、特征等。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构重点题</title>
      <link href="/post/44667.html"/>
      <url>/post/44667.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构选择题"><a href="#数据结构选择题" class="headerlink" title="数据结构选择题"></a>数据结构选择题</h1><p>09~21年</p><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220623205440767.png" alt="image-20220623205440767"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：x每次都稳定翻倍，所以时间复杂度为A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220623215207221.png" alt="image-20220623215207221"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：n每次－1，当n为1时，循环结束，所以时间复杂度为B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220624094829383.png" alt="image-20220624094829383"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：双循环，外循环执行$log_2n$次，内循环固定执行n次，所以结果是C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220624213924748.png" alt="image-20220624213924748"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：<code>i</code>的值会从1增加到n，通项求和公式为$sum=\frac{(1+n)n}{2}$，所以时间复杂度是B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221130161228135.png" alt="image-20221130161228135"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：x以平方的速度增长，所以时间复杂度为B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221210195457872.png" alt="image-20221210195457872"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：等差序列的求和公式了，(1+n)n/2，所以是B</p></div></div><hr><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220623225047439.png" alt="image-20220623225047439"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：换个思路，从开头双指针比较，较小的元素插入到新表头，如果按头插法依次比较插入，则可以得到降序链表，显然最坏时间复杂度为max(m,n)，选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220624205311767.png" alt="image-20220624205311767"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：根据内存表中的情况：C–a–e–b–d，如果将f插入到a，e之间，则a会连接到f，链接地址为1014H，e的链接地址不变，是1004H，f连接到e，地址为1010H，选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220624211853516.png" alt="image-20220624211853516"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：双向循环链表，很明显选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221201191128215.png" alt="image-20221201191128215"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：考虑到只有一个元素的情况，如果p=q，那么p直接指向头结点，选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221201191447916.png" alt="image-20221201191447916"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：行优先存储，假设每行有n个元素，那么3n+4=121，n=39，则100+39×5+6-1=300，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221210191732334.png" alt="image-20221210191732334"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：对于ABC来说，要在尾结点插入一个元素都需要遍历链表，而对于循环双链表来说，只需要改变指针即可，所以选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221210200135957.png" alt="image-20221210200135957"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：用带尾指针的循环链表查找首尾结点的效率都是O(1)，所以选B</p></div></div><hr><h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220623154316948.png" alt="image-20220623154316948"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：缓冲区+先进先出 很明显是队列 选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220623154450332.png" alt="image-20220623154450332"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：模拟可知，栈中元素最多时为3，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220623164024589.png" alt="image-20220623164024589"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：D中的f，e，d依次退栈明显违背了题目规则</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220623173935240.png" alt="image-20220623173935240"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：以a为起点，看其左右两边是否符合规律，C明显不符合</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220623205604516.png" alt="image-20220623205604516"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：有dcbae，decba，dceba，dcbea 四种，故选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220623205841503.png" alt="image-20220623205841503"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：顺序表存储队列，，rear指向队尾元素，开始时rear应该为n-1，才能保证第一个元素进队后指向0，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220623215430424.png" alt="image-20220623215430424"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：中缀转后缀表达式，过程中操作符最大时：-*((+，为5个，选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220623231751570.png" alt="image-20220623231751570"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：$p_3$不可能是3，其余皆有可能，所以选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220624095157151.png" alt="image-20220624095157151"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：中缀表达式转后缀，操作符进栈，扫描到f，栈内元素为<code>+(-*</code>，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220624095430280.png" alt="image-20220624095430280"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：顺序表存储循环队列，首尾指针相同时队空，留一个空间以判断队满，所以选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220624111342472.png" alt="image-20220624111342472"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：先执行main函数，再执行S函数，选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220624212026668.png" alt="image-20220624212026668"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：这是一个栈的问题，栈结构是，栈内元素自下往上下降，8,4,2.1组成一个栈  5,3组成一个栈 ，9,6组成一个栈，7组成一个栈，最后的结果是n至少为4，选C  </p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220624212442325.png" alt="image-20220624212442325"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：三对角矩阵，首先，前29行的元素之和为2+28×3=86个，$m_{30,30}$是对角线元素，是第30行的第2个元素，所以是数组中的第88个元素，下标要在此基础上-1，所以答案是87，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220624214217261.png" alt="image-20220624214217261"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：1，3太绝对了，2是栈的正常用途，4说法错误，所以选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220624214336683.png" alt="image-20220624214336683"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：三元组是存储稀疏矩阵的常规方法，而十字链表也可以存储稀疏矩阵，所以选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220626171342683.png" alt="image-20220626171342683"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：(8-(3+2))*5= 15，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220626171555120.png" alt="image-20220626171555120"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：C的序列都是队列，但是没有按顺序</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220626172457866.png" alt="image-20220626172457866"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：上三角矩阵，前5行的元素个数是(12+8)×5÷2=50，查找元素处于第6行第6个，是对角线元素，50+1=51个元素，下标是从0开始的，所以下标是51-1=50，选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221130193705913.png" alt="image-20221130193705913"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：首先是对称矩阵，$m_{7,2}=m_{2,7}$，注意到是按列存放的，所以$m_{2,7}$是第1+2+3+4+5+6+2=23个，下标为个数-1=22，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221130194209334.png" alt="image-20221130194209334"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：按照顺序，b，c，e，选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221201191327211.png" alt="image-20221201191327211"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：按照顺序，1的左右肯定有2，明显是D不合理</p></div></div><hr><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><div class="table-container"><table><thead><tr><th><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220623154619892.png" alt="image-20220623154619892"></th><th><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220623154637265.png" alt="image-20220623154637265" style="zoom:67%;" /></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：很明显的RNL，选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220623160443450.png" alt="image-20220623160443450"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：根据AVL的定义，很明显的B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220623160541036.png" alt="image-20220623160541036"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：前5层最多有$2^5-1=31$个，第6层最多有$2^{6-1}=32$个结点，其中8个叶节点，则24个非叶节点，则结点数最多为31+32+48=111个，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220623161020800.png" alt="image-20220623161020800"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：首先如果v是u的左孩子的左孩子，那么肯定满足父子关系，其次如果v是u的右孩子的右孩子，则满足兄弟关系，最后，如果v是u的右孩子的左孩子，则满足u的父节点和v是兄弟关系，如果v是u的左孩子的右孩子，则u和u的父节点是兄弟关系，故3错误，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220623174035729.png" alt="image-20220623174035729"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：符合条件的是D，后序遍历是左右根的顺序，无法找到后继</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220623175121172.png" alt="image-20220623175121172"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：插入48之后，AVL会不平衡，是RL型不平衡，即需要先右旋，再左旋，37会变成根节点，左右分别是24和53，即选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220623185815751.png" alt="image-20220623185815751"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：根据规律：结点数=度数+1，则n=4×20+10×3+1×2+10×1+1=123，而叶子结点数=123-20-10-1-10=82，即选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220623190305950.png" alt="image-20220623190305950"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：根据哈夫曼树的特点，选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220623205946707.png" alt="image-20220623205946707"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：完全二叉树的非叶节点=[n/2]（向下取整）=384个，即叶子结点也是384个</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220623210145515.png" alt="image-20220623210145515"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：前序序列说明根节点是1，观察选项BCD，即234都在根节点的左子树中，对34进行排序，若3,4都是左，那么D成立，若34都是右，那么B成立，无论如何C都不成立，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220623211014612.png" alt="image-20220623211014612"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：极端一点，设想其2011结点的树含有116个叶子结点以及2011-116-1=1894个度为1的结点，以及一个度为116的结点，将其转化为二叉树，则有1895个结点没有兄弟，所以二叉树中也没有右孩子，再加上二叉树中最深的一个结点没有孩子，结果为1896个，选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220623215700137.png" alt="image-20220623215700137"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：可以确定a为根节点，而e是前序第二个以及后序倒数第二个，说明根节点只有左子树或只有右子树，则选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220623215924799.png" alt="image-20220623215924799"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：画出符合条件的高度为2,3的AVL，加一个根节点即是高度为4的符合条件的AVL，同理，高度为6的AVL=7+12+1=20，此题选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220623232108292.png" alt="image-20220623232108292"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：排序结果是一棵高度为3的完全二叉树，所以个数为3</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220624003310046.png" alt="image-20220624003310046"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：6+7+(4+5)×2+(2+3)×3=46，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220624003545973.png" alt="image-20220624003545973"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：右线索指向后继，是其父节点，选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220624003754037.png" alt="image-20220624003754037"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：如果删除的是叶节点，则最后结果是相同的，如果不是叶节点，那么结果不同，毕竟BST没有平衡机制，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220624095627186.png" alt="image-20220624095627186"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：中序化，x的左线索指向前驱，即是b，右线索指向后继，即是a，所以选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220624095748767.png" alt="image-20220624095748767"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：T中左孩子指针为空的，说明没有孩子，是叶子结点，和F中叶节点的个数相当</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220624100416899.png" alt="image-20220624100416899"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：前缀编码要求，即任一一个编码不能是其他编码的前缀，而D中，110完全是1100的前缀，所以D错误</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220624111521728.png" alt="image-20220624111521728"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：①  n个不同元素进栈，出栈元素不同排列的个数为$\frac{1}{n+1}C^n_{2n}$(卡特兰数)，② 由先序序列和中序序列可以完全确定一棵二叉树 ③ 将先序序列压入栈，元素出栈的顺序构成中序序列(结合先序和中序的非递归序列来考虑，先序就是在元素入栈前访问，中序在出栈时访问)  得出结论，结果为$\frac{1}{4+1}C^4_{8}=14$  答案选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220624200303719.png" alt="image-20220624200303719"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：只有CD可以结合生成24这一结点，而在C中，叶子结点10和0结合，另一边却是11和3结合，不符合哈夫曼树的定义，所以选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220624201309669.png" alt="image-20220624201309669"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：显然AB错误，AVL可以旋转，所以最后插入的不一定是叶节点，树中最大元素是其左子树的最左下结点，一定无左孩子，所以选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220624212842710.png" alt="image-20220624212842710"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：在森林中，结点数=度数+根节点数，所以是10个，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220624214600740.png" alt="image-20220624214600740"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：先序序列和中序序列相同，联系到二叉树的非递归遍历，则只有右单枝树能满足条件，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220625005603717.png" alt="image-20220625005603717"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：在图中标记出各个结点，答案明显是B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220625010415946.png" alt="image-20220625010415946"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：将序列解析为 0100  011 001 001 011 11 0101 所以是 a f e e f g d 所以选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220626173058042.png" alt="image-20220626173058042"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：是满二叉树，有k个叶节点，假设有n层，$k=2^{n-1},n=log_2k+1$，n层一共有$2^n-1$个结点，即$2k-1$个结点</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220626173824610.png" alt="image-20220626173824610"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：出现频率越高的字符，编码越短，首先排除B，D，而C不符合哈夫曼树的要求，10和1011的前缀相同了，所以选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220626174519707.png" alt="image-20220626174519707"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：BST按中序遍历顺序，依次增大或减小，所以选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221130161408598.png" alt="image-20221130161408598"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：概念问题，树的后根遍历=二叉树的中序遍历，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221130161454905.png" alt="image-20221130161454905"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：n个哈夫曼树会新建n-1个结点，因此结点总数2n-1=115，n=58，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221130161654652.png" alt="image-20221130161654652"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析： 如果删除了叶子结点导致AVL不平衡，那么AVL会改变，所以$T_1$和$T_3$可能不相同，而2.3说的都太绝对，可举反例证明其错误，选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221130194648579.png" alt="image-20221130194648579"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：为了满足任意性，其1~5层的所有结点都要存储起来，所以是1+2+4+8+16=31 选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221130194846283.png" alt="image-20221130194846283"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：已知二叉树的先序和中序遍历，画出二叉树的结构，可知二叉树后序序列我b，f，e，d，c，a，选C </p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221130195133260.png" alt="image-20221130195133260"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：明显是B无法满足 </p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221201191700966.png" alt="image-20221201191700966"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：画出二叉树的图</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221201191735984.png" alt="image-20221201191735984"></p><p>a的右孩子都是树的头结点，所以选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221201191824091.png" alt="image-20221201191824091"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：根据哈夫曼树的构造方法进行构造，显然选B</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221201191909352.png" alt="image-20221201191909352"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221201191938274.png" alt="image-20221201191938274"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：显然是RL型交换，25是关键字</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221211025859026.png" alt="image-20221211025859026"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：根据堆的性质，父节点只可能比子结点大or小，所有必然是有序的，选D</p></div></div><hr><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220623161255751.png" alt="image-20220623161255751"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：根据性质，显然1成立，对于2，边数有可能等于顶点个数减1，不成立，对于3，对于无向完全图来说，不成立，所以选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220623190507489.png" alt="image-20220623190507489"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：根据公式最多边数：n(n-1)，则在满足剩下6个顶点形成无向完全图的情况下，再多一条边则能保证连通，最少是6(6-1)+1=16，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220623201451072.png" alt="image-20220623201451072"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：按拓扑排序的规则，序列开头必定是a，结尾必定是d，中间肯定b在c之前，故序列有 bce，ebc，bec三种，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220623212031137.png" alt="image-20220623212031137"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：1，2错误，3正确，选C，都是基本概念</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220623220436966.png" alt="image-20220623220436966"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：邻接表的BFS，显然时间复杂度为C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220623220530409.png" alt="image-20220623220530409"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：主对角线以下元素为0，说明是有向无环图，但是拓扑排序不能确定，所以选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220623221439527.png" alt="image-20220623221439527"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：将abc视作一个整体，则下一条权值最短路径是c-f，之后是c-d，最后是d-e，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220623222459496.png" alt="image-20220623222459496"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：对于1，代价为最小是唯一的，正确，对于2，不一定会完全出现，对于3，错误，对于4，错误，所以选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220624003915010.png" alt="image-20220624003915010"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：度为列和行的非0元素个数，所以选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220624004103979.png" alt="image-20220624004103979"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：D错误，a之后应该是bhe三个节点</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220624004221453.png" alt="image-20220624004221453"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：最短路径为bdeh，bfh，bdcg，只有同时减少f和d，可以减少3条关键路径上的关键活动，所以选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220624101014514.png" alt="image-20220624101014514"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：D符合条件</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220624201500774.png" alt="image-20220624201500774"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：从0开始 有  0132  0213  0231 0312 0321 5种序列</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220624201905539.png" alt="image-20220624201905539" style="zoom:67%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：克鲁斯卡尔可以直接选权最小的边，而普利姆算法则会选能连通的边，在第二次选择中，图中3条权值为8的边，克鲁斯卡尔算法均能选择，而普利姆算法不选选择$v_3,v_2$的边，所以选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220624212958960.png" alt="image-20220624212958960"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：D有明显问题，2之后应该是$V_5$，而非$V_3$</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220624213102352.png" alt="image-20220624213102352"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：概念问题，B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220624213213520.png" alt="image-20220624213213520"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：依次是：5,2,3,6,4  选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220625010453951.png" alt="image-20220625010453951"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：在无向图中，度数=边数×2 所以图G的总度数为32，而已知的度数有12+12=24 最少还需要(32-24)/2=4个度为2的点，顶点总数最少是3+4+4=11个，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220626174825420.png" alt="image-20220626174825420"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：概念问题，选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221130161900073.png" alt="image-20221130161900073"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：显然活动d并不在关键路径上，最早开始时间是：4+8=12，最晚开始时间是将d变为关键路径，即从6开始，9+10=6+7+4+x，x=2，最多延迟2，故为12+2=14，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221130162304790.png" alt="image-20221130162304790"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析： 先确定xy会占2个顶点，然后标记运算顺序，后一个+号先生效，第一个+号和/号同时生效，最后中间的×号生效，化为有向无环图，选A</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221130163205942.png" alt="image-20221130163205942"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221130195213663.png" alt="image-20221130195213663"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：退出递归前输出，那么会首先输出最末尾的结点，即是逆拓扑有序序列，选B </p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221130195331501.png" alt="image-20221130195331501"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：克鲁斯卡尔算法会选取最小的边加入到集合中，所以按最小边选就是了，选A </p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221130195454580.png" alt="image-20221130195454580"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：概念问题，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221201192028775.png" alt="image-20221201192028775"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：显然只有一个顺序，即ABCDEF，选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221201192814276.png" alt="image-20221201192814276"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：注意要做路径的累加，毕竟是算到顶点1的最短路径，所以是C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221210192243312.png" alt="image-20221210192243312"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：有26354 26534 62354 62534 65234 共5种，所以选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221210201657300.png" alt="image-20221210201657300"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：AB显然有错，对于D来说，非强连通图并不一定会出现“孤岛”，A到B有单向路径也是非强连通图，所以选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221211025947572.png" alt="image-20221211025947572"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：当权值一致的时候，最短路径问题简化为BFS问题，所以选A</p></div></div><hr><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220623161807258.png" alt="image-20220623161807258"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：叶节点之间通过指针链接是B+树的特点，还支持顺序存储，所以选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220623202126517.png" alt="image-20220623202126517"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：16个元素构筑的完全二叉树最多有5层，所以比较次数最多为5，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220623211545851.png" alt="image-20220623211545851"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：A，94大于91，不符合规律</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220623212207688.png" alt="image-20220623212207688"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：装填因子就是表中记录数/表的长度，增大并不能提高效率，2，3可以直接提高效率选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220623222739580.png" alt="image-20220623222739580"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：删除了78，则65顶替，选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220624004423720.png" alt="image-20220624004423720"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：最多有5个元素，导致根节点分裂，成为高度为2的B树，选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220624101119335.png" alt="image-20220624101119335"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：散列函数并不会受碰撞影响，装填因子就是表中记录数/表的长度，不会受影响，而ASL一定会受到影响，选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220624101819453.png" alt="image-20220624101819453"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：每个结点最少要含1个关键字，所以最多为15个</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220624202152702.png" alt="image-20220624202152702"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：明显是A，180&lt;200</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220624202540210.png" alt="image-20220624202540210"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：只要写出模式串t的next数组就行咯，abaabc的length数组为 0 0 1 1 2 0，next数组为-1 0 0 1 1 2，KMP算法中<code>i</code>的并不会回溯，依然是5,<code>j</code>回溯，回溯到2，所以选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220624213511345.png" alt="image-20220624213511345"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：概念问题，A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220625011030265.png" alt="image-20220625011030265"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：只需要判定折半查找判定树的结构是否符合规律就行了，A符合左子树结点数大于等于右子树结点数的规律，所以选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220625011520345.png" alt="image-20220625011520345"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：B+树就是为了磁盘中数据搜索和数据库而生的，所以选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220626174937594.png" alt="image-20220626174937594"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：3阶B树，每个结点最多含2个关键字，最少含1个关键字，所以近似看做完全二叉树，结果是B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220626175053908.png" alt="image-20220626175053908"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：3个关键字的余数相同，所以ASL=(1+2+3)/3=2，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221130163444356.png" alt="image-20221130163444356"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：注意到只需要比较0~6之间的关键字，其次要注意到和空数据的比较也算一次查找</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221130163510122.png" alt="image-20221130163510122"></p><p>ASL=（9+8+7+6+5+4+3）/7=6，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221130163708160.png" alt="image-20221130163708160"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：首先得出模式串的next数组：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221130163849388.png" alt="image-20221130163849388"></p><p>第一趟会比较6次，然后回到2的位置再比较4次，所以是10次，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221130195819955.png" alt="image-20221130195819955"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：根据B树插入的性质，结点满后再插入，从[m/2]处（向上取整）分裂，其中间的[m/2]会并入到父节点，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221201192946949.png" alt="image-20221201192946949"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：最多情况如下：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221201193023106.png" alt="image-20221201193023106"></p><p>所以选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221211030057905.png" alt="image-20221211030057905"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：伪随机再散列法的作用是，当发生冲突时，让关键字加上伪随机序列，然后再进行散列，70%13=5，和18冲突，加上5后，75%13=10，和75冲突，加上8后，78%17=0，与39冲突，加上3后，73%13=8，无冲突，故放入位置是8，选B</p></div></div><hr><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220623162807020.png" alt="image-20220623162807020"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：先按照完全二叉树的性质建立堆，然后将3插入，进行换位，得到答案A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220623163439349.png" alt="image-20220623163439349"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：如果是冒泡排序，则最小(大)值应该在末尾，如果是选择排序，则最小(大)值应该在开始,如果是二路归并，那么序列应该被分成2个有序部分，所以选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220623203831548.png" alt="image-20220623203831548"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：首先对快排来说，递归次数和初始排列肯定是有关的，但是与划分的分区处理无关，所以选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220623204238548.png" alt="image-20220623204238548"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：很明显的冒泡排序痕迹，选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220623212339414.png" alt="image-20220623212339414"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：快排的话，要不断的进行交换，所以顺序存储最好，选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220623212434549.png" alt="image-20220623212434549"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：先建立大根堆，在堆底部，一路交换上去，可以比较次数为2次，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220623224214570.png" alt="image-20220623224214570"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：选择排序和堆排序都可以一趟可以选出最大(小)值，而快速排序一趟可以确定枢轴的最终位置，所以选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220623224426157.png" alt="image-20220623224426157"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：插入排序的总趟数是固定的，移动次数也不会改变，选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220624004548573.png" alt="image-20220624004548573"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：第一趟的结果是 110 120 911 122 114 007 119，第二趟结果是 007 110 911 114 119 120 122 ，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220624101951354.png" alt="image-20220624101951354"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：观察序列，发现以9,13,20 |1,7 23| 4,8 15保持递增，所以间隔为3</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220624102317112.png" alt="image-20220624102317112"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：快速排序每一趟确定枢轴的位置，C不符合要求</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220624202818096.png" alt="image-20220624202818096"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：冒泡排序和快速排序都是交换排序，首先排除，而直接插入排序也与初始排序相关，所以选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220624203201226.png" alt="image-20220624203201226" style="zoom:80%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：先建立小根堆，删除8之后，用表尾元素12代替，然后让12下坠，过程中12和15比较一次，12和10比较一次，12和16比较一次，共3次，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220624203436450.png" alt="image-20220624203436450"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：希尔排序就是插入排序的升级版，而且不适合用折半插入，所以选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220624213356507.png" alt="image-20220624213356507"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：从数组开头以每组3个来查找，所以在开头处更好，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220624213535200.png" alt="image-20220624213535200"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：10TB属于外部排序，外部排序本质上使用归并排序，选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220625011718633.png" alt="image-20220625011718633"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：归并排序使用的空间和代码都比插入排序多，但是时间复杂度比插入排序好很多，所以选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220625011820788.png" alt="image-20220625011820788"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：如果数据要采用随机查找的方式找到指定元素，那么链表的效率很低，比如堆排序和希尔排序，所以选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220626175154840.png" alt="image-20220626175154840"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：1在第1位，然后第一轮的间隔是5，第二轮6到了第3位，显然第二轮间隔是3，选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220626175345836.png" alt="image-20220626175345836"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：根据建堆过程，从表尾元素开始，先是5和4,7比较，交换5和7的位置，然后是1和9,8比较，交换1和9的位置，所以选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221130163329127.png" alt="image-20221130163329127"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：显然都要考虑到，选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221130164008842.png" alt="image-20221130164008842"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：A：72,28符合枢轴，B：72,2符合，C：2,28,32都符合，D仅32符合，不可能是第二趟结果，所以选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221130165323366.png" alt="image-20221130165323366"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：根据公式：即$n_k=\frac{(n_v+n_s-1)}{k-1}$</p><p>为了让$n_k$为正整数，需要补充的虚段就是满足这一条件的最小正整数，所以选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221130195534812.png" alt="image-20221130195534812"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：显然1.2是对的，大根堆堆顶元素最大，次大肯定在根的下一层，4也正确，所以选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221130200120094.png" alt="image-20221130200120094"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：直接插入每趟会比较有序序列的后一个，将其插入到前面的有序序列中去，而简单选择每趟会选择一个最小(大)的数插入到前面去，所以有序序列的比较而言，肯定是直接插入排序少，选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221201193215162.png" alt="image-20221201193215162"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：分配，收集后，372被夹在了301和892中间，所以选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221201193306242.png" alt="image-20221201193306242"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：要求依次建立大根堆，所以每插入一个数字就调整依次，最终结果为B</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221201193416061.png" alt="image-20221201193416061"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221210202221276.png" alt="image-20221210202221276"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：直接插入排序的每一趟只用比一次即可，所以选B</p></div></div>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.排序</title>
      <link href="/post/8893.html"/>
      <url>/post/8893.html</url>
      
        <content type="html"><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>排序就是重新排列表中的元素，使表中的元素满足按关键字有序的过程</p><p>稳定性：在排序前相同的的两个元素，在排序后如果前后顺序没有改变，则是稳定，如果发生了改变，则不稳定</p><p>排序可以分为内部排序和外部排序，内部排序的数据都在内存中，考虑时空复杂度，而外部排序发生在磁盘和内存中，要考虑到尽可能降低读写次数</p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/QrpMRnlZd9TkYHw.gif" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> x[],<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp, j, i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)     </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (x[i] &lt; x[i - <span class="number">1</span>]) &#123;  <span class="comment">//如果x[i]小于前驱,保证了稳定性</span></span><br><span class="line">temp = x[i];              <span class="comment">//暂存x[i]</span></span><br><span class="line"><span class="keyword">for</span> (j = i ; j &gt;<span class="number">0</span> &amp;&amp; x[j<span class="number">-1</span>] &gt; temp; j--)</span><br><span class="line">                <span class="comment">//在之前的序列中，找到x[i]的位置，如果x[j-1]&lt;=x[i]了，那么j正好就是插入位置 </span></span><br><span class="line">&#123;                     </span><br><span class="line">x[j] = x[j<span class="number">-1</span>];             <span class="comment">//大于x[i]的数向后移位</span></span><br><span class="line">&#125;</span><br><span class="line">x[j] = temp;                   <span class="comment">//插入</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法存在优化空间，可以用二分查找的思路来查找插入位置，但是时间复杂度并没有改变，插入排序在面对倒序排列元素时表现非常糟糕</p><p>空间复杂度：$O(1)$</p><p>时间复杂度：$O(n²)$</p><p>算法稳定性：稳定</p><hr><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li></ul><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录”基本有序”时，再对全体记录进行依次直接插入排序</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/pH1SIeK3zTRDG79.gif" alt="img"></p><p>可以说希尔排序也就是插入排序的升级版，代码非常相似，就是在外面加了层嵌套</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span> x[],<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp, j, i,gap;</span><br><span class="line"><span class="keyword">for</span> (gap = n/<span class="number">2</span>; gap &gt; <span class="number">0</span>; gap/=<span class="number">2</span>)   <span class="comment">//逐渐减少增量</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (i = gap; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (x[i] &lt; x[i - gap]) &#123;  <span class="comment">//如果x[i]小于前驱</span></span><br><span class="line">temp = x[i];              <span class="comment">//暂存x[i]</span></span><br><span class="line"><span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; x[j - gap] &gt; temp; j-=gap)</span><br><span class="line">        <span class="comment">//在之前的序列中，找到x[i]的位置，如果x[j-1]&lt;=x[i]了，那么j正好就是插入位置 </span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">x[j] = x[j - gap]; <span class="comment">//大于x[i]的数向后移位</span></span><br><span class="line">&#125;</span><br><span class="line">x[j] = temp;                   <span class="comment">//插入</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间复杂度：O(1)</p><p>时间复杂度：O(n²)</p><p>算法稳定性：不稳定</p><p><strong>只适用于顺序表</strong></p><hr><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢”浮”到数列的顶端。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/bubbleSort.gif" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, temp;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)   <span class="comment">//只用比较n-1次</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)   <span class="comment">//从前往后比，当然从后往前也是可以的</span></span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;   <span class="comment">//交换</span></span><br><span class="line">     swap(arr[j],arr[j+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间复杂度：O(1)</p><p>时间复杂度：O(n²)</p><p>算法稳定性：稳定</p><hr><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，<strong>快速排序应该算是在冒泡排序基础上的递归分治法</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/pyF8DNqUowLg3dn.gif" alt="img"></p><p> 算法步骤</p><ol><li>从数列中挑出一个元素，称为 “基准”（pivot）;</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Paritition1</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> pivot = A[low];    <span class="comment">//选定low位置上的数作为枢轴，low空缺</span></span><br><span class="line">   <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">     <span class="keyword">while</span> (low &lt; high &amp;&amp; A[high] &gt;= pivot) &#123; </span><br><span class="line">       --high;                 <span class="comment">// 直到找到小于枢轴的数</span></span><br><span class="line">     &#125;  </span><br><span class="line">     A[low] = A[high];         <span class="comment">//把小于枢轴的数换到low的位置去，此时high空缺</span></span><br><span class="line">     <span class="keyword">while</span> (low &lt; high &amp;&amp; A[low] &lt;= pivot) &#123;</span><br><span class="line">       ++low;                   <span class="comment">// 直到找到大于枢轴的数</span></span><br><span class="line">     &#125;</span><br><span class="line">     A[high] = A[low];        <span class="comment">//把大于枢轴的数换到high的位置去，此时low空缺</span></span><br><span class="line">   &#125;</span><br><span class="line">   A[low] = pivot;            <span class="comment">//high=low时结束，此时将枢轴的值放到该中间位置</span></span><br><span class="line">   <span class="keyword">return</span> low;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> <span class="comment">//快排母函数</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">     <span class="keyword">int</span> pivot = Paritition1(A, low, high);</span><br><span class="line">     QuickSort(A, low, pivot - <span class="number">1</span>);   <span class="comment">//递归</span></span><br><span class="line">     QuickSort(A, pivot + <span class="number">1</span>, high);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>空间复杂度：$O(log_2n)到O(n)$，取决于递归树的深度</p><p>时间复杂度：最好情况下$O(nlog_2n)$  ，最差情况下$O(n²)$，递归次数是$log_2n$，完成排序操作是n</p><p>算法稳定性：不稳定</p><div class="note primary flat"><p>快速排序在数据已经基本有序的情况下不好发挥其速度，因为会以首个元素为基准，导致其左子表为0，但排序列表为倒序，用快速排序能将其很快变为正序，只要在中间位置选中枢轴即可</p></div><hr><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 $O(n²)$ 的时间复杂度。所以用到它的时候，数据规模越小越好。</p><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。重复第二步，直到所有元素均排序完毕。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/tzxDLsJ9Bd6HcgR.gif" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span> <span class="comment">//交换两个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; len - <span class="number">1</span> ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">           <span class="keyword">int</span> min = i;</span><br><span class="line">           <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; len; j++)     <span class="comment">//遍历未排序的元素</span></span><br><span class="line">                  <span class="keyword">if</span> (arr[j] &lt; arr[min])     <span class="comment">//找到目前最小值</span></span><br><span class="line">                  &#123;                  </span><br><span class="line">                       min = j;    <span class="comment">//记录最小值</span></span><br><span class="line">                       swap(&amp;arr[min], &amp;arr[i]);    <span class="comment">//交换</span></span><br><span class="line">                  &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间复杂度：$O(1)$</p><p>时间复杂度：$O(n²)$</p><p>算法稳定性：不稳定</p><hr><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p><ol><li>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</li><li>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</li></ol><p>首先需要回忆完全二叉树的顺序存储的性质：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/uyijC7QprLnOHF2.png" alt="image-20220525162107152" style="zoom:67%;" /></p><div class="note primary simple"><p>数组0位置是空，然后按层级遍历顺序存储， <code>i</code>的左孩子结点是<code>2i</code>，<code>i</code>的右孩子结点是<code>2i+1</code>，<code>i</code>的父节点是<code>[i/2]</code>,而<code>n</code>是数组长度，<code>n/2</code>是最后一个非叶子结点位置</p></div><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/heapSort.gif" alt="img"></p><p>先建立大根堆，堆顶元素即是最大元素，然后交换堆顶和堆底元素，将堆顶元素移出堆外，重新构建堆，形成递增序列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>* r, <span class="keyword">int</span> dad, <span class="keyword">int</span> end)</span> <span class="comment">//k~end为调整的范围 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ch = <span class="number">2</span> * dad; <span class="comment">//ch为dad的左孩子 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (ch &lt;= end)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//让指针j选出左、右孩子中较大者 </span></span><br><span class="line"><span class="keyword">if</span> (ch &lt; end &amp;&amp; r[ch] &lt; r[ch + <span class="number">1</span>]) </span><br><span class="line">          <span class="comment">//&quot;lch&lt;end&quot;表示i还有右孩子 ,若右孩子大，则让指针j指向右孩子// </span></span><br><span class="line">&#123;</span><br><span class="line">ch++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根节点与左、右孩子中的较大者 进行比较，进一步筛选出较大者，并将其换到根节点的位置上去 </span></span><br><span class="line"><span class="keyword">if</span> (r[dad] &lt; r[ch])</span><br><span class="line">&#123;</span><br><span class="line">swap(&amp;r[dad], &amp;r[ch]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若发生了，则可能需要对其孩子进行二次调整 </span></span><br><span class="line">dad = ch;</span><br><span class="line">ch = <span class="number">2</span> * dad;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> r[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="comment">//构建堆：由下至上 （由第一个非叶子结点开始） </span></span><br><span class="line"><span class="keyword">for</span> (k = n / <span class="number">2</span>; k &gt;= <span class="number">1</span>; k--)        <span class="comment">// n/2即是由下到上的第一个非叶子结点</span></span><br><span class="line">&#123;</span><br><span class="line">heapify(r, k, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调整堆：由上至下 </span></span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span>; k &lt; n; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//移走堆顶元素 </span></span><br><span class="line">swap(&amp;r[<span class="number">1</span>], &amp;r[n - k <span class="number">-1</span>]);  </span><br><span class="line">        <span class="comment">//r[1]是堆顶元素，即最大的元素，与堆最小的元素进行交换</span></span><br><span class="line"><span class="comment">//调整堆 </span></span><br><span class="line">heapify(r, <span class="number">1</span>, n - k);        <span class="comment">//每次都让堆顶元素出局，再重新构建堆</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆的建立：按照完全二叉树的顺序建立堆，然后从<strong>底部</strong>（表尾）开始，按照堆的要求进行换位，即从下到上，从右到左</p><p>堆的插入：新元素放到堆底部（表尾），然后按照堆的要求不断上升，上升只用对比父节点一次关键字</p><p>堆的删除：被删除元素和底部元素换位（表尾），然后按堆的要求不断下坠，下坠有可能需要比较两次，也有可能只比一次</p><p>注意：堆的排序有两种类型：</p><ol><li>给了数据序列，问变化序列，那就就按<strong>堆的建立</strong>开始换位</li><li>给了数据序列，强调依次插入，那么就按<strong>堆的插入</strong>一步步加入形成堆</li></ol><div class="note danger flat"><p>堆由数组存储，只适合用于排序，而不适合用于查找</p></div><p>空间复杂度：$O(1)$</p><p>时间复杂度：$O(nlog_2n)$  堆顶的交换次数是$n$，堆的调整的时间复杂度是$log_2n$</p><p>算法稳定性：不稳定</p><hr><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p><p> 算法步骤</p><ol><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li><li>重复步骤 3 直到某一指针达到序列尾；</li><li>将另一序列剩下的所有元素直接复制到合并序列尾。</li></ol><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/7RV1pseHcr5AFdN.gif" alt="img"></p><p>数组的归并操作就是两个有序数组（链表）的合并，就是合并<code>low-mid</code>，<code>mid+1-high</code>两个数组</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/dEgJkj5YolsS6DW.png" alt="image-20220526143706541"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> low ,<span class="keyword">int</span> mid,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *b=(<span class="keyword">int</span>*) <span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));       <span class="comment">//创建辅助数组b</span></span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">for</span>(k=low;k&lt;=high;k++)                <span class="comment">//将数组a复制到数组b中</span></span><br><span class="line">    &#123;</span><br><span class="line">        b[k]=a[k];   </span><br><span class="line">    &#125;</span><br><span class="line">    i=low;                 <span class="comment">//i指向第一组起始位置，j指向第二组</span></span><br><span class="line">    j=mid+<span class="number">1</span>               <span class="comment">//low~mid以及mid+1~high内都是有序的</span></span><br><span class="line">     <span class="keyword">for</span>(k=i;i&lt;=mid&amp;&amp;j&lt;=high;k++)   <span class="comment">//k是指向数组a起始位置</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">if</span>(b[i]&lt;=b[j])     <span class="comment">//比较i，j指针数的值，保证稳定性</span></span><br><span class="line">         &#123;            <span class="comment">//结果会替代a[k]位置的值，并且i或者j指针加一，继续比较</span></span><br><span class="line">           a[k]=b[i];     <span class="comment">//直到某一组数都比较完</span></span><br><span class="line">           i++;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           a[k]=b[j];</span><br><span class="line">           j++;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;     </span><br><span class="line">     <span class="keyword">while</span>(i&lt;=mid) a[k++]=b[i++];    <span class="comment">//将剩下的另一组数填到k后</span></span><br><span class="line">     <span class="keyword">while</span>(j&lt;=high) a[k++]=b[j++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> low ,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(low+high)/<span class="number">2</span>;      <span class="comment">//从中间划分</span></span><br><span class="line">        MergeSort(A,low,mid);      <span class="comment">//对左半部分进行归并排序</span></span><br><span class="line">        MergeSort(A,mid+<span class="number">1</span>,high);   <span class="comment">//对右半部分进行归并排序</span></span><br><span class="line">        Merge(A,low,mid,high);     <span class="comment">//归并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间复杂度：$O(n)$ 来自辅助数组</p><p>时间复杂度：$O(nlog_2n)$   归并次数是$log_2n$，每次归并的时间复杂度是$n$</p><p>算法稳定性：稳定</p><hr><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/yhf4DlQZ9BsS6qP.gif" alt="img"></p><p>假设要比较很多两位整数的大小，首先需要建立队列，第一趟先比较各个数个位大小，个位大的先入队，然后出队，按十位大的先入队，十位相同的两个数，由于第一趟排序后，个位大的排在前面，所以个位大的先入队，当数都入队后，再出队</p><p>一般使用链式队列来存储数据，需要r个队列，r为进制位数</p><p>空间复杂度：O(r)</p><p>时间复杂度：O(d(n+r))   一次排序需要O(r)，总共有d次分配，收集</p><p>稳定性：稳定</p><hr><h2 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h2><p>由于数据元素过多，无法一次全部读入内存进行排序，所以需要在内存和磁盘之间进行操作</p><p><strong>外部排序的核心还是归并排序</strong>，在内存中最少只需要3块大小的缓冲区就能对任意大小的文件进行排序归并</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/TKF7zQklHfmJ32X.png" alt="image-20220526160856370"></p><p>每次读入两块数据到缓冲区，然后进行归并排序，结果到输出缓冲区写入到磁盘中去，如果输入缓冲区空了就再加入一块新数据</p><p>步骤：</p><ol><li>生成r个初始归并段</li><li>进行S趟k路归并 $S=[log_kr]$</li></ol><p>外部排序时间开销=读写外存的时间+内部排序所需时间+内部归并所需时间</p><p>优化思路：</p><ol><li>可以多加2个缓冲区，这样就是4路归并，减少读写磁盘的时间（败者树）</li><li>减少初始归并段（置换-选择排序）</li></ol><hr><p><strong>败者树</strong></p><p>多加了缓冲区后，内部排序需要对比关键字的次数也增加了，为了减少内部排序的对比次数，可以采用败者树的形式</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/ATPRwE6Cj9uzOBL.png" alt="image-20220526163640881"></p><p>接下来的对比，只需要对比分支结点里面记录的败者归并段的首元素就行了，只需要对比关键字$log_2k$次</p><hr><p><strong>置换-选择排序</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/vifFZz1JR7rmgWu.png" alt="image-20220526164455552"></p><p>将初始待排序文件集中放在一起，然后进入内存工作区，内部排序得到最小的值，输出该元素，并记录该元素的值为MIN，添加新元素，每次离开内存工作区的元素要比MIN大，并且会成为新的MIN</p><p>如果工作区所有的数都比MIN小，就新开一个归并段</p><hr><p><strong>最佳归并树</strong></p><p>在进行归并的时候，将每个初始归并段看做一个叶子结点，归并段的长度作为结点权值，那么利用哈夫曼树的性质就能实现最少归并次数</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/YqtJXW5QUSdxApH.png" alt="image-20220526165915036"></p><p>归并过程中磁盘I/O次数=归并树WPL×2</p><p>对于K叉归并，如果初始归并段的数量无法构成严格的k叉归并树，就需要补充几个长度为0的虚段，至于虚段的计算，参照二叉树的性质</p><div class="note primary simple"><p>已知树的结点数=总度数+1 即$n=n_1+2n_2+1$，同时$n=n_0+n_1+n_2$，所以可以推出$n_0=n_2+1$</p></div><p>补充了虚段的最佳归并树的结点只有两种类型，叶子结点和度为k的结点，叶子结点由归并段结点和虚段结点组成，那么可根据树的性质推导</p><ul><li><p>$1+k×n_k=n$  即 1+树的总度数=树的结点总数</p></li><li><p>$n_0+n_k=n$   即 叶子结点+度为k的结点=树的结点总数</p></li><li>$n_0=n_v+n_s$  即 叶子结点=虚段结点+归并段结点</li></ul><p>根据这三个公式推出：$n_v+n_s+n_k=1+k×n_k$，</p><p>即$n_k=\frac{(n_v+n_s-1)}{k-1}$</p><p>为了让$n_k$为正整数，需要补充的虚段就是满足这一条件的最小正整数</p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.查找</title>
      <link href="/post/12586.html"/>
      <url>/post/12586.html</url>
      
        <content type="html"><![CDATA[<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><p>在数据集合中寻找满足某种条件的数据元素的过程称为查找</p><p>平均查找长度：所有查找过程中进行关键字的比较次数的平均值</p><hr><h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><p>就是从头到尾依次查找</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"> <span class="keyword">int</span> *elem;</span><br><span class="line"> <span class="keyword">int</span>  length;</span><br><span class="line">&#125;<span class="function">table</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_Seq</span><span class="params">(table st,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==key)&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以添加“哨兵“，就不必担心越界问题</p><p>如果查找的是有序表的话，如果查找到比关键字大的数的话，可提前结束查找</p><p>时间复杂度：<code>O(n)</code></p><hr><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>仅适用于有序的顺序表，每次查找从顺序表的一半开始</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/sLNTz1P6EU8oite.png" alt="image-20220524142406209"  /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"> <span class="keyword">int</span> *elem;</span><br><span class="line"> <span class="keyword">int</span>  length;</span><br><span class="line">&#125;<span class="function">table</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(table st,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid,high,low;</span><br><span class="line">high=st.length<span class="number">-1</span>;</span><br><span class="line">low=<span class="number">0</span>;</span><br><span class="line">whlie(low&lt;=high)&#123;</span><br><span class="line">mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(st.elem[mid]==key)&#123;</span><br><span class="line">     <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(L.elem[mid]&gt;key)</span><br><span class="line">        high=mid<span class="number">-1</span>; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        low=mid+<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>；</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>折半查找如果是向下取整，则判定树的右子树结点数-左子树结点数=0或1，折半查找如果是向上取整，则判定树的左子树结点数-右子树结点数=0或1   </p><div class="note primary flat"><p>观察树形是否是折半查找判定树，需要注意一整树的所有结点是否都符合左子树≥右子树或右子树≥左子树的规律(注意是结点数，而非平衡因子)</p></div><p>判定树高为$log_2(n+1)$</p><p>时间复杂度：$O(log_2n)$</p><hr><h2 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h2><p>建立索引表，保存每个分块的最大关键字和分块的存储区间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType maxValue;</span><br><span class="line">    <span class="keyword">int</span> low,high;</span><br><span class="line">&#125;Index;</span><br><span class="line">Elemtype <span class="built_in">list</span>[<span class="number">100</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/IQcHgMAbRymNqCh.png" alt="image-20220524145733262"></p><p>在索引表中确定待查记录所属的分块（可顺序，可折半），在块内顺序查找</p><p>若索引表中不包含目标关键字，则折半查找索引表最终停在了<code>low&gt;high</code>，要在l<code>ow</code>的分块中查找</p><p>如果长度为n的查找表被均匀地分为了b块，每块s个元素</p><p>$ASL=L_1+L_S$，当$s=\sqrt{n}$时，$ASL$有最小值$\sqrt{n}+1$</p><hr><h2 id="二叉排序树（BST）"><a href="#二叉排序树（BST）" class="headerlink" title="二叉排序树（BST）"></a>二叉排序树（BST）</h2><p>之前介绍过，是左节点值&lt;根节点值&lt;右节点值</p><h3 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在二叉排序树T中查找包含关键字key的元素的结点 </span></span><br><span class="line"><span class="function">BSTree <span class="title">SearchBST</span><span class="params">(<span class="keyword">const</span> BSTree T, <span class="keyword">int</span>  k)</span> </span>&#123;</span><br><span class="line">    BSTree p = T;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == p-&gt;data ) &#123;</span><br><span class="line">            <span class="keyword">return</span> p;<span class="comment">//查找成功 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; p-&gt;data ) &#123;</span><br><span class="line">            p = p-&gt;Lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p = p-&gt;Rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//查找失败，返回空值 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertBST</span><span class="params">(BSTree* treePtr, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化根节点*/</span></span><br><span class="line">    <span class="keyword">if</span> (*treePtr == <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">        *treePtr = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (*treePtr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            (*treePtr)-&gt;data = value;</span><br><span class="line">            (*treePtr)-&gt;Lchild = <span class="literal">NULL</span>;</span><br><span class="line">            (*treePtr)-&gt;Rchild = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d not inserted. No memory available.\n&quot;</span>, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归实现</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 在左子树中插入 */</span></span><br><span class="line">        <span class="keyword">if</span> (value &lt; (*treePtr)-&gt;data) &#123;</span><br><span class="line">            InsertBST(&amp;((*treePtr)-&gt;Lchild), value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 在右子树中插入*/</span></span><br><span class="line">            <span class="keyword">if</span> (value &gt; (*treePtr)-&gt;data) &#123;</span><br><span class="line">                InsertBST(&amp;((*treePtr)-&gt;Rchild), value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;the element is exists&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>有多种情况</p><ol><li>如果是叶子结点，那么直接删除即可</li><li>如果是只有一棵子树，那么让子树代替即可</li><li>如果有两棵子树，那么需要找到被删除结点的直接前驱或后继，代替其位置即可</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BSTree <span class="title">DeleteBST</span><span class="params">(BSTree T, <span class="keyword">int</span>  k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//BSTree p, fatherp, fatherpre, pre;//设指针p指向待删除的节点，q为p的父节点指针</span></span><br><span class="line">                   <span class="comment">//pre为p的直接前驱，fatherpre为pre的父结点 </span></span><br><span class="line">    BSTree p,fatherp,pre,fatherpre;</span><br><span class="line">    p = T;</span><br><span class="line">    fatherp=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;<span class="comment">//寻找被删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> (k == p-&gt;data )<span class="keyword">break</span>;<span class="comment">//找到被删除的节点，退出 </span></span><br><span class="line">        fatherp = p;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; p-&gt;data ) &#123;</span><br><span class="line">            p = p-&gt;Lchild;<span class="comment">//在左子树中查找 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p = p-&gt;Rchild;<span class="comment">//在右子树中查找 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)<span class="keyword">return</span> T;<span class="comment">//没有找到</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;Lchild == <span class="literal">NULL</span>) &#123;<span class="comment">//p无左子树时</span></span><br><span class="line">        <span class="keyword">if</span> (fatherp== <span class="literal">NULL</span>) &#123;</span><br><span class="line">            T = p-&gt;Rchild;<span class="comment">//p为根，删除后，其右子为根 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (fatherp-&gt;Lchild == p) &#123;<span class="comment">//p为q的左子树时，将p的右子树给q的左子树 </span></span><br><span class="line">            fatherp-&gt;Lchild = p-&gt;Rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//p为q的右子树时，将p的右子树给q的右子树 </span></span><br><span class="line">            fatherp-&gt;Rchild = p-&gt;Rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//当p的左子树存在时，寻找p在中序的直接前驱pre</span></span><br><span class="line">        fatherpre = p;</span><br><span class="line">        pre = p-&gt;Lchild;</span><br><span class="line">        <span class="keyword">while</span> (pre-&gt;Rchild) &#123;</span><br><span class="line">            fatherpre = pre;</span><br><span class="line">            pre = pre-&gt;Rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;data = pre-&gt;data;<span class="comment">//以pre节点代替p结点，相当于删除p结点</span></span><br><span class="line">        <span class="keyword">if</span> (fatherpre!= p) &#123;</span><br><span class="line">            fatherpre-&gt;Rchild = pre-&gt;Lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            fatherpre-&gt;Lchild = pre-&gt;Lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(pre);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找效率分析</p><p>在查找运算中，需要对比关键字的次数称为查找长度</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/spiB7H3OoC1jXUT.png" alt="image-20220512143616816" style="zoom:67%;" /></p><p>查找失败的平均查找长度ASL=(3×7+4×2)/9=3.22</p><p>因为没有要求BST平衡，所以查找和插入的时间复杂度在<code>O(n)</code>（最坏情况下形成单枝树)</p><hr><h2 id="平衡二叉树（AVL）"><a href="#平衡二叉树（AVL）" class="headerlink" title="平衡二叉树（AVL）"></a>平衡二叉树（AVL）</h2><p>平衡二叉树，首先是二叉排序树，然后树上任一结点的左子树和右子树的高度之差不超过1</p><p>平衡因子：左子树高-右子树高</p><p>平衡二叉树的平衡因子只有可能是-1,0,1</p><p>定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义二叉排序树</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">int</span> bf;<span class="comment">//balance flag</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span>* <span class="title">lchild</span>, * <span class="title">rchild</span>;</span></span><br><span class="line">&#125;*BSTree, BSTNode;</span><br></pre></td></tr></table></figure><p>让AVL维持平衡是重点，根据不同的插入位置，AVL维持平衡的方法也有不同</p><ol><li><p><strong>LL型</strong></p><p>即在AVL的左孩子的左子树上插入了新节点</p><p>调整方法：<strong>①将A的左孩子B提升为新的根结点；②将原来的根结点A降为B的右孩子；③各子树按大小关系连接(BL和AR不变，BR调整为A的左子树)</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/4VXsFpGtlIQOD7b.png" alt="image-20220512135105861"></p><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 右旋操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R_Rotate</span><span class="params">(BSTNode *p)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//结合图中理解，P是结点A，而lc是结点B</span></span><br><span class="line">    BSTree lc = p-&gt;lchild;   <span class="comment">//定义为根节点的左孩子</span></span><br><span class="line">    p-&gt;lchild = lc-&gt;gtrchild;   <span class="comment">//此时lc的右孩子是null，也就是将A与B断开</span></span><br><span class="line">    lc-&gt;rchild = p;            <span class="comment">//让B的右孩子为A</span></span><br><span class="line">    p = lc;                   <span class="comment">//让B取代A成为根节点</span></span><br><span class="line">&#125;-</span><br></pre></td></tr></table></figure></li><li><p><strong>RR型</strong></p><p>即在AVL的右孩子的右子树上插入了新节点</p><p>调整方法：<strong>①将A的右孩子B提升为新的根结点；②将原来的根结点A降为B的左孩子；③各子树按大小关系连接(AL和BR不变，AR调整为A的右子树)</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/evykRxLC7tAQT21.png" alt="image-20220512141059711"></p><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左旋操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">L_Rotate</span><span class="params">(BSTNode *p)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//结合图中理解，P是结点A，而lc是结点B</span></span><br><span class="line">    BSTree rc = p-&gt;rchild;   <span class="comment">//定义为根节点的右孩子</span></span><br><span class="line">    p-&gt;rchild = rc-&gt;lchild;   <span class="comment">//此时lc的左孩子是null，也就是将A与B断开</span></span><br><span class="line">    lc-&gt;lchild = p;            <span class="comment">//让B的左孩子为A</span></span><br><span class="line">    p = rc;                   <span class="comment">//让B取代A成为根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>LR型</strong></p><p>即在AVL的左孩子的右子树上插入了结点，导致不平衡</p><p><strong>①将B的左孩子C提升为新的根结点；②将原来的根结点A降为C的右孩子；③各子树按大小关系连接(BL和AR不变，CL和CR分别调整为B的右子树和A的左子树)</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/qrSL8R49mxQtsgK.png" alt="image-20220512141340932"></p><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先对B子树做左旋处理，再对A子树做右旋处理</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LR_Rotate</span><span class="params">(BSTNode *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> BSTree lc = p-&gt;lchild;   <span class="comment">//定义为根结点的左孩子</span></span><br><span class="line"> p-&gt;lchild=L_Rotate(lc);   <span class="comment">// 将根节点的左子树左旋</span></span><br><span class="line"> p=R_Rotate(p);           <span class="comment">//整个根节点右旋</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p><strong>RL型</strong></p><p>即在AVL的右孩子的左子树上插入了结点，导致不平衡</p><p><strong>①将B的左孩子C提升为新的根结点；②将原来的根结点A降为C的左孩子；③各子树按大小关系连接(AL和BR不变，CL和CR分别调整为A的右子树和B的左子树)</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/fBTH63qac9Kpory.png" alt="image-20220512142406409"></p><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先对B子树做右旋处理，再对A子树做左旋处理</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RL_Rotate</span><span class="params">(BSTNode *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> BSTree rc = p-&gt;rchild;   <span class="comment">//定义为根结点的右孩子</span></span><br><span class="line"> p-&gt;rchild=R_Rotate(rc);   <span class="comment">// 将根节点的右子树右旋</span></span><br><span class="line"> p=L_Rotate(p);           <span class="comment">//整个根节点左旋</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>不平衡的子树就是需要进行操作树，如果整体不平衡，那就调整整体，总之：RR，LL是下一个当父节点，而RL和LR是跳一个当父节点，C的孩子结点是之前的父节点</strong></p></li></ol><hr><p>求二叉树的平衡因子,即分别求树左子树和右子树的深度，相减即是平衡因子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Factor_Depth_Make</span><span class="params">(Tree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> left,right;</span><br><span class="line">left=right=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(T-&gt;llink)</span><br><span class="line">left=Factor_Depth_Make(T-&gt;llink);</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;rlink)</span><br><span class="line">right=Factor_Depth_Make(T-&gt;rlink);</span><br><span class="line">        T-&gt;bf=left-right;</span><br><span class="line">        T-&gt;depth+=(left&gt;right?left:right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> T-&gt;depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找的时间复杂度不可能超过$O(h)$,平均查找长度为$O(log_2n)$</p><p><code>n</code>层的平衡二叉树，节点数目最少是$F(n)=F(n-1)+F(n-2)+1$</p><hr><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/95jlsYqomO3thk7.png" alt="image-20220524153449378"></p><p>AVL虽然相较于BST的查找效率有所提升，但是对AVL的操作需要频繁调整树的形态，计算平衡因子，找到最小不平衡子树，再进行旋转操作</p><p>红黑树牺牲了平衡性，换来的是不需要频繁调整树的形态，在适用于<strong>频繁插入，删除</strong>的场景，实用性更强，如果单论查找，AVL更好</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rbnode</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> key;</span><br><span class="line">Rbnode *paraent;  <span class="comment">//父节点指针</span></span><br><span class="line">Rbnode *lchild;   </span><br><span class="line">Rbnode* rchild;</span><br><span class="line"><span class="keyword">int</span> color;       <span class="comment">//结点颜色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/k6IZvxHrXCFTlny.png" alt="image-20220524155152233"></p><p>性质：</p><ol><li>每个结点是红色的或者黑色的</li><li>根结点是黑色的</li><li>每个叶结点(NIL)是黑色的</li><li>不存在两个相邻的红结点</li><li>对于每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点</li><li>新加入的结点是红色结点</li></ol><p>推论：</p><ol><li><strong>从根节点到叶子节点的最长路径不大于最短路径的2倍</strong>，当红色节点和黑色节点数量相同时，就是最长路径，也就是黑色节点（或红色节点）* 2</li><li>有<code>n</code>个内部结点的红黑树高度$h&lt;2log_2(n+1)$</li></ol><hr><h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>又称多路平衡查找树，B树中所有结点的孩子的个数的最大值称为B树的阶，通常用m表示，一棵m阶B树应满足以下性质：</p><p><strong>B树就是m叉平衡排序树</strong></p><ol><li>树中每个结点至多有<code>m</code>棵子树，即至多有<code>m-1</code>个关键字</li><li>若根节点不是终端结点，则至少有两棵子树</li><li>除根节点外的所有非叶结点至少有<code>[m/2]</code>（向上取整）棵子树，即至少有<code>[m/2]-1</code>个关键字</li><li>所有叶节点出现在同一层次上，并不带信息，叶子结点<strong>不算入</strong>树的高度</li></ol><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/r8CPnDkG9m35BHp.png" alt="image-20220524162027943"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    ElemType keys[<span class="number">4</span>]; <span class="comment">//4个关键字</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">child</span>[5];</span>  <span class="comment">//5个孩子</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B树：为磁盘而生</p><p>传统用来搜索的平衡二叉树有很多，如 AVL 树，红黑树等。这些树在一般情况下查询性能非常好，但当数据非常大的时候它们就无能为力了。原因当数据量非常大时，内存不够用，大部分数据只能存放在磁盘上，只有需要的数据才加载到内存中。一般而言内存访问的时间约为 50 ns，而磁盘在 10 ms 左右。速度相差了近 5 个数量级，磁盘读取时间远远超过了数据在内存中比较的时间。这说明程序大部分时间会阻塞在磁盘 IO 上。那么我们如何提高程序性能？减少磁盘 IO 次数，像 AVL 树，红黑树这类平衡二叉树从设计上无法“迎合”磁盘</p><p><strong>平衡二叉树是通过旋转来保持平衡的，而旋转是对整棵树的操作，若部分加载到内存中则无法完成旋转操作。</strong>其次平衡二叉树的高度相对较大为$log_2n$，<strong>这样逻辑上很近的节点实际可能非常远，无法很好的利用磁盘预读（局部性原理）</strong>，所以这类平衡二叉树在数据库和文件系统上的选择就被 pass 了</p><p>B树多叉的好处非常明显，有效的降低了B-树的高度，为底数很大的$logn$，底数大小与节点的子节点数目有关，一般一棵B-树的高度在 3 层左右。层数低，每个节点区确定的范围更精确，范围缩小的速度越快（<strong>比二叉树深层次的搜索肯定快很多</strong>）</p><div class="note primary flat"><p>含有<code>n</code>个非叶子结点的<code>m</code>阶B树中总共至少包含$(n-1)([m/2]-1)+1$个关键字，因为非叶子结点至少有$[m/2]-1$个关键字，而根节点最少有1个关键字</p></div><hr><p><strong>插入操作</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/cvP1rSfs298AhEk.png" alt="image-20220524163844052"></p><p>一定是插入到底层结点，如果插入key后导致原结点关键字数超过上限，则从中间位置$[m/2]$，将其中关键字分为两部分，左部分包含关键字放在原结点中，右部分包含关键字放在新结点中，而中间位置$[m/2]$插入原结点的<strong>父节点</strong></p><hr><p><strong>删除操作</strong></p><p>若被删除的关键字在非终端节点，则用直接前驱或直接后继来替代被删除的关键字</p><p>若被删关键字在终端结点，</p><ol><li>被删关键字所在结点中的关键字数目不小于<code>⌈m/2⌉</code>，则只需从该结点删除该关键字</li><li>被删关键字所在结点中的关键字数目等于<code>⌈m/2⌉-1</code>，而与该结点相邻的右兄弟结点（或者左兄弟）结点中的关键字数目大于<code>⌈m/2⌉-1</code>，只需将该兄弟结点中的最小（或者最大）的关键字上移到双亲结点中，然后将双亲结点中小于（或者大于）且紧靠该上移关键字的关键字移动到被删关键字所在的结点中。(兄弟上去，双亲下来)</li><li>被删除关键字所在的结点如果和其相邻的兄弟结点中的关键字数目都正好等于<code>⌈m/2⌉-1</code>，假设其有右兄弟结点，且其右兄弟结点是由双亲结点中的指针 Ai 所指，则需要在删除该关键字的同时，将剩余的关键字和指针连同双亲结点中的 Ki 一起合并到右兄弟结点中。（双亲和兄弟合并）</li></ol><hr><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>B+树是B-树的变体，也是一种多路搜索树, 它与 B- 树的不同之处在于:</p><ol><li>所有关键字存储在叶子节点出现,内部节点(非叶子节点并不存储真正的 data)</li><li>为所有叶子结点增加了一个链指针</li></ol><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/uf3dTG4OScx9H6Z.png" alt="image-20220524164949895"></p><p>所有叶节点包含全部关键字以及指向相应记录的指针，并且相邻叶节点按大小顺序相互链接起来，支持<strong>顺序查找</strong></p><p>和B树的不同之处在于：</p><ol><li><strong>B+树内节点不存储数据，所有 data 存储在叶节点导致查询时间复杂度固定为 log n。而B-树查询时间复杂度不固定，与 key 在树中的位置有关，最好为O(1)。</strong></li><li><strong>B+树叶节点两两相连可大大增加区间访问性，可使用在范围查询等，而B-树每个节点 key 和 data 在一起，则无法区间查找。</strong></li><li><strong>B+树更适合外部存储。由于内节点无 data 域，每个节点能索引的范围更大更精确</strong></li></ol><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/5nxKTdSNh7JwoiP.png" alt="image-20220524165633725"></p><hr><h2 id="散列查找"><a href="#散列查找" class="headerlink" title="散列查找"></a>散列查找</h2><p>散列表(Hash Table)：又称哈希表，是一种数据结构，特点是数据元素的关键字和存储地址直接相关</p><p>用空间换时间，所以时间复杂度为O(1)</p><p>通过<strong>散列函数</strong>建立关键字和存储地址的联系</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/GNVe31b7tYoZmcq.png" alt="image-20220524193048839"></p><p>常见的散列函数有：</p><ol><li><p>除留余数法</p><p>$H(key)=key\%b$     取一个不大于m但最接近或等于m的质数p</p></li><li><p>直接定址法</p><p>$H(key)=a×key+b$      </p><p> a和b是常数，适合关键字的分布基本连续的情况</p></li><li><p>数字分析法</p><p>设关键字是r进制数，而r个数码在各位上出现的频率不一定相同，可能在某些位上分布更加均匀，可以选取更加均匀地若干位作为散列地址</p></li><li><p>平方取中法</p><p>取关键字的平方值的中间几位作为散列地址，这种方法的散列地址与关键字的每位都有关系</p></li></ol><p>如果不同的关键字通过散列函数映射到同一个值，则称位同义词，通过散列函数确定的位置已经存放了其他元素，则称这种情况为冲突</p><p>处理这种冲突有多种方法：</p><ol><li><p>链地址法</p><p>把所有同义词存储在一个链表中</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/16mOidTcQl7RXDI.png" alt="image-20220524193148870"></p><p><strong>装填因子$\alpha$=表中记录数/散列表长度</strong></p></li><li><p>开放定址法</p><p>就是可存放的空闲地址既向同义词表项开放，又向非同义词表项开放</p><p>而线性探测法，就是当发生冲突时，就将表项往后移动一个单位即可，对散列表的查找</p><div class="note primary flat"><p><strong>如果查找到空位置则查找失败，对空位置的判断也要算作是一次比较</strong></p></div><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/P5qHdhMGQOUXwWn.png" alt="image-20220524201123667"></p><p>散列函数为key%7</p><p>$ASL_{成功}=(1+1+1+1+1+1+1+2)/8=1.125$</p><p>因为H(key)肯定是在<strong>0~6之间</strong>的，所以只用考虑在这区间内的查找失败情况</p><p>$ASL_{失败}=(9+8+7+6+5+4+3)/7=6$</p></li></ol><p>   采用开放定址法，删除结点不能简单地将被删结点置空，而是应该做一个标志，方便继续向后查找</p><p>   线性探测法很容易造成同义词和非同义词的<strong>堆积</strong>，影响查找效率</p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.图</title>
      <link href="/post/39739.html"/>
      <url>/post/39739.html</url>
      
        <content type="html"><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>图</strong>是由顶点的有穷非空集合和顶点之间边的集合组成， 通常表示为: G（V，E）， 其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/OLvaXWJd3z5qGgx.png" alt="image-20220512210137535"></p><p>线性表可以是空表，树可以是空树，但是图不可以是空，即V一定是非空集</p><hr><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/z1KmcbnPL4iZDrw.png" alt="image-20220512210442402"></p><p><strong>无向图</strong>：如果E是由无向边的有限集合时，则图G为无向图</p><p><strong>度</strong>：对于无向图，顶点的度指依附于该顶点的边的条数</p><p><strong>无向完全图</strong>：在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。含有n个顶点的无向完全图有$\frac{n(n+1)}{2}$条边</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/mqi15snV4zdSKaA.png" alt="image-20220512210814592"></p><p><strong>有向图</strong>：若E是有向边(弧)的有限集合时，则图G为有向图，弧是顶点的有序对，记为<em><v,w></em>，其中v,w是顶点，<em>v</em>称为弧尾，<em>w</em>称为弧头，<em><v,w></em>称为从顶点<em>v</em>到顶点<em>w</em>的弧，<em><v,w>≠<w,v></em>；</p><p><strong>入度，出度</strong>：对于有向图，入度是以顶点为终点的有向边的数目，记为ID(<em>v</em>)，出度是以顶点为起点的有向边的数目，记为OD(<em>v</em>)，顶点的度等于其入度和出度之和，对于有向图，图的总入度和总出度肯定是相同的</p><p><strong>有向完全图</strong>：在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。含有<code>n</code>个顶点的有向完全图有<code>n× (n-1)</code>条边</p><hr><p><strong>子图</strong>： 假设有两个图<code>G= (V，&#123;E&#125;</code>)和<code>G&#39;= (V&#39;，&#123;E&#39;&#125;)</code>，如果V’是V的子集，且E’是E的子集，则称G’为G的子图。如下图带底纹的图均为左侧无向图与有向图的子图。</p><p><strong>路径和路径的长度</strong>：从顶点A到顶点B的路径是一个顶点序列。路径的长度是路径上的边或弧的数目。有向图的路径也是有向的</p><p><strong>回路</strong>：第一个顶点和最后一个顶点相同的路径称为回路</p><p><strong>简单路径、简单回路或简单环</strong>：序列中顶点不重复出现的路径称为简单路径。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环</p><p><strong>点与点的距离</strong>：从顶点<code>u</code>出发到顶点<code>v</code>的最短路径若存在，则此路径的长度称为从<code>u</code>到<code>v</code>的距离，若不存在路径，则记该距离为无穷($\infty$)</p><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/QeLfHRSBV56qz2U.png" alt="image-20220517160124855" style="zoom:67%;" /></p><p><strong>连通、连通图和连通分量</strong>：在无向图G中，如果从顶点v到顶点v’有路径，则称v和v’是连通的。 如果对于图中任意两个顶点vi、vj ∈E， vi，和vj都是连通的，则称G是连通图</p><p><strong>无向图</strong>中的<strong>极大连通子图</strong>称为<strong>连通分量</strong>。注意连通分量的概念，它强调:</p><ul><li>要是子图；</li><li>子图要是连通的；</li><li>连通子图含有极大顶点数；</li><li>具有极大顶点数的连通子图包含依附于这些顶点的所有边。</li></ul><p>图2，图3，图4都是无向图1的子图，图2是极大连通子图，图3也极大连通子图，图4不满足极大的特点</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/TS2H3xYQXLJDGuE.png" alt="image-20220517160843870" style="zoom:67%;" /></p><p><strong>强连通图和强连通分量</strong>：在有向图G中，如果对于每一对vi，vj属于E，从vi到vj和vj 到vi都有路径，则称G是强连通图。有向图中的极大强连通子图称作有向图的强连通分量。</p><p>即ABCDE组成了一个强连通分量，而F缺乏到B的路径，没有包含在内，F和G单独为一个强连通分量</p><p>每一个孤立结点都构成连通分量</p><hr><p><strong>生成树</strong>：一个极小的连通子图， 它含有图中全部的n个顶点，但只有足以构成一棵树的n-1条边，简而言之就是用最少的边连接所有顶点</p><p><strong>权和网</strong>：有些图的边或弧具有与它相关的数字，这种与图的边或弧相关的数叫做权。这些权可以表示从一个顶点到另一个顶点的距离或耗费。这种带权的图通常称为网</p><p><strong>树</strong>是一种不存在回路，且连通的无向图</p><hr><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>无向图边数的2倍等于各顶点的度数的总和</p><hr><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="邻接矩阵法"><a href="#邻接矩阵法" class="headerlink" title="邻接矩阵法"></a>邻接矩阵法</h3><p>图的邻接矩阵存储方式是用<strong>两个数组来表示图</strong>。一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息</p><p>定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VertexMax 100 <span class="comment">//最大顶点数为100</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxInt 32767 <span class="comment">//表示最大整数，表示 ∞</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Maxsize 100 <span class="comment">//队列最大元素个数100 </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VertexType; <span class="comment">//每个顶点数据类型为字符型</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">int</span> dataType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> Vertex[<span class="number">100</span>];<span class="comment">//存放顶点元素的一维数组,VertexType表示元素的数据类型</span></span><br><span class="line"><span class="keyword">int</span> AdjMatrix[<span class="number">1</span>][<span class="number">100</span>];<span class="comment">//邻接矩阵二维数组 </span></span><br><span class="line"><span class="keyword">int</span> vexnum, arcnum;<span class="comment">//图的顶点数和边数</span></span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找元素v在一维数组 Vertex[] 中的下标，并返回下标 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateVex</span><span class="params">(MGraph* G, <span class="keyword">char</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (v == G-&gt;Vertex[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;No Such Vertex!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结点数为n的图G中，邻接矩阵是<code>n×n</code>大小的，初始化数值为<code>0</code>，如果<code>i</code>行<code>j</code>列数值为<code>1</code>，表示第<code>i</code>个元素到第<code>j</code>个元素存在路径，在无向图中，是双向的，即<code>i</code>行<code>j</code>列以及<code>j</code>行<code>i</code>列数值都会为<code>1</code>，而在有向图中，是单向的</p><p>无向图：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/LyCzKNQmqZjD64B.png" alt="image-20220517170049835"></p><p>有向图：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/4G9PYVzwNU3Mqds.png" alt="image-20220517170107887"></p><p>创建邻接矩阵</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无向图和有向图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateUDG</span><span class="params">(MGraph* G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="comment">//1.输入顶点数和边数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入顶点个数和边数(用逗号隔开)：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>, &amp;G-&gt;vexnum, &amp;G-&gt;arcnum);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.输入顶点元素 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入顶点元素(无需空格隔开)：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, G-&gt;Vertex);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="comment">//3.矩阵初始化</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G-&gt;vexnum; j++)</span><br><span class="line">&#123;</span><br><span class="line">G-&gt;AdjMatrix[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.构建邻接矩阵</span></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">cv1, v2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入边的信息：\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;arcnum; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot; %c%c&quot;</span>, &amp;v1, &amp;v2);</span><br><span class="line">n = LocateVex(G, v1); <span class="comment">//获取v1所对应的在Vertex数组中的坐标 </span></span><br><span class="line">m = LocateVex(G, v2); <span class="comment">//获取v2所对应的在Vertex数组中的坐标</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">-1</span> || m == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NO This Vertex!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">G-&gt;AdjMatrix[n][m] = <span class="number">1</span>;   <span class="comment">// 创建有向图</span></span><br><span class="line"><span class="comment">//G-&gt;AdjMatrix[m][n] = 1;      创建无向图</span></span><br><span class="line">    <span class="comment">//  G-&gt;AdjMatrix[n][m] = w;      将1改为w，而将0改为∞，则是网</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>对于带权图（网）来说，将矩阵里面的值初始化为<code>∞</code>，如果存在路径，则路径的值为权值</p><p>无向网：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/Hzq8dinVEOs7myg.png" alt="image-20220517171039499"></p><p>有向网：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/VcxEn2s5zFteZrM.png" alt="image-20220517171059855"></p><hr><p>对有向图来说</p><p>第<code>i</code>个结点的出度=第<code>i</code>行非零元素个数</p><p>第<code>i</code>个结点的入度=第<code>i</code>列非零元素个数</p><p>第<code>i</code>个结点的度=第<code>i</code>行，第<code>i</code>列非零元素个数之和</p><p>邻接矩阵法求顶点的度的时间复杂度为<code>O(n)</code>，空间复杂度为<code>O(n²)</code>，之和顶点数有关，和实际边数无关，适用用于存储稠密图，而且无向图的邻接矩阵是对称矩阵，可以压缩存储</p><div class="note primary simple"><p><strong>设图G的邻接矩阵为A，则$A^n$的元素$A^n[i][j]$等于由顶点<code>i</code>到顶点<code>j</code>的长度为<code>n</code>的路径的数目</strong></p></div><hr><h3 id="邻接表法"><a href="#邻接表法" class="headerlink" title="邻接表法"></a>邻接表法</h3><p>邻接表由顶点表和边表组成，顶点表是结构体数组，边表是一环一环的链节</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/ZiDEqIHxLljbrnQ.png" alt="image-20220518144342896"></p><p><strong>顶点表</strong>是结构体数组，其中的每个元素有两个域：</p><ul><li><p>数据域（用于存放顶点元素如V1、V2、V3或A、B、C之类的）</p></li><li><p>指针域，用于连接边表。</p></li></ul><p><strong>边表</strong>是结构体，其中每个结点也有两个域：</p><ul><li>下标域，存储的是对应元素在顶点表中的下标。</li><li>指针域，用于连接后续结点</li></ul><div class="note primary simple"><p>邻接表法和树的孩子表示法一模一样，都是顺序+链式存储</p></div><p>定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>//边表 </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> adjvex;<span class="comment">//存储的是该顶点在顶点数组即AdjList[]中的位置  下标域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">next</span>;</span>  <span class="comment">//指针域，用于连接后续结点</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span> //单个顶点 </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">int</span> vertex;  <span class="comment">//数据域   </span></span><br><span class="line"><span class="comment">//int weight；//存储网的时候需要添加此项</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">firstarc</span>;</span>   <span class="comment">//第一个孩子节点  指针域，用于连接边表</span></span><br><span class="line">&#125;VNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> //顶点表 </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">VNode AdjList[VertexMax];<span class="comment">//由顶点构成的结构体数组 </span></span><br><span class="line"><span class="keyword">int</span> vexnum,arcnum; <span class="comment">//顶点数n和边数e </span></span><br><span class="line">&#125;ALGraph;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/EnHsg9ONylz8rBI.png" alt="image-20220518144643827"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/qRZ6A4sWnladHtx.png" alt="image-20220518150702207"></p><p>对于无向图，边节点的数量是<code>2n</code>，整体空间复杂度为<code>V+2n</code></p><p>对于有向图，边节点的数量是<code>n</code>，整体空间复杂度为<code>V+n</code></p><p>在无向图中，如果要求节点的度，遍历节点的边表即可，在有向图中，如果要找有向边的入度，那么需要遍历所有结点</p><p>图的邻接表表示并不唯一，空间复杂度低，适合存放稀疏图</p><hr><h3 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h3><p>因为邻接表法在存储无向图的时候会存储冗余数据，所以利用十字链表的方法，使用邻接多重表来存储无向图</p><p>比起十字链表法，邻接多重表只有边表被扩充了</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/yl4YrtRKDTAaqiM.png" alt="image-20220518160212613" style="zoom:67%;" /></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/VeQGfR4NdKtcig5.png" alt="image-20220518160235586"></p><p>空间复杂度<code>V+n</code>，而且删除边和节点操作变得简单，只适合用存储无向图</p><hr><h3 id="十字链表法"><a href="#十字链表法" class="headerlink" title="十字链表法"></a>十字链表法</h3><p>邻接表法容易求顶点的出度，但不容易求顶点的入度</p><p>如果我们更改邻接表的定义，将有向图中指向该结点的弧记录为孩子，那么就变成了逆邻接表，容易求顶点的入度，但不容易求顶点的出度</p><p>如果把邻接表和逆邻接表结合起来，既可以方便求入度，也可以方便求出度，这就是十字链表法</p><p>顶点结点：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/4I9fbS8hveVa5Tr.png" alt="image-20220518154636296" style="zoom:67%;" /></p><p>弧结点：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/Srt9pvRxMNOZBsQ.png" alt="image-20220518154311640" style="zoom:67%;" /></p><p>相比于邻接表法，顶点表多了一个firstin区域，用于记录指向结点的弧</p><p>边表扩充了一倍，同时记录了弧头顶点编号和弧头相同的下一条弧（橙色部分）</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/nRTih6tqUpdE9xu.png" alt="image-20220518155636604"></p><p>（如果把橙色区域以及指针全去了，就是邻接表法）</p><p>空间复杂度为V+n，只适合存储有向图</p><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/dUvxYiXfDN2jtVJ.png" alt="image-20220518161142466"></p><hr><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/JSxVpUYeB7lKvg9.gif" alt="img"></p><h3 id="广度优先遍历-BFS"><a href="#广度优先遍历-BFS" class="headerlink" title="广度优先遍历(BFS)"></a>广度优先遍历(BFS)</h3><p>类似于树的层次遍历</p><p>即先从某个结点开始，先遍历最离其最近的结点，再遍历到深层的结点</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/dlCsAfBb1SkPnOI.png" alt="image-20220518163613467"></p><p>基本步骤：</p><ol><li><p>设置全局变量<code>visited</code>数组并初始化为全0，代表所有节点均未被访问</p></li><li><p>设置起始点：包括对起始点进行<strong>输出、标记成已访问、入队</strong></p></li><li><p>对后续结点进行操作：由起始点开始，对后续结点进行操作（<strong>输出、标记成已访问、入队</strong>）<br>（步骤2-3为<strong>广度优先搜索</strong>）</p></li><li><p>循环重复2-3的操作避免有“孤岛”结点被遗漏。<br>（步骤4 循环执行广度优先搜索避免遗漏“孤岛”结点，就是广度优先遍历）</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接矩阵法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> visitedBFS[VertexMax];<span class="comment">//定义&quot;标志&quot;数组为全局变量 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(MGraph *G,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line">CyQueue q;    <span class="comment">//队列</span></span><br><span class="line">create(&amp;q);   <span class="comment">//初始化队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.设置起始点 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,G-&gt;Vertex[i]);<span class="comment">//1.输出起始结点 </span></span><br><span class="line">visited[i]=<span class="number">1</span>;<span class="comment">//2.将已访问的结点标志成1</span></span><br><span class="line">EnQueue(&amp;q,i);<span class="comment">//3.将第一个结点入队 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.由起始点开始，对后续结点进行操作 </span></span><br><span class="line"><span class="keyword">while</span>(!QueueEmpty(&amp;q))<span class="comment">//队列非空</span></span><br><span class="line">&#123;</span><br><span class="line">DeQueue(&amp;q,&amp;i);  <span class="comment">//出队  i的值根据出队的元素在变</span></span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G-&gt;vexnum;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(G-&gt;AdjMatrix[i][j]==<span class="number">1</span>&amp;&amp;visited[j]==<span class="number">0</span>) <span class="comment">//如果矩阵内存在路径</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,G-&gt;Vertex[j]);<span class="comment">//输出符合条件的顶点 </span></span><br><span class="line">            visitedBFS[j]=<span class="number">1</span>;<span class="comment">//设置成已访问状态1 </span></span><br><span class="line">            EnQueue(&amp;q,j);<span class="comment">//入队 j的值根据入队的元素在变</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//为了避免孤岛结点无法被遍历到，需要确认visit数组都为1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(MGraph *G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组初始化为全0 </span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;vexnum;i++)</span><br><span class="line">&#123;</span><br><span class="line">visited[i]=<span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;vexnum;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(visited[i]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">BFS(G,i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于BFS，邻接矩阵的遍历序列唯一，邻接表不唯一</p><p>对于无向图，调用BFS函数的次数等于连通分量的次数</p><p>空间复杂度：来自于辅助队列，大小为<code>O(n)</code></p><p>时间复杂度：</p><p>对于邻接矩阵：针对每一个元素<code>i</code>，都会扫描<code>j</code>列来确定是否邻接，所以其时间复杂度为<code>O(n²)</code></p><p>对于邻接表：针对每一个元素<code>i</code>，只需要找其边表即可确定邻接的点，所以时间复杂度为<code>O(n)</code></p><hr><h3 id="深度优先遍历-DFS"><a href="#深度优先遍历-DFS" class="headerlink" title="深度优先遍历(DFS)"></a>深度优先遍历(DFS)</h3><p>类似于树的先序遍历</p><p>基本步骤</p><ol><li>设置全局变量<code>visited</code>数组并初始化为全0，代表所有节点均未被访问</li><li>选取初始端点：对初始端点进行访问，并在<code>visited</code>数值中标记成已访问状态（代码演示的初始端点是<code>G-&gt;Vertex[i]</code>，此时<code>i=0</code>）</li><li>循环对所有节点都执行步骤2，前提是该节点未被访问！（对应函数<code>DFSTraverse</code>，主要用于非连通图能访问到每一个结点）</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> visitedDFS[VertexMax];<span class="comment">//定义&quot;标志&quot;数组为全局变量 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(MGraph* G, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.处理起始点 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, G-&gt;Vertex[i]);<span class="comment">//1.输出起始结点 </span></span><br><span class="line">visitedDFS[i] = <span class="number">1</span>;<span class="comment">//2.将已访问的结点标志成1</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//2.由起始点开始，对后续结点进行操作</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G-&gt;vexnum; j++)<span class="comment">//依次搜索vi的邻接点 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (G-&gt;AdjMatrix[i][j] == <span class="number">1</span> &amp;&amp; visitedDFS[j] == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//当满足有边且未被访问过时，递归调用去查找该邻接点 </span></span><br><span class="line">&#123;</span><br><span class="line">DFS(G, j);<span class="comment">//注意此处的G已经是指针类型，不需要再&amp;G </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(MGraph* G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="comment">//初始化&quot;标志&quot;数组为0，代表未访问</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i++)</span><br><span class="line">&#123;</span><br><span class="line">visitedDFS[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (visitedDFS[i] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">DFS(G, i);<span class="comment">//注意此处的G已经是指针类型，不需要再&amp;G </span></span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于BFS，邻接矩阵的遍历序列唯一，邻接表不唯一</p><p>空间复杂度：来自于递归调用工作栈，大小为<code>O(n)</code></p><p>时间复杂度：</p><p>对于邻接矩阵：针对每一个元素<code>i</code>，都会扫描<code>j</code>列来确定是否邻接，所以其时间复杂度为<code>O(n²)</code></p><p>对于邻接表：针对每一个元素<code>i</code>，只需要找其边表即可确定邻接的点，所以时间复杂度为<code>O(n)</code></p><hr><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>在无向网中，所有路径的权值之和最小的生成树，称为最小生成树(Minimum Cost Spanning Tree)</p><h3 id="普里姆算法-Prim"><a href="#普里姆算法-Prim" class="headerlink" title="普里姆算法(Prim)"></a>普里姆算法(Prim)</h3><p>对<strong>顶点</strong>操作，在<strong>最小生成树的顶点集U</strong>和<strong>待处理顶点集V-U</strong>中，不断地寻找<strong>最短边(代价最小边)</strong>，找到后将对应顶点<strong>加入集合U</strong>，直到所有顶点均处理完毕(V-U里没有剩余顶点)</p><ol><li><p>首先我们需要一个结构体数组：最短路径数组<code>shortedge</code>来存储当前各个顶点之间的最短路径信息，其中的<code>adjvex</code>用于存储最短边的邻接点，<code>lowcost</code>是其对应权值，也就是当前最小的代价</p></li><li><p>对<code>shortedge</code>数组写入初始化信息，将起始点放入集合U中，即 <code>shortedge[k].lowcost=0;</code>lowcost为0表示该顶点属于U集合,<code>k</code>是起始点的位置</p></li><li><p>求最小值的函数（<code>minimal</code>）：只需要在当前<code>shortage</code>数组中比较出<code>lowcost</code>最小的元素，返回它的下标<code>loc</code>即可在<code>Vertex</code>数组中找到该元素。</p></li><li><p>对后续顶点处理：通过<code>minimal</code>函数找到最小路径所对应的的顶点， 将此路径对应的顶点放入集合<code>U</code>中（将其对应的<code>lowcost</code>改为<code>0</code>），更新<code>shortedge</code>数组（集合U中加入新的顶点，阵营U中有可能生成新的最小路径到达阵营V-U中）</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/xpSlz9HwgGi3mkd.png" alt="image-20220518203726957"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//1.结构体数组存储最短路径</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>//最短路径数组结构体(候选最短边) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> adjvex;<span class="comment">//候选最短边的邻接点 </span></span><br><span class="line"><span class="keyword">int</span> lowcost;<span class="comment">//候选最短边的权值 </span></span><br><span class="line">&#125;ShortEdge;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 求最小值的函数(minimal):只需要在当前shortage数组中比较出lowcost最小的元素</span></span><br><span class="line"><span class="comment">//    返回它的下标loc即可在Vertex数组中找到该元素。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimal</span><span class="params">(MGraph* G, ShortEdge* shortedge)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> min, loc;</span><br><span class="line"></span><br><span class="line">min = MaxInt;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; G-&gt;vexnum; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (min &gt; shortedge[i].lowcost &amp;&amp; shortedge[i].lowcost != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">min = shortedge[i].lowcost;</span><br><span class="line">loc = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> loc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MiniSpanTree_Prim</span><span class="params">(MGraph* G, VertexType start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, k;</span><br><span class="line">ShortEdge shortedge[VertexMax];</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.处理起始点start，写入初始信息</span></span><br><span class="line">k = LocateVex(G, start);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i++)</span><br><span class="line">&#123;</span><br><span class="line">shortedge[i].adjvex = start;</span><br><span class="line">shortedge[i].lowcost = G-&gt;AdjMatrix[k][i]; </span><br><span class="line">        <span class="comment">//G是无向网，AdjMatrix[k][i]中存的是权值</span></span><br><span class="line">&#125;</span><br><span class="line">shortedge[k].lowcost = <span class="number">0</span>;<span class="comment">//lowcost为0表示该顶点属于U集合 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.处理后续结点 </span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;vexnum - <span class="number">1</span>; i++)<span class="comment">//对集合U，去找最短路径的顶点 </span></span><br><span class="line">&#123;</span><br><span class="line">k = minimal(G, shortedge);<span class="comment">//找最短路径的顶点 </span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%c-&gt;%c,%d\n&quot;</span>, shortedge[k].adjvex, G-&gt;Vertex[k], shortedge[k].lowcost);</span><br><span class="line">        <span class="comment">//输出找到的最短路径顶，及路径权值 </span></span><br><span class="line">shortedge[k].lowcost = <span class="number">0</span>;<span class="comment">//将找到的最短路径顶点加入集合U中 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G-&gt;vexnum; j++)</span><br><span class="line">            <span class="comment">//U中加入了新的K节点，可能出现新的最短路径，故更新shortedge数组 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (G-&gt;AdjMatrix[k][j] &lt; shortedge[j].lowcost)</span><br><span class="line">                <span class="comment">//有更短路径出现时，将其替换进shortedge数组 </span></span><br><span class="line">&#123;</span><br><span class="line">shortedge[j].lowcost = G-&gt;AdjMatrix[k][j];</span><br><span class="line">shortedge[j].adjvex = G-&gt;Vertex[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>时间复杂度：<code>O(n²)</code>，显然有个嵌套，第一个嵌套是遍历<code>n-1</code>个节点，时间复杂度是<code>O(n)</code>，第二个嵌套中，先要找到最短路径的顶点，即<code>miniaml</code>函数，时间复杂度是<code>O(n)</code>，找到后需要更新<code>shortedge</code>数组，时间复杂度是<code>O(n)</code>，共<code>O(2n)</code>，所有总时间复杂度为<code>O(n²)</code></p><p><strong>适合于稠密图</strong></p><hr><h3 id="克鲁斯卡尔算法-Kruskal"><a href="#克鲁斯卡尔算法-Kruskal" class="headerlink" title="克鲁斯卡尔算法(Kruskal)"></a>克鲁斯卡尔算法(Kruskal)</h3><p><strong>每次选取最短边，但不能构成回路</strong></p><p>如果用邻接矩阵和邻接表，每次寻找最短边都要搜索所有边，故邻接矩阵和邻接表均不合适，所以最终选用了边集数组</p><p><strong>边集数组edge</strong>是一个结构体数组，每一个单元包含起点、终点、权值</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/HvqWrK6ynBQFa43.png" alt="image-20220518205130127" style="zoom:67%;" /></p><p>定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">VertexType begin;<span class="comment">//起点</span></span><br><span class="line">VertexType end;<span class="comment">//终点</span></span><br><span class="line"><span class="keyword">int</span> weight;</span><br><span class="line">&#125;Edge;<span class="comment">//边集数组edge[]的单元 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">VertexType Vertex[VertexMax];<span class="comment">//顶点数组 </span></span><br><span class="line">Edge edge[VertexMax];<span class="comment">//边集数组 </span></span><br><span class="line"><span class="keyword">int</span> vexnum;<span class="comment">//顶点数 </span></span><br><span class="line"><span class="keyword">int</span> edgenum;<span class="comment">//边数 </span></span><br><span class="line">&#125;EdgeGraph;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>选取最短边的关键：排序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选用简单排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(EdgeGraph *E)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line">Edge temp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;E-&gt;edgenum<span class="number">-1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;E-&gt;edgenum;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(E-&gt;edge[i].weight&gt;E-&gt;edge[j].weight)</span><br><span class="line">&#123;</span><br><span class="line">temp=E-&gt;edge[i];</span><br><span class="line">E-&gt;edge[i]=E-&gt;edge[j];</span><br><span class="line">E-&gt;edge[j]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>检查回路：只需要看两个顶点所属的树是否有相同的根节点，使用了<strong>并查集</strong>判断是否成环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindRoot</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> parent[])</span><span class="comment">//t接收到是结点在Vertex数组中的下标 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(parent[t]&gt;<span class="number">-1</span>)<span class="comment">//parent=-1表示没有双亲，即没有根节点 </span></span><br><span class="line">&#123;</span><br><span class="line">t=parent[t];<span class="comment">//逐代查找根节点 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> t;<span class="comment">//将找到的根节点返回，若没有根节点返回自身 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MiniSpanTree_Kruskal</span><span class="params">(EdgeGraph *E)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> num;<span class="comment">//生成边计数器，当num=顶点数-1 就代表最小生成树生成完毕 </span></span><br><span class="line"><span class="keyword">int</span> root1,root2; </span><br><span class="line"><span class="keyword">int</span> LocVex1,LocVex2; </span><br><span class="line"><span class="keyword">int</span> parent[VertexMax];</span><br><span class="line">    <span class="comment">//用于查找顶点的双亲，判断两个顶点间是否有共同的双亲，来判断生成树是否会成环 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.按权值从小到大排序 </span></span><br><span class="line">sort(E);</span><br><span class="line">print(E);</span><br><span class="line"><span class="comment">//2.初始化parent数组 </span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;E-&gt;vexnum;i++)</span><br><span class="line">&#123;</span><br><span class="line">parent[i]=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n 最小生成树(Kruskal):\n\n&quot;</span>);</span><br><span class="line"><span class="comment">//3.</span></span><br><span class="line"><span class="keyword">for</span>(num=<span class="number">0</span>,i=<span class="number">0</span>;i&lt;E-&gt;edgenum;i++)</span><br><span class="line">&#123;</span><br><span class="line">LocVex1=LocateVex(E,E-&gt;edge[i].begin);</span><br><span class="line">LocVex2=LocateVex(E,E-&gt;edge[i].end);</span><br><span class="line">root1=FindRoot(LocVex1,parent);</span><br><span class="line">root2=FindRoot(LocVex2,parent);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(root1!=root2)<span class="comment">//若不会成环，则在最小生成树中构建此边 </span></span><br><span class="line">&#123;</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;\t\t%c-%c w=%d\n&quot;</span>,E-&gt;edge[i].begin,E-&gt;edge[i].end,E&gt;edge[i].weight);</span><br><span class="line">            <span class="comment">//输出此边 </span></span><br><span class="line">parent[root2]=root1;<span class="comment">//合并生成树</span></span><br><span class="line">num++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(num==E-&gt;vexnum<span class="number">-1</span>)<span class="comment">//若num=顶点数-1，代表树生成完毕，提前返回 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>排序算法决定了克鲁斯卡尔算法的时间复杂度</strong>。若采用插入排序，时间复杂度为$O(n²)$ ，若采用堆排序或者快速排序，那么时间复杂度为$O(nlog_2n)$ [注：$n$为边数]，也就是说克鲁斯卡尔算法的时间复杂度<strong>取决于边数，所以适合稀疏图</strong></p><hr><h2 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h2><p>最短路径算法</p><ul><li>对于网（带权图）而言，求两点之间的最短路径有两种算法：迪杰斯特拉（Dijkstra算法）和 弗洛伊德（Floyd算法）</li></ul><ol><li>单源最短路径—迪杰斯特拉算法：从一个起始点出发，到达一个终点</li><li>多源最短路径—弗洛伊德算法：求每一对顶点之间的最短路径</li></ol><h3 id="迪杰斯特拉算法-Dijkstra"><a href="#迪杰斯特拉算法-Dijkstra" class="headerlink" title="迪杰斯特拉算法(Dijkstra)"></a>迪杰斯特拉算法(Dijkstra)</h3><p><strong>迪杰斯特拉算</strong>法处处可见<strong>普里姆算法</strong>的影子，大体上两者都是在寻找当前情况下的最短边，而不同之处在于，<strong>迪杰斯特拉算法做了路程的累加</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/Nc1AOkTHBLmiXZy.png" alt="image-20220523141139432"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindMinDist</span><span class="params">(<span class="keyword">int</span> dist[],<span class="keyword">int</span> s[],<span class="keyword">int</span> vexnum)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> loc;</span><br><span class="line"><span class="keyword">int</span> min=MaxInt+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;vexnum;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s[i]==<span class="number">0</span>)<span class="comment">//只对s[i]=0的顶点进行查找 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dist[i]&lt;min)</span><br><span class="line">&#123;</span><br><span class="line">min=dist[i];</span><br><span class="line">loc=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> loc;<span class="comment">//返回dist中最小元素的下标 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShortestPath_Dijkstra</span><span class="params">(MGraph *G,VertexType start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,num;</span><br><span class="line"><span class="keyword">int</span> loc;</span><br><span class="line"><span class="keyword">int</span> min;</span><br><span class="line"><span class="keyword">int</span> dist[VertexMax];<span class="comment">//最短路径长度数组 </span></span><br><span class="line"><span class="keyword">int</span> path[VertexMax];<span class="comment">//最短路径数组 </span></span><br><span class="line"><span class="keyword">int</span> s[VertexMax];</span><br><span class="line">    <span class="comment">//代表集合S（1代表该顶点已处理，属于集合S；0代表该顶点未处理，不属于集合S，属于集合V-S） </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.初始化dist和path数组 </span></span><br><span class="line">loc=LocateVex(G,start);<span class="comment">//获取源点的下标位置 </span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;vexnum;i++)</span><br><span class="line">&#123;</span><br><span class="line">dist[i]=G-&gt;AdjMatrix[loc][i];<span class="comment">//初始化dist数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dist[i]!=MaxInt)<span class="comment">//初始化path数组</span></span><br><span class="line">&#123;</span><br><span class="line">path[i]=loc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">path[i]=<span class="number">-1</span>;</span><br><span class="line">&#125;  </span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line"><span class="comment">//2.初始化S数组(s数组：代表集合S，1代表该元素属于集合S(已处理的顶点),0该元素不属于集合S(未处理的顶点)) </span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;vexnum;i++)</span><br><span class="line">&#123;</span><br><span class="line">s[i]=<span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line">s[loc]=<span class="number">1</span>;<span class="comment">//代表起始点(源点)以处理完毕 </span></span><br><span class="line">num=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.</span></span><br><span class="line"><span class="keyword">while</span>(num&lt;G-&gt;vexnum)</span><br><span class="line">&#123;</span><br><span class="line">min=FindMinDist(dist,s,G-&gt;vexnum);</span><br><span class="line">        <span class="comment">//在dist数组中查找其对应s[i]=0，即未处理的最小值元素 </span></span><br><span class="line">s[min]=<span class="number">1</span>;<span class="comment">//将找到的最短边所对应的的顶点加入集合S</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;vexnum;i++)<span class="comment">//加入新的顶点后，更新dist和path数组 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((s[i]==<span class="number">0</span>)&amp;&amp;(dist[i]&gt;dist[min]+G-&gt;AdjMatrix[min][i]))<span class="comment">//路径累加</span></span><br><span class="line">&#123;</span><br><span class="line">dist[i]=dist[min]+G-&gt;AdjMatrix[min][i];</span><br><span class="line">path[i]=min;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    num++;</span><br><span class="line">&#125;    </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>时间复杂度：<code>O(n²)</code></p><hr><h3 id="弗洛伊德算法（Floyd）"><a href="#弗洛伊德算法（Floyd）" class="headerlink" title="弗洛伊德算法（Floyd）"></a>弗洛伊德算法（Floyd）</h3><p>多源点意为多起始点，也就是图中所有顶点都将作为起始点，求此顶点到达图中其他所有顶点的最短路径</p><p>在之前学习的Dijskra算法，我们知道Dijskra算法是求解<strong>单源点最短路径</strong>的算法，使用Dijskra算法可以求出一个源点到其他所有顶点的最短路径，那么我们将Dijskra算法循环执行n次（n为顶点数），每次带入图中的一个顶点，不就实现了求解多源最短路吗？</p><p>Dijskra算法执行单次的时间复杂度为$O(n^2)$，其中n为顶点个数，循环执行n次，那么使用Dijskra算法求解多源点最短路径的整体时间复杂度为$O(n^3)$</p><p>此次我们引入的求解多源点最短路径问题的算法是——Floyd算法，时间复杂度也为$O(n^3)$，但是在算法构造和算法可读性上优于执行<code>n</code>次的Dijskra算法</p><p>弗洛伊德的核心思想是：对于网中的任意两个顶点（例如顶点 A 到顶点 B）来说，之间的最短路径不外乎有 2 种情况：</p><ol><li>直接从顶点 A 到顶点 B 的边的权值为顶点 A 到顶点 B 的最短路径。</li><li>从顶点 A 开始，经过若干个顶点，最终达到顶点 B，期间经过的边的权值和为顶点 A 到顶点 B 的最短路径</li></ol><p>所以，弗洛伊德算法的核心为：对于从顶点 A 到顶点 B 的最短路径，拿出网中所有的顶点进行如下判断：<br><code>Dist（A，K）+ Dist（K，B）&lt; Dist（A，B）</code><br>其中，K 表示网中所有的顶点；Dist（A，B） 表示顶点 A 到顶点 B 的距离</p><p>也就是说，拿出所有的顶点 K，判断经过顶点 K 是否存在一条可行路径比直达的路径的权值小，如果式子成立，说明确实存在 一条权值更小的路径，此时只需要更新记录的权值和即可</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/w5vzrhAyQ8L6cZV.png" alt="image-20220523142527193"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dist[VertexMax][VertexMax];</span><br><span class="line"><span class="keyword">int</span> path[VertexMax][VertexMax];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShortestPath_Floyd</span><span class="params">(MGraph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,k;</span><br><span class="line">    <span class="comment">//初始化部分</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;j++)</span><br><span class="line">&#123;</span><br><span class="line">dist[i][j]=G.AdjMatrix[i][j];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dist[i][j]!=MaxInt)</span><br><span class="line">            &#123;</span><br><span class="line">              path[i][j]=i;<span class="comment">//存入前驱 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> path[i][j]=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//Floyd算法核心部分</span></span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;G.vexnum;k++)<span class="comment">//拿出每个顶点作为遍历条件</span></span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">  <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;j++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span>(dist[i][j]&gt;dist[i][k]+dist[k][j])</span><br><span class="line">       &#123;</span><br><span class="line">       dist[i][j]=dist[i][k]+dist[k][j];</span><br><span class="line">       path[i][j]=path[k][j];<span class="comment">//存入前驱 </span></span><br><span class="line">&#125; </span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/coYdWz1hGAVp2B7.png" alt="image-20220523142855434"></p><hr><h2 id="有向无环图描述表达式"><a href="#有向无环图描述表达式" class="headerlink" title="有向无环图描述表达式"></a>有向无环图描述表达式</h2><ol><li>把各个操作数不重复地排成一排</li><li>标出各个运算符的生效顺序</li><li>按顺序加入运算符，注意分层</li><li>从底向上逐层检查同层的运算符是否可以合体</li></ol><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/CUnbVxqmprfkwL5.png" alt="image-20220523144808573" style="zoom:67%;" /></p><hr><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>AOV网（Activity On Vertex NetWork）：用顶点表示活动，边表示活动发生的 <strong>先后关系</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/CLkYwEX1WgKHPoN.png" alt="image-20220523152946305"></p><p>拓扑序列：在AOV网（无环图）中，由顶点$V_i$到顶点$V_j$有一条路径，则在该线性序列中的顶点$V_i$必定在顶点$V_j$之前。</p><p><strong>拓扑排序</strong>：将AOV网中的顶点序列排成拓扑序列就叫拓扑排序。</p><p>拓扑排序条件：必须是<strong>有向无环图</strong>（Directed Acycline Graph），AOV网满足有向无环图条件，若是有向成环图，则会进入死循环。</p><div class="note primary flat"><p>有向无环图只在意图中是否有环，即使不是连通图，也可以是有向无环图</p></div><p>拓扑排序的执行过程相当于每次 删去<strong>入度为0的顶点</strong>和<strong>这个顶点发射出去的边</strong>，那么我们每次删去一个顶点和其发射边，就会生成一个新图，在这个新图上继续执行删去<strong>入度为0的顶点</strong>和<strong>这个顶点发射出去的边</strong>，直到所有顶点都被删完。删除每个顶点的顺序，就是拓扑序列</p><p>步骤：</p><ol><li>我们首先找到入度为0的顶点，然后对其进行输出，接着根据邻接表的邻接关系，找到与其邻接的其他顶点，再去对其他顶点进行相同的处理，由此往复。</li><li>我们需要一个 <strong>临时存取空间space</strong>，我们每次把入度为0的顶点放入space中，然后按顺序（顺序可以从头开始、从尾开始、甚至可以任意取）从space中取出，然后进行<strong>步骤1</strong>的处理，再将更新后入度为0的顶点放入space中，直到space中的元素被取空，即拓扑排序结束。</li><li><strong>临时存取空间space的存取顺序可以是任意的</strong>，所以，这个space可以是栈结构，队列结构，也可以是一个数组，甚至可以是其他（源代码用数组模拟栈结构）。由此可见，存取顺序的不同，直接导致了拓扑排序结果不唯一。</li><li>总结一下拓扑排序在程序中的执行流程：首先我们搞了一个<strong>临时存储空间space</strong>，然后将入度为0的顶点放入space，再按顺序取出，每去取出一次，就根据邻接表的邻接关系，查找当前取出的顶点的邻接点，对每个邻接点入度-1，更新完入度后，看看有没有出现新的入度为0的结点，将其放入space中，直到space为空时，即所有顶点处理完毕，输出的序列就是拓扑序列</li></ol><p>邻接表法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>//边表 </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> adjvex;<span class="comment">//存储的是该顶点在顶点数组即AdjList[]中的位置 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span> //单个顶点 </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> data;  <span class="comment">//数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">firstarc</span>;</span>   <span class="comment">//第一个孩子节点</span></span><br><span class="line">&#125;VNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> //顶点表 </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">VNode AdjList[MAX];<span class="comment">//由顶点构成的结构体数组 </span></span><br><span class="line"><span class="keyword">int</span> vexnum,arcnum; <span class="comment">//顶点数n和边数e </span></span><br><span class="line">&#125;ALGraph;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> indegree[MAX];<span class="comment">//用来存储所有节点的入度之和</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindInputDgeree</span><span class="params">(ALGraph G)</span></span>&#123;<span class="comment">//计算所有节点的入度</span></span><br><span class="line">ArcNode *p;   <span class="comment">//临时边表变量</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; i ++)</span><br><span class="line">indegree[i] = <span class="number">0</span>;         <span class="comment">//初始化入度数组</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; i ++)&#123;</span><br><span class="line">p = G.AdjList[i].firstarc;    <span class="comment">//p设置为顶点的第一条边</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(p)&#123;            <span class="comment">//如果边不为空</span></span><br><span class="line">indegree[p-&gt;adjvex] ++;  <span class="comment">//顶点的对应位置的度+1</span></span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TopologicalSort</span><span class="params">(ALGraph *G)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"> <span class="comment">//用于统计拓扑排序生成的结点数（若生成结点数 &lt; 图的结点数，则代表图中有环，拓扑排序不成功） </span></span><br><span class="line"> <span class="comment">//顺便检测了图中是否存在环</span></span><br><span class="line">    SqStack S;   <span class="comment">//文中说的space就是此处的栈结构</span></span><br><span class="line">    ArcNode *p;<span class="comment">//临时边表变量 </span></span><br><span class="line">    </span><br><span class="line">    InitStack(S);   <span class="comment">//初始化栈</span></span><br><span class="line">    </span><br><span class="line">FindInputDegree(G); <span class="comment">//求入度</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.初始化部分：将初始入度为0的顶点序号入栈</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;vexnum;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(indegree[i]==<span class="number">0</span>)   </span><br><span class="line">&#123;</span><br><span class="line">Push(S,i);    </span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.拓扑排序</span></span><br><span class="line">    <span class="keyword">while</span>(!StackEmpty(S))&#123;</span><br><span class="line">Pop(S,i);    <span class="comment">//pop操作会改变i的值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,G.AdjList[i].data); <span class="comment">//输出栈顶元素 </span></span><br><span class="line">                count++;</span><br><span class="line"> </span><br><span class="line">p = G.AdjList[i].firstarc;  <span class="comment">//p为结点的第一条边</span></span><br><span class="line"><span class="keyword">while</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">             indegree[p-&gt;adjvex]--;       <span class="comment">//p-&gt;adjvex代表的的A--&gt;B中的B的序号1</span></span><br><span class="line"><span class="keyword">if</span>(indegree[p-&gt;adjvex]==<span class="number">0</span>)<span class="comment">//判断去掉一条边后节点的入度是否为零</span></span><br><span class="line">            &#123;</span><br><span class="line">                Push(S,p-&gt;adjvex);  <span class="comment">//如果入度为0，压入栈中</span></span><br><span class="line">            &#125;</span><br><span class="line">p = p-&gt;next;     <span class="comment">//下一条边</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.判断拓扑排序是否成功（生成结点数 &lt; 图的结点数，则代表图中有环，拓扑排序不成功） </span></span><br><span class="line"><span class="keyword">if</span>(count&lt;G-&gt;vexnum) </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;TopologicalSort Failed!\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span>;     </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>邻接矩阵法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接矩阵实现拓扑排序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindInDegree</span><span class="params">(MGraph G)</span></span>&#123;<span class="comment">//计算图中各节点的入度</span></span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; i ++)&#123;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.vexnum; j ++)</span><br><span class="line"><span class="keyword">if</span>(G.AdjMatrix[i][j])<span class="comment">//当两顶点之间存在边时，入度自加</span></span><br><span class="line">indegree[j] ++;  <span class="comment">//列表示入度</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TopologicalSort</span><span class="params">(MGraph G)</span></span>&#123;</span><br><span class="line">FindInDegree(G);</span><br><span class="line">SqStack S;                <span class="comment">//使用栈存储</span></span><br><span class="line"><span class="keyword">int</span> i,j,count = <span class="number">0</span>;</span><br><span class="line">InitStack(S);           <span class="comment">//初始化栈</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; i ++)</span><br><span class="line"><span class="keyword">if</span>(indegree[i]==<span class="number">0</span>)</span><br><span class="line">Push(S,i);<span class="comment">//把入度为零的节点压栈</span></span><br><span class="line">     </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;拓扑序列如下:\n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(!StackEmpty(S))&#123;</span><br><span class="line">Pop(S,i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,G.Vertex[i]);</span><br><span class="line">         count ++;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.vexnum; j ++)&#123;</span><br><span class="line"><span class="keyword">if</span>(G.AdjMatrix[i][j]！=<span class="number">0</span>)&#123;</span><br><span class="line">                indegree[j]--;       <span class="comment">//删除出栈结点向对应的边，让其相邻结点的入度-1</span></span><br><span class="line"><span class="keyword">if</span>(indegree[j]==<span class="number">0</span>)   <span class="comment">//如果入度为0，进栈</span></span><br><span class="line">Push(S,j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(count &lt; G.vexnum)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;此图有环存在!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note primary flat"><p><strong>拓扑排序可以判断图中是否存在环</strong></p></div><hr><p>逆拓扑排序：根据拓扑排序的思路，如果用逆邻接表来存储图，先输出出度为为0的结点，自然构成了逆拓扑排序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(MGraph* G, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.处理起始点 </span></span><br><span class="line"></span><br><span class="line">visitedDFS[i] = <span class="number">1</span>;<span class="comment">//2.将已访问的结点标志成1</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//2.由起始点开始，对后续结点进行操作</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G-&gt;vexnum; j++)<span class="comment">//依次搜索vi的邻接点 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (G-&gt;AdjMatrix[i][j] == <span class="number">1</span> &amp;&amp; visitedDFS[j] == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//当满足有边且未被访问过时，递归调用去查找该邻接点 </span></span><br><span class="line">&#123;</span><br><span class="line">DFS(G, j);<span class="comment">//注意此处的G已经是指针类型，不需要再&amp;G </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, G-&gt;Vertex[i]);<span class="comment">//逆拓扑排序，在出栈时输出 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此，DFS当然也可以用于拓扑排序，只要用队列来存储访问到的结点，就是拓扑排序</p><div class="note prime flat"><p>不如说，利用队列+DFS的方法是代码量最少实现拓扑排序的办法</p></div><p>时间复杂度：邻接表：<code>O(V+E)</code>  邻接矩阵：<code>O(V²)</code></p><hr><h2 id="判断图中是否有环"><a href="#判断图中是否有环" class="headerlink" title="判断图中是否有环"></a>判断图中是否有环</h2><p><strong>DFS</strong></p><p>思路如下，在利用DFS遍历节点时，将遍历节点的<code>visitedDFS[i]</code>数组设置为-1，表示正在访问，如果在之后的递归过程中发现有节点的<code>visitedDFS[i]</code>为-1，则表示有环</p><p>这种方法只能用于有向图，如果要用DFS检测无向图的环，需要一个<code>parent</code>数组记录其父节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(MGraph* G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="comment">//初始化&quot;标志&quot;数组为0，代表未访问</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i++)</span><br><span class="line">&#123;</span><br><span class="line">visitedDFS[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (visitedDFS[i] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">x= DFS(G, i);<span class="comment">//注意此处的G已经是指着类型，不需要再&amp;G </span></span><br><span class="line"><span class="keyword">if</span> (x == <span class="literal">false</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;false&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*深度优先遍历DFS*/</span></span><br><span class="line"><span class="keyword">int</span> visitedDFS[VertexMax];<span class="comment">//定义&quot;标志&quot;数组为全局变量 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DFS</span><span class="params">(MGraph* G, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="comment">//1.处理起始点 </span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span> == visitedDFS[i])</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == visitedDFS[i])</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">visitedDFS[i] = <span class="number">-1</span>;</span><br><span class="line"> <span class="comment">//2.由起始点开始，对后续结点进行操作</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G-&gt;vexnum; j++)<span class="comment">//依次搜索vi的邻接点 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (G-&gt;AdjMatrix[i][j] == <span class="number">1</span>)<span class="comment">//当满足有边时，递归调用去查找该邻接点 </span></span><br><span class="line">    <span class="comment">//此处要把visitedDFS[j] == 0的条件删掉，因为有向无环图是不可能递归到父节点的</span></span><br><span class="line">&#123;</span><br><span class="line">DFS(G, j);<span class="comment">//注意此处的G已经是指针类型，不需要再&amp;G </span></span><br><span class="line"><span class="keyword">if</span> (DFS(G,j) == <span class="literal">false</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">visitedDFS[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>拓扑排序</strong></p><p>在上一小节中已经使用了拓扑排序来判断是否存在有向环了，而使用拓扑排序同样可以判断一个无向图中是否存在环，只要将入栈条件从度为0的结点，改成度为0或1的结点即可</p><hr><p><strong>并查集</strong></p><p>并查集可以找到无向图的环，在最小生成树的克鲁斯卡尔算法（使用了边集数组）中，就已经使用了并查集来寻找图中的环</p><hr><p>总结<br>无向图：</p><ul><li>DFS(需要数组记录父节点)</li><li>拓扑排序(将度为0和1的结点压入栈)</li><li>并查集(克鲁斯卡尔算法)</li></ul><p>有向图：</p><ul><li>DFS(给visit数组多设置一个状态变量表示正在搜索)</li><li>拓扑排序(将度为1的结点压入栈)</li></ul><hr><h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h2><p><strong>AOE网（Activity On Edge NetWork）</strong>：在带权有向图中若以顶点表示事件，有向边表示活动，边上的权值表示该活动持续的时间，AOE网通常用于 <strong>估算事件/工程完成的工期（时间）</strong></p><p>从定义上来看，很容易看出两种网的不同，AOV网的活动以顶点表示，而AOE网的活动以有向边来表示，<strong>AOV网的有向边仅仅表示活动的先后次序</strong>。纵观这两种网图，其实它们总体网络结构是一样的，仅仅是活动所表示的方式不同，因此可以猜想从AOV网转换成AOE网应该是可行的</p><p><strong>关键路径</strong>：在AOE网中仅有一个入度为0的点，称为开始顶点，它表示整个工程的开始，也仅有一个出度为0的点，称为结束顶点，代表整个工程的结束，这两个点之间的距离有很多条，<strong>在所有路径中，具有最大路径长度的路径称为关键路径，而把关键路径上的活动称为关键活动</strong></p><div class="note primary flat"><p>所以求关键路径非常简单，只需要在图中找出权值和最大的一条或多条路即可，关键活动的最早和最晚发生时间一致，而非关键活动的最晚发生时间只需要和关键活动同时发生就行了</p></div><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/Uckt7lqYhPpGEK8.png" alt="image-20220523160028568"></p><ol><li>事件$v_i$的最早发生时间ve(i)：事件$v_i$的最早发生时间是等待$v_i$之前的所有活动都完成，所以ve(i)是从源点到vi的最长路径长度。起始点（源点）的最早发生时间为0。（$v_k$是$v_i$的前驱事件）<br>所以可以推出：<br><code>ve(0) = 0;</code>（源点的<strong>最早发生时间</strong>为0）<br><code>i∈[1,n]时，ve(i) = Max&#123; ve(k) + weight（k-&gt;i）&#125; ;</code></li><li>事件$v_i$的最晚发生时间vl(i)：不拖延工期的前提下，事件vi被允许的最晚发生时间。（$v_k$是$v_i$的后续事件）活动ai=&lt;$v_i$,$v_k$&gt;,$v_i$的最晚发生时间，取决于这个活动<strong>被允许的最晚结束时间</strong>，而所被<strong>允许的最晚结束时间</strong>也正是vk的最晚开始时间，也就是vl（k），所以我们就得到等式:<br><code>最晚发生时间vl（i）+ 活动持续时间weight = 最晚结束时间vl（k）</code><br>所以可以推出：<br><code>vl(n-1) = ve(n-1);</code>（汇点的<strong>最早发生时间</strong>与<strong>最晚发生时间</strong>相等）<br><code>i∈[0,n-2]时，vl(i) = Min&#123; vl(k) - weight（i-&gt;k）&#125; ;</code></li></ol><hr><p>步骤：</p><ol><li>求出事件最早发生时间ve[i]：顺拓扑序</li><li>求出事件最晚发生时间vl[i]：逆拓扑序</li><li>通过ve[i]和vl[i]计算出活动最早开始时间（e） 与 活动最晚开始时间（l）</li><li>若<code>e(i)==l(i)</code>则当前i所指向的活动是关键活动（Critical Activity）</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CriticalPath</span><span class="params">(ALGraph *G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> j,k;<span class="comment">// &lt;Vj,Vk&gt;</span></span><br><span class="line"><span class="keyword">int</span> e,l;<span class="comment">//活动最早开始时间/活动最晚开始时间  </span></span><br><span class="line"><span class="keyword">int</span> topo[VertexMax];<span class="comment">//拓扑数组，用于存储拓扑排序结果（存储内容是每个结点的坐标） </span></span><br><span class="line"><span class="keyword">int</span> ve[VertexMax]; <span class="comment">//事件vi的最早发生时间 </span></span><br><span class="line"><span class="keyword">int</span> vl[VertexMax]; <span class="comment">//事件vi的最晚发生时间 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.调用拓扑排序，检测图是否存在环 </span></span><br><span class="line"><span class="keyword">if</span>(!TopologicalSort(G,topo))<span class="comment">//若拓扑排序成功，topo数组也将处理完毕 </span></span><br><span class="line"> <span class="keyword">return</span>; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//2.正拓扑排序，求出事件最早发生时间 </span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;vexnum;i++)</span><br><span class="line">    ve[i]=<span class="number">0</span>;<span class="comment">//所有ve都初始化为0</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;vexnum;i++)</span><br><span class="line">&#123;</span><br><span class="line">j=topo[i];<span class="comment">//j为起始点，k为终点 </span></span><br><span class="line">p=G-&gt;AdjList[j].firstarc;<span class="comment">//用指针p去依次寻找j的每一个邻接点 </span></span><br><span class="line"><span class="keyword">while</span>(p)</span><br><span class="line">&#123;</span><br><span class="line">k=p-&gt;adjvex;</span><br><span class="line"><span class="keyword">if</span>(ve[k]&lt;ve[j]+p-&gt;weight)</span><br><span class="line">             <span class="comment">//根据j的邻接点k，不断更新ve[]的值（选出最大值，原理类似于选择排序） </span></span><br><span class="line">&#123;</span><br><span class="line">ve[k]=ve[j]+p-&gt;weight;</span><br><span class="line">&#125;</span><br><span class="line">p=p-&gt;next;    </span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//3.逆拓扑排序，求出事件最迟发生时间 </span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;vexnum;i++)</span><br><span class="line">    vl[i]=ve[G-&gt;vexnum<span class="number">-1</span>];<span class="comment">//所有vl都初始化为ve[G-&gt;vexnum-1]</span></span><br><span class="line"><span class="keyword">for</span>(i=G-&gt;vexnum<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">j=topo[i];</span><br><span class="line">p=G-&gt;AdjList[j].firstarc;<span class="comment">//让p去依次查找邻接点 </span></span><br><span class="line"><span class="keyword">while</span>(p)</span><br><span class="line">&#123;</span><br><span class="line">k=p-&gt;adjvex;</span><br><span class="line"><span class="keyword">if</span>(vl[j]&gt;vl[k]-p-&gt;weight)</span><br><span class="line">               <span class="comment">//根据j的邻接点k，不断更新vl[]的值（选出最小值，原理类似于选择排序）</span></span><br><span class="line">&#123;</span><br><span class="line">vl[j]=vl[k]-p-&gt;weight;</span><br><span class="line">&#125;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;       </span><br><span class="line"><span class="comment">//4.计算e和l，通过判断e是否等于l确定该活动是否是关键活动，从而确定关键路径</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;vexnum;i++)</span><br><span class="line">&#123;</span><br><span class="line">p=G-&gt;AdjList[i].firstarc;<span class="comment">//让p去依次查找邻接点 </span></span><br><span class="line"><span class="keyword">while</span>(p)</span><br><span class="line">&#123;</span><br><span class="line">j=p-&gt;adjvex;</span><br><span class="line">e=ve[i];<span class="comment">//计算活动最早开始时间 e </span></span><br><span class="line">l=vl[j]-p-&gt;weight;<span class="comment">//计算活动最晚开始时间 l </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(e==l)<span class="comment">//如果e=l，说明该活动是关键活动 </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//把每个关键活动输出，即是关键路径</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t%c-&gt;%c(%d)\n&quot;</span>,G-&gt;AdjList[i].vertex,G-&gt;AdjList[j].vertex,p-&gt;weight);</span><br><span class="line">&#125;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.树</title>
      <link href="/post/30685.html"/>
      <url>/post/30685.html</url>
      
        <content type="html"><![CDATA[<h1 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h1><h2 id="树的逻辑结构"><a href="#树的逻辑结构" class="headerlink" title="树的逻辑结构"></a>树的逻辑结构</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>树形结构，即是从树根生长，逐级分支的结构</p><p>结点数为<code>0</code>的树称为空树，非空树的特性是：有且仅有一个根节点，除了根节点外，任何一个结点都有且仅有一个前驱</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/R5oDNluqSA8rGvg.png" alt="image-20220509152907265"></p><p>子树：树可以分为<code>m</code>个互不相交的有限集合，其中每个集合本身又是一棵树，并且称为根节点的子树</p><p>树是一种<strong>递归定义</strong>的数据结构</p><p>结点的度：即结点孩子的数量</p><p>树的度：各结点的度的最大值</p><p>森林：<code>m</code>棵互不相交的树的集合</p><hr><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ol><li><p><strong>结点数=总度数+1</strong></p><p>这个较好理解，总度数就是除了根节点之外的结点数，或者说，总度数就是树的”树枝“</p><p><strong>对于森林来说，结点数=总度数+树的数量</strong></p></li><li><p>度为<code>m</code>的树是指结点的度的最大值，而<code>m</code>叉树是指，每个结点最多只能有<code>m</code>个孩子，实际上即使没有也可以</p></li><li><p>度为<code>m</code>的树的第<code>i</code>层至多有$m^{i-1}$个结点</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/TKCe5tsk2WDAil1.png" alt="image-20220509154338974"></p></li><li><p>由3可知，把每层的结点加起来，根据等比数列求和，高度为h的m叉树最多有$\frac{m^h-1}{m-1}$个结点</p></li><li><p>高度为<code>h</code>的<code>m</code>叉树至少有<code>h</code>个结点，高度为<code>h</code>，度为<code>m</code>的树至少有<code>h+m-1</code>个结点</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/bd8ErWAmqXPDTRh.png" alt="image-20220509154723746"></p></li></ol><hr><h2 id="二叉树的逻辑结构"><a href="#二叉树的逻辑结构" class="headerlink" title="二叉树的逻辑结构"></a>二叉树的逻辑结构</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>二叉树是<code>n</code>个结点的有限集合，<code>n</code>为<code>0</code>时是空二叉树，<code>n&gt;0</code>时是由一个根节点和两个互不相交的被称为根的左子树和右子树组成</p><p>特点：每个结点至少只有两棵子树，左右子树不能颠倒</p><p>几种特殊的二叉树：</p><ol><li><p><strong>满二叉树</strong></p><p>一颗高度为h，且含有$2^h-1$个结点的二叉树</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/gNfn1iuyLDh3drF.png" alt="image-20220509155321356"></p><p>只有最后一层有叶子结点，而且不存在度为1的结点</p></li><li><p><strong>完全二叉树</strong></p><p>当且仅当每个结点都与高度为<code>h</code>的满二叉树中编号为<code>1~n</code>的结点一一对应时，称为完全二叉树</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/7fYEilKtCsFPLV6.png" alt="image-20220509160245884"></p><p><strong>最多只有一个度为1的结点，$i≤[n/2]$为分支结点，$i＞[n/2]$为叶子结点</strong></p></li><li><p><strong>二叉排序树（BST）</strong></p><p>左子树上所有结点的关键字均小于根节点的关键字</p><p>右节点上所有结点的关键字均大于根节点的关键字</p><p>左子树和右子树又均是一颗二叉排序树</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/f8hml1qnVjBiLIA.png" alt="image-20220509160730761"></p></li><li><p><strong>平衡二叉树（AVL）</strong></p><p>树上任一结点的左子树和右子树的深度之差不超过1</p></li></ol><hr><h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h3><p>设非空二叉树中度为0,1,2的结点个数分别为$n_0,n_1,n_2$，则$n_0=n_2+1$，即叶子结点比二分支结点多一个</p><p>推导过程：已知树的结点数=总度数+1 即$n=n_1+2n_2+1$，同时$n=n_0+n_1+n_2$，所以可以推出$n_0=n_2+1$</p><hr><p>完全二叉树</p><ol><li>具有<code>n</code>个结点的完全二叉树的高度<code>h</code>为$log_2(n+1)$或$[log_2n]+1$</li><li>对于完全二叉树， 已知其最多只有一个度为1的结点，$n_1=0或1$，而二叉树有性质$n_0=n_2+1$,所以$n=n_1+2n_2+1$，如果完全二叉树有偶数个结点，那么$n_1$为1，奇数个为0</li></ol><hr><h2 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h2><h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><p><strong>定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    ElemType value;</span><br><span class="line">    <span class="keyword">bool</span> isEmpty;</span><br><span class="line">&#125;;</span><br><span class="line">TreeNode t[MaxSize];</span><br></pre></td></tr></table></figure><p>用数组存储二叉树的结点，一定要把二叉树的结点编号与完全二叉树对应起来</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/WlhZY4pvMJS9cNt.png" alt="image-20220509165446882"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/pTdJBoPuywaltMh.png" alt="image-20220509165426378"></p><p>在最坏的情况下，二叉树为右单枝树，也至少需要$2^h-1$个存储单元，结论是二叉树的顺序存储结构，只适合存储完全二叉树</p><hr><h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h3><p><strong>定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>* <span class="title">lchild</span>, * <span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode, * BiTree;</span><br></pre></td></tr></table></figure><p><del>（有两个指针域的链表罢了)</del></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/mvu7osSFTx81dfJ.png" alt="image-20220509170458898"></p><p><code>n</code>个结点的二叉链表共有<code>n+1</code>个空链域</p><hr><p><strong>创建二叉树</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBiTree</span><span class="params">(BiTree* T)</span>  <span class="comment">// 双重指针，因为需要修改根节点的指向，就是需要修改root的值，所以应该传入指向root的地址，这样在被调用的函数中，对*T的操作等价于操作root</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;ch);</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">        *T = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        *T = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">        <span class="keyword">if</span> (!*T)</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        (*T)-&gt;data = ch;</span><br><span class="line">        CreateBiTree(&amp;(*T)-&gt;lchild);<span class="comment">// 递归创建</span></span><br><span class="line">        CreateBiTree(&amp;(*T)-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>遍历：按照某种次序把所有结点都访问一遍</p><p>一共有4种遍历</p><ol><li><strong>先序遍历</strong>：对于二叉树和其子树，先访问二叉树的根节点，然后是左孩子，然后是右孩子 （根左右）</li><li><strong>中序遍历</strong>：对于二叉树和其子树，先访问二叉树的左孩子，然后是根节点，然后是右孩子    (左根右)</li><li><strong>后序遍历</strong>：对于二叉树和其子树，先访问二叉树的左孩子，然后是右孩子，然后是根节点       （左右根）</li><li><strong>层序遍历</strong>：按照二叉树的分层，从左到右依次访问</li></ol><p>先序，中序，后序遍历的代码实现（递归）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的先序，中序，后序遍历(递归)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">//  printf(&quot;%c &quot;, T-&gt;data);  先序</span></span><br><span class="line">    PreOrderTraverse(T-&gt;lchild);</span><br><span class="line">  <span class="comment">//  printf(&quot;%c &quot;, T-&gt;data);  中序</span></span><br><span class="line">    PreOrderTraverse(T-&gt;rchild);</span><br><span class="line">  <span class="comment">//  printf(&quot;%c &quot;, T-&gt;data);  后序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以很明显的看出，三种遍历方式的不同之处在于，在何时对二叉树结点进行操作</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/kxyqeUEHIM42uBP.png" alt="image-20220510140133236"></p><p>对二叉树进行遍历，模拟访问路径，红色路线表示第一次访问，绿色路线表示第二次访问，紫色表示第三次访问</p><p>可以看出，第一次访问就出栈是前序遍历，第二次访问就出栈是中序遍历，第三次访问就出栈是后序遍历</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栈的顺序结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    BiTree data[MAX]; <span class="comment">//定义一个数组，用来存储二叉树的结点指针</span></span><br><span class="line">    <span class="keyword">int</span> top; <span class="comment">//定义一个整型变量，用来表示栈顶指针的位置</span></span><br><span class="line">&#125;Stack;  <span class="comment">//用栈来存储结点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(BiTree T)</span> </span>&#123; <span class="comment">//定义一个函数，用来实现非递归的前序遍历，参数是二叉树的根结点指针</span></span><br><span class="line">    Stack s; <span class="comment">//声明一个栈变量</span></span><br><span class="line">    s.top = <span class="number">-1</span>; <span class="comment">//初始化栈为空，栈顶指针为-1</span></span><br><span class="line">    BiTree p = T; <span class="comment">//声明一个二叉树结点指针变量，用来指向当前访问的结点，初始为根结点</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> || s.top != <span class="number">-1</span>) &#123; <span class="comment">//循环条件是当前结点不为空或者栈不为空，表示还有结点没有访问完</span></span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123; <span class="comment">//如果当前结点不为空，表示还可以继续向左子树访问</span></span><br><span class="line">            s.data[++s.top] = p; <span class="comment">//将当前结点入栈，同时栈顶指针加一</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, p-&gt;data); <span class="comment">//打印当前结点的数据，这是前序遍历的访问操作</span></span><br><span class="line">            p = p-&gt;lchild; <span class="comment">//将当前结点指向其左子结点，继续向左子树访问</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//如果当前结点为空，表示左子树已经访问完毕，需要回溯到上一个结点，并访问其右子树</span></span><br><span class="line">            p = s.data[s.top--]; <span class="comment">//将栈顶元素出栈，并赋值给当前结点指针，同时栈顶指针减一</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, p-&gt;data); <span class="comment">//打印当前结点的数据，这是中序遍历的访问操作</span></span><br><span class="line">            p = p-&gt;rchild; <span class="comment">//将当前结点指向其右子结点，继续向右子树访问</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于第三次访问，则需要增加一个辅助栈来记录访问次数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归利用顺序栈来进行后序遍历</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>  data[MAX];</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125;Stack1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    Stack s;</span><br><span class="line">    s.top = <span class="number">-1</span>;</span><br><span class="line">    Stack1 flagStack;   <span class="comment">//记录每个节点访问次数栈</span></span><br><span class="line">    BiTree p = T;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> || s.top != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;     <span class="comment">//第一次访问，flag置1，入栈</span></span><br><span class="line">            s.data[++s.top] = p;</span><br><span class="line">            flagStack.data[s.top] = <span class="number">1</span>;</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//（p == NULL）</span></span><br><span class="line">            <span class="keyword">if</span> (flagStack.data[s.top] == <span class="number">1</span>) &#123;  <span class="comment">//第二次访问，flag置2，取栈顶元素但不出栈</span></span><br><span class="line">                p = s.data[s.top];</span><br><span class="line">                flagStack.data[s.top] = <span class="number">2</span>;</span><br><span class="line">                p = p-&gt;rchild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;         <span class="comment">//第三次访问，出栈</span></span><br><span class="line">                p = s.data[s.top--];</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, p-&gt;data);    <span class="comment">//出栈时，访问输出</span></span><br><span class="line">                p = <span class="literal">NULL</span>;      <span class="comment">//p置空，以便继续退栈</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>层序遍历</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/le5gPTWnYANc6Ei.png" alt="image-20220510144707198"></p><p>需要构造一个辅助队列，如队列非空，则队头结点出队，访问该结点，并将其左右孩子插入队尾，直到队列为空</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义层次遍历中辅助队列的结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">queue</span> &#123;</span></span><br><span class="line">    BiTree data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">queue</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode,*PNODE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义辅助队列的队头队尾指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    LinkNode* front, * rear;</span><br><span class="line">&#125;LinkQueue,*PQUEUE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化队列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(PQUEUE Q)</span> </span>&#123;</span><br><span class="line">    Q-&gt;front = Q-&gt;rear = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode)); </span><br><span class="line">    Q-&gt;front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进队操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(PQUEUE Q, BiTree x)</span> </span>&#123;</span><br><span class="line">    PNODE s = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Q-&gt;rear-&gt;next = s;</span><br><span class="line">    Q-&gt;rear = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队操作</span></span><br><span class="line"><span class="function">BiTree <span class="title">DeQueue</span><span class="params">(PQUEUE Q)</span> </span>&#123;</span><br><span class="line">    PNODE p = Q-&gt;front-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">    Q-&gt;front-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;rear == p)</span><br><span class="line">        Q-&gt;rear = Q-&gt;front;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 层次遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    InitQueue(&amp;Q);</span><br><span class="line">    BiTree p=<span class="literal">NULL</span>;</span><br><span class="line">    EnQueue(&amp;Q, T);</span><br><span class="line">    <span class="keyword">while</span> (Q.front!=Q.rear) &#123;  <span class="comment">//判断是否队空</span></span><br><span class="line">        p=DeQueue(&amp;Q);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, p-&gt;data);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">            EnQueue(&amp;Q, p-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">            EnQueue(&amp;Q, p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据遍历构造二叉树</p><p>根据一种遍历顺序是无法得到二叉树结构的，需要<strong>中序和其他任一遍历序列</strong>才能构造出二叉树</p><hr><p>寻找任一二叉树结点的父节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">getParent</span><span class="params">(TreeNode root,TreeNode p)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(root == <span class="keyword">null</span> ||root.left == p || root.right == p) <span class="keyword">return</span> root; <span class="comment">//树为空，或者p是root的子节点，返回root  </span></span><br><span class="line"></span><br><span class="line">    TreeNode left = getParent(root.left,p); <span class="comment">//root的左孩子 是否为p的父节点</span></span><br><span class="line">    <span class="keyword">if</span>(left != <span class="keyword">null</span>) <span class="keyword">return</span> left;  <span class="comment">//是的话，return left，无需找右子树</span></span><br><span class="line">    TreeNode right = getParent(root.right,p); <span class="comment">//root的右孩子 是否为p的父节点</span></span><br><span class="line">    <span class="keyword">if</span>(right != <span class="keyword">null</span>) <span class="keyword">return</span> right;  <span class="comment">//是的话，return right</span></span><br><span class="line">    <span class="keyword">return</span> left; <span class="comment">//左右子树都不包含p，返回 null; (return right 同样是null)</span></span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="线索化二叉树"><a href="#线索化二叉树" class="headerlink" title="线索化二叉树"></a>线索化二叉树</h3><p>二叉树的问题：</p><ol><li>建立二叉树时，<code>n</code>个结点的二叉树总共有<code>2n</code>个指针域，会有<code>n+1</code>个指针域被浪费</li><li>在创建二叉树的时候，大部分算法都是用递归实现，实现起来简单，然而系统运行起来却很吃力，很占用系统资源。当我们在建立好二叉树之后我们需要频繁的查找某个单元，就得频繁的调用遍历递归去查找，这显然并不高效</li></ol><p>结合这两个问题，解决办法是<strong>用这些空指针域，存放一些有用的指向信息，从而尽量的将一棵二叉树线性化成双向链表</strong>，我们把这些<strong>指向信息</strong>称之为<strong>线索</strong>，<strong>也就是说线索二叉树等效成双向链表</strong></p><p>中序遍历</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/DjkWZq3w1GSBbQR.png" alt="image-20220511141151393" style="zoom:67%;" /></p><p>先序遍历</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/bBamOZNiFM9jcIx.png" alt="image-20220511163802955" style="zoom:67%;" /></p><p>后序遍历</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/jDtMLRZykrbA75W.png" alt="image-20220511163932656" style="zoom:67%;" /></p><hr><p>结点的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将原来的三个域扩展到五个域</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">dataType data; <span class="comment">//根节点的值 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">lchild</span>;</span> <span class="comment">//左孩子 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">rchild</span>;</span> <span class="comment">//右孩子 </span></span><br><span class="line"><span class="keyword">int</span> ltag; <span class="comment">//左标记</span></span><br><span class="line"><span class="keyword">int</span> rtag; <span class="comment">//右标记</span></span><br><span class="line">&#125;BiTree; </span><br></pre></td></tr></table></figure><hr><p>创建并初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BiTree *<span class="title">creat</span><span class="params">()</span> <span class="comment">//二叉树的创建及初始化(初始化左右标记为0) </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dataType value;</span><br><span class="line">BiTree *t;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;value);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(value==<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">t=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">t=(BiTree *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTree));</span><br><span class="line">t-&gt;data=value;</span><br><span class="line">t-&gt;ltag=<span class="number">0</span>;<span class="comment">//初始化左标记为0 </span></span><br><span class="line">t-&gt;rtag=<span class="number">0</span>;<span class="comment">//初始化右标记为0 </span></span><br><span class="line">t-&gt;lchild=creat();</span><br><span class="line">t-&gt;rchild=creat();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p>中序化二叉树</p><ul><li>利用两个指针<code>p</code>和<code>pre</code>，让其在中序遍历的过程中分别指向一前一后，也就是说始终保持p是<code>pre</code>的后继，<code>pre</code>是<code>p</code>的前驱；那么在处理到<code>p</code>结点的时候，我们可以根据p节点是否有左孩子来判断，<code>p-&gt;lchild</code>是否要指向<strong>前驱</strong>，若<code>p</code>指向的节点没有左孩子，则直接让<code>p-&gt;lchild=pre;</code>并将<code>p-&gt;ltag</code>赋值为1，即可完成将结点的左孩子指向<strong>前驱结点</strong>。<code>pre</code>也一个道理，若<code>pre</code>所指向的节点没有右孩子，将<code>pre-&gt;rchild=p;</code>并即将<code>pre-&gt;rtag</code>赋值为1，即可完成该结点的右孩子指向<strong>后继节点</strong></li><li>整体思路就是：<strong>通过<code>p</code>来处理左孩子指向前驱（左孩子为空的情况下），通过<code>pre</code>来处理右孩子指向后继（右孩子为空的情况下）</strong></li></ul><p><code>pre</code>与<code>p</code>指针功能相同，但定义却不相同，<code>p</code>是线索化函数内的局部变量，而<code>pre</code>为了保证在每一次递归序列中能够正确返回当前值，必须定义成全局变量 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为我们是以中序遍历的顺序给二叉树填上线索，所以，整个线索化的函数是套用在中序遍历的框架下的。</span></span><br><span class="line"><span class="comment">// 线索化二叉树就是给二叉树的基础上，添加能完整表示出二叉树节点前驱后继的指针</span></span><br><span class="line">BiTree *pre=<span class="literal">NULL</span>; <span class="comment">//定义全局变量pre</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThreaded</span><span class="params">(BiTree* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//  后序化二叉树</span></span><br><span class="line">   <span class="comment">//InThreaded(p-&gt;lchild);  递归遍历右子树</span></span><br><span class="line">       <span class="comment">//InThreaded(p-&gt;rchild);  递归线索化左子树</span></span><br><span class="line"></span><br><span class="line">InThreaded(p-&gt;lchild); <span class="comment">// 递归线索化左子树，直到找到首结点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p-&gt;lchild==<span class="literal">NULL</span>)   <span class="comment">//如果当前结点没有左子树，那么需要给其添加前驱的指针</span></span><br><span class="line">&#123;</span><br><span class="line">p-&gt;ltag = <span class="number">1</span>;       <span class="comment">//标志为1，表示其前驱</span></span><br><span class="line">p-&gt;lchild = pre;    <span class="comment">// 那么当前结点的前驱就是pre</span></span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">// 如果上个结点没有右子树，那么他的后继就是p，即当前结点</span></span><br><span class="line"><span class="keyword">if</span> (pre!=<span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild==<span class="literal">NULL</span>) </span><br><span class="line">            <span class="comment">// 如果当前结点的前驱不是NULL，或者前驱的右孩子不存在</span></span><br><span class="line">&#123;</span><br><span class="line">pre-&gt;rtag = <span class="number">1</span>;              <span class="comment">// 标志为1，表示为后继    </span></span><br><span class="line">pre-&gt;rchild = p;            <span class="comment">// 那么前驱的后继就是当前结点</span></span><br><span class="line">&#125;</span><br><span class="line">pre = p;    <span class="comment">//下一个结点</span></span><br><span class="line"><span class="comment">/*  先序化二叉树</span></span><br><span class="line"><span class="comment">    InThreaded(p-&gt;rchild);  //递归遍历右子树</span></span><br><span class="line"><span class="comment">                if(p.ltag==0)&#123;    //为了避免循环</span></span><br><span class="line"><span class="comment">         InThreaded(p-&gt;lchild); // 递归线索化左子树</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>查找后继</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BiTree* <span class="title">Next</span><span class="params">(BiTree* t)</span> <span class="comment">//已知节点t找t的&quot;后继&quot;结点位置 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (t-&gt;rtag == <span class="number">1</span>) <span class="comment">//右标志为1，可以直接得到&quot;后继&quot;结点 </span></span><br><span class="line">&#123;</span><br><span class="line">t = t-&gt;rchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">/*右标志为0，不能直接的到&quot;后继&quot;结点，</span></span><br><span class="line"><span class="comment">   则需要找到右子树最左下角的节点*/</span></span><br><span class="line">&#123;</span><br><span class="line">t = t-&gt;rchild;</span><br><span class="line"><span class="keyword">while</span> (t-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">t = t-&gt;lchild;</span><br><span class="line">&#125; <span class="comment">//while</span></span><br><span class="line">&#125;<span class="comment">//else</span></span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>查找前驱</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BiTree* <span class="title">Prior</span><span class="params">(BiTree* t)</span><span class="comment">//已知节点t找t的&quot;前驱&quot;结点位置 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (t-&gt;ltag == <span class="number">1</span>)<span class="comment">//左标志为1，可以直接找到&quot;前驱&quot;结点的位置 </span></span><br><span class="line">&#123;</span><br><span class="line">t = t-&gt;lchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">/*左标志为0，不能直接的到&quot;前驱&quot;结点，</span></span><br><span class="line"><span class="comment">   则需要找到左子树最右下角的节点*/</span></span><br><span class="line">&#123;</span><br><span class="line">t = t-&gt;lchild;</span><br><span class="line"><span class="keyword">while</span> (t-&gt;rtag == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">t = t-&gt;rchild;</span><br><span class="line">&#125; <span class="comment">//while</span></span><br><span class="line">&#125; <span class="comment">//else</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>利用线索实现中序遍历</p><p>但是需要注意的一点是，我们<code>creat</code>函数中输入是以先序的次序输入端，故<code>p</code>一开始指向的节点是先序的第一个节点，而不是中序的第一个结点，所以要先查找第一个节点，在用Next中的线索查找后续结点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InorderTraverse</span><span class="params">(BiTree *t)</span><span class="comment">//利用线索实现中序遍历 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(t-&gt;ltag==<span class="number">0</span>)<span class="comment">//查找第一个节点 </span></span><br><span class="line"><span class="comment">//因为二叉树的创建creat是以先序遍历序列创建，所以t所指向的第一个结点并不是中序遍历所要访问的第一个结点 </span></span><br><span class="line">&#123;</span><br><span class="line">t=t-&gt;lchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,t-&gt;data);<span class="comment">//访问第一个结点</span></span><br><span class="line"><span class="keyword">while</span>(t-&gt;rchild)</span><br><span class="line"><span class="comment">// 此处以&quot;t的右孩子不为空&quot;为循环条件，是因为，先前设定了最后一个结点的&quot;后继&quot;为空，表示结束 </span></span><br><span class="line">&#123;               <span class="comment">//根据线索访问后续结点 </span></span><br><span class="line">t=Next(t);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,t-&gt;data); </span><br><span class="line">&#125;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><hr><p>在中序遍历中，左根右的顺序，任意一结点可以找到前驱和后继</p><p>在前序遍历中，根左右的顺序，有左孩子的结点是无法找到其前驱的</p><p>在后序遍历中，左右根的顺序，有右孩子的结点是无法找到其后继的</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/cP7R8ZCwGYoHq92.png" alt="image-20220511164049416"></p><hr><h2 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h2><h3 id="双亲表示法（顺序存储）"><a href="#双亲表示法（顺序存储）" class="headerlink" title="双亲表示法（顺序存储）"></a>双亲表示法（顺序存储）</h3><p>每个结点中保存自身数据以及指向父节点的位置</p><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/caKy84qPre7vkYp.png" width="400"/></td><td><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/ELTwHDmsVIhKGBj.png" width="150"/></td></tr></tbody></table></div><p>定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line">    ElemType data;  <span class="comment">//数据元素</span></span><br><span class="line">    <span class="keyword">int</span> parent;     <span class="comment">//双亲位置域</span></span><br><span class="line">&#125;TreeNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Ptree</span>&#123;</span>         <span class="comment">//存放树的顺序表</span></span><br><span class="line">    TreeNode nodes[size];   <span class="comment">//双亲表示</span></span><br><span class="line">    <span class="keyword">int</span> n;               <span class="comment">//结点数</span></span><br><span class="line">&#125;PTree</span><br></pre></td></tr></table></figure><p>优点：查指定结点的双亲很方便</p><p>缺点：查指定结点的孩子只能从头遍历</p><hr><h3 id="孩子表示法（顺序＋链式）"><a href="#孩子表示法（顺序＋链式）" class="headerlink" title="孩子表示法（顺序＋链式）"></a>孩子表示法（顺序＋链式）</h3><p>顺序存储各个结点，每个结点中保存孩子链表头指针</p><div class="table-container"><table><thead><tr><th><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/caKy84qPre7vkYp.png" width="450"/></th><th><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/h5qr4RGtYKZA3uN.png" width="300"/></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>&#123;</span>     </span><br><span class="line">    <span class="keyword">int</span> child ;       <span class="comment">//孩子结点在数组中的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span> <span class="comment">//下一个孩子</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>              <span class="comment">//结点定义，包括数据和孩子的链表</span></span><br><span class="line"> ElemType data;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">firstChild</span> ;</span>  <span class="comment">//第一个孩子</span></span><br><span class="line">&#125;CTBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>                     <span class="comment">//存放结点的顺序表</span></span><br><span class="line">    CTBox nodes[MAXSIZE];</span><br><span class="line">    <span class="keyword">int</span> n,r;               <span class="comment">//结点数和根的位置</span></span><br><span class="line">&#125;CTree;    </span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>优点：查指定结点的孩子很方便</p><p>缺点：查指定结点的父节点只能从头遍历</p><hr><h3 id="孩子兄弟表示法（链式存储）"><a href="#孩子兄弟表示法（链式存储）" class="headerlink" title="孩子兄弟表示法（链式存储）"></a>孩子兄弟表示法（链式存储）</h3><p>其定义和二叉树一模一样，不过是指针域指向的对象不一样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>  *<span class="title">firstchild</span>,*<span class="title">nextsibling</span>;</span>   <span class="comment">//第一个孩子和右兄弟</span></span><br><span class="line">&#125;CSNode,*CSTree;</span><br></pre></td></tr></table></figure><p>关键在于，这种表示法可以将树转化为二叉树，从而可以用熟悉的二叉树的操作来操作树</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/UmqcOFuXkGprAWE.png" alt="image-20220511171632428"></p><p>而对森林来说，则可以将几颗树的头结点相连，再用孩子兄弟表示法表示即可</p><hr><h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><p><strong>先根遍历</strong></p><p>如果树非空，先访问根节点，然后依次访问其子树，对树的先根遍历和对其转换二叉树的先序遍历结果是一样的</p><p><strong>后根遍历</strong></p><p>若树非空，先依次对每棵树进行后根遍历，最后再访问根节点，对树的后根遍历和对其转换二叉树的中序遍历结果是一样的</p><p><strong>层序遍历</strong></p><p>按照层次访问树，可以看做对树的广度优先遍历（BFS）</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/WhYmdgBzZDUeO5T.png" alt="image-20220511184038119"></p><hr><h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>当有 <code>n</code> 个结点（都做叶子结点且都有各自的权值）构建一棵树时，如果构建的这棵树的<strong>带权路径长度(WPL)最小</strong>，称这棵树为“<strong>最优二叉树</strong>”，有时也叫“<strong>哈夫曼树</strong>“</p><p>权值可以理解为是访问频率，而<code>带权路径长度=权值 x 该节点到树根的路径长度</code></p><p><code>树的带权路径长度=所有叶节点的带权路径之和WPL(Weighted Path Length)</code></p><h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><ol><li><p>选取并合并：选取取值最小的两个结点合并成一棵树（根节点为权值之和）</p></li><li><p>删除并加入：从序列中删除上述选取的两个两个最小结点，加入新合并的树，新合并的树权值为两结点之和</p></li><li><p>加入：选择两个结点，和第2步合并的结点，一共三个节点，选择其中最小的两个结点合并，组成新合并的树</p></li><li><p>继续重复上述操作即可得到哈夫曼树</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/2soR9tZbMDeNTuz.png" alt="image-20220512161945398"></p></li></ol><p>哈夫曼树并不唯一，但是WPL的值肯定是唯一的</p><hr><h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><p><strong>即任一一个编码不能是其他编码的前缀</strong>，将字符集中的每个字符作为一个叶子结点，各个字符出现的频率作为结点的权值，可用于数据压缩</p><hr><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>并指合并操作，查指查找操作，集指采用集合这种逻辑结构，并查集就是可以进行合并和查找的集合</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/H4byXdltWRsLeED.png" alt="image-20220523195741382"></p><p>森林就将各个元素划分为若干个互不相交的子集</p><p>在森林中，查指在森林中查找某一结点属于那个集合，并指两棵树的合并</p><hr><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>存储结构采取双亲表示法可以方便地实现并查</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/Eqj9peVwGPbF4cx.png" alt="image-20220523200019796"></p><p>用一个数组就可以表示集合关系</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 13</span></span><br><span class="line"><span class="keyword">int</span> UFSets[SIZE];</span><br><span class="line"><span class="comment">// 初始化并查集</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Initial</span><span class="params">(<span class="keyword">int</span> S[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;SIZE;i++)&#123;</span><br><span class="line">    S[i]=<span class="number">-1</span>;         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Find 查操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> S[],<span class="keyword">int</span> x)</span></span>&#123; </span><br><span class="line">    <span class="keyword">while</span>(S[x]&gt;=<span class="number">0</span>)   <span class="comment">////循环查找x的根</span></span><br><span class="line">    &#123;   </span><br><span class="line">    x=S[x];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Union 并操作  将两个集合合并成一个</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> S[],<span class="keyword">int</span> Root1,<span class="keyword">int</span> Root2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Root1==Root2)&#123;</span><br><span class="line">          <span class="keyword">return</span> ;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       S[Root2]=Root1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>并操作给出了两棵树的根节点，合并的时间复杂度只需要O(1)</p><p>查操作的时间复杂度在O(n)</p><hr><p>查操作的时间复杂度和树的高度有关，可以优化并的操作，让小树成为大树的子树，从而尽量不增加树的高度</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/TwX68epWarSMhLm.png" alt=""></p><p>优化思路：在每次Union操作构建树的时候，用根的绝对值表示树的结点总数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Union 并操作  将两个集合合并成一个</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> S[],<span class="keyword">int</span> Root1,<span class="keyword">int</span> Root2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Root1==Root2)&#123;</span><br><span class="line">          <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(S[Root2]&gt;S[Root1]&#123;  <span class="comment">//Root2结点数更少</span></span><br><span class="line">       S[Root1]+=S[Root2];  <span class="comment">//累加结点总数</span></span><br><span class="line">       S[Root2]=Root1;     <span class="comment">//合并</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        S[Root2]+=S[Root1];</span><br><span class="line">        S[Root1]=Root2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化后find操作的最坏时间复杂度为$O(log_2n)$</p><hr><p>Find操作可以继续优化，如果不考虑保持树的结构，可以将尽可能多的树挂靠在根节点之下，从而可以更快查到根节点</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/B2zEkdHwUXgbxqs.png" alt="image-20220523202958232"></p><p>压缩路径可以将被查找节点到根节点路径中的所有结点都挂靠在根节点之下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Find 查操作 压缩路径</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> S[],<span class="keyword">int</span> x)</span></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> root =x;</span><br><span class="line">    <span class="keyword">while</span>(S[root]&gt;=<span class="number">0</span>)   <span class="comment">////循环查找x的根</span></span><br><span class="line">    &#123;   </span><br><span class="line">    root =S[root];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(x!=root)&#123;   <span class="comment">//压缩路径</span></span><br><span class="line">        <span class="keyword">int</span> t=S[x];   <span class="comment">//t指向x的父节点</span></span><br><span class="line">        S[x]=root;    <span class="comment">//x挂到根节点下</span></span><br><span class="line">        x=t;          <span class="comment">//回到x的父节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.字符串</title>
      <link href="/post/5702.html"/>
      <url>/post/5702.html</url>
      
        <content type="html"><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>字符串是由零个或多个字符组成的有限序列</p><p>字符的个数<code>n</code>就是字符串的长度，<code>n=0</code>时称为空串</p><h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><p>串是一种特殊的线性表，数据元素之间呈线性关系</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/dsMW7i5cSgXLZC4.png" alt="image-20220507203329378" style="zoom: 67%;" /></p><hr><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>赋值，复制，求串的长度，连接串，求子串，定位，比较</p><hr><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><p>字符串是线性表，所以可以用顺序存储的方式，就是在定义中，把数组的类型规定为<code>char</code>类型即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体定义 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> *data;  <span class="comment">//存放顺序表元素的数组 </span></span><br><span class="line"><span class="keyword">int</span> length; <span class="comment">//存放顺序表的长度 </span></span><br><span class="line"> &#125;Sqlist;<span class="comment">//顺序表类型的定义 </span></span><br></pre></td></tr></table></figure><hr><h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h3><p>同理也可以使用链式存储</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">NEXT</span>;</span></span><br><span class="line">&#125;Node, *LinkList;  </span><br></pre></td></tr></table></figure><p>不过这样的存储密度很低，建议每个结点存储多个字符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> data[<span class="number">4</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">NEXT</span>;</span></span><br><span class="line">&#125;Node, *LinkList;  </span><br></pre></td></tr></table></figure><hr><h2 id="字符串的模式匹配"><a href="#字符串的模式匹配" class="headerlink" title="字符串的模式匹配"></a>字符串的模式匹配</h2><p>在主串中找到与模式串相同的子串，并返回其所在位置</p><h3 id="朴素模式匹配算法"><a href="#朴素模式匹配算法" class="headerlink" title="朴素模式匹配算法"></a>朴素模式匹配算法</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/1JSgIpFbWGBqVXk.png" alt="image-20220507211122668"></p><p>主串长度为<code>n</code>，模式串长度为<code>m</code></p><p>朴素模式匹配算法：将主串中所有长度为<code>m</code>的子串依次与模式串对比，直到找到一个完全匹配的子串或所有的子串都不匹配为止。（很朴素）</p><p>如果子串匹配失败，则主串指针指向下一个子串的第一个位置，模式串指针回到模式串第一个位置</p><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxsize 100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index_BF</span><span class="params">(<span class="keyword">char</span> S[],<span class="keyword">char</span> T[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(S[i]!=<span class="string">&#x27;\0&#x27;</span>&amp;&amp;T[j]!=<span class="string">&#x27;\0&#x27;</span>)<span class="comment">//S[i]==&#x27;\0&#x27;则为匹配失败，T[i]==‘\0’为匹配成功！</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(S[i]==T[j])  <span class="comment">//某一字符匹配成功</span></span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">i=i-j+<span class="number">1</span>;<span class="comment">//i回溯到下一位置</span></span><br><span class="line">j=<span class="number">0</span>;<span class="comment">//j回溯</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(T[j]==<span class="string">&#x27;\0&#x27;</span>)<span class="comment">//对应上面循环条件匹配成功</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Match succeed!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> i-j; <span class="comment">//返回第一位的下标</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//对应上面循环条件S[i]==&#x27;\0&#x27;匹配失败</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Match failed!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码很容易理解，注意一点，<code>i</code>和<code>j</code>的默认是0，而王道上默认是<code>1</code>，其实都可以，不过默认是<code>0</code>的方便一点</p><p>主串长度为<code>n</code>，模式串长度为<code>m</code>，最坏的时间复杂度是<code>O(mn)</code>，最好时间复杂度是<code>O(n)</code></p><hr><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><p>KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt提出的，简称KMP算法。KMP算法的<strong>核心是利用匹配失败后的信息</strong>，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是通过一个<code>NEXT()</code>函数实现，函数本身包含了模式串的局部匹配信息</p><p>KMP算法是基于朴素算法的，对比朴素识别和KMP算法：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/mBN5hYC4x26ZWrR.png" alt="image-20220508194629894"></p><p>最大的差别在于，else里面的<code>j=NEXT[j]</code>，也就是匹配失败后，<strong><code>i</code>不会回溯</strong>，而是<code>j</code>回溯到<code>NEXT[j]</code>的位置，而不是从0开始</p><p>而KMP的核心正是利用NEXT数组来存储匹配失败后的信息以减少匹配次数</p><hr><p>而求取<code>NEXT</code>数组的值，成为了KMP算法的关键</p><p>在此之间，需要先介绍“”最大长度“”<code>Length</code>数组，该数组的作用是用来存放一个字符串的最长前缀和最长后缀相同的长度，按每一位下标将对应长度值存于数组<code>Length</code>中</p><p>比如模式串<code>“ababaca”</code>的<code>Length</code>数组就是<code>&#123;0，0，1，2，3，0，1&#125;</code></p><p>之所以需要这个<code>Length</code>数组，是因为<code>Length</code>数组的下标与模式串<code>T</code>的下标是一致的（也就是下标 <code>j</code>），也就是模式串<code>T</code>中每一位都可以对应其下标<code>j</code>在<code>Length</code>数组中找到该位<strong>当前前缀与后缀的最长匹配长度</strong>，那么也就知道了，在当前位置下（也就是后缀）是否与模式串的开头（也就是前缀）有相同的部分、相同的部分是几位，这就是利用前缀匹配失败的信息</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/yK58x6BkF1mA4sH.png" alt="image-20220508205033697"></p><p>那么也就是说，有了<code>Length</code>数组，我们只需要知道下标就可以知道，当前的前后缀的最长匹配长度。而当<code>j</code>位发生不匹配，需要回溯时，我们要看前一位也就是<code>j-1</code>位的前后缀匹配情况也就是<code>Length[j-1]</code>，可以知道要从<code>j</code>位回溯到<code>Length[j-1]</code>位</p><p>但是，有个问题，第<code>j</code>位的回溯位置需要看第<code>j-1</code>位的信息，为了让第<code>j</code>位的回溯信息可以直接到第<code>j</code>位去找，我们可以把<code>Length</code>数组整体后移一位，这就是<strong>NEXT数组</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/oFg86aZ1T5DYdOu.png" alt="image-20220508205735375"></p><ul><li><code>NEXT</code>数组也正是KMP算法的精髓所在，<strong>充分记录并利用探路人</strong>（后缀）获取的信息（已匹配信息），让算法能绕过很多不必要的匹配项，少走很多弯路</li></ul><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/vm2TyDLjuSYkAnZ.png" alt="image-20220508210350464"></p><p>观察求<code>NEXT</code>数组的代码，可以发现，与KMP算法的代码相似性极高，那么其实<strong>求NEXT数组就是让模式串T的前缀和后缀相匹配，那么也就是一个自我匹配的过程</strong>，用前缀去匹配后缀。</p><p>那么不同之处在于<strong>当匹配成功时</strong>，我们不但要把指针（下标）向后推一位，还同时需要<strong>对应当前下标记录下当前的最佳匹配长度</strong>，也就是<code>NEXT[j]=k</code>,表示的是模式串T的<strong>前缀的前k项</strong>与<strong>后缀的前k项</strong>相匹配，那么k也正是当前的匹配长度</p><p>而先<code>j++</code>后将k的值存放在NEXT数组中，正好对应了将<code>Length</code>数组右移一位变成<code>NEXT</code>数组的过程</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/hSHkaTYZe1sJXzL.png" alt="image-20220508214230678"></p><p>同时k++，j++，的原因也很简单，既然模式串T的<strong>前缀的前k项</strong>与<strong>后缀的前k项</strong>，那么k+1项和j+1项会不会也匹配？</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/2ifAdOUypXrwSWs.png" alt="image-20220508214316318"></p><p>如果在前k项与后k项相同的情况下，<strong>第k+1项失配</strong>，也就是下图所视情况，<code>T[k]≠T[j]</code> ，那么我们的前缀指针k是不是要回溯，在此处使用BF算法的回溯思路，从零开始重新找前后缀匹配长度，固然可以，但是我们如果用kmp算法的回溯思路，是不是可以更快找到呢？</p><p>为什么在NEXT数组没有完全成型之前就用NEXT数组来回溯呢，因为在求NEXT数组的算法中，<strong>K永远比J小</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/GDZ4jJQWUAiguwH.png" alt="image-20220508214556007"></p><hr><p>算法漏洞</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/n9TjR5sF1LdhIuA.png" alt="image-20220508214955963"></p><p>我们发现这个算法其实还是存在漏洞，如下图的情况，第2步的情况是完全没有必要的，因为在第1步时已经判断过“B”≠”D”,第2步又判断了一次“B”≠”D”。那有没有办法可以省掉，或者是跳过这个多余步骤呢？</p><p>其实我们只需要加一个判断就可以了，当if判断完前<code>k</code>项与后<code>k</code>项相匹配后，<code>j++；k++;</code>此时<code>j</code>和<code>k</code>都向后推了一位，分别指向下一位，那么这时我们不着急记录长度<code>k</code>于NEXT数组，而是加一个判断，预判断一下下一位（这里的下一位是指<code>j++；k++;</code>之前的下一位）是否相等，也就是<code>T[j]</code>与<code>T[k]</code>是否相等，如果不相等，我们记录<code>k</code>的值于NEXT数组；<strong>如果相等的话</strong>，就会出现上述多余重复匹配的现象，那么我们在这里通过<strong>连续的两次回溯，来跳过它</strong>，也就是<code>k = NEXT[NEXT[k]];</code>(<code>NEXT[j]=NEXT[k];</code>将<code>NEXT[k]</code>的值存于<code>NEXT[j]</code>也是一样的道理），<strong>回溯完之后不进行匹配判断就进行下一次回溯，即是跳过了他的匹配步骤</strong></p><p>完整代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxsize 100 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Nextval</span><span class="params">(<span class="keyword">char</span> T[],<span class="keyword">int</span> *next)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> lenT=<span class="built_in">strlen</span>(T);</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">-1</span>;<span class="comment">//前缀 </span></span><br><span class="line"><span class="keyword">int</span> j=<span class="number">0</span>;<span class="comment">//后缀 </span></span><br><span class="line">next[<span class="number">0</span>]=<span class="number">-1</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(j&lt;lenT)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">-1</span>||T[j]==T[k])</span><br><span class="line">&#123;</span><br><span class="line">j++;</span><br><span class="line">k++;</span><br><span class="line"><span class="comment">//较之前next数组求法，改动在下面4行</span></span><br><span class="line"><span class="keyword">if</span>(T[j]!=T[k])</span><br><span class="line">&#123;</span><br><span class="line">next[j]=k;<span class="comment">//之前只有这一行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">next[j]=next[k];<span class="comment">//为不能出现T[j] = T[ next[j ]]，</span></span><br><span class="line">            <span class="comment">//所以当出现时连续进行两次回溯，k = next[next[k]] </span></span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">k=next[k];</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="keyword">char</span> S[],<span class="keyword">char</span> T[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,lenS,lenT;</span><br><span class="line">lenS=<span class="built_in">strlen</span>(S);</span><br><span class="line">lenT=<span class="built_in">strlen</span>(T);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> next[maxsize];</span><br><span class="line">Nextval(T,next);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i&lt;lenS&amp;&amp;j&lt;lenT)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(j==<span class="number">-1</span>||S[i]==T[j])</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123; </span><br><span class="line">j=next[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(j==lenT)</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Match succeed!\n&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> i-j;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Match failed!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> S[maxsize],T[maxsize];</span><br><span class="line">    <span class="keyword">int</span> target;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(S,<span class="string">&quot;AAAAAAAAAAttract&quot;</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(T,<span class="string">&quot;Attract&quot;</span>);</span><br><span class="line"></span><br><span class="line">target=KMP(S,T);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Position is %d\n&quot;</span>,target);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.栈和队列</title>
      <link href="/post/43592.html"/>
      <url>/post/43592.html</url>
      
        <content type="html"><![CDATA[<h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>栈是只允许在一端进行插入和删除操作的线性表</p><p>特点是<strong>先进后出</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/1cZ4JMLoKFYEUm7.png" alt="image-20220507151516634"></p><p><code>n</code>个不同元素进栈，出栈元素不同排列的个数为$\frac{1}{n+1}C^n_{2n}$(卡特兰数)</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>创建，元素进栈，出栈，获取栈顶元素</p><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><h4 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h4><p>定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data[MaxSize];  <span class="comment">//栈的最大值</span></span><br><span class="line"><span class="keyword">int</span> top;             <span class="comment">//栈顶指针</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><p>初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(SqStack  *S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">S-&gt;top=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进栈</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(SqStack* S, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">S-&gt;data[S-&gt;top] = x;</span><br><span class="line">S-&gt;top++;              <span class="comment">//栈顶指针永远指向下一个元素进来的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出栈</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">(SqStack* S,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">S-&gt;top--;</span><br><span class="line">x = S-&gt;data[S-&gt;top];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取栈顶元素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gettop</span><span class="params">(SqStack* S,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t=S-&gt;top<span class="number">-1</span></span><br><span class="line">x = S-&gt;data[t];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h4><p>头插法创建链表就是链式栈</p><hr><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="逻辑结构-1"><a href="#逻辑结构-1" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>队列是只允许在一端进行插入，在另一端进行删除的线性表</p><p>特点是先进先出</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/TiYU9nbxOwN3HBp.png" alt="image-20220507155526596"></p><hr><h3 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h3><p>创建，初始化，入队，出队，读队头元素</p><hr><h3 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h3><h4 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h4><p>定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data[MaxSize];  <span class="comment">//静态数组存放队列元素</span></span><br><span class="line"><span class="keyword">int</span> front, rear;    <span class="comment">//队头元素和队尾元素</span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure><p>初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(SqQueue* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">q-&gt;front = <span class="number">0</span>;    <span class="comment">//队头和队尾指针为0</span></span><br><span class="line">q-&gt;rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>入队</p><p>（以下是队尾指针指向队尾元素的后一个位置，如果队尾指针指向队尾元素，就要先让队尾指针+1，再进行插入操作）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">Insert</span><span class="params">(SqQueue *q,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">q-&gt;data[q-&gt;rear] = x;    <span class="comment">//插入到队尾</span></span><br><span class="line">q-&gt;rear = q-&gt;rear + <span class="number">1</span>;   <span class="comment">//队尾指针加1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出队</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除一个队头元素，并用x返回</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">DeQueue</span><span class="params">(SqQueue* q,<span class="keyword">int</span> *x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (((q-&gt;rear) + <span class="number">1</span>) % MaxSize == q-&gt;front) &#123;   <span class="comment">// 需要牺牲一个空间来判断是否满队列</span></span><br><span class="line">                         <span class="comment">// 不能用rear=front判断，因为判空就是根据指针相同</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;full&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">x = q-&gt;data[q-&gt;front];</span><br><span class="line">q-&gt;front = (q-&gt;front + <span class="number">1</span>) % MaxSize;    <span class="comment">// MOD元素让队列变成了循环队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队满：</p><p><code>(q-&gt;rear) + 1) % MaxSize == q-&gt;front</code></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/Svc5UbYE9l1xdiL.png" alt="image-20220507161556684" style="zoom:67%;" /></p><p>队空：</p><p><code>q-&gt;rear == q-&gt;front</code></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/2WCFB6stYpiOhzE.png" alt="image-20220507161801286" style="zoom: 80%;" /></p><p>为了区别队空和队满时的状态，除了牺牲一个空间以外，也可以用标志位tag进行判断</p><hr><h4 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h4><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/uiWR8srZXqkyF24.png" alt="image-20210323153544209"></p><p>定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">    ElemType data ;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    LinkNode *front,*rear;</span><br><span class="line">&#125;LinkQueue</span><br></pre></td></tr></table></figure><p>初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化时front和rear都指向头结点</span></span><br><span class="line">    Q.front=Q.rear=(LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    Q.front-&gt;next=null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>入队</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q,ElemType x)</span></span>&#123;</span><br><span class="line">    LinkNode *s=(LinkNode *)<span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    s-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next=s;   <span class="comment">//让新节点变为rear</span></span><br><span class="line">    Q.rear=s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出队</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span> <span class="params">(LinkQueue &amp;Q,ElemType &amp;x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(Q.front==Q.rear)&#123;          <span class="comment">// 如果front=rear则队空</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> LinKNode *p=Q.front-&gt;next;</span><br><span class="line"> x=p-&gt;data;</span><br><span class="line"> Q.front-&gt;next=p-&gt;next;</span><br><span class="line">  <span class="keyword">if</span>(Q.rear==p)           <span class="comment">//如果rear=p,那么队空了</span></span><br><span class="line">  &#123;</span><br><span class="line">      Q.rear=Q.front;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链式一般不会队满，所以不需要考虑</p><hr><h4 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h4><p>允许从双端插入，双端删除的队列</p><hr><h2 id="栈和队列的应用"><a href="#栈和队列的应用" class="headerlink" title="栈和队列的应用"></a>栈和队列的应用</h2><p>栈和队列相对来说应用较少，栈一般用来解决成对元素消去的问题</p><h3 id="括号匹配问题"><a href="#括号匹配问题" class="headerlink" title="括号匹配问题"></a>括号匹配问题</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">pairs</span><span class="params">(<span class="keyword">char</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="string">&#x27;&#125;&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;&#123;&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="string">&#x27;]&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="string">&#x27;)&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> stk[n + <span class="number">1</span>], top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch = pairs(s[i]);</span><br><span class="line">        <span class="keyword">if</span> (ch) &#123;</span><br><span class="line">            <span class="keyword">if</span> (top == <span class="number">0</span> || stk[top - <span class="number">1</span>] != ch) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            top--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stk[top++] = s[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> top == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="中缀转为后缀表达式"><a href="#中缀转为后缀表达式" class="headerlink" title="中缀转为后缀表达式"></a>中缀转为后缀表达式</h3><p>算数表达式由操作数（数字），运算符（+ - × ÷），界限符（括号）组成</p><p>运算符在两个操作数后面就称为后缀表达式</p><p>手算：</p><ol><li><p>先确定中缀表达式中各个运算符的运算顺序，</p></li><li><p>选择下一个运算符，按照[左操作数 右操作数 运算符]的方式组成一个新的操作数</p></li></ol><p>机算：</p><ol><li><p>遇到<strong>左括号</strong>直接入栈，遇到<strong>右括号</strong>将栈中<strong>左括号</strong>之后入栈的运算符全部弹栈输出，同时<strong>左括号出栈但是不输出</strong>。</p></li><li><p>遇到<strong>乘号和除号</strong>直接入栈，直到遇到<strong>优先级</strong>比它更<strong>低</strong>的运算符，依次弹栈。</p></li><li><p>遇到<strong>加号和减号</strong>，如果此时<strong>栈空</strong>，则<strong>直接入栈</strong>，否则，将栈中<strong>优先级高</strong>的运算符依次弹栈（注意：加号和减号属于同一个优先级，所以也依次弹栈）直到<strong>栈空或则遇到左括号</strong>为止，停止弹栈。（因为左括号要匹配右括号时才弹出）。</p></li><li><p>获取完后，将栈中剩余的运算符号依次弹栈输出</p></li></ol><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*中缀转后缀函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Change</span><span class="params">(SqStack *S,Elemtype str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">Elemtype e;</span><br><span class="line">InitStack(S);  <span class="comment">//初始化运算符栈</span></span><br><span class="line"><span class="keyword">while</span>(str[i]!=<span class="string">&#x27;\0&#x27;</span>)  <span class="comment">//字符串未到末尾</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(str[i]))  </span><br><span class="line">&#123;<span class="comment">/*过滤数字字符，直接输出，直到下一位不是数字字符打印空格跳出循环 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,str[i++]);</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">isdigit</span>(str[i]))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*加减运算符优先级最低，如果栈顶元素为空则直接入栈，否则将栈中存储的运算符</span></span><br><span class="line"><span class="comment">全部弹栈，如果遇到左括号则停止，将弹出的左括号从新压栈，因为左括号要和右括号</span></span><br><span class="line"><span class="comment">匹配时弹出，这个后面单独讨论。弹出后将优先级低的运算符压入栈中*/</span></span><br><span class="line"><span class="keyword">if</span>(str[i]==<span class="string">&#x27;+&#x27;</span>||str[i]==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!StackLength(S))</span><br><span class="line">&#123;</span><br><span class="line">PushStack(S,str[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">PopStack(S,&amp;e);</span><br><span class="line"><span class="keyword">if</span>(e==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">PushStack(S,e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">while</span>( StackLength(S) &amp;&amp; e != <span class="string">&#x27;(&#x27;</span> );</span><br><span class="line"></span><br><span class="line">PushStack(S,str[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*当遇到右括号是，把括号里剩余的运算符弹出，直到匹配到左括号为止</span></span><br><span class="line"><span class="comment">左括号只弹出不打印（右括号也不压栈）*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(str[i]==<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">PopStack(S,&amp;e);</span><br><span class="line"><span class="keyword">while</span>(e!=<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,e);</span><br><span class="line">PopStack(S,&amp;e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*乘、除、左括号都是优先级高的，直接压栈*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(str[i]==<span class="string">&#x27;*&#x27;</span>||str[i]==<span class="string">&#x27;/&#x27;</span>||str[i]==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">PushStack(S,str[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(str[i]==<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n输入格式错误！\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*最后把栈中剩余的运算符依次弹栈打印*/</span></span><br><span class="line"><span class="keyword">while</span>(StackLength(S))</span><br><span class="line">&#123;</span><br><span class="line">PopStack(S,&amp;e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后缀表达式求值"><a href="#后缀表达式求值" class="headerlink" title="后缀表达式求值"></a>后缀表达式求值</h3><ol><li>从左往右扫描下一个元素，直到处理完所有元素</li><li>若扫描到操作数则压入栈</li><li>若扫描到运算符，则弹出两个栈顶元素，执行相应运算</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="keyword">char</span>* token)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strlen</span>(token) &gt; <span class="number">1</span> || (<span class="string">&#x27;0&#x27;</span> &lt;= token[<span class="number">0</span>] &amp;&amp; token[<span class="number">0</span>] &lt;= <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="keyword">char</span>** tokens, <span class="keyword">int</span> tokensSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tokensSize;</span><br><span class="line">    <span class="keyword">int</span> stk[n], top = <span class="number">0</span>;      <span class="comment">//操作数栈</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span>* token = tokens[i];</span><br><span class="line">        <span class="keyword">if</span> (isNumber(token)) &#123;</span><br><span class="line">            stk[top++] = atoi(token);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> num2 = stk[--top];</span><br><span class="line">            <span class="keyword">int</span> num1 = stk[--top];</span><br><span class="line">            <span class="keyword">switch</span> (token[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    stk[top++] = num1 + num2;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    stk[top++] = num1 - num2;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    stk[top++] = num1 * num2;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                    stk[top++] = num1 / num2;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stk[top - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="特殊矩阵的压缩"><a href="#特殊矩阵的压缩" class="headerlink" title="特殊矩阵的压缩"></a>特殊矩阵的压缩</h2><h3 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h3><p>若n阶方阵中任意一个元素都有$a_{i,j}=a_{j,i}$，则改矩阵为对称矩阵</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/ewEqHv6mnSDgL9o.png" alt="image-20220507193320066" style="zoom: 80%;" /></p><p>可以按行优先原则，只存储主对角线和下三角的元素，用一个大小为$\frac{n(n+1)}{2}$的数组来存储</p><p>$a_{i,j}$对应的就是数组中第$\frac{i(i-1)}{2}+j$个元素，下标在此基础上<code>-1</code></p><p>（不需要背公式，主要是理解存储顺序以及下标需要<code>-1</code>）</p><hr><h3 id="三角矩阵"><a href="#三角矩阵" class="headerlink" title="三角矩阵"></a>三角矩阵</h3><p>除了主对角区和上(下)三角区，其余的元素都相同</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/b1LKMBiOZUYzn8F.png" alt="image-20220507194132179" style="zoom: 80%;" /></p><p>相比与对称矩阵，三角矩阵需要空间为$\frac{n(n+1)}{2}+1$，多一个空间用于最后存放c这个常量</p><hr><h3 id="三对角矩阵"><a href="#三对角矩阵" class="headerlink" title="三对角矩阵"></a>三对角矩阵</h3><p>当$|i-j|&gt;1$时，有$a_{i,j=0}$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/BeydsbnLmYMNcxU.png" alt="image-20220507195404275" style="zoom: 80%;" /></p><p>需要大小为<code>3n-2</code>的数组，前<code>i-1</code>行共<code>3(i-1)-1</code>个元素，$a_{i,j}$是第<code>i</code>行第<code>j-i+2</code>个元素</p><p>所以$a_{i,j}$是第<code>2i+j-2</code>个元素</p><hr><h3 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h3><p>非零元素远远少于矩阵元素的个数</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/xQGXE1fTNWR49dr.png" alt="image-20220507200903464" style="zoom:67%;" /></p><p>使用三元组，即<code>i</code>行 <code>j</code>列 <code>v</code>值的方法存储</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/XUSYb7wNTfJpQvG.png" alt="image-20220507202249532"></p><p>假设矩阵中有X个非零元素，除了需要X个三元组之外，还需要一个三元组记录当前矩阵的行数，列数，非零元素个数</p><p>也可以使用<strong>十字链表</strong>法</p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.线性表</title>
      <link href="/post/42354.html"/>
      <url>/post/42354.html</url>
      
        <content type="html"><![CDATA[<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><p>线性表是具有相同数据类型的<code>n</code>个数据元素的<strong>有限</strong>序列，其中<code>n</code>为表长，当<code>n=0</code>时表是一个空表</p><p>除了第一个元素和最后一个元素外，每个元素有且仅有一个直接前驱和直接后继</p><h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/yN6gMPA7r3UlfYB.png" alt="image-20220506165445334"></p><hr><h2 id="基本运算和操作"><a href="#基本运算和操作" class="headerlink" title="基本运算和操作"></a>基本运算和操作</h2><p>包括初始化，销毁，插入，删除，查找，求表长等操作，针对不同的存储结构，其实现形式有所不同</p><hr><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><p>即是用顺序存储方式实现的线性表，把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现</p><p>可以通过静态分配或动态分配的方式实现顺序表</p><p>特点：</p><ul><li>随机访问，在<code>O(1)</code>时间内找到第<code>i</code>个元素</li><li>存储密度高，每个节点都只存储数据元素</li><li>拓展容量不方便（只能通过动态分配）</li><li>插入，删除不方便，要移动大量元素</li></ul><p>代码实现：</p><p>定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序表的结构体定义 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> *data;  <span class="comment">//存放顺序表元素的数组 </span></span><br><span class="line"><span class="keyword">int</span> length; <span class="comment">//存放顺序表的长度 </span></span><br><span class="line"> &#125;Sqlist;<span class="comment">//顺序表类型的定义 </span></span><br></pre></td></tr></table></figure><p>初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化顺序表 </span></span><br><span class="line"><span class="function">Sqlist <span class="title">initList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> Sqlist L;</span><br><span class="line"> L.data = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(maxSize*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));   <span class="comment">//动态分配数组空间</span></span><br><span class="line"> L.length = <span class="number">0</span>; </span><br><span class="line"> <span class="keyword">return</span> L;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>插入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在顺序表的第p个位置上插入新的元素e。如果p输入不正确，返回0，p输入正确，插入成功，返回1。 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insertElem</span><span class="params">(Sqlist &amp;L, <span class="keyword">int</span> p, <span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">if</span>(p&lt;<span class="number">0</span>||p&gt;L.length||L.length==maxSize)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=L.length<span class="number">-1</span>;i&gt;=p;--i)</span><br><span class="line">&#123;</span><br><span class="line">L.data[i+<span class="number">1</span>] = L.data[i];</span><br><span class="line">&#125;</span><br><span class="line">L.data[p] = e;</span><br><span class="line">++L.length;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> &#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>平均移动次数是 <code>n/2</code></p><p>删除</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除表L中下标为p的元素，成功返回1，否则返回0，并将被删除元素的值赋给e。 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteElem</span><span class="params">(Sqlist &amp;L, <span class="keyword">int</span> p, <span class="keyword">int</span> &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">if</span> (p&lt;<span class="number">0</span>||p&gt;L.length<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">e = L.data[p];</span><br><span class="line"><span class="keyword">for</span>(i=p;i&lt;L.length<span class="number">-1</span>;++i)</span><br><span class="line">&#123;</span><br><span class="line">L.data[i] = L.data[i+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">--L.length;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><hr><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>每个结点除了存放数据元素外，还要存储指向下一个节点的指针</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/gOHYsF8VDxKUdTu.png" alt="image-20220507145406767"></p><p>定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;Node, *LinkList;  </span><br></pre></td></tr></table></figure><p>初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单链表的初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function">LinkList <span class="title">LinkedListInit</span><span class="params">()</span> </span>&#123;    <span class="comment">//　为什么用指针操纵结构体？因为比起直接传递结构体，指针的效率更高　　</span></span><br><span class="line">    Node* L;</span><br><span class="line">    L = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));   <span class="comment">//动态分配内存，申请结点空间，此语言的意思是开辟一个大小为一个Ｎｏｄｅ字节数的内存区域，而Ｌ指向的就是该区域 </span></span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>) &#123; <span class="comment">//判断是否有足够的内存空间 </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;申请内存空间失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;                  <span class="comment">//指针使用－＞运算符，表示直接操作结构体成员，将next设置为NULL,初始长度为0的单链表 </span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表的创建</span></span><br><span class="line"><span class="comment">//头插法，将新加入的元素都插到表头中</span></span><br><span class="line"><span class="function">LinkList <span class="title">LinkListCreatH</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node* L;</span><br><span class="line">    L = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));   <span class="comment">//申请头结点空间</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;                      <span class="comment">//初始化一个空链表</span></span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;您要创建长度为多少的链表：&quot;</span>);</span><br><span class="line">    scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>  x;                         <span class="comment">//x为链表数据域中的数据</span></span><br><span class="line">        scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"></span><br><span class="line">        Node* p;</span><br><span class="line">        p = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));   <span class="comment">//申请新的结点 </span></span><br><span class="line">        p-&gt;data = x;                     <span class="comment">//结点数据域赋值 </span></span><br><span class="line">        p-&gt;next = L-&gt;next;               <span class="comment">//将结点插入到表头L--&gt;|2|--&gt;|1|--&gt;NULL </span></span><br><span class="line">        L-&gt;next = p;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//尾插法，将新加入的元素都插入到表尾中</span></span><br><span class="line"><span class="function">LinkList <span class="title">LinkListCreatT</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* L;</span><br><span class="line">    L = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;您要创建长度为多少的链表：&quot;</span>);</span><br><span class="line">    scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">        Node* s;</span><br><span class="line">        s = L;                            <span class="comment">// 设置一个和头结点相同起点的的尾巴指针</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>  x;                         <span class="comment">//x为链表数据域中的数据</span></span><br><span class="line">        scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"></span><br><span class="line">        Node* p;</span><br><span class="line">        p = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));   <span class="comment">//申请新的结点 </span></span><br><span class="line"></span><br><span class="line">            p-&gt;data = x;                     <span class="comment">//结点数据域赋值 </span></span><br><span class="line">            p-&gt;next = <span class="literal">NULL</span>;               <span class="comment">//将结点插入到表尾L--&gt;|1|--&gt;|2|--&gt;NULL </span></span><br><span class="line">            s-&gt;next = p;</span><br><span class="line">            s = p;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表的插入</span></span><br><span class="line"><span class="function">LinkList <span class="title">LinkedListInsert</span><span class="params">(LinkList L, <span class="keyword">int</span> i, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    Node* pre;                      <span class="comment">//pre为前驱结点 </span></span><br><span class="line">    pre = L;                       <span class="comment">// pre 首先指向头结点</span></span><br><span class="line">    <span class="keyword">int</span> tempi = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (tempi = <span class="number">1</span>; tempi &lt; i; tempi++) &#123;</span><br><span class="line">        pre = pre-&gt;next;                 <span class="comment">//查找第i个位置的前驱结点 </span></span><br><span class="line">    &#125;</span><br><span class="line">    Node* p;                                <span class="comment">//插入的结点为p</span></span><br><span class="line">    p = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));         <span class="comment">// 为插入的结点初始化内存</span></span><br><span class="line">    p-&gt;data = x;                            <span class="comment">// 为数据域赋值</span></span><br><span class="line">    p-&gt;next = pre-&gt;next;</span><br><span class="line">    pre-&gt;next = p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表的删除</span></span><br><span class="line"><span class="function">LinkList <span class="title">LinkedListDelete</span><span class="params">(LinkList L, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* p;</span><br><span class="line">    Node* pre;                   <span class="comment">//pre为前驱结点，p为查找的结点。</span></span><br><span class="line">    pre = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));         <span class="comment">// 为插入的结点初始化内存</span></span><br><span class="line">    p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;data != x) &#123;              <span class="comment">//查找值为x的元素 </span></span><br><span class="line">        pre = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    pre-&gt;next = p-&gt;next;          <span class="comment">//删除操作，将其前驱next指向其后继。 </span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><p>在单链表的基础上，增加了指向前驱结点的指针</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/cjniyXYzU4lgCLW.png" alt="image-20220507145324905"></p><p>定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DoubleNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DoubleNode</span>* <span class="title">prior</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DoubleNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;Dnode,*DnodeList;</span><br></pre></td></tr></table></figure><p>初始化和创建</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DnodeList <span class="title">CreatDnodeH</span><span class="params">()</span> </span>&#123;</span><br><span class="line">DnodeList L;</span><br><span class="line">L = (Dnode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Dnode));</span><br><span class="line">L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">L-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;number:&quot;</span>);</span><br><span class="line">scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x; i++) &#123;</span><br><span class="line">DnodeList P;</span><br><span class="line">P= (Dnode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Dnode));</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line">scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">P-&gt;data = m;</span><br><span class="line">        <span class="comment">//很明显是头插法</span></span><br><span class="line">P-&gt;next = L-&gt;next;</span><br><span class="line">L-&gt;next = P;</span><br><span class="line">P-&gt;prior = L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DnodeList <span class="title">InsertDnode</span><span class="params">(DnodeList L,<span class="keyword">int</span> i,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">DnodeList P;</span><br><span class="line">P = (Dnode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Dnode));</span><br><span class="line">P-&gt;data = x;</span><br><span class="line">DnodeList pre;</span><br><span class="line">pre = L;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">1</span>; m &lt; i; m++) &#123;</span><br><span class="line">pre = pre-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P-&gt;next=pre-&gt;next;</span><br><span class="line">    pre-&gt;next-&gt;prior=P;</span><br><span class="line">P-&gt;prior = pre;</span><br><span class="line">pre-&gt;next = P;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链表不具备随机存取特性，查找操作只能通过顺序遍历实现</p><hr><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>在单链表/双链表的基础上，尾结点不指向<code>NULL</code>，而是指向头结点，这种链表称作循环链表</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/ebgfBI4TDodRkwK.png" alt="image-20220507144839138"></p><hr><h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><p>分配一整片连续的内存空间，各个结点集中安置</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/DlEB7gu4FafIv1n.png" alt="image-20220507145636932" style="zoom:50%;" /></p><p><code>0</code>号结点当作头结点，游标为<code>-1</code>表示已经到达表尾，其他的游标表示下一个结点的数组下标</p><p>本质上是用数组形式实现的链表，优点是增删不需要大量移动元素，缺点是不能随机存取，只能从头结点开始一次查找，容量固定不可变</p><p>适用于数据元素数量固定不变的场景（<strong>操作系统的文件分配表FAT</strong>）</p><hr><h3 id="顺序表和链表的比较"><a href="#顺序表和链表的比较" class="headerlink" title="顺序表和链表的比较"></a>顺序表和链表的比较</h3><p>顺序表</p><ul><li>优点：支持随机存取，存储密度高</li><li>缺点：大片连续空间分配不方便，改变容量不方便</li></ul><p>链表</p><ul><li>优点：离散的小空间分配方便，改变容量方便</li><li>缺点：不可随机存取，存储密度低</li></ul>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>874数据结构大题</title>
      <link href="/post/6371.html"/>
      <url>/post/6371.html</url>
      
        <content type="html"><![CDATA[<h1 id="874数据结构大题"><a href="#874数据结构大题" class="headerlink" title="874数据结构大题"></a>874数据结构大题</h1><hr><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;Node, *LinkList;  </span><br></pre></td></tr></table></figure><hr><h3 id="2016年题1：查询链表倒数第K个数据"><a href="#2016年题1：查询链表倒数第K个数据" class="headerlink" title="2016年题1：查询链表倒数第K个数据"></a>2016年题1：查询链表倒数第K个数据</h3><p>已知一个带有表头结点的单链表，结点结构为 <code>data|link</code>。假设该链表只给出了头指针 <code>list</code>（类型为 <code>LinKlist</code>）。在不改变链表的前提下，请设计一个尽可能高效的算法，查找链表中倒数第 <code>k</code> 个位置上的结点（<code>k</code> 为正整数）。若查找成功，算法输出该结点的 <code>data</code> 值，并返回 1，否则，只返回 0</p><p>算法思想：由于单链表只能从头到尾依次访问链表的各个节点，所以如果要找链表的倒数第<code>k</code>个元素，也只能从头到尾进行遍历查找。在查找过程中，设置两个指针，让其中一个指针比另一个指针先前移<code>k-1</code>步，然后两个指针同时往前移动。循环直到先行的指针指为<code>NULL</code>时，另一个指针所指的位置就是所要找的位置，这样只需要一次遍历即可找到倒数第<code>k</code>个元素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LinKlist;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找出单链表中的倒数第k个元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">search_last_k</span><span class="params">(LinKlist *head, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinKlist *p1 = head;</span><br><span class="line">    LinKlist *p2 = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        p2 = p2-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(p2==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        p1 = p1-&gt;next;</span><br><span class="line">        p2 = p2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,p1-&gt;data);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2017年题1：求两个链表的交集"><a href="#2017年题1：求两个链表的交集" class="headerlink" title="2017年题1：求两个链表的交集"></a>2017年题1：求两个链表的交集</h3><p>有两个非空的整数集合 A.B，分别采用带头结点的单链表 <code>ha</code> 和 <code>hb</code> 存储，单链表中数据结点值的次序和对应集合的元素次序相同。单链表的结点类型如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"></span><br><span class="line">Struct node *next;</span><br><span class="line"></span><br><span class="line">&#125;LinkNode;</span><br></pre></td></tr></table></figure><p>现在求它们的交集，交集存放在带头结点的单链表 <code>hc</code> 中，完成以下算法设计，要求算法执行后不破坏原来的单链表，算法中给出适当的注释：</p><p>若两个集合的元素是递增有序的，设计对应的高效算法，给出算法的时间复杂度。</p><p>思路：釆用归并的思想，设置两个工作指针<code>pa</code>和<code>pb</code>，对两个链表进行归并扫描，只有同时出现在两集合中的元素才链接到结果表中且仅保留一个，其他的结点全部释放。当一个链表遍历完毕后，释放另一个表中剩下的全部结点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">Union</span><span class="params">(LinkList &amp;ha,LinkList &amp;hb,LinkList hc)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  LinkNode *pc=<span class="literal">NULL</span>;</span><br><span class="line">  LinkNode *pa=ha-&gt;next;</span><br><span class="line">  LinkNode *pb=hb-&gt;next;</span><br><span class="line">  LinkNode *c_tail=(*hc);</span><br><span class="line">  <span class="keyword">while</span>(pa&amp;&amp;pb)&#123;</span><br><span class="line">      <span class="keyword">if</span>(pa-&gt;data&gt;pb-&gt;data)&#123;</span><br><span class="line">          pb=pb-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(pa-&gt;data&lt;pb-&gt;data)&#123;</span><br><span class="line">          pa=pa-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        pc=(LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode*)); <span class="comment">//开辟新链点pc</span></span><br><span class="line">        pc-&gt;data=pa-&gt;data;           <span class="comment">//处理pc数据域</span></span><br><span class="line">        pc-&gt;next=<span class="literal">NULL</span>;             <span class="comment">//处理pc指针域</span></span><br><span class="line">        c_tail-&gt;next=pc;        <span class="comment">//将pc挂到C的链尾</span></span><br><span class="line">        c_tail=pc;</span><br><span class="line">      &#125;</span><br><span class="line">     </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> hc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：在<code>ha，hb</code>长度之间</p><hr><h3 id="2019年题2：链表相减"><a href="#2019年题2：链表相减" class="headerlink" title="2019年题2：链表相减"></a><strong>2019年题2：链表相减</strong></h3><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相减，并以相同形式返回一个表示差的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>以下是两数相加的代码，关于两数相减的代码暂无</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个新联表伪指针，用来指向头指针，返回结果</span></span><br><span class="line">        ListNode prev = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//定义一个可移动的指针，用来指向存储两个数之和的位置</span></span><br><span class="line">        ListNode cur = prev;</span><br><span class="line">        <span class="comment">//当l1 不等于null或l2 不等于空时，就进入循环</span></span><br><span class="line">        <span class="keyword">while</span>(l1!=null || l2!=null)&#123;</span><br><span class="line">            <span class="comment">//如果l1 不等于null时，就取他的值，等于null时，就赋值0，保持两个链表具有相同的位数</span></span><br><span class="line">            <span class="keyword">int</span> x= l1 !=null ? l1.val : <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//如果l1 不等于null时，就取他的值，等于null时，就赋值0，保持两个链表具有相同的位数</span></span><br><span class="line">            <span class="keyword">int</span> y = l2 !=null ? l2.val : <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//将两个链表的值，进行相加，并加上进位数</span></span><br><span class="line">            <span class="keyword">int</span> sum = x + y + carry;</span><br><span class="line">            <span class="comment">//计算进位数</span></span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            <span class="comment">//计算两个数的和，此时排除超过10的请况（大于10，取余数）</span></span><br><span class="line">            sum = sum % <span class="number">10</span>;</span><br><span class="line">            <span class="comment">//将求和数赋值给新链表的节点，</span></span><br><span class="line">            <span class="comment">//注意这个时候不能直接将sum赋值给cur.next = sum。这时候会报，类型不匹配。</span></span><br><span class="line">            <span class="comment">//所以这个时候要创一个新的节点，将值赋予节点</span></span><br><span class="line">            cur.next = <span class="keyword">new</span> ListNode(sum);</span><br><span class="line">            <span class="comment">//将新链表的节点后移</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">            <span class="comment">//当链表l1不等于null的时候，将l1 的节点后移</span></span><br><span class="line">            <span class="keyword">if</span>(l1 !=null)&#123;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当链表l2 不等于null的时候，将l2的节点后移</span></span><br><span class="line">            <span class="keyword">if</span>(l2 !=null)&#123;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果最后两个数，相加的时候有进位数的时候，就将进位数，赋予链表的新节点。</span></span><br><span class="line">        <span class="comment">//两数相加最多小于20，所以的的值最大只能时1</span></span><br><span class="line">        <span class="keyword">if</span>(carry == <span class="number">1</span>)&#123;</span><br><span class="line">            cur.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回链表的头节点</span></span><br><span class="line">        <span class="keyword">return</span> prev.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data[MaxSize];  <span class="comment">//栈的最大值</span></span><br><span class="line"><span class="keyword">int</span> top;             <span class="comment">//栈顶指针</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><hr><h3 id="2021年题2：设计中缀表达式转后缀表达式的算法"><a href="#2021年题2：设计中缀表达式转后缀表达式的算法" class="headerlink" title="2021年题2：设计中缀表达式转后缀表达式的算法"></a><strong>2021年题2：设计中缀表达式转后缀表达式的算法</strong></h3><p>机算：</p><p>从左到右开始扫描中缀表达式，遇到数字， 直接输出<br>遇到运算符</p><ol><li>若为“(” 直接入栈</li><li>若为“)” 将符号栈中的元素依次出栈并输出, 直到 “(“, “(“只出栈, 不输出</li><li>若为其他符号, 将符号栈中的元素依次出栈并输出, 直到遇到比当前符号优先级更低的符号或者”(“<ul><li>如果”+“or “-” 是当前符号，那么会将栈清空，或者遇到“（”</li><li>如果“×”or “/” 是当前符号，那么会在遇到下一个“×”or “/” 时停止，或者遇到“（”</li></ul></li><li>将当前符号入栈。扫描完后, 将栈中剩余符号依次输出</li></ol><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*中缀转后缀函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Change</span><span class="params">(SqStack *S,Elemtype str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">Elemtype e;</span><br><span class="line">InitStack(S);  <span class="comment">//初始化运算符栈</span></span><br><span class="line"><span class="keyword">while</span>(str[i]!=<span class="string">&#x27;\0&#x27;</span>)  <span class="comment">//字符串未到末尾</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(str[i]))  </span><br><span class="line">&#123;<span class="comment">/*过滤数字字符，直接输出，直到下一位不是数字字符打印空格跳出循环 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,str[i++]);</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">isdigit</span>(str[i]))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*加减运算符优先级最低，如果栈顶元素为空则直接入栈，否则将栈中存储的运算符</span></span><br><span class="line"><span class="comment">全部弹栈，如果遇到左括号则停止，将弹出的左括号从新压栈，因为左括号要和右括号</span></span><br><span class="line"><span class="comment">匹配时弹出，这个后面单独讨论。弹出后将优先级低的运算符压入栈中*/</span></span><br><span class="line"><span class="keyword">if</span>(str[i]==<span class="string">&#x27;+&#x27;</span>||str[i]==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!StackLength(S))        <span class="comment">//判断栈是否为空</span></span><br><span class="line">&#123;</span><br><span class="line">PushStack(S,str[i]);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>( StackLength(S) &amp;&amp; e != <span class="string">&#x27;(&#x27;</span> )</span><br><span class="line">&#123;</span><br><span class="line">PopStack(S,&amp;e);   <span class="comment">//出栈，将栈顶元素赋予e</span></span><br><span class="line"><span class="keyword">if</span>(e==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">PushStack(S,e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PushStack(S,str[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*当遇到右括号是，把括号里剩余的运算符弹出，直到匹配到左括号为止</span></span><br><span class="line"><span class="comment">左括号只弹出不打印（右括号也不压栈）*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(str[i]==<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">PopStack(S,&amp;e);</span><br><span class="line"><span class="keyword">while</span>(e!=<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,e);</span><br><span class="line">PopStack(S,&amp;e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*乘、除、左括号都是优先级高的，直接压栈*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(str[i]==<span class="string">&#x27;*&#x27;</span>||str[i]==<span class="string">&#x27;/&#x27;</span>||str[i]==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">PushStack(S,str[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(str[i]==<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n输入格式错误！\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*最后把栈中剩余的运算符依次弹栈打印*/</span></span><br><span class="line"><span class="keyword">while</span>(StackLength(S))</span><br><span class="line">&#123;</span><br><span class="line">PopStack(S,&amp;e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来几道题加强一下树的递归吧</p><ul><li>路径总和</li></ul><p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sum == root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li>翻转二叉树</li></ul><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode left = invertTree(root.left);</span><br><span class="line">        TreeNode right = invertTree(root.right);</span><br><span class="line">        root.left = right;</span><br><span class="line">        root.right = left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li>二叉树的最小深度</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> min_depth = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            min_depth = Math.min(minDepth(root.left), min_depth);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            min_depth = Math.min(minDepth(root.right), min_depth);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min_depth + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="基础知识-1"><a href="#基础知识-1" class="headerlink" title="基础知识"></a>基础知识</h3><p>定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>* <span class="title">lchild</span>, * <span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode, * BiTree;</span><br></pre></td></tr></table></figure><p>递归遍历操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的先序，中序，后序遍历(递归)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">//  printf(&quot;%c &quot;, T-&gt;data);  先序</span></span><br><span class="line">    PreOrderTraverse(T-&gt;lchild);</span><br><span class="line">  <span class="comment">//  printf(&quot;%c &quot;, T-&gt;data);  中序</span></span><br><span class="line">    PreOrderTraverse(T-&gt;rchild);</span><br><span class="line">  <span class="comment">//  printf(&quot;%c &quot;, T-&gt;data);  后序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>层序遍历&amp;队列相关操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义层次遍历中辅助队列的结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">queue</span> &#123;</span></span><br><span class="line">    BiTree data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">queue</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode,*PNODE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义辅助队列的队头队尾指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    LinkNode* front, * rear;</span><br><span class="line">&#125;LinkQueue,*PQUEUE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化队列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(PQUEUE Q)</span> </span>&#123;</span><br><span class="line">    Q-&gt;front = Q-&gt;rear = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode)); </span><br><span class="line">    Q-&gt;front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进队操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(PQUEUE Q, BiTree x)</span> </span>&#123;</span><br><span class="line">    PNODE s = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Q-&gt;rear-&gt;next = s;</span><br><span class="line">    Q-&gt;rear = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队操作</span></span><br><span class="line"><span class="function">BiTree <span class="title">DeQueue</span><span class="params">(PQUEUE Q)</span> </span>&#123;</span><br><span class="line">    PNODE p = Q-&gt;front-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">    Q-&gt;front-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;rear == p)</span><br><span class="line">        Q-&gt;rear = Q-&gt;front;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 层次遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    InitQueue(&amp;Q);</span><br><span class="line">    BiTree p=<span class="literal">NULL</span>;</span><br><span class="line">    EnQueue(&amp;Q, T);</span><br><span class="line">    <span class="keyword">while</span> (Q.front!=Q.rear) &#123;  <span class="comment">//判断是否队空</span></span><br><span class="line">        p=DeQueue(&amp;Q);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, p-&gt;data);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">            EnQueue(&amp;Q, p-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">            EnQueue(&amp;Q, p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2015年题2：输出根节点到指定结点的路径"><a href="#2015年题2：输出根节点到指定结点的路径" class="headerlink" title="2015年题2：输出根节点到指定结点的路径"></a>2015年题2：输出根节点到指定结点的路径</h3><p>思路：借助栈结构来保存路径上的结点，首先从根结点开始，一直往左找，如果左边找到就返回true；否则，如果左边找不到并且右子树不为空的情况下再继续往右子树找。如果左右子树都找不到，就弹出栈顶结点并返回false。方法运行完毕后，栈中保存的元素就是一条从根到给定结点的路径。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> boolean <span class="title">searchNode</span><span class="params">(TreeNode root,Stack&lt;TreeNode&gt; s,TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == null) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        s.push(root);</span><br><span class="line">        <span class="keyword">if</span>(root.val == node.val) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        boolean b = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//先去左子树找</span></span><br><span class="line">        <span class="keyword">if</span>(root.left != null) b = searchNode(root.left,s,node);</span><br><span class="line">        <span class="comment">//左子树找不到并且右子树不为空的情况下才去找</span></span><br><span class="line">        <span class="keyword">if</span>(!b &amp;&amp; root.right != null) b = searchNode(root.right,s,node);</span><br><span class="line">        <span class="comment">//左右都找不到，弹出栈顶元素</span></span><br><span class="line">        <span class="keyword">if</span>(!b) s.pop();</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2018年题2：求树的平衡因子"><a href="#2018年题2：求树的平衡因子" class="headerlink" title="2018年题2：求树的平衡因子"></a>2018年题2：求树的平衡因子</h3><p>二叉树结点的平衡因子（bf）定义为该结点的左子树高度与右子树高度之差。</p><p>设二叉树结点结构为：(<code>lchild,data,bf,rchild</code>)，<code>child，rchild</code> 左右儿子指针；<code>data</code> 是数据元素；</p><p><code>bf</code> 是平衡因子，编写递归算法计算二叉树中各个结点的平衡因子。</p><p>递归的计算每个节点的左子树与右子树的深度，然后左子树深度-右子树深度即为平衡因子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Depth</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">p=T;          <span class="comment">//p指向当前树T</span></span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">l=Depth(p-&gt;lchild);      <span class="comment">//遍历左子树</span></span><br><span class="line">r=Depth(p-&gt;rchild);        <span class="comment">//遍历右子树</span></span><br><span class="line"><span class="keyword">return</span> (l&gt;r?l:r)+<span class="number">1</span>;       <span class="comment">//左子树与右子树个数多的为当前树的深度</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bf</span><span class="params">(BiTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> LNum,RNum;     <span class="comment">//记录左右子树的度</span></span><br><span class="line"><span class="keyword">if</span>(T)</span><br><span class="line">&#123;</span><br><span class="line"> bf(T-&gt;lchild);       <span class="comment">//从树的底部开始计算</span></span><br><span class="line"> bf(T-&gt;rchild):</span><br><span class="line"> LNum=Depth(T-&gt;lchild);      <span class="comment">//当前节点左子树的度</span></span><br><span class="line"> RNum=Depth(T-&gt;rchild);  <span class="comment">//当前节点右子树的度</span></span><br><span class="line"> T-&gt;bf=LNum-RNum;     <span class="comment">//当前节点的平衡因子</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2020年题1：打印二叉树的某一层"><a href="#2020年题1：打印二叉树的某一层" class="headerlink" title="2020年题1：打印二叉树的某一层"></a>2020年题1：打印二叉树的某一层</h3><p>层数即level值，每递归一次将level值-1，减到1的时候就是该层</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TransLevel</span><span class="params">(Node* root,<span class="keyword">int</span> level)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(level == <span class="number">1</span>)</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,root-&gt;data);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            TransLevel(root-&gt;left,level<span class="number">-1</span>);</span><br><span class="line">            TransLevel(root-&gt;right,level<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="基础知识-2"><a href="#基础知识-2" class="headerlink" title="基础知识"></a>基础知识</h3><p>邻接矩阵法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VertexMax 100 <span class="comment">//最大顶点数为100</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxInt 32767 <span class="comment">//表示最大整数，表示 ∞</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Maxsize 100 <span class="comment">//队列最大元素个数100 </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VertexType; <span class="comment">//每个顶点数据类型为字符型</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">int</span> dataType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> Vertex[<span class="number">100</span>];<span class="comment">//存放顶点元素的一维数组,VertexType表示元素的数据类型</span></span><br><span class="line"><span class="keyword">int</span> AdjMatrix[<span class="number">100</span>][<span class="number">100</span>];<span class="comment">//邻接矩阵二维数组 </span></span><br><span class="line"><span class="keyword">int</span> vexnum, arcnum;<span class="comment">//图的顶点数和边数</span></span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找元素v在一维数组 Vertex[] 中的下标，并返回下标 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateVex</span><span class="params">(MGraph* G, <span class="keyword">char</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (v == G-&gt;Vertex[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;No Such Vertex!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindInDegree</span><span class="params">(MGraph G)</span></span>&#123;<span class="comment">//计算图中各节点的入度</span></span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; i ++)&#123;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.vexnum; j ++)</span><br><span class="line"><span class="keyword">if</span>(G.AdjMatrix[i][j])<span class="comment">//当两顶点之间存在边时，入度自加</span></span><br><span class="line">indegree[j] ++;  <span class="comment">//列表示入度</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>邻接表法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>//边表 </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> adjvex;<span class="comment">//存储的是该边指向的边在顶点数组即AdjList[]中的位置  下标域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">next</span>;</span>  <span class="comment">//指针域，用于连接后续结点</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span> //单个顶点 </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">int</span> vertex;  <span class="comment">//数据域   </span></span><br><span class="line"><span class="comment">//int weight；//存储网的时候需要添加此项</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">firstarc</span>;</span>   <span class="comment">//第一个孩子节点  指针域，用于连接边表</span></span><br><span class="line">&#125;VNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> //顶点表 </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">VNode AdjList[VertexMax];<span class="comment">//由顶点构成的结构体数组 </span></span><br><span class="line"><span class="keyword">int</span> vexnum,arcnum; <span class="comment">//顶点数n和边数e </span></span><br><span class="line">&#125;ALGraph;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> indegree[MAX];<span class="comment">//用来存储所有节点的入度之和</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindInputDgeree</span><span class="params">(ALGraph G)</span></span>&#123;<span class="comment">//计算所有节点的入度</span></span><br><span class="line">ArcNode *p;   <span class="comment">//临时边表变量</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; i ++)</span><br><span class="line">indegree[i] = <span class="number">0</span>;         <span class="comment">//初始化入度数组</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; i ++)&#123;</span><br><span class="line">p = G.AdjList[i].firstarc;    <span class="comment">//p设置为顶点的第一条边</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(p)&#123;            <span class="comment">//如果边不为空</span></span><br><span class="line">indegree[p-&gt;adjvex] ++;  <span class="comment">//顶点的对应位置的度+1</span></span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2016年题2：时间复杂度为O-V-E-logK-的最短路径算法"><a href="#2016年题2：时间复杂度为O-V-E-logK-的最短路径算法" class="headerlink" title="2016年题2：时间复杂度为O((V+E)logK)的最短路径算法"></a>2016年题2：时间复杂度为O((V+E)logK)的最短路径算法</h3><p>首先，朴素的迪杰斯特拉算法的时间复杂度为:$O(n^2)$，达不到题目要求</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShortestPath_Dijkstra</span><span class="params">(MGraph *G,VertexType start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,num;</span><br><span class="line"><span class="keyword">int</span> loc;</span><br><span class="line"><span class="keyword">int</span> min;</span><br><span class="line"><span class="keyword">int</span> dist[VertexMax];<span class="comment">//最短路径长度数组 </span></span><br><span class="line"><span class="keyword">int</span> path[VertexMax];<span class="comment">//最短路径数组 </span></span><br><span class="line"><span class="keyword">int</span> s[VertexMax];</span><br><span class="line">    <span class="comment">//代表集合S（1代表该顶点已处理，属于集合S；0代表该顶点未处理，不属于集合S，属于集合V-S） </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.初始化dist和path数组 </span></span><br><span class="line">loc=LocateVex(G,start);<span class="comment">//获取源点的下标位置 </span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;vexnum;i++)</span><br><span class="line">&#123;</span><br><span class="line">dist[i]=G-&gt;AdjMatrix[loc][i];<span class="comment">//初始化dist数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dist[i]!=MaxInt)<span class="comment">//初始化path数组</span></span><br><span class="line">&#123;</span><br><span class="line">path[i]=loc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">path[i]=<span class="number">-1</span>;</span><br><span class="line">&#125;  </span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line"><span class="comment">//2.初始化S数组(s数组：代表集合S，1代表该元素属于集合S(已处理的顶点),0该元素不属于集合S(未处理的顶点)) </span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;vexnum;i++)</span><br><span class="line">&#123;</span><br><span class="line">s[i]=<span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line">s[loc]=<span class="number">1</span>;<span class="comment">//代表起始点(源点)以处理完毕 </span></span><br><span class="line">num=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.</span></span><br><span class="line"><span class="keyword">while</span>(num&lt;G-&gt;vexnum)</span><br><span class="line">&#123;</span><br><span class="line">min=FindMinDist(dist,s,G-&gt;vexnum);</span><br><span class="line">        <span class="comment">//在dist数组中查找其对应s[i]=0，即未处理的最小值元素 </span></span><br><span class="line">s[min]=<span class="number">1</span>;<span class="comment">//将找到的最短边所对应的的顶点加入集合S</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;vexnum;i++)<span class="comment">//加入新的顶点后，更新dist和path数组 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((s[i]==<span class="number">0</span>)&amp;&amp;(dist[i]&gt;dist[min]+G-&gt;AdjMatrix[min][i]))<span class="comment">//路径累加</span></span><br><span class="line">&#123;</span><br><span class="line">dist[i]=dist[min]+G-&gt;AdjMatrix[min][i];</span><br><span class="line">path[i]=min;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    num++;</span><br><span class="line">&#125;    </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>观察代码</p><p>在上述流程中，我们发现要想找到数组<code>dist</code>最小的节点，是需要<code>O(n)</code>的时间复杂度去遍历所有的点，而这一个操作也是朴素版dijkstra时间复杂度为$O(n^2)$的主要原因。</p><p>那么我们该如何优化它呢？很简单，我们可以维护一个堆，用堆来储存我们下一个需要用来更新的节点，取出堆顶元素的时间复杂度为$O(log_2n)$，是远快于遍历所有节点的，再用$O(log_2n)$遍历每一条边，时间复杂度为$O((n+m)log_2n)$</p><p>由于堆优化与边的数量有关，所以一般运用于稀疏图。</p><p>由于堆很难写，我们可以直接使用<code>JAVA</code>中的<code>TreeMap</code>数据结构，<code>TreeMap</code>会自动对<code>Key</code>值进行排序，所以每次更新<code>dist</code>的时候，用<code>TreeMap</code>可以提高效率，将原版那个耗时的for循环换成从优先队列中<code>pop</code>出<code>dist值</code>最小的顶点，其他一切照常</p><hr><h3 id="2017年题2：判断无向图是否有环"><a href="#2017年题2：判断无向图是否有环" class="headerlink" title="2017年题2：判断无向图是否有环"></a>2017年题2：判断无向图是否有环</h3><p>解法：有向图和无向图都可以用拓扑排序来判断是否有环,区别在于，无向图将度为0和1的结点压入栈，有向图将度为1的结点压入栈</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TopologicalSort</span><span class="params">(MGraph G)</span></span>&#123;</span><br><span class="line">FindInDegree(G);</span><br><span class="line">SqStack S;                <span class="comment">//使用栈存储</span></span><br><span class="line"><span class="keyword">int</span> i,j,count = <span class="number">0</span>;</span><br><span class="line">InitStack(S);           <span class="comment">//初始化栈</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; i ++)</span><br><span class="line"><span class="keyword">if</span>(indegree[i]==<span class="number">0</span>)</span><br><span class="line">Push(S,i);<span class="comment">//把入度为零的节点压栈</span></span><br><span class="line">     </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;拓扑序列如下:\n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(!StackEmpty(S))&#123;</span><br><span class="line">Pop(S,i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,G.Vertex[i]);</span><br><span class="line">         count ++;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.vexnum; j ++)&#123;</span><br><span class="line"><span class="keyword">if</span>(G.AdjMatrix[i][j]！=<span class="number">0</span>)&#123;</span><br><span class="line">                indegree[j]--;       <span class="comment">//删除出栈结点向对应的边，让其相邻结点的入度-1</span></span><br><span class="line"><span class="keyword">if</span>(indegree[j]==<span class="number">0</span>)   <span class="comment">//如果入度为0，进栈</span></span><br><span class="line">Push(S,j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(count &lt; G.vexnum)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;此图有环存在!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：邻接表：<code>O(V+E)</code>  邻接矩阵：<code>O(V²)</code></p><hr><h3 id="2018年题1：求邻接表的入度"><a href="#2018年题1：求邻接表的入度" class="headerlink" title="2018年题1：求邻接表的入度"></a>2018年题1：求邻接表的入度</h3><p>设有向图用邻接表表示，图有 <code>n</code> 个顶点，表示为 <code>0</code> 至 <code>n-1</code>，试写一个算法求顶点 <code>k</code> 的入度（<code>0＜＝k＜n</code>）</p><p>在拓扑排序中已经使用过了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> indegree[MAX];<span class="comment">//用来存储所有节点的入度之和</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindInputDgeree</span><span class="params">(ALGraph G)</span></span>&#123;<span class="comment">//计算所有节点的入度</span></span><br><span class="line">ArcNode *p;   <span class="comment">//临时边表变量</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; i ++)</span><br><span class="line">indegree[i] = <span class="number">0</span>;         <span class="comment">//初始化入度数组</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; i ++)&#123;</span><br><span class="line">p = G.AdjList[i].firstarc;    <span class="comment">//p设置为顶点的第一条边</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(p)&#123;            <span class="comment">//如果边不为空</span></span><br><span class="line">indegree[p-&gt;adjvex] ++;  <span class="comment">//顶点的对应位置的度+1</span></span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="2019年题1：深度遍历实现拓扑排序"><a href="#2019年题1：深度遍历实现拓扑排序" class="headerlink" title="2019年题1：深度遍历实现拓扑排序"></a>2019年题1：深度遍历实现拓扑排序</h3><p>按DFS的顺序，在出栈时输出，自然是逆拓扑排序，要实现拓扑排序，只需要再添加一个栈的结构，即可实现拓扑排序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(MGraph* G, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.处理起始点 </span></span><br><span class="line"></span><br><span class="line">visitedDFS[i] = <span class="number">1</span>;<span class="comment">//2.将已访问的结点标志成1</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//2.由起始点开始，对后续结点进行操作</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G-&gt;vexnum; j++)<span class="comment">//依次搜索vi的邻接点 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (G-&gt;AdjMatrix[i][j] == <span class="number">1</span> &amp;&amp; visitedDFS[j] == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//当满足有边且未被访问过时，递归调用去查找该邻接点 </span></span><br><span class="line">&#123;</span><br><span class="line">DFS(G, j);<span class="comment">//注意此处的G已经是指针类型，不需要再&amp;G </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, G-&gt;Vertex[i]);<span class="comment">//逆拓扑排序，在出栈时输出 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2021题1：图中两点的途径"><a href="#2021题1：图中两点的途径" class="headerlink" title="2021题1：图中两点的途径"></a>2021题1：图中两点的途径</h3><p>设计一个算法，找出带权图中是否存在点 <code>i</code> 到点 <code>j</code> 的途径，有的话是多长，该图由邻接矩阵表示，说明邻接矩阵的数据结构</p><p>迪杰斯特拉算法即可</p><hr><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="2020年题2：编写算法删除堆中一个元素"><a href="#2020年题2：编写算法删除堆中一个元素" class="headerlink" title="2020年题2：编写算法删除堆中一个元素"></a>2020年题2：编写算法删除堆中一个元素</h3><p>按照堆排序的思想，只需要将被删除元素与堆末尾元素换位，其他的按堆的调整即可</p><p>堆的调整代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>* r, <span class="keyword">int</span> dad, <span class="keyword">int</span> end)</span> <span class="comment">//k~end为调整的范围 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ch = <span class="number">2</span> * dad; <span class="comment">//ch为dad的左孩子 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (ch &lt;= end)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//让指针j选出左、右孩子中较大者 </span></span><br><span class="line"><span class="keyword">if</span> (ch &lt; end &amp;&amp; r[ch] &lt; r[ch + <span class="number">1</span>]) </span><br><span class="line">          <span class="comment">//&quot;lch&lt;end&quot;表示i还有右孩子 ,若右孩子大，则让指针j指向右孩子// </span></span><br><span class="line">&#123;</span><br><span class="line">ch++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根节点与左、右孩子中的较大者 进行比较，进一步筛选出较大者，并将其换到根节点的位置上去 </span></span><br><span class="line"><span class="keyword">if</span> (r[dad] &lt; r[ch])</span><br><span class="line">&#123;</span><br><span class="line">swap(&amp;r[dad], &amp;r[ch]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若发生了，则可能需要对其孩子进行二次调整 </span></span><br><span class="line">dad = ch;</span><br><span class="line">ch = <span class="number">2</span> * dad;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> r[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="comment">//构建堆：由下至上 （由第一个非叶子结点开始） </span></span><br><span class="line"><span class="keyword">for</span> (k = n / <span class="number">2</span>; k &gt;= <span class="number">1</span>; k--)        <span class="comment">// n/2即是由下到上的第一个非叶子结点</span></span><br><span class="line">&#123;</span><br><span class="line">heapify(r, k, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调整堆：由上至下 </span></span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span>; k &lt; n; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//移走堆顶元素 </span></span><br><span class="line">swap(&amp;r[<span class="number">1</span>], &amp;r[n - k +<span class="number">1</span>]);  </span><br><span class="line">        <span class="comment">//r[1]是堆顶元素，即最大的元素，与堆最小的元素进行交换</span></span><br><span class="line"><span class="comment">//调整堆 </span></span><br><span class="line">heapify(r, <span class="number">1</span>, n - k);        <span class="comment">//每次都让堆顶元素出局，再重新构建堆</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设删除元素为T，找到T的位置<code>i</code>，与堆底元素交换，有两种情况：</p><ol><li>表尾元素&gt;T，那么可能与T的父节点冲突，需要进行上浮操作</li><li>表尾元素&lt;T，那么可能与T的子节点冲突，需要进行下沉操作</li></ol><p>上浮：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_increase_key</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> i,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">a[i] = key;</span><br><span class="line"><span class="keyword">while</span>(i&gt;<span class="number">1</span>&amp;&amp; i/<span class="number">2</span> &lt;a[i])</span><br><span class="line">&#123;</span><br><span class="line">h_swap(a[i],a[i/<span class="number">2</span>]);</span><br><span class="line">i=i/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下沉：即常规的调整操作，<code>dad</code>即是<code>t</code>，<code>end</code>即是<code>Length-1</code> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>* r, <span class="keyword">int</span> dad, <span class="keyword">int</span> end)</span> <span class="comment">//k~end为调整的范围 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ch = <span class="number">2</span> * dad; <span class="comment">//ch为dad的左孩子 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (ch &lt;= end)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//让指针j选出左、右孩子中较大者 </span></span><br><span class="line"><span class="keyword">if</span> (ch &lt; end &amp;&amp; r[ch] &lt; r[ch + <span class="number">1</span>]) </span><br><span class="line">          <span class="comment">//&quot;lch&lt;end&quot;表示i还有右孩子 ,若右孩子大，则让指针j指向右孩子// </span></span><br><span class="line">&#123;</span><br><span class="line">ch++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根节点与左、右孩子中的较大者 进行比较，进一步筛选出较大者，并将其换到根节点的位置上去 </span></span><br><span class="line"><span class="keyword">if</span> (r[dad] &lt; r[ch])</span><br><span class="line">&#123;</span><br><span class="line">swap(&amp;r[dad], &amp;r[ch]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若发生了，则可能需要对其孩子进行二次调整 </span></span><br><span class="line">dad = ch;</span><br><span class="line">ch = <span class="number">2</span> * dad;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2022：快速排序"><a href="#2022：快速排序" class="headerlink" title="2022：快速排序"></a>2022：快速排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Paritition1</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> pivot = A[low];    <span class="comment">//选定low位置上的数作为枢轴，low空缺</span></span><br><span class="line">   <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">     <span class="keyword">while</span> (low &lt; high &amp;&amp; A[high] &gt;= pivot) &#123; </span><br><span class="line">       --high;                 <span class="comment">// 直到找到小于枢轴的数</span></span><br><span class="line">     &#125;  </span><br><span class="line">     A[low] = A[high];         <span class="comment">//把小于枢轴的数换到low的位置去，此时high空缺</span></span><br><span class="line">     <span class="keyword">while</span> (low &lt; high &amp;&amp; A[low] &lt;= pivot) &#123;</span><br><span class="line">       ++low;                   <span class="comment">// 直到找到大于枢轴的数</span></span><br><span class="line">     &#125;</span><br><span class="line">     A[high] = A[low];        <span class="comment">//把大于枢轴的数换到high的位置去，此时low空缺</span></span><br><span class="line">   &#125;</span><br><span class="line">   A[low] = pivot;            <span class="comment">//high=low时结束，此时将枢轴的值放到该中间位置</span></span><br><span class="line">   <span class="keyword">return</span> low;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> <span class="comment">//快排母函数</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">     <span class="keyword">int</span> pivot = Paritition1(A, low, high);</span><br><span class="line">     QuickSort(A, low, pivot - <span class="number">1</span>);   <span class="comment">//递归</span></span><br><span class="line">     QuickSort(A, pivot + <span class="number">1</span>, high);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.绪论</title>
      <link href="/post/10659.html"/>
      <url>/post/10659.html</url>
      
        <content type="html"><![CDATA[<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="数据结构的基本概念"><a href="#数据结构的基本概念" class="headerlink" title="数据结构的基本概念"></a>数据结构的基本概念</h2><p>数据：信息的载体，是描述客观事件属性的数，字符以及所有能输入到计算机中并被计算机程序识别和处理的符号的集合</p><p>数据元素：是数据的基本单位</p><p>数据项：一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位</p><p>数据对象：具有相同性质的数据元素的集合，是数据的一个子集</p><p><strong>数据结构：相互之间存在一种或多种特定关系的数据元素的集合</strong></p><hr><p>例子：</p><div class="table-container"><table><thead><tr><th>姓名</th><th>学号</th><th>年龄</th><th>成绩</th></tr></thead><tbody><tr><td>candle</td><td>2018114514</td><td>20</td><td>98</td></tr><tr><td>nightswatch</td><td>2018114515</td><td>22</td><td>99</td></tr></tbody></table></div><p>一个学生的数据可以视作一个数据元素，而姓名，学号等属性可以看做是数据项，多个学生组成了一个数据对象</p><hr><h2 id="数据结构三要素"><a href="#数据结构三要素" class="headerlink" title="数据结构三要素"></a>数据结构三要素</h2><h3 id="1-逻辑结构"><a href="#1-逻辑结构" class="headerlink" title="1.逻辑结构"></a>1.逻辑结构</h3><p>即是数据元素之间的逻辑关系，和实际在计算机中的存储形式没有关系</p><p>常见的逻辑结构有：集合结构，线性结构，树形结构，图状结构</p><h3 id="2-数据运算"><a href="#2-数据运算" class="headerlink" title="2.数据运算"></a>2.数据运算</h3><p>即是针对某种逻辑结构，定义基本运算，或者说是基本操作</p><p>比如查找，插入，删除等</p><p>通过逻辑结构和数据运算就可以定义一种数据结构了</p><h3 id="3-物理结构（存储结构）"><a href="#3-物理结构（存储结构）" class="headerlink" title="3.物理结构（存储结构）"></a>3.物理结构（存储结构）</h3><p>物理结构即是数据在计算机中的存储结构</p><p>常见的物理结构有：</p><ul><li>顺序存储：把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现</li><li>链式存储：逻辑上相邻的元素在物理位置上可以不相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系</li><li>索引存储：在存储元素信息的同时，还建立附加的索引表。索引表中每一项称为索引项，一般由关键字和地址组成</li><li>散列存储：根据元素的关键字直接计算出该元素的存储地址</li></ul><p>存储结构会影响存储空间分配的方便程度和数据运算的速度</p><hr><h2 id="算法的基本概念"><a href="#算法的基本概念" class="headerlink" title="算法的基本概念"></a>算法的基本概念</h2><p>算法：对特定问题求解步骤的一种描述，是指令的有限序列，其中每条指令表示一个或多个操作</p><p>特性：</p><ul><li>有穷性：一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成</li><li>确定性：算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出</li><li>可行性：算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现</li></ul><hr><h2 id="时间复杂度和空间复杂度"><a href="#时间复杂度和空间复杂度" class="headerlink" title="时间复杂度和空间复杂度"></a>时间复杂度和空间复杂度</h2><p>评估算法的时间开销以及空间（内存）开销的指标</p><p>一般是大O表示法 </p><p>（空间换时间）</p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.存储器管理</title>
      <link href="/post/37793.html"/>
      <url>/post/37793.html</url>
      
        <content type="html"><![CDATA[<h1 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h1><h2 id="内存管理的必要性"><a href="#内存管理的必要性" class="headerlink" title="内存管理的必要性"></a>内存管理的必要性</h2><p>内存的基础知识在计算机执行时，处理器处理的几乎每一条指令都涉及到对存储器的访问，因此要求存储器的访问速度能跟上处理机的运行速度。此外还要求存储器有非常大的容量</p><p>因为主存储器的速度是跟不上处理器的，所以为了缓和这一矛盾，引入寄存器和高速缓存</p><p><strong>寄存器</strong>：有和处理器一样的速度，所以寄存器的访问速度最快，但是价格昂贵，主要用于存放处理器运行时的数据</p><p><strong>高速缓存</strong>：介于寄存器和储存器之间的存储器，主要用于备份主存中较常用的数据，一减少主存储器的访问次数，可以大幅提高程序执行速度</p><p><strong>磁盘缓存</strong>：磁盘的I/O速度也远低于对主存的访问速度，为了缓和矛盾，而设置了磁盘缓存，主要用于暂时存放频繁使用的一部分磁盘数据与信息，减少访问磁盘的次数，磁盘缓存与高速缓存不同，并不实际存在，而是将主存中部分存储空间暂时存放从磁盘中读出的信息，主存当然也可以看做是硬盘的高速缓存</p><p>由于任何程序和数据都<strong>必须占用内存空间</strong>才能执行和处理，因此有效地存储管理也是多道程序设计技术的关键支撑</p><hr><h2 id="内存管理的概念"><a href="#内存管理的概念" class="headerlink" title="内存管理的概念"></a><strong>内存管理的概念</strong></h2><ul><li><strong>内存分配</strong></li></ul><p>要为每道程序分配内存空间，提高存储器的利用率，尽量减少碎片，允许正在运行的程序增加内存空间，</p><ul><li><strong>内存保护</strong></li></ul><p>确保每道用户程序都仅在自己的内存空间中运行，绝不允许用户程序访问操作系统的程序和数据</p><ul><li><strong>地址映射</strong></li></ul><p>每道程序经过编译和链接后形成的地址都是从0开始的，但是不可能将它们真的从0开始的物理地址装入内存，为了保证程序运行，存储器必须提供地址映射功能，即将<strong>地址空间中的逻辑地址转换为内存空间中的物理地址，在硬件支持下完成</strong></p><ul><li><strong>内存扩充</strong></li></ul><p>借助虚拟存储功能，在逻辑上扩充内存容量</p><p>​    </p><hr><h2 id="覆盖与交换技术"><a href="#覆盖与交换技术" class="headerlink" title="覆盖与交换技术"></a>覆盖与交换技术</h2><p><strong>覆盖技术</strong></p><p>覆盖技术用来解决程序大小超过物理内存总和的问题</p><p>覆盖技术的思想：将程序分为多个段，常用的段常驻内存，不常用的段在需要时调入内存</p><p>在内存中分一个固定区和若干个覆盖区，需要常驻内存的段放在固定区中，调入后就不再调出，不常用的段放在覆盖区，需要用到时调入内存，用不到时调出内存</p><p>必须由程序员声明覆盖结构，操作系统自动完成覆盖</p><p>缺点：对用户不透明，增加了用户编程负担，现在已经成为历史</p><hr><p><strong>交换技术</strong></p><p>设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存(<strong>中级调度：进程在内存与磁盘间动态调度</strong>)</p><p>通常把磁盘分为文件区和对换区两部分，文件区主要用于存放文件，主要追求存储空间的利用率，因此采用的是<strong>离散分配方式</strong></p><p>对换区空间只占磁盘空间的小部分，因此对换区空间的管理主要追求换入换出速度，因此对换区采用<strong>连续分配方式</strong></p><hr><h2 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h2><p>连续分配：为用户分配的必须是一个连续的内存空间</p><h3 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h3><p>内存被分为系统区和用户区，系统区通常位于内存的低地址部分，用户存放操作系统的相关数据，用户区用于存放用户进程相关数据</p><p>内存中只能有一道用户程序，用户程序独占整个用户区空间</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220720165525523.png" alt="image-20220720165525523"></p><p>优点：</p><ul><li>实现简单，无外部碎片，可以采用覆盖技术扩充内存</li><li>不一定需要采用内存保护(早期的PC操作系统MS-DOS)</li></ul><p>缺点：</p><ul><li>只能用于单用户，单任务的操作系统中；</li><li>有内部碎片；</li><li>存储利用率极低</li></ul><div class="note primary flat"><p>内部碎片：分配给某进程的内存区域，如果有些部分没有用上</p><p>外部（内存）碎片：是指内存中某些空闲分区由于太小而难以利用</p></div><hr><h3 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h3><p>将整个用户空间分配为若干个固定大小的分区，在每个分区中只装入一道作业，这样就形成了最早的，最简单的一种可执行多道程序的内存管理方式</p><p>分区大小相等：缺乏灵活性，但是很适合用于用一台计算机控制多个相同对象的场合</p><p>分区大小不同：增加了灵活性，可以满足不同大小的进程需求</p><p>操作系统需要建立一个分区说明表，来实现各个分区的分配与回收，每个表项对应一个分区，通常按分区大小排列，每个表项包括对应分区的大小，起始地址，状态</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/gIUqhR3fL2Q7i1a.png" alt="image-20210809141346845"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/qnuWJP5LBlNzjAF.png" alt="image-20210809141333066" style="zoom:67%;" /></p><p><strong>地址转换</strong>：对于固定分区的方式采用<strong>静态地址重定位</strong>的方式</p><p><strong>内存保护</strong>：可由加载程序进行地址越界检查，即界地址保护</p><p>优点：</p><ul><li>实现简单，无外部碎片</li></ul><p>缺点</p><ul><li>会产生内部碎片，内存利用率低，当用户程序太大，不得不采取覆盖技术</li></ul><hr><h3 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a><strong>动态分区分配</strong></h3><p>在进程装入内存的时候，根据进程的大小<strong>动态</strong>地建立分区，并使分区的大小正好适合进程的需要，因此系统分区的大小数目是可变的</p><p>系统可以采用空闲分区表或者空闲分区链来记录内存的使用情况</p><ul><li>空闲分区表：每个空闲分区对应一个表项，表项中包含分区号，分区大小，分区起始地址等信息</li><li>空闲分区链：每个分区的起始部分和末尾部分分别设置前向指针和后向指针，起始部分处还可记录分区大小等信息</li></ul><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/fowURdezKrCsina.png" alt="image-20210809141433554"></p><p><strong>分配算法</strong>：当一个新作业装入内存时，须按照一定的动态分区分配算法，从空闲分区表中选出一个分区分配给该作业。由于分配算法对系统性能有很大影响，因此很重要</p><p><strong>分配内存</strong>：如果请求的分区比空闲分区小，只需要在空闲分区表中修改分区大小和起始位置，如果请求的分区和空闲分区一样，那么可以直接删除空闲分区的那个表项</p><p><strong>回收内存</strong>：有3种情况</p><p>如果回收区的前后有一个相邻的空闲分区，则将其合并</p><p>如果回收区的前后各有一个相邻的空闲分区，则全部合并</p><p>如果回收区的前后都没有相邻的空闲分区，则新增一个表项</p><hr><p><strong>地址转换</strong>：采用<strong>动态地址重定位</strong></p><p><strong>内存保护</strong>：设置两个专用控制寄存器，分别存放分区的起始地址和进程占有的连续存储空间的长度，在执行指令或访问数据时，由寄存器对比知道绝对地址以达到保护的目的</p><p><strong>动态分区分配没有内部碎片，但是有外部碎片</strong></p><hr><h4 id="首次适应算法（按序）"><a href="#首次适应算法（按序）" class="headerlink" title="首次适应算法（按序）"></a>首次适应算法（按序）</h4><p>算法思想：每次都从低地址开始查找，找到<strong>第一个能满足大小</strong>的空闲分区</p><p>实现方式：空闲分区以地址递增的次序排列，每次分配内存时顺序查找空闲分区表，找到大小能满足要求的第一个空闲分区</p><hr><h4 id="最佳适应算法（最小）"><a href="#最佳适应算法（最小）" class="headerlink" title="最佳适应算法（最小）"></a>最佳适应算法（最小）</h4><p>算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域，因此，为了保证当大进程到来时有连续的大片空间，可以尽可能多地留下大片的空闲区，<strong>优先使用更小的空闲区</strong></p><p>实现方式：将空闲分区按容量递增次序链接，每次分配内存时顺序查找空闲分区链，找到大小能满足要求的第一个空闲分区</p><p>缺点：每次都选最小的分区进行分配，会留下越来越多的，很小的，难以利用的内存块，这种方法会产生很多的外部碎片</p><hr><h4 id="最坏适应算法（最大）"><a href="#最坏适应算法（最大）" class="headerlink" title="最坏适应算法（最大）"></a>最坏适应算法（最大）</h4><p>算法思想：为了解决最佳适应算法的问题，可以在每次分配时<strong>优先利用最大</strong>的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用</p><p>实现方式：空闲分区按容量递减次序链接，每次分配内存时顺序查找空闲分区链，找到大小能满足要求的第一个空闲分区</p><p>缺点：每次都选最大的分区分配，但是会导致较大的连续空箱区被迅速用完，之后如果有大进程到达，就没有内存分区可用了</p><hr><h4 id="邻近适应算法（最近）"><a href="#邻近适应算法（最近）" class="headerlink" title="邻近适应算法（最近）"></a>邻近适应算法（最近）</h4><p>算法思想：首次适应算法每次都从表头开始查找，每次都要经过细小的分区，增加了查找的开销，如果每次<strong>都从上次查找结束的位置开始查找</strong>，就能解决上述问题</p><p>实现方式：空闲分区以地址递增的顺序排列，每次分配内存时从上次查找结束的位置开始查找空闲分区表，找到大小能满足要求的第一个空闲分区</p><hr><h4 id="算法总结"><a href="#算法总结" class="headerlink" title="算法总结"></a>算法总结</h4><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220720171539057.png" alt="image-20220720171539057"></p><p>综合来看，<strong>首次适应算法效果最好</strong></p><hr><h2 id="离散分配管理方式"><a href="#离散分配管理方式" class="headerlink" title="离散分配管理方式"></a>离散分配管理方式</h2><p>连续分配方式会形成很多碎片，虽然可以通过<strong>紧凑(compact)</strong>方法将许多碎片拼接成可用的大块空间，但是要付出很大开销，如果允许将一个进程直接分散地装入到许多不相邻接的分区中，便可充分利用内存空间，而无须紧凑，这就是离散分配方式，而离散分配方式又可以分为三种</p><ul><li>分页存储管理方式</li><li>分段存储管理方式</li><li>段页式存储管理方式</li></ul><hr><h3 id="分页存储管理方式"><a href="#分页存储管理方式" class="headerlink" title="分页存储管理方式"></a>分页存储管理方式</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><strong>页框</strong>（物理）：将内存空间分为一个个大小相等的分区，<strong>每个分区就是一个页框或物理块</strong>，每个页框有一个编号，即页框号，页框号<strong>从0开始</strong></p><p><strong>页面</strong>（逻辑）：将进程的<strong>逻辑地址空间</strong>也分为与页框大小相等的一个个部分，每个部分称为<strong>页或页面</strong>，每个页面也有一个编号，称为页号，页号也是<strong>从0开始</strong></p><p>操作系统以页框为单位为各个进程分配内存空间。进程的每个页面分别放入一个页框中，也就是说，进程的页面与内存的页框有一一对应的关系</p><p>各个页面不必连续存放，可以放到不相邻的各个页框中</p><p><strong>页表</strong>（对应）：为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表</p><ul><li>一个进程就对应一张页表</li><li>进程的每个页面对应一个<strong>页表项</strong></li><li><strong>页表记录进程页面和实际存放的内存块之间的映射关系</strong></li><li>页表实际上也是存储在页面内，所以页面大小能决定一页能存放多少个页表</li></ul><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/WPDd91chkJjYg2o.png" alt="image-20210801200907245" style="zoom:67%;" /></p><p>在页表中页号是隐含的</p><p><strong>页表项</strong>：在页表中，一个页号与其对应的物理块号称之为一个页表项</p><hr><p>例题：假设某物理内存大小为4GB，页面大小为4KB,则每个页表项至少应该为多少字节？</p><p>解：内存块大小=页面大小=4KB=$2^{12}$B</p><p>4GB的内存会被分为 $2^{32}/2^{12}=2^{20}$个内存块</p><p>内存块号至少需要20bit来表示来表示，即3B，页表项由页号和块号组成，页号是隐含的，所以每个页表项至少需要3B来表示</p><hr><p>内存的块数等于物理内存大小除以页面大小，可以算出需要多少个二进制数来表达具体的内存块数，再转换为字节数</p><p>页表记录的只是内存块号，而不是内存块的起始地址，<strong>J号内存块的起始地址等于J×内存块大小</strong></p><hr><p><strong>地址结构</strong></p><p>虽然进程的各个页面在物理上是离散存放的，但是页面内部是连续存放的</p><p>即一个进程只有一个页表以及多个页面，在每个页面里面，地址都是从0开始，连续存放的，而页内偏移量就是指，该逻辑地址在页面内部，距离页面起始的偏差值</p><p>如果要访问逻辑结构A，则需要找到A的页号P，然后找到P号页面在内存中的起始地址，确定逻辑地址A的页内偏移量W</p><hr><p>例：在某计算机系统中，页面大小是50B，某进程的逻辑地址空间大小时200B，则逻辑地址110的页号和页内偏移量是多少？</p><p>页号=110/2=2 </p><p>页内偏移量=110%50=10</p><hr><p>而在计算机内部，地址是用二进制表示的，如果页面大小刚好是2的整数幂，则计算机硬件可以很快速的把逻辑地址拆分为页号和页内偏移量</p><p>如果计算机用32个bit来表示逻辑地址，每个页面大小为$2^kB$，用二进制数表示逻辑地址，则末尾$K$位即为页内偏移量，其余部分就是页号</p><p>分页存储管理的逻辑地址结构如下</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/DytgG4FR1o26BIh.png" alt="image-20210801210543135"></p><p>地址结构包含两个部分：前一部分为页号，后一部分为页内偏移量，在图中，地址长度为<code>32</code>位，其中<code>0~11</code>位为页内偏移量，或称页内地址，12到31位是页号</p><p><strong>如果有K位表示页内偏移量，则说明该系统中一个页面的大小是$2^k$个内存单元</strong></p><p><strong>如果有M位表示页号，则说明在系统中，一个进程最多允许有$2^M$个页面</strong></p><hr><h4 id="基本地址变化机构"><a href="#基本地址变化机构" class="headerlink" title="基本地址变化机构"></a>基本地址变化机构</h4><p>基本地址变换结构可以借助进程的页表将<strong>逻辑地址转换为物理地址</strong></p><p>通常会在系统中设置一个<strong>页表寄存器</strong>，存放页表在内存中的起始位置$F$和页表长度$M$，进程未执行时，页表的起始位置和页表长度放在<strong>进程控制块(PCB)</strong>中，当进程被调度时，操作系统内核会把它们放在页表寄存器中</p><p>设页面大小为$L$，逻辑地址$A$到物理地址$E$的变换过程如下</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/ySdpBHliEt6TaLA.png" alt="image-20210801211947435"></p><ol><li>计算页号$P$和页内偏移量$W$</li><li>比较页号$P$和页表长度$M$，检查$P$是否小于$M$</li><li>页表中页号$P$对应的页表项地址=页表起始地址$F+$页号$P×$页表项长度，取出该页表项内容$B$，即内存块号</li><li>计算得到物理地址$E=$内存块号$B×$页面大小$L+$页内偏移量$W$，用得到的物理地址$E$去访存</li></ol><hr><h4 id="具有快表的地址变换结构"><a href="#具有快表的地址变换结构" class="headerlink" title="具有快表的地址变换结构"></a>具有快表的地址变换结构</h4><p><strong>快表</strong>，又称联想寄存器(TLB,translation lookaside buffer)，是一种访问速度比内存快很多的高速缓存，用来<strong>存放最近访问的页表项的副本</strong>，可以加速地址变换，与此对应，内页中的页表常称为慢表</p><p>变换过程：</p><ol><li>CPU给出逻辑地址，由某个硬件算得页号，页内偏移量，将页号与快表中的所有页号进行比较</li><li>如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元，因此，如果快表命中，则访问某个逻辑地址仅需<strong>一次访存</strong>即可</li><li>如果没有找到匹配的页号，则需要访问内存中的页表，计算得到物理地址后，访问该物理地址对应的内存单元，因此，若快表未命中，则访问某个逻辑地址需要<strong>两次访存</strong>(在找到页表项后，应同时将其存入快表，以便后面可能的再次访问)</li></ol><hr><h4 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a><strong>两级页表</strong></h4><p>单级页表的不便：</p><ul><li>如果要用页号来查询页表项，要在所有的页表项都连续存放的基础上才能用这种方法找到页表项，这违背了离散存储的特性</li><li>很多时候，进程在一段时间内只需要访问某几个页面就可以正常运行了，因此没有必要让整个页表都常驻内存</li></ul><p>解决进程必须在内存中连续存储的问题时，运用了分页的思想，那么解决页表必须连续存放时，同样可以把必须存放的页表再分页</p><p>可以将长长的页表进行分组，使每个内存块刚好可以放入一个分组，为离散分配的页表再建立一张页表，称为<strong>页目录表</strong>，或称外层页表</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/ew5xI9gTEbiMmjU.png" alt="image-20210802211551250"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/184SPyOb5H6ltZE.png" alt="image-20210802211746583"></p><p>其中一级页号可以在页目录表中指示页表的存放内存块号，然后二级页号可以指示页面的具体存放位置</p><p>若采取多级页表机制，则<strong>各级页表大小不能超过一个页面</strong></p><p>N级页表访问一个逻辑地址需要N+1次访存</p><hr><h3 id="分段存储管理方式"><a href="#分段存储管理方式" class="headerlink" title="分段存储管理方式"></a>分段存储管理方式</h3><p>进程的地址空间：按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名，每段从0开始</p><p>内存分配规则：以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻，由于是按逻辑功能模块划分，用户编程更方便，刻度性更高</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/Wu1986k4YF7dpwa.png" alt="image-20210803081423916"></p><p>段号的位数决定了每个进程最多可以分为几个段</p><p>段内地址位数决定了每个段的最大长度是多少</p><p>程序分为多个段，各段离散地装入内存，为了保证程序的运行，就必须从物理内存中找到各个逻辑段的存放位置，为此需要每个进程建立一张段映射表，简称<strong>段表</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/7TxhgkZL8dBurVX.png" alt="image-20210803081707171"></p><p>每个段对应一个段表项，其中记录了该段内存中的起始位置和段的长度</p><p>各个段表项的长度是相同的，因此，段号可以是隐含的，不占存储空间</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/bt1MLfahgB6smeZ.png" alt="image-20210803082507660"></p><hr><p><strong>分段，分页管理的对比</strong></p><ul><li><p>页是信息的物理单位，分页的主要目的是为了实现离散分配，提高内存利用率，分页仅仅是系统管理上的需要，对用户不可见</p></li><li><p>段是信息的逻辑单位，分段的主要目的是更好地满足用户需求，一个段通常包含着一组属于一个逻辑模块的信息。分段对用户是可见的</p></li></ul><hr><ul><li>分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址</li><li>分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址</li><li>分段比分页更容易实现信息的共享和保护</li></ul><p>分段，分页的优缺点分析</p><div class="table-container"><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>分页管理</td><td>内存空间利用率高，不会产生外部碎片，只会有少量页内碎片</td><td>不方便按照逻辑模块实现信息的共享和保护</td></tr><tr><td>分段管理</td><td>方便按照逻辑模块实现信息的共享和保护</td><td>如果段长过大，为其分配很大的连续空间会很不方便，另外，段式管理会产生<strong>外部碎片</strong></td></tr></tbody></table></div><hr><h3 id="段页式管理方式"><a href="#段页式管理方式" class="headerlink" title="段页式管理方式"></a>段页式管理方式</h3><p>段页式系统的基本原理还是分段和分页原理的结合，即先将用户程序分为若干段，再把每个段分为大小相同的内存块，并为每个段赋予一个段名</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/7PfF1sTjlknctyX.png" alt="image-20210803091142355"></p><p>段号的位数决定了每个进程最多可以分为几个段</p><p>页号位数决定了每个段最大有多少页</p><p>页内偏移量决定了页面大小，内存块大小</p><p>每个段对应一个段表项，每个段表项由段号，页表长度，页表存放块号组成，每个段表项长度相等，段号是隐含的</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/GtjNwQeP9YsFO1M.png" alt="image-20210803091514735"></p><p>变换过程</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/2UznTBkK8i34MQr.png" alt="image-20210803091614851"></p><p>需要三次访存，第一次是访问内存中的段表，第二次是访问内存中的页表，最后才是访问目标内存单元</p><hr><h2 id="不同分配方式的总结"><a href="#不同分配方式的总结" class="headerlink" title="不同分配方式的总结"></a><strong>不同分配方式的总结</strong></h2><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/wo8Y5bSRpWDyNm3.png" alt="image-20210811160917953"></p><hr><h1 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>传统存储管理方式存在一些问题，比如作业必须一次全部装入内存后才能开始运行，一旦作业被装入内存，就会一直驻留在内存中，直到作业结束，这会浪费很多内存资源</p><p>根据局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行，在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序</p><p>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存</p><p>在操作系统的作用下，在用户开始似乎有一个比实际内存大得多的内存，这就是<strong>虚拟内存</strong></p><p>虚拟内存技术，允许一个作业分多次调入内存，实现需要建立在离散分配的内存管理方式上</p><hr><h2 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h2><p>请求分页存储管理和基本分页存储管理的主要区别是：</p><p>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序，操作系统需要提供请求调页功能</p><p>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存，操作系统需要提供页面置换的功能</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/bCoa7GMtIJerE65.png" alt="image-20210803101510437"></p><p>请求分页存储管理的页表</p><p><strong>状态位</strong>：表示是否已调入内存</p><p><strong>访问字段</strong>：可记录最近被访问过几次，或记录上次被访问的时间，供置换算法参考</p><p><strong>修改位</strong>：表示页面调入内存后是否被修改过</p><p><strong>外存位置</strong>：页面在外存中的存放位置</p><hr><p>每当要访问的页面不在内存时，便产生一个缺页中断，然后由操作系统的缺页中断处理程序处理中断，此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放入就绪队列</p><p>如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中相应的页表项</p><p>如果内存中没有空闲块，则由<strong>页面置换算法</strong>选择一个页面淘汰，若该页面在内存期间被修改过，则要将其写回外存，未修改过的页面不用写回外存</p><p>缺页中断属于内中断，一条指令在实行期间，可能产生多次缺页中断</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/yeXovTDz1fq3KiS.png" alt="image-20210803102256507"></p><hr><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><p>页面的换入换出需要磁盘I/O，会有较大的开销，因此好的页面置换算法应该追求更少的缺页率</p><h3 id="最佳置换算法-OPT-Optimal"><a href="#最佳置换算法-OPT-Optimal" class="headerlink" title="最佳置换算法(OPT,Optimal)"></a><strong>最佳置换算法(OPT,Optimal)</strong></h3><p>每次选择淘汰的页面将是以后永不使用，或者最长时间内不再被访问的页面，这样可以保证最低的缺页率</p><p>最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面，操作系统无法提前预判页面访问序列，因此，最佳置换算法是无法实现的</p><hr><h3 id="先进先出算法（First-In-First-Out"><a href="#先进先出算法（First-In-First-Out" class="headerlink" title="先进先出算法（First In First Out)"></a><strong>先进先出算法（First In First Out)</strong></h3><p>每次选择淘汰的页面是最早进入内存的页面</p><p>Belady异常：当为进程分配的物理块数增大时，缺页次数不减反增的异常现象</p><p>只有FIFO算法会产生Belady异常，FIFO算法虽然实现简单，但是该算法与进程实际运行时的规律不适应，因此算法性能差</p><hr><h3 id="最近最久未使用置换算法-LRU-Least-Recently-Used"><a href="#最近最久未使用置换算法-LRU-Least-Recently-Used" class="headerlink" title="最近最久未使用置换算法(LRU,Least Recently Used)"></a><strong>最近最久未使用置换算法(LRU,Least Recently Used)</strong></h3><p>每次淘汰的页面是最近最久未使用的页面</p><p>实现方法：赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间t，当要淘汰一个页面时，选择t值最大的</p><p>该算法实现需要专门的硬件，虽然算法性能好，但是实现困难，开销大</p><hr><h3 id="时钟置换算法-CLOCK"><a href="#时钟置换算法-CLOCK" class="headerlink" title="时钟置换算法(CLOCK)"></a><strong>时钟置换算法(CLOCK)</strong></h3><p>又称最近未用算法(NRU,Not Recently Used)</p><p>实现方法：为每个页面设置一个访问位，再将内存中的页面都通过指针链接成一个循环队列。当某页被访问时，其访问位置为1。当要淘汰一个页面时，只需检查页的访问位。如果是0，就将其换出，如果是1，就将它置为0，继续检查下一个页面</p><p>若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0，再进行第二轮扫描</p><hr><h3 id="改进型时钟置换算法"><a href="#改进型时钟置换算法" class="headerlink" title="改进型时钟置换算法"></a><strong>改进型时钟置换算法</strong></h3><p>简单的时钟置换算法仅考虑到一个页面最近是否被访问过，事实上，如果被淘汰的页面没有被修改过，就不需要执行I/O操作写回外存，只有被淘汰的页面修改过，才需要写回外存</p><p>因此，操作系统还应考虑页面有没有被修改过，在其他条件都相同时，应优先淘汰没有修改过的页面，避免I/O操作，这就是改进型的时钟置换算法思想</p><p>修改位=0，表示未修改过，修改位为1，表示页面修改过，用(访问位,修改位)表示页面</p><p>第一轮：从当前位置开始扫描到第一个(0,0)替换</p><p>第二轮：若第一轮失败，则查找第一个(0,1)替换，本轮将所有扫描过的帧访问为设为0</p><p>第三轮：若第二轮失败，则重新扫描，查找到第一个(0,0)替换</p><p>第四轮：若第三轮扫描失败，则重新扫描，查找到第一个(0,1)替换</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/O4vuJlhzNQ1Xe3D.png" alt="image-20210803133816478"></p><hr><h2 id="页面分配策略，抖动，工作集"><a href="#页面分配策略，抖动，工作集" class="headerlink" title="页面分配策略，抖动，工作集"></a>页面分配策略，抖动，工作集</h2><p><strong>驻留集</strong>：指请求分页存储管理中给进程分配的物理块的集合</p><p><strong>工作集</strong>：指在某段时间间隔里，进程实际访问页面的集合</p><p>在任一时刻<code>t</code>，都存在一个集合，它包含所有最近<code>k</code>次（即为窗口大小）内存访问所访问过的页面。这个集合<code>w（k，t）</code>即为工作集</p><p>在使用虚拟存储技术的系统中，驻留集大小一般小于进程总大小</p><p><strong>固定分配</strong>：操作系统为每个进程分配一个固定数目的物理快</p><p><strong>可变分配</strong>：先为每个进程分配一定的数目，在运行期间，可根据情况做适当的增加或减少</p><hr><p><strong>局部置换</strong>：发生缺页的时候只能选进程自己的物理块进行置换</p><p><strong>全部置换</strong>：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程有的物理快置换到外存，在分配给缺页进程</p><p>全部置换肯定是可变分配</p><hr><h3 id="分配策略"><a href="#分配策略" class="headerlink" title="分配策略"></a><strong>分配策略</strong></h3><p><strong>固定分配局部置换</strong></p><p>系统为每个进程分配一定数量的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。</p><p>这种策略的缺点是：很难在刚开始就确定应为每个进程分配多少个物理块才算合理。（采用这种策略的系统可 以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的内存块数）</p><hr><p><strong>可变分配全部置换</strong></p><p>刚开始会为每个进程分配一定数量的物理块。操作系统会保持一个空闲物理块队列。当某进程发生缺页时，从空闲物理块中取出一块分配给该进程；若已无空闲物理块，则可选择一个未锁定的页面换出外存，再将该物理块分配给缺页的进程。</p><p>采用这种策略时，只要某进程发生缺页， 都将获得新的物理块，仅当空闲物理块用完时，系统才选择一个未锁定的页面调出。被选择调出的页可能是系统中任何一个进程中的页，因此这个被选中的进程拥有的物理块会减少，缺页率会增加。</p><hr><p><strong>可变分配局部置换</strong></p><p>刚开始会为每个进程分配一定数量的物理块，若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。若进程在运行中频繁缺页，系统会为该进程多分配几个物理块，直至该进程缺页率趋势适当程度</p><hr><h3 id="调入页面策略"><a href="#调入页面策略" class="headerlink" title="调入页面策略"></a><strong>调入页面策略</strong></h3><p><strong>预调页策略</strong>：根据局部性原理，一次调入若干个相邻的页面可能比一次调入一个页面更高效，但如果提前调入的页面中大多数都没被访问过，则又是低效的。因此可以预测不久之后可能访问到的页面，将它们预先调入内存，但目前预测成功率只有50%左右。故这种策略主要用于进程的<strong>首次调入</strong>， 由程序员指出应该先调入哪些部分。</p><hr><p><strong>请求调入策略</strong>：进程在<strong>运行期间</strong>发现缺页时才将所缺页面调入内存。由这种策略调入的页面一定会被访问到，但由于每次只能调入一页，而每次调页都要磁盘I/O操作，因此I/O开销较大。</p><hr><h3 id="调入页面的位置"><a href="#调入页面的位置" class="headerlink" title="调入页面的位置"></a><strong>调入页面的位置</strong></h3><p><strong>系统拥有足够的对换区空间</strong>：页面的调入、调出都是在内存与对换区之间进行，这样可以保证页面的调入、调出速度很快。在进程运行前，需将进程相关的数据从文件区复制到对换区。</p><p><strong>系统缺少足够的对换区空间</strong>：凡是不会被修改的数据都直接从文件区调入，由于这些页面不会被修改，因此换出时不必写回磁盘，下次需 要时再从文件区调入即可。对于可能被修改的部分，换出时需写回磁盘对换区，下次需要时再从对换区调入。</p><p><strong>UNIX 方式</strong>：运行之前进程有关的数据全部放在文件区，故未使用过的页面，都可从文件区调入。若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/KJhQi7u4gpwnex5.png" alt="image-20210803165725723" style="zoom:80%;" /></p><hr><h3 id="抖动现象"><a href="#抖动现象" class="headerlink" title="抖动现象"></a>抖动现象</h3><p>刚刚换出的页面马上就要换入内存，刚刚换入的页面马上又换出外存，这种频繁的页面行为称为抖动现象</p><p>产生抖动现象的主要原因是<strong>进程频繁访问的页面数目高于可用的物理块数</strong></p><p>操作系统会根据窗口尺寸来算出工作集，工作集大小可能小于窗口尺寸，在实际应用中，操作系统可以统计进程的工作集大小来考虑分配的驻留集</p><p>预防方法</p><ol><li>采用局部置换策略，即使发送了抖动也不会对其他进程造成影响</li><li>在调度中融入工作集算法</li><li>综合考虑缺页平均时间和平均缺页服务时间</li></ol><hr><h2 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h2><p>​        传统IO中当对文件进行操作的时候，一般总是先打开文件，然后申请一块内存用做缓冲区，再将文件数据循环读入并处理，当文件长度大于缓冲区长度的时候需要多次读入。  </p><p>​        内存映射文件是将一个文件直接映射到进程的进程空间中（“映射”就是建立一种对应关系,这里指硬盘上文件的位置与进程逻辑地址空间中一块相同区域之间一 一对应,这种关系纯属是逻辑上的概念，物理上是不存在的），这样可以通过内存指针用读写内存的办法直接存取文件内容。  在内存映射过程中,并没有实际的数据拷贝,文件没有被载入内存,只是逻辑上放入了内存,具体到代码,就是建立并初始化了相关的数据结构,<strong>这个过程由系统调用mmap()实现</strong>,所以映射的效率很高.</p><p>　　经验表明，内存映射IO允许加载不能直接访问的潜在巨大文件，在大文件处理方面性能更加优异。它的不足是增加了页面错误的数目（由于操作系统只将一部分文件加载到内存，如果一个请求页面没有在内存中，它将导致页面错误）。  </p><p>　映射文件区域的能力取决于于内存寻址的大小。在32位机器中，你不能一次访问超过4GB或2 ^ 32（以上的文件），只能分批映射。</p><hr><p>虚拟内存和内存映射文件的联系和区别</p><p>联系：</p><p>虚拟内存是内存映射文件的基础，内存映射文件的底层还是依赖虚拟内存。虚拟内存和内存映射文件都是<strong>将一部分内容加载到内存,另一部分放在磁盘上</strong>,二者都是应用程序动态性的基础,由于二者的虚拟性,对于用户都是透明的.  </p><p><strong>虚拟内存</strong>是硬盘的一部分,是计算机RAM（随机存取存储器）与硬盘的数据交换区,因为实际的物理内存可能远小于进程的地址空间，这就需要把内存中暂时不用到的数据放到硬盘上一个特殊的地方，当请求的数据不在内存中时，系统产生缺页中断，内存管理器便将对应的内存页重新从硬盘调入物理内存。  　</p><p><strong>内存映射文件</strong>是由一个文件到一块内存的映射，使应用程序可以通过内存指针对磁盘上的文件进行访问，其过程就如同对加载了文件的内存的访问，因此内存文件映射非常适合于用来管理大文件。</p><p>区别：</p><p><strong>虚拟内存</strong>实现的基础是分页机制和局部性原理，架构在物理内存之上,其引入是因为实际的物理内存运行程序所需的空间，即使现在计算机中的物理内存越来越大，将所有运行着的程序全部加载到内存中非常不现实。 　</p><p><strong>内存映射文件</strong>虚拟性并不是由于局部性，而是使进程虚拟地址空间的某个区域建立映射磁盘文件的全部或部分内容，通过该区域可以直接对被映射的磁盘文件进行访问，而不必执行文件I/O操作也无需对文件内容进行缓冲处理。</p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.进程管理</title>
      <link href="/post/14199.html"/>
      <url>/post/14199.html</url>
      
        <content type="html"><![CDATA[<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="进程基础"><a href="#进程基础" class="headerlink" title="进程基础"></a>进程基础</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>进程(Process)是<strong>进程实体</strong>的运行过程，是系统进行<strong>资源分配</strong>和<strong>调度</strong>的一个独立单位</p><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p><strong>进程控制块PCB(Process Control Block )是进程存在的唯一标志</strong>，当进程被创建时，操作系统会为其创建一个PCB,当进程结束时，会回收PCB</p><p>PCB包括了进程描述信息，进程控制和管理信息，资源分配清单，处理机相关信息</p><p><strong>进程标识符PID</strong>(Process ID)是计算机系统用来标识进程的标识符</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/gfhaxWIEndXGokR.png" alt="image-20211228220221061"></p><p>操作系统对进程进行管理工作所需的信息都存在PCB中</p><hr><p>而进程由<strong>PCB，程序段，数据段</strong>组成，<strong>PCB是由操作系统使用</strong>，程序段和数据段是给进程自己使用</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/Ngarjlzt6Mwi5Ie.png" alt="image-20211228220242360"></p><p>程序段：指程序在运行过程中需要的指令</p><p>数据段：包含运行过程中产生的各种数据</p><hr><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul><li>动态性  进程是程序的一次执行过程，是动态的产生，变化和消亡</li><li>并发性  内存中有多个进程实体，各进程可并发执行</li><li>独立性  进程是能独立运行，独立获得资源，独立接受调度的基本单位</li><li>异步性  各进程按各自独立的，不可预知的速度向前推进，操作系统要提供进程同步机制</li><li>结构性  各个进程都会有一个PCB</li></ul><hr><h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><p>创建态：进程正在被创建，状态是创建态，这个阶段操作系统会为进程分配资源，初始化PCB</p><p>就绪态：当进程创建完成后，就进入就绪态，处于就绪态的进程已经具备运行条件，但由于没有空闲CPU，就暂时不能运行</p><p>运行态：如果一个进程此时就在CPU上运行，那么这个进程就处于“运行态”，CPU会执行该进程对应的程序</p><p>阻塞态：在进程运行的过程中，可能会请求等待某个事件的发生，在这个事件发生之前，进程无法继续往下执行，此时操作系统会让这个进程下CPU，并让它进入阻塞态</p><p>终止态：执行exit系统调用，请求操作系统终止该进程，操作系统会让该进程下CPU，并回收内存空间等资源，最后还要回收该进程的PCB</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/X9VWdnRQUTyPN7u.png" alt="image-20211228220334514"></p><p>运行态到阻塞态是一种进程自身作出的<strong>主动行为</strong></p><p>阻塞态到就绪态不是进程自身能控制的，是一种<strong>被动行为</strong></p><p>在PCB中，有状态字state来记录当前进程的状态</p><hr><h3 id="进程的组织"><a href="#进程的组织" class="headerlink" title="进程的组织"></a>进程的组织</h3><p>链式方式：通过指针来指向PCB，执行指针指向运行态的程序，就绪队列指针指向在就绪态的PCB</p><p>索引方式：通过索引表来记录进程的状态</p><hr><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程，撤销已有进程，实现进程状态转换等功能</p><p>进程的控制通过<strong>原语</strong>来实现，原语的执行具有原子性，即执行过程只能一气呵成，期间不允许被中断，可以用“<strong>关中断指令</strong>”和“<strong>开中断指令</strong>”这个两个特权指令来实现原子性</p><p>CPU执行了关中断指令后，就不会检查中断指令了</p><hr><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><p>在OS中，允许一个进程去创建另一个进程，通常把创建进程的进程称为父进程，而把被创建的进程叫做子进程</p><p>子进程可以继承父进程所拥有的资源，和父进程并发执行，子进程在被创建的时候会被分配<strong>虚拟地址空间</strong></p><p>导致创建新线程的操作有</p><ul><li>用户登录</li><li>作业调度</li><li>提供服务</li><li>应用请求</li></ul><hr><h3 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h3><p>导致终止进程的操作有：</p><ul><li>正常结束</li><li>异常结束，比如非法指令，越界错误等</li><li>外界干预，比如父进程终止</li></ul><hr><h3 id="进程的阻塞和唤醒"><a href="#进程的阻塞和唤醒" class="headerlink" title="进程的阻塞和唤醒"></a>进程的阻塞和唤醒</h3><p>导致进程阻塞的操作有：</p><ul><li>向系统请求共享资源失败</li><li>等待某种操作的完成，比如等待I/O设备</li><li>新数据还没到达</li><li>等待新任务的到达</li></ul><p>导致进程唤醒的操作即是满足了进程的要求</p><hr><h3 id="进程的切换"><a href="#进程的切换" class="headerlink" title="进程的切换"></a>进程的切换</h3><p>让两个进程的状态发生改变，让进程在就绪状态和运行状态中切换</p><p>就绪→运行：进程被调度</p><p>运行→就绪：时间片耗尽或被高优先级进程抢占</p><hr><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>之前已经提到过操作系统具有异步性，各并发执行的进程以独立的，不可预知的速度向前推进</p><p>在管道通信中，读进程和写进程并发地运行，由于并发必然导致异步性，因此写数据和读数据两个操作的执行先后顺序是不确定的，而在实际应用中，又必须按照先写再读的顺序来执行</p><p><strong>进程同步</strong>，就是要对多个相关进程在执行次序上进行协调，使并发执行的多个进程之间能按照<strong>一定的规则</strong>共享系统资源，并能很好地相互合作，从而使执行具有可再现性</p><hr><p><strong>临界资源</strong>：一个时间段只允许一个进程使用的资源称为临界资源，许多物理设备都是临界资源</p><p>对于临界资源的访问，必须要<strong>互斥</strong>的进行。互斥，又称<strong>间接制约关系</strong>，进程互斥指当一个进程访问临界资源的时候，另一个想要访问该临界资源的进程必须等待</p><p>对临界资源的互斥访问，可以在逻辑上划分为以下四个部分</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/1qldyj6o98shf2W.png" alt="image-20211228220737049"></p><p>进入区：负责检查是否可以进入临界区，如可进入，则应设置正在访问临界资源的标志（上锁），防止其他进程同时进入临界区</p><p><strong>临界区</strong>：每个进程中访问临界资源的<strong>那段代码</strong>叫做临界区</p><p>退出区：负责解除正在访问临界资源的标志(解锁)</p><p>剩余区：做其他处理</p><hr><p>为了实现对临界资源的互斥访问，同时保证系统性能，需要遵循以下原则：</p><ul><li><strong>空闲让进</strong> 当临界区空闲的时候，可以允许一个请求进入临界区的进程立即进入</li><li><strong>忙则等待</strong> 当临界区中有进程时，其他试图进入临界区的进程必须等待</li><li><strong>有限等待</strong> 对请求访问的进程，应保证能在有限的时间内进入临界区</li><li><strong>让权等待</strong> 当进程不能进入临界区时，应立即释放处理机，防止进程忙等待</li></ul><hr><h3 id="进程互斥的软件实现方法"><a href="#进程互斥的软件实现方法" class="headerlink" title="进程互斥的软件实现方法"></a>进程互斥的软件实现方法</h3><p><strong>单标志法</strong>：两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程，也就是说每个进程进入临界区的权限只能被另一个进程赋予</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> turn=<span class="number">0</span>;</span><br><span class="line"><span class="comment">// 进程0</span></span><br><span class="line"><span class="keyword">while</span>(turn!=<span class="number">0</span>);</span><br><span class="line">    critical section;</span><br><span class="line">    turn=<span class="number">1</span>;</span><br><span class="line">    remained section;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程1</span></span><br><span class="line"><span class="keyword">while</span>(turn!=<span class="number">1</span>);</span><br><span class="line">    critical section</span><br><span class="line">    turn=<span class="number">0</span>;</span><br><span class="line">    remainder section</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>turn作为标志位，可以实现同一时刻最多只允许一个进程访问临界区</p><p>最大的问题在于，只能轮流访问，如果临界区空闲，但是并不允许其他进程访问，主要问题就是违反了空闲让进原则</p><hr><p><strong>双标志先检查法</strong>：设置一个布尔数组<code>flag[]</code>，数组中的各个元素用来标记各进程想要进入临界区的意愿</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> flag[<span class="number">2</span>];</span><br><span class="line">flag[<span class="number">0</span>]=<span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>]=<span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 刚开始设计两个进程都不行进入临界区</span></span><br><span class="line"><span class="comment">//进程0</span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>]==<span class="literal">false</span>);</span><br><span class="line">flag[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">0</span>]=<span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进程1</span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>]==<span class="literal">false</span>);</span><br><span class="line">flag[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">1</span>]=<span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>双标志先检查法的主要问题是：进入区的检查和上锁两个处理不是一气呵成的，检查之，上锁前可能发生进程切换</p><hr><p><strong>双标志后检查法</strong>：如果把while和flag的位置交换，就是后检查法</p><p>虽然解决了忙则等待的问题，但是如果两个进程同时把flag改为1，就都无法进入临界区了，也是不行的</p><hr><p><strong>Peterson算法</strong></p><p>结合双标志法和单标志法，结合轮转和表达意愿</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> flag[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> turn=<span class="number">0</span>;</span><br><span class="line"><span class="comment">// 进程0</span></span><br><span class="line">flag[<span class="number">0</span>]=<span class="literal">true</span>;   <span class="comment">// 我要进入</span></span><br><span class="line">turn=<span class="number">1</span>;        <span class="comment">// 进程1先用</span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>]==<span class="literal">false</span>&amp;&amp;turn==<span class="number">1</span>);</span><br><span class="line">cirtical section;</span><br><span class="line">flag[<span class="number">0</span>]=<span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进程1</span></span><br><span class="line">flag[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">turn=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>]==<span class="literal">false</span>&amp;&amp;turn==<span class="number">0</span>);</span><br><span class="line">cirtical section;</span><br><span class="line">flag[<span class="number">1</span>]=<span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用软件的方法解决了进程互斥问题，遵循了空闲让进，忙着等待，有限等待三个原则，但是依然没有遵循<strong>让权等待</strong>的原则</p><hr><h3 id="进程互斥的硬件实现方法"><a href="#进程互斥的硬件实现方法" class="headerlink" title="进程互斥的硬件实现方法"></a>进程互斥的硬件实现方法</h3><p><strong>1.利用开/关中断</strong></p><p>在进入临界区之前关闭中断，中断关闭后即不允许当前进程被被中断，也必然不会发生进程切换，直到进程访问完临界区，再执行开中断指令，才有可能有别的进程上处理机并访问临界区</p><p>优点：简单，高效</p><p>缺点：滥用关中断权利可能会导致严重后果，关中断时间过长，会影响系统效率，不适用于多CPU系统</p><hr><p><strong>2.利用Test-and-Set指令实现互斥</strong></p><p>借助TSL指令以实现互斥，TS指令用硬件实现，执行的过程不允许被中断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//布尔型共享lock表示当前临界区是否被加锁</span></span><br><span class="line"><span class="comment">//true表示已加锁，false表示未加锁</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TestAndSet</span><span class="params">(<span class="keyword">bool</span> *lock)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> old;</span><br><span class="line">    old=*lock;</span><br><span class="line">    *lock=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用TEL执行实现互斥的算法逻辑</span></span><br><span class="line"><span class="keyword">while</span>(TestAndSet(&amp;lock));<span class="comment">// 上锁并检查</span></span><br><span class="line"><span class="comment">//临界区</span></span><br><span class="line">lock=<span class="literal">false</span>;   <span class="comment">// 解锁</span></span><br><span class="line"><span class="comment">//剩余区</span></span><br></pre></td></tr></table></figure><p>相比软件实现方法，TSL指令把上锁和检查操作用硬件的方式变成了一气呵成的原子操作</p><p>优点：实现简单，无需像软件实现方法那样严格检查是否有逻辑漏洞</p><p>缺点：不满足让权等待</p><hr><p><strong>3.Swap指令</strong></p><p>也叫Exchange指令，或者XCHG指令</p><p>Swap指令是用硬件实现的，执行过程不允许被中断，只能一气呵成</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swap指令就是交换两个变量的值</span></span><br><span class="line">Swap(<span class="keyword">bool</span> *a,<span class="keyword">bool</span> *b)&#123;</span><br><span class="line"><span class="keyword">bool</span> temp;</span><br><span class="line">temp=*a;</span><br><span class="line">*a=*b;</span><br><span class="line">*b=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//lock表示临界区是否被加锁</span></span><br><span class="line"><span class="keyword">bool</span> old=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(old==<span class="literal">true</span>)</span><br><span class="line">    Swap(&amp;lock,&amp;old);</span><br><span class="line"><span class="comment">//临界区代码段</span></span><br><span class="line">lock=<span class="literal">false</span>;</span><br><span class="line"><span class="comment">//剩余区代码段</span></span><br></pre></td></tr></table></figure><p>优缺点和TSL指令一致</p><hr><h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><p>回顾之前解决互斥的方法，都无法实现让权等待的问题，Dijkstra提出了一种方案，就也就是信号量机制</p><p>用户进程可以通过使用操作系统提供的<strong>一对原语</strong>来对信号量进行操作</p><p><strong>信号量</strong>：其实就是一个变量，可以用一个信号量来表示系统中某种资源的数量</p><p><strong>一对原语</strong>：<code>wait(S)</code>原语和<code>signal(S)</code>原语，可以把原语理解为自己写的函数，名字分别为<code>wait</code>和<code>signal</code>，括号里的<strong>信号量S</strong>其实就是函数调用时传入的一个参数</p><p><code>wait，signal</code>原语常被简称为<code>P,V</code>操作</p><hr><p><strong>整型信号量</strong>：用一个整数型的变量作为信号量，用来表示系统中某种资源的数量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> S=<span class="number">1</span>;<span class="comment">// 初始化整型信号量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> S)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(S&lt;=<span class="number">0</span>);</span><br><span class="line">S--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> S)</span></span>&#123;</span><br><span class="line">S++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进程0</span></span><br><span class="line">wait(S);</span><br><span class="line"><span class="comment">//临界区</span></span><br><span class="line">signal(S)</span><br></pre></td></tr></table></figure><p>和双标志先检查法类似，不过将检查和上锁通过原语操作一气呵成，所以避免了并发和异步的问题</p><p>缺点：依然不满足让权等待的原则</p><hr><p><strong>记录型信号量</strong></p><p>即用记录型数据结构表示的信号量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录型信号量的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"> <span class="keyword">int</span> value;         <span class="comment">//剩余资源数</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">L</span>;</span>  <span class="comment">//等待队列</span></span><br><span class="line">&#125;semaphore</span><br><span class="line"></span><br><span class="line"> <span class="comment">//某进程需要使用资源时，通过wait原语申请</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">wait</span> <span class="params">(semaphore S)</span></span>&#123;</span><br><span class="line">  S.value--;          <span class="comment">// 在等待就将value值-1</span></span><br><span class="line">  <span class="keyword">if</span>(S.value&lt;<span class="number">0</span>)&#123;</span><br><span class="line">      block(S.L)  <span class="comment">//资源数不够就阻塞，并且挂到信号量S的等待队列中去</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进程使用完资源后，通过signal原语释放</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span> <span class="params">(semaphore S)</span></span>&#123;</span><br><span class="line">    s.value++;</span><br><span class="line">    <span class="keyword">if</span>(S.value&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        wakeup(S.L); </span><br><span class="line"><span class="comment">// 释放资源后，若还有别的进程在等待，就使用wakeup原语唤醒一个进程，该进程从阻塞态变为就绪态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>遵循了让权等待的原则</p><hr><p>使用信号量机制实现<strong>进程互斥，进程同步，前驱关系</strong></p><p><strong>进程互斥</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置互斥信号量mutex，初值为1</span></span><br><span class="line">semaphore mutex=<span class="number">1</span>;</span><br><span class="line">P1()&#123;</span><br><span class="line">P(mutex);</span><br><span class="line">....    </span><br><span class="line">V(mutex):</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P2()&#123;</span><br><span class="line">P(mutex);</span><br><span class="line">....    </span><br><span class="line">V&#123;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于不同临界资源设置不同的信号量</p><hr><p><strong>进程同步</strong></p><p>要求让各并发进程按要求有序地推进</p><p>分析在什么地方实现同步关系，设置同步信号量S，初始为0</p><p>在前操作之后执行V(S),后操作之前执行P(S)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">P1()&#123;</span><br><span class="line"> 代码<span class="number">1</span>；</span><br><span class="line"> 代码<span class="number">2</span>；</span><br><span class="line"> V(S);</span><br><span class="line"> 代码<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P2()&#123;</span><br><span class="line"> P(S);</span><br><span class="line"> 代码<span class="number">4</span>;</span><br><span class="line"> 代码<span class="number">5</span>;</span><br><span class="line"> 代码<span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样可以保证代码4一定在代码2之后执行</p><p>若先执行V(S),则S+1后S=1，此时P(S)可以执行，反之，P(S)在S=0时不能执行，要等V(S)执行后唤醒</p><hr><p><strong>前驱关系</strong></p><p>有些进程必须等其他进程执行了之后才具备执行条件，所以要为每一对前驱关系各设置一个同步信号量</p><hr><h3 id="管程机制"><a href="#管程机制" class="headerlink" title="管程机制"></a>管程机制</h3><p>虽然信号量机制是一种方便有效地进程同步机制，但是会产生大量的PV操作，不仅给系统的管理带来了麻烦，而且还会因为同步不当导致系统死锁，为了解决上述问题，所以使用了管程(Monitors)机制</p><p><strong>管程的定义</strong></p><ul><li><p>系统中各种硬件资源和软件资源都可以用数据结构抽象地描述其资源特性，可以利用共享数据结构抽象地表示系统中的共享资源。</p></li><li><p>将对该共享数据结构实施的特定操作定义为一组过程。</p></li><li><p>对局部于管程的共享数据设置初始值的语句</p></li></ul><p><strong>管程的特征</strong></p><ul><li><p>局部于管程的数据只能被局部于管程的过程所访问</p></li><li><p>一个进程只能通过调用管程内的过程才能进入管程访问共享数据</p></li><li><p><strong>每次仅允许一个进程在管程内执行某个内部过程</strong></p></li></ul><p>管程就是面向对象里面封装思想的体现，将复杂的PV操作写进管程里面，从而使主函数变得简洁</p><hr><h2 id="经典的进程同步问题"><a href="#经典的进程同步问题" class="headerlink" title="经典的进程同步问题"></a>经典的进程同步问题</h2><h3 id="生产者与消费者问题"><a href="#生产者与消费者问题" class="headerlink" title="生产者与消费者问题"></a><strong>生产者与消费者问题</strong></h3><p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品在缓冲区，而消费者消费一个产品在缓冲区，生产者，消费者共享一个大小为<code>n</code>的缓冲区，缓冲区是临界资源</p><ul><li>只有缓冲区没满，生产者才能把产品放进去</li><li>只有缓冲区不空，消费者才能从中取出产品</li><li>缓冲区必须互斥访问</li></ul><p>所以需要有3个PV操作</p><hr><p><strong>1.记录型信号量</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex=<span class="number">1</span>; <span class="comment">//互斥信号量，实现对缓冲区的互斥访问 </span></span><br><span class="line">semaphore empty=n; <span class="comment">//同步信号量，表示空闲缓冲区的数量</span></span><br><span class="line">sempahore full=<span class="number">0</span>   <span class="comment">//同步信号量，表示产品的数量</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 可以具象化实现过程，产品等于菜，而空闲缓冲区等于座位，有多少座位就可以上多少道菜，座位和菜是绑定关系，对于生产来说，首先是占一个座位，然后在上面生产出一道菜，对于消费来说，首先是消费了一道菜，然后才会释放一个座位</span></span><br><span class="line">producer()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">       produce;</span><br><span class="line">       P(empty);  </span><br><span class="line">       P(mutex);</span><br><span class="line">       input;</span><br><span class="line">       V(mutex);</span><br><span class="line">       V(full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">comsumer()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(full);</span><br><span class="line">        P(mutex);</span><br><span class="line">        output;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(empty);</span><br><span class="line">        use;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：实现互斥的P操作一定要在实现同步的P操作之后</p><hr><p><strong>2.管程</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">monitor ProducerConsumer</span><br><span class="line">    condition full,empty;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;<span class="comment">//产品数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Item item)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count==N)</span><br><span class="line">        &#123;</span><br><span class="line">            P(empty);</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">        insert_item(item);</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">1</span>)</span><br><span class="line">            V(full);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function">Item <span class="title">remove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(count==<span class="number">0</span>)</span><br><span class="line">        P(full);</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span>(count==N<span class="number">-1</span>)</span><br><span class="line">        V(empty);</span><br><span class="line">    <span class="keyword">return</span> remove_item()</span><br><span class="line">&#125;</span><br><span class="line">end monitor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line">produce()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        item=生产;</span><br><span class="line">        ProducerConsumer.insert(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line">produce()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        item=ProdecuerConsumer.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="哲学家进餐"><a href="#哲学家进餐" class="headerlink" title="哲学家进餐"></a><strong>哲学家进餐</strong></h3><p>该问题是描述有五个哲学家共用一张圆桌，分别坐在周围的五张椅子上，在圆桌上有五个碗和五只筷子，他们的生活方式是交替地进行思考和进餐。平时，一个哲学家进行思考，饥饿时便试图取用其左右最靠近他的筷子，只有在他拿到两只筷子时才能进餐。进餐毕，放下筷子继续思考。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/f2cWdCtQoKb3yzH.png" alt="image-20211228220755055"></p><p>首先，有5个哲学家进程，哲学家与左右邻居对其中间筷子的访问是互斥关系，每个哲学家进程需要同时持有两个临界资源才开始吃饭，主要问题在于如何避免死锁</p><p>信号量设置，定义互斥信号量数组<code>chopstick[5]=&#123;1,1,1,1,1&#125;</code>用于实现对5个筷子的互斥访问。并对哲学家按0~4编号，哲学家<code>i</code>左边的筷子编号为i，右边的筷子编号为<code>(i+1)%5</code></p><p>为了防止5个哲学家都持有一只筷子而发生死锁，需要对筷子的拿取设置一定的规则</p><p>比如最多允许4个哲学家同时进餐，或者仅当哲学家的左右筷子均可用时，才允许拿起筷子进餐</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 仅当哲学家的左右筷子均可用时，才允许拿起筷子进餐</span></span><br><span class="line">semaphore chopstick[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;</span><br><span class="line">semaphore mutex=<span class="number">1</span>;</span><br><span class="line">Pi()&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    P(mutex);</span><br><span class="line">    P(chopstick[i]);</span><br><span class="line">    P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">    V(mutex);</span><br><span class="line">    吃饭...</span><br><span class="line">    V(chopstick[i]);</span><br><span class="line">    V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">    思考...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最多允许4个哲学家进餐</span></span><br><span class="line">semaphore chopstick[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;</span><br><span class="line">semaphore x=<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    p(x);</span><br><span class="line">    P(chopstick[i]);</span><br><span class="line">    P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">    就餐</span><br><span class="line">    V(chopstick[i]);</span><br><span class="line">    V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">    V(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a><strong>读者-写者问题</strong></h3><p>一个数据文件或记录可被多个进程共享，我们把只要求读该文件的进程称为”Reader进程”，其他进程则称为”Writer 进程”。</p><p>允许多个进程同时读一个共享对象，因为读操作不会使数据文件混乱。</p><p>但不允许一个 Writer 进程和其他 Reader 进程或 Writer 进程同时访问共享对象。因为这种访问将会引起混乱。</p><p>所谓”读者-写者（Reader-Writer Problem）问题”是指保证一个 Writer 进程必须与其他进程互斥地访问共享对象的同步问题。读者-写者问题常被用来测试新同步原语。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">semaphore rw=<span class="number">1</span>; <span class="comment">//实现对共享文件的互斥访问</span></span><br><span class="line"><span class="keyword">int</span> count =<span class="number">0</span>;  <span class="comment">//记录当前有几个读进程在访问文件</span></span><br><span class="line">semaphore mutex=<span class="number">1</span> <span class="comment">//保证对count变量的互斥访问</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"> writer()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(rw);  <span class="comment">//写之前加锁</span></span><br><span class="line">        <span class="function">Write</span></span><br><span class="line"><span class="function">        <span class="title">V</span><span class="params">(rw)</span></span>;  <span class="comment">//写完了解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">reader()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(mutex)  <span class="comment">//各个读进程互斥访问count</span></span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)<span class="comment">// 由第一个读进程负责</span></span><br><span class="line">            P(rw);   <span class="comment">//读之前加锁</span></span><br><span class="line">        count++;</span><br><span class="line">        V(mutex);</span><br><span class="line">        <span class="function">Read</span></span><br><span class="line"><span class="function">        <span class="title">P</span><span class="params">(mutex)</span></span>;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>) <span class="comment">//由最后一个读进程负责</span></span><br><span class="line">            V(rw);    <span class="comment">//读完了解锁</span></span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="抽烟者问题"><a href="#抽烟者问题" class="headerlink" title="抽烟者问题"></a><strong>抽烟者问题</strong></h3><p>假设一个系统有三个抽烟者进程和一个供应者进程。 每个抽烟者不停地卷烟并抽掉，但是要卷起并抽掉一支烟，抽烟者需要三种材料：烟草、纸和胶水。 三个抽烟者中，第一个拥有烟草，第二个拥有纸，第三个拥有胶水。 供应者无限地提供三种材料，供应者每次讲两种材料挡在桌子上，拥有剩下那种材料的卷烟者卷一根烟并抽掉它，并给供应者一个告诉完成信号，供应者就会放另外两种材料在桌上，这种过程一直重复</p><p>首先分析同步和互斥的关系，桌子可以抽象为容量为1的缓冲区</p><p>将桌子上的两种材料抽象为组合，当桌子上有组合1时，第一个抽烟者取走东西，有组合2时，第二个抽烟者取走东西，有组合3时，第三个抽烟者取走东西，然后都需要发出完成信号，让供应者将下一个组合放到桌上</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">semaphore offer1=<span class="number">0</span>; <span class="comment">// 组合1的数量</span></span><br><span class="line">semaphore offer2=<span class="number">0</span>; <span class="comment">// 组合2的数量</span></span><br><span class="line">semaphore offer3=<span class="number">0</span>; <span class="comment">// 组合3的数量 </span></span><br><span class="line">semaphore finish=<span class="number">0</span>; <span class="comment">// 抽烟是否完成</span></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;            <span class="comment">// 用于实现三个抽烟者轮流抽烟</span></span><br><span class="line">provider()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">            put mix1;</span><br><span class="line">            V(offer1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            put mix2;</span><br><span class="line">            V(offer2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">2</span>)</span><br><span class="line">        &#123;   </span><br><span class="line">            put mix3;</span><br><span class="line">            V(offer3);</span><br><span class="line">        &#125;</span><br><span class="line">        i=(i+<span class="number">1</span>)%<span class="number">3</span>;</span><br><span class="line">        P(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">smoker1()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(offer1);</span><br><span class="line">        smoke;</span><br><span class="line">        V(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">smoker2()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(offer2);</span><br><span class="line">        smoke;</span><br><span class="line">        V(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">smoker3()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(offer3);</span><br><span class="line">        smoke;</span><br><span class="line">        V(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>进程通信就是指进程之间的信息交换</p><p><strong>进程是分配系统资源的单位，因此各进程拥有的内存地址空间相互独立</strong></p><hr><h3 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h3><p>在内存中创建一个共享空间，让两个进程都可以访问，并映射到进程的虚拟地址空间，两个进程对共享空间的访问必须是<strong>互斥</strong>的</p><p>共享存储的方式有基于数据结构的共享和基于存储区的共享</p><ul><li><p>基于数据结构的共享：只能放特定结构的数组，这种共享方式速度慢，限制多，是一种低级通信方式</p></li><li><p>基于存储区的共享：在内存中画出一块共享存储区，数据的形式，存放的位置都由进程控制，这种方式速度更快，<strong>是一种高级通信方式</strong></p></li></ul><hr><h3 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h3><p>管道是指用于连接读写进程的一个共享文件，其实就是在内存够中开辟一个<strong>大小固定的缓冲区</strong></p><ul><li>管道只能采用半双工通信，如果要双向同时通信，则要使用两个管道</li><li>各个进程要互斥的访问管道</li><li>数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据取走，当读进程被数据全部取走后，管道变空，此时读进程的<code>read()</code>系统调用将被阻塞</li><li><strong>管道允许多个写进程，但读进程最多只能有一个</strong></li></ul><hr><h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><p>进程间的数据交换以格式化的消息(message)为单位，进程通过操作系统提供的“<strong>发送消息/接收消息”两个原语</strong>进行数据交换</p><p>一个格式化的消息包括一个消息头和消息尾两个部分</p><p>消息头包含：发送进程ID，接收进程ID，消息类型，消息长度等格式化的消息</p><p>消息传递的直接通信方式直接将消息挂到接收进程的PCB的消息缓冲队列上，需要指明接收进程的PID</p><p>间接通信方式是将消息先发到中间体</p><hr><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>线程是一个基本的CPU执行单元，也是<strong>程序执行流的最小单位</strong></p><ul><li><p>引入线程后，不仅进程之间可以并发，进程内各线程之间也可以并发，从而进一步提高了系统的并发度</p></li><li><p>引入线程后，进程只作为除CPU之外的系统资源的分配单元</p></li><li><p>引入线程后，并发所带来的系统开销减小</p></li></ul><hr><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li><p>线程是处理机调度的单位</p></li><li><p>同一线程的不同线程共享进程的资源</p></li><li><p>切换进程内的线程，系统开销很小</p></li></ul><hr><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p><strong>用户级线程</strong>：即由应用程序通过线程库实现，所有的线程管理工作都由应用程序负责</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/9eFva2kxYyu6O4M.png" alt="image-20211228220809437"></p><p>在用户级线程中，线程切换可以在用户态下直接完成</p><p>在用户看来是有多个线程，但是在操作系统内核看来，并意识不到线程的存在，用户级线程就从用户视角能看到的线程</p><p>优点：在用户空间就可以完成，不需要切换到核心态，系统开销小，效率高</p><p>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高，多个进程不可再多核处理机上并发运行</p><hr><p><strong>内核级线程</strong>：操作系统内核支持的线程</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/dYZPmbVW3pf2IN8.png" alt="image-20211228220829437"></p><p>内核级线程的管理工作由操作系统内核完成</p><p>线程调度，切换等工作都由内核负责，因此内核级线程的切换也必须在核心态下才能完成</p><p>操作系统会为每个内核级线程建立相应的TCB(线程控制块)，通过TCB对线程进行管理。内核级线程就是从操作系统内核视角看能看到的线程</p><p>优点：当一个线程被阻塞后，别的线程还有继续执行，并发能力强</p><p>缺点：一个用户进程会占用多个内核级线程，切换状态的成本高，开销大</p><hr><p><strong>多线程模型</strong></p><p>一对一模型即是内核级线程</p><p>多对一模型即是用户级线程</p><p>多对多模型：n用户及线程映射到m个内核级线程（n&gt;m），每个用户进程对应m个内核级线程</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/ljSsmoP7vwXUyi3.png" alt="image-20210720154626538" style="zoom:50%;" /></p><p>优点：既克服了多对一模型并发度不高的缺点，有克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点</p><p><strong>内核级线程才是处理机分配的单位</strong>，内核级线程可以运行任意一个有映射关系的用户级线程代码，只有两个内核级线程中正在运行的代码逻辑都阻塞时，这个进程才会被阻塞</p><hr><h3 id="状态与转换"><a href="#状态与转换" class="headerlink" title="状态与转换"></a>状态与转换</h3><p>几乎和进程的状态和转换一致，线程通过线程控制块TCB来操纵线程</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220705144636319.png" alt="image-20220705144636319" style="zoom:80%;" /></p><p>多个TCB可以被组织成一张线程表使用</p><hr><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><div class="table-container"><table><thead><tr><th></th><th>进程</th><th>线程</th></tr></thead><tbody><tr><td>资源分配</td><td>进程是资源分配和拥有的基本单位</td><td>线程自己基本不拥有系统资源，但可以访问所属进程所拥有的全部资源</td></tr><tr><td>调度</td><td>在没有引入线程的操作系统中，进程是独立调度和分派的基本单位</td><td>引入线程后的操作系统中，线程是调度和分派的基本单位</td></tr><tr><td>地址空间</td><td>进程的地址空间之间相互独立</td><td>同一进程间的各线程共享进程的地址空间</td></tr></tbody></table></div><hr><h1 id="处理机的调度与死锁"><a href="#处理机的调度与死锁" class="headerlink" title="处理机的调度与死锁"></a>处理机的调度与死锁</h1><h2 id="调度的层次"><a href="#调度的层次" class="headerlink" title="调度的层次"></a>调度的层次</h2><p><strong>调度</strong>：当有很多任务要处理，但由于资源有限，这些事情没法同时处理，这就需要去确定某种规则来决定处理这些任务的<strong>顺序</strong>，这就是调度研究的问题</p><p><strong>作业</strong>：一个具体的任务</p><p><strong>高级调度(作业调度)</strong>：按一定的原则从外存的作业后备队列中挑选一个作业<strong>调入内存</strong>，并创建进程。每个作业只调入一次，调出一次，作业调入时会建立PCB，调出的时候才撤销PCB</p><p>高级调度主要用于多道批处理系统中，而在分时和实时系统中不设置高级调度</p><p><strong>低级调度(进程调度)</strong>：按照某种策略从就绪队列中选取一个<strong>进程</strong>，将处理机分配给它</p><p>进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度，频率很高</p><p><strong>中级调度(内存调度)</strong>：按照某种策略将进程在<strong>内存和外存</strong>中调出和调入，让进程在<strong>挂起和运行状态切换</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/d5KHgFqfIEsix6t.png" alt="image-20210723163601374"></p><hr><h2 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h2><ul><li><strong>CPU利用率</strong></li></ul><p>指CPU忙碌的时间占总时间的比例</p><ul><li><strong>系统吞吐量</strong></li></ul><p><strong>系统吞吐量</strong>：指在<strong>单位时间内系统所完成的作业数</strong>，因此与批处理作业的平均长度有关，如果单纯为了获得高的系统吞吐量，就应尽量多地选择短作业运行</p><ul><li><strong>周转时间</strong></li></ul><p><strong>周转时间</strong>：是指<strong>作业被提交给系统开始，到作业完成为止的这段时间间隔</strong>，包括4部分时间：作业在外存后备队列上等待调度的时间，进程在就绪队列上等待进程调度的时间，进程在CPU上执行的时间，以及进程等待I/O操作完成的时间</p><p>计算机系统的管理者总是希望平均周转时间最短，可以把平均周转时间描述为<strong>(各作业周转时间之和)/(作业数)</strong></p><p>为了进一步反应调度的性能，更清晰地描述各个进程在其周转时间中，等待和执行时间的具体分配情况，往往使用<strong>带权周转时间</strong>，其值等于<strong>作业周转时间和在CPU上执行的时间的比值</strong>，带权周转时间必然大于等于1，因为在CPU上执行的时间被包括在了周转时间之内</p><ul><li><strong>等待时间</strong></li></ul><p>即是进程或作业等待被服务时间之和，平均等待时间即各个作业或进程等待时间的平均值</p><ul><li><strong>响应时间</strong></li></ul><p><strong>响应速度</strong>：响应速度是选择分时系统中进程调度算法的重要准则，是从通过键盘提交一个请求开始，知道屏幕上显示出处理结果为止的一段时间间隔。</p><p>包括三部分时间：一是请求信息从键盘输入开始，直至将其传送到处理机的时间。二是处理机对请求信息进行处理的时间，三是将所形成的响应信息回送到终端显示器的时间</p><p><strong>响应比</strong>：(等待时间+要求服务时间)/要求服务时间</p><hr><h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><ol><li>保存处理机的现场信息。如程序计数器，多个通用寄存器中的内容等</li><li>按某种算法选取进程</li><li>把处理器分配给进程，此时需要将选中进程的进程控制块内有关处理机现场的信息装入处理器相应的各个寄存器中，把处理器的控制权交予该进程，让它从上次的断点处恢复</li></ol><h3 id="调度器和调度程序"><a href="#调度器和调度程序" class="headerlink" title="调度器和调度程序"></a>调度器和调度程序</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220705155602395.png" alt="image-20220705155602395"></p><p>进程调度的时机有：</p><ul><li>创建新进程</li><li>进程退出</li><li>运行进程阻塞</li><li>I/O中断发生</li></ul><p>非抢占式调度策略：只有运行进程阻塞或退出才触发调度程序工作</p><p>抢占式调度策略：每个时钟中断或k个时钟中断会触发调度程序工作</p><p>不能进行进程调度的情况</p><ul><li>处理中断的过程中</li><li>进程在<strong>操作系统内核程序临界区</strong>中</li><li>在原语操作中</li></ul><hr><h3 id="闲逛进程"><a href="#闲逛进程" class="headerlink" title="闲逛进程"></a>闲逛进程</h3><p>当没有其他就绪程序时，运行闲逛进程(idle)</p><p>闲逛进程的优先级最低，能耗低</p><hr><h3 id="进程调度的方式"><a href="#进程调度的方式" class="headerlink" title="进程调度的方式"></a>进程调度的方式</h3><p>非剥夺调度方式(非抢占方式)</p><p>只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态</p><p>特点：实现简单，系统开销小，只适用于早起的批处理系统</p><hr><p>剥夺调度方式(抢占方式)</p><p>当一个进程正在处理机上运行时，处理机可以立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程</p><p>特点：可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能，适合于分时操作系统，实时操作系统</p><hr><h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><h3 id="先来先服务算法-FCFS-First-Come-First-Serve"><a href="#先来先服务算法-FCFS-First-Come-First-Serve" class="headerlink" title="先来先服务算法(FCFS,First Come First Serve)"></a>先来先服务算法(FCFS,First Come First Serve)</h3><p>算法规则：系统按照作业到达的先后次序来进行调度</p><p>作用范围：可以用于作业调度和进程调度</p><p>算法类型：非抢占式的算法</p><p>优点：公平，算法实现简单</p><p>缺点：排在长作业后面的短作业需要等待很长时间，带权周转时间很大，FCFS算法对长作业有利，对短作业不利</p><p>饥饿：不会导致</p><hr><h3 id="短作业优先算法-SJF-Shortest-Job-First"><a href="#短作业优先算法-SJF-Shortest-Job-First" class="headerlink" title="短作业优先算法(SJF,Shortest Job First )"></a>短作业优先算法(SJF,Shortest Job First )</h3><p>算法规则：最短的作业优先得到服务</p><p>作用范围：可以用于作业调度和进程调度</p><p>算法类型：非抢占式的算法，但是也有抢占式的版本——SRTN</p><p>优点：<strong>最短的平均等待时间，平均周转时间</strong></p><p>缺点：不公平，对短作业有利，对长作业不利</p><p>饥饿：会导致饥饿</p><hr><h3 id="高响应比优先算法-HRRN-Highest-Response-Ratio-Next"><a href="#高响应比优先算法-HRRN-Highest-Response-Ratio-Next" class="headerlink" title="高响应比优先算法(HRRN,Highest Response Ratio Next)"></a>高响应比优先算法(HRRN,Highest Response Ratio Next)</h3><p><strong>响应比</strong>：<strong>(等待时间+要求服务时间)/要求服务时间</strong></p><p>算法规则：每次调度时先计算各个进程响应比，选择响应比最高的进程</p><p>作用范围：可以用于作业调度和进程调度</p><p>算法类型：非抢占式</p><p>优点：综合考虑了等待时间和运行时间，如果等待时间相同，则要求服务时间小的进程先运行(SJF)，如果要求服务时间相同，则等待时间长的先运行(FCFS)</p><p>饥饿：不会</p><hr><h3 id="时间片轮转调度算法-RR，Round-Robin"><a href="#时间片轮转调度算法-RR，Round-Robin" class="headerlink" title="时间片轮转调度算法(RR，Round-Robin)"></a>时间片轮转调度算法(RR，Round-Robin)</h3><p>算法规则：按照各个进程到达就绪队列的顺序，轮流让各进程执行一个时间片，如果进程未在一个时间片内执行完，就剥夺处理机，并将进程放在就绪队列队尾重新排队</p><p>作用范围：仅进程调度</p><p>算法类型：可抢占式</p><p>优点：公平，响应快</p><p>缺点：由于高频率的进程切换，因此有一定的开销，不区分任务的紧急程度</p><p>饥饿：不会</p><hr><h3 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h3><p>算法规则：每个进程都有各自的优先级，调度时选择最高的优先级进程</p><p>作用范围：可以用于作业调度和进程调度</p><p>算法类型：有抢占式和非抢占式</p><p>优点：用优先级区分紧急程度，适用于实时操作系统</p><p>缺点：若高优先级进程很多，则可能导致饥饿</p><p>饥饿：会</p><p>优先级可以分为静态优先级和动态优先级，静态优先级创建时确定并保持不变，动态优先级创建时有一个初始值，之后会根据情况动态地调整优先级</p><hr><h3 id="多级反馈队列调度算法-multileved-feedback-queue"><a href="#多级反馈队列调度算法-multileved-feedback-queue" class="headerlink" title="多级反馈队列调度算法(multileved feedback queue)"></a>多级反馈队列调度算法(multileved feedback queue)</h3><p>算法规则：</p><ul><li>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大</li><li>新进程到达时，先进入第一级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进入下一级队列队尾，如果已经在最下级，则重新放回队列队尾</li><li>只有第k级队列为空，才会为k+1级队头的进程分配时间片</li></ul><p>作用范围：进程调度</p><p>算法类型：抢占式算法，在k级队列的运行过程中，若更上级的队列中进入了新进程，那么新进程会抢占处理机，原来运行的进程放回k级队尾</p><p>优点：</p><ul><li>对各个进程相对公平(FCFS)</li><li>每个新到达的进程都可以很快响应(RR)</li><li>短进程只用较少时间就可完成(SJF)</li><li>不必实现估计进程的运行时间</li><li>可以灵活的调整对各类进程的偏好程度</li></ul><p>饥饿：会</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><div class="table-container"><table><thead><tr><th><strong>算法名称</strong></th><th><strong>算法思想</strong></th><th><strong>是否可抢占</strong></th><th><strong>特点</strong></th><th>饥饿</th></tr></thead><tbody><tr><td><strong>先来先服务算法（FCFS</strong></td><td>按照作业/进程到达的先后次序来进行调度</td><td>不可抢占</td><td>优点：简单、算法简单；缺点：作业的平均带权周转时间太长，对于短作业不友好，只考虑到了等待时间</td><td>不会</td></tr><tr><td><strong>短作业/进程优先算法（SJF/SPF）</strong></td><td>要求最短的作业/进程先得到调度</td><td>通常不可抢占，但是有可抢占版本</td><td>平均周转时间通常是最短的，只考虑了服务时间</td><td>会</td></tr><tr><td><strong>高响应比优先算法（HRRN）</strong></td><td>每次调度前就算每个作业/进程的响应比，响应比高的优先得到调度</td><td>非抢占式算法，当前作业/进程主动放弃cpu使用才需调度</td><td>综合考虑了等待时间和服务时间，对于长作业来说，随着等待时间增长，响应比也会增长，不会出现饥饿现象</td><td>不会</td></tr><tr><td><strong>轮转调度算法（RR）</strong></td><td>每个进程最多执行一个时间片长度，没执行完就保存结果，并存放到就绪队列，接着执行下一个进程</td><td>抢占式</td><td>非常公平的分配方式，利于进行人机交互</td><td>不会</td></tr><tr><td><strong>优先级调度算法</strong></td><td>根据优先级来进行调度（静态/动态优先级）</td><td>根据需求，可以是抢占式，可以使非抢占式</td><td>考虑了进程任务的紧迫性</td><td>会</td></tr><tr><td><strong>多级反馈队列（multileved feedback queue）</strong></td><td>1.将以往的一个就绪队列设置为多个就绪队列（n个），并使队列的优先级依次递减，时间片依次递增。2. 每个队列采用FCFS算法，若在该时间片内完成就撤离系统，否则加入下一队列，若排到最后的一个队列第n队列，则采用RR算法执行。</td><td>抢占式</td><td>不必事先知道进程的所需执行时间，思想虽然先进，却较为复杂</td><td>可能会</td></tr></tbody></table></div><hr><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p>死锁：在并发环境下，各进程因争夺资源而造成的一种互相等待对方手里的资源，导致各进程阻塞，都无法向前推进的现象</p><div class="note primary flat"><p>设程序有<code>n</code>个进程并发，共同竞争<code>X</code>个资源，且每个进程都需要<code>m</code>个资源数，那么，资源X最少有$n*(m-1)+1$个，才能避免发生死锁</p></div><p>产生条件：</p><ul><li>互斥条件：只有对必须互斥使用的资源争抢才会导致死锁</li><li>不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放</li><li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有</li><li>循环等待条件：存在一种进程资源的循环等待链，链中每个进程已获得的资源同时被下一个进程所请求</li></ul><hr><h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><p>已经知道死锁的产生需要4个条件，那么破坏其中任意一个条件就可以破坏死锁</p><div class="note primary flat"><p>预防死锁方式可以完全避免死锁发生</p></div><p><strong>1. 互斥条件</strong></p><p>如果能把互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态</p><p>比如<strong>SPOOLing</strong>技术，将独占设备在逻辑上改造为共享设备</p><p>并不是所有的资源都可以改造成可共享使用的资源，并且为了系统安全，很多地方还必须保护这种互斥性，因此，很多情况下都无法破坏互斥条件</p><hr><p><strong>2. 不剥夺条件</strong></p><p>方案一：当某个进程请求新的资源得不到满足，就必须立刻释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件</p><p>方案二：当某个进程需要的资源被其他进程占有的时候，可以由操作系统协助，将想要的资源强行剥夺，这种方式一般要考虑各进程的优先级</p><p>缺点：实现复杂，增加系统开销，方案一会导致饥饿</p><hr><p><strong>3. 请求和保持条件</strong></p><p>采用<strong>静态分配</strong>方法，即进程在运行时一次申请完它所需要的全部资源，在它的资源未满足前不让它投入运行，一旦投入运行后，这些资源就一直归它所有</p><p>缺点：有些资源可能只需要使用很短的时间，但是一直保持所有资源会让资源利用率极低，另外，也有可能导致某些进程保持饥饿</p><hr><p><strong>4. 循环等待条件</strong></p><p>采用顺序资源分配法，首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求支援，同类资源一次申请完</p><p>原理分析：一个进程只有已占有小编号的资源，才有资格去申请更大编号的资源，有大编号资源的进程不可能逆向回来申请小编号资源，从而不会循环等待</p><p>缺点：不方便增加新的设备，如果与实际顺序不一样，就会浪费资源</p><hr><h3 id="避免死锁——银行家算法"><a href="#避免死锁——银行家算法" class="headerlink" title="避免死锁——银行家算法"></a><strong>避免死锁——</strong>银行家算法</h3><p>安全序列：就是指系统按照这种序列分配资源，则每个进程都能顺利完成，只要能找出一个安全序列，系统就是安全状态</p><p>如果系统在安全状态，就一定不会发生死锁，如果系统进入不安全状态，就可能发生死锁</p><p>银行家算法的<strong>核心思想</strong>是在资源分配之前想判断这次分配是否会导致系统进入不安全状态</p><p>具体执行如下：</p><p>假设系统中有<strong>n个进程，m种资源</strong>，每个进程在运行前先声明对各种资源的最大需求数，则可以用一个n×m的矩阵来表示所有进程对各种资源的最大需求数，称为<strong>最大需求矩阵Max</strong>，同理系统可以用一个n×m的<strong>分配矩阵Allocation</strong>来表示所有进程的资源分配情况，Max-Allocation=<strong>Need矩阵</strong>，表示各进程最多还需要多少各类资源</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/fGxaKc4WTX1e2dZ.png" alt="image-20210726202126613"></p><p>另外，还需要一个长度为<code>m</code>的一维数组<code>Available</code>表示当前系统中还有多少可用资源，某进程Pi向系统申请资源，可用一个长度为<code>m</code>的以为数组<code>Request</code>表示本次申请的各种资源量，算法执行步骤如下</p><ol><li>如果某进程的<code>Need</code>数组大于该进程的<code>Request</code>数组，则到第2步，否则则出错</li><li>如果某进程的<code>Request</code>数组小于当前的<code>Available</code>数组，则到第3步，否则表示系统尚无足够资源，进程必须等待</li><li>系统试探性把资源分配给进程，并修改相应的数据（并非真的分配，修改数据只是为了预判），修改<code>Available，Request，Allocation</code>的值</li><li>操作系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态，若安全，才正式分配，否则，恢复相应数据</li></ol><p>安全性算法步骤：检查当前剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并且把该进程持有的资源全部回收，不断重复上述过程，看最终是否能让所有进程都加入安全序列</p><hr><h3 id="死锁的检测和解除"><a href="#死锁的检测和解除" class="headerlink" title="死锁的检测和解除"></a>死锁的检测和解除</h3><p>为了能对系统是否发生了死锁进行检测，必须：</p><ul><li>用某种数据结构来保存资源的请求和分配信息</li><li>提供一种算法，利用上述信息来检测系统是否死锁</li></ul><p>利用资源分配图这一数据结构，包含两种结点，进程结点对应包含一个进程，资源结点对应一类资源，可能有多个 包含两种边，进程结点到资源结点是申请边，资源结点到进程结点是分配边</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/Mah8FxRIl64ByXm.png" alt="image-20210729191739037" style="zoom:50%;" /></p><p>如果剩余资源数可以满足进程的需求，那么进程不会被阻塞，可以顺利地执行下去，如果这个进程结束后归还资源，那么可以让另外一些进程执行下去</p><p>如果按上述过程，最终消除了所有边，那么这个图是可以简化的，并且一定没有发生死锁，如果不能消除，那么一定发生了死锁</p><p>检测死锁的算法：</p><ol><li>在资源分配图中，找出不阻塞不孤立的进程，消去它所有的请求边和分配边，使之孤立，然后释放资源</li><li>释放的资源可以唤醒原来的阻塞进程，然后再重复1过程，直至取去除所有的边</li></ol><p>死锁定理：如果某时刻系统的资源分配图是不可简化的，那么此时系统死锁</p><hr><p>解除死锁的主要方法：</p><ol><li><p>资源剥夺法。挂起某些死锁进程，并抢占它的资源</p></li><li><p>撤销进程法，强制撤销进程</p></li><li><p>进程回退法，将一个或多个进程直接回退到足以避免死锁的地步</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.计算机操作系统概述</title>
      <link href="/post/56273.html"/>
      <url>/post/56273.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机操作系统概述"><a href="#计算机操作系统概述" class="headerlink" title="计算机操作系统概述"></a>计算机操作系统概述</h1><h2 id="操作系统的基本概念"><a href="#操作系统的基本概念" class="headerlink" title="操作系统的基本概念"></a>操作系统的基本概念</h2><p>操作系统（OS）是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，是计算机系统中最基本的系统软件</p><hr><ul><li>操作系统是系统资源的管理者</li></ul><p>举例：如果要用QQ和同学视频聊天，首先需要在文件夹中找到QQ安装位置（文件管理），其次双击打开QQ.exe程序（内存管理），QQ程序正常运行（进程管理），开始和朋友视频聊天（输入输出管理）。</p><ul><li>操作系统向上层提供方便易用的服务</li></ul><p>GUI：图形化用户接口（Graphical User Interface）用户可以使用形象的图形界面进行操作，而不需要记忆复杂的命令和参数</p><p>联机命令接口，又称交互式命令接口，即在命令提示符中直接输入命令进行交互</p><p>脱机命令接口，即批处理命令接口，可以将命令写成.bat的批处理文件，与系统进行交互</p><p>程序接口：可以在程序中进行系统调用来使用程序接口，即系统调用，用户通过程序间接使用</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220704171945140.png" alt="image-20220704171945140"></p><ul><li>最接近硬件的一层软件</li></ul><p>没有任何软件支持的计算机称为裸机，在裸机上安装的操作系统，可以提供资源管理功能和方便的服务功能，通常把覆盖了软件的机器称为扩充机器，又称之为虚拟机</p><hr><h2 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h2><p>一共有4个特征：并发，共享，虚拟，异步</p><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>指两个或多个事件在同一时间间隔内发生，这些事件宏观上是同时发生的，但微观上是交替发生的</p><p>操作系统的并发性指计算机系统中“同时”运行着多个程序，这些程序宏观上看是同时运行的，微观上看是交替运行的</p><p>单核CPU同一时刻只能执行一个程序，各个程序只能并发的执行</p><p>多核CPU同一时刻可以同时执行多个程序，多个程序可以并行的执行</p><hr><h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><p>共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用</p><p>互斥共享：某些资源，虽然可以提供给多个进程使用，但一个时间段只允许一个进程访问该资源</p><p>同时共享：系统中的某些资源，允许一个时间段内由多个进程同时对它们进行访问</p><p>共享和并发互为存在条件</p><hr><h3 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h3><p>虚拟是指把一个物理上的实体变为若干个逻辑上的对应物，物理实体是实际存在的，逻辑上的对应物是用户感受到的</p><p>比如单核CPU的计算机中，可以运行多个程序，这就是虚拟处理器技术，实际只有一个CPU，但是在用户看来似乎用6个CPU在同时服务，这里利用了时分复用技术</p><hr><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是程序的异步性</p><hr><h2 id="操作系统的发展和分类"><a href="#操作系统的发展和分类" class="headerlink" title="操作系统的发展和分类"></a>操作系统的发展和分类</h2><p>手工操作阶段：用户独占全机，人机速度矛盾导致资源利用率极低</p><p><strong>批处理阶段-单道批处理系统</strong>：引入了脱机输入/输出技术，并由监督程序负责作业的输入和输出，</p><p>缺点：内存中仅能有一道程序运行，CPU有大量的时间在空闲等待I/O完成</p><p><strong>批处理阶段-多道批处理系统</strong>：操作系统正式诞生，多道程序并发执行，共享计算机资源。</p><p>优点：</p><ul><li>让CPU处于忙碌状态，利用率高；在内存中装入多道程序提高内存的利用率，此外还可以提高I/O设备的利用率</li><li>系统吞吐量大，仅当作业完成时或运行不下去才进行进程切换</li></ul><p>缺点：</p><ul><li>平均周转时间长</li><li>无交互能力</li><li>系统需要付出额外的系统开销来组织作业和切换作业，系统开销大</li></ul><p><strong>分时操作系统</strong>：计算机以时间片为单位轮流为<strong>各个用户服务</strong>，各个用户可以通过终端与计算机进行交互，用户请求可以被即时响应，解决了人机交互问题，主要缺点是不能处理一些紧急任务</p><p><strong>实时操作系统</strong>：主要优点：能够响应一些紧急任务，某些紧急任务不需要时间片排队，在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且在严格的时限内处理完时间，主要特点是及时性和可靠性</p><hr><h2 id="程序的运行环境"><a href="#程序的运行环境" class="headerlink" title="程序的运行环境"></a>程序的运行环境</h2><h3 id="CPU运行模式"><a href="#CPU运行模式" class="headerlink" title="CPU运行模式"></a>CPU运行模式</h3><p>操作系统的内核(Kernel)是操作系统最重要最核心的部分，也是最接近硬件的部分</p><p>操作系统内核为管理者，有时会让CPU执行一些特权指令，如：内存清零指令，这些指令只允许管理者来使用，在CPU设计和生产的时候就划分了特权指令和非特权指令，因此CPU执行一条指令前就能判断其类型</p><p><strong>CPU有两种状态：内核态和用户态</strong></p><p>处于内核态时，说明此时正在运行的是内核程序，此时可以执行特权指令</p><p>处于用户态时，说明此时正在运行的是应用程序，此时只能执行非特权指令</p><p>内核态切换到用户态：执行一条特权指令，修改PSW的标志位为用户态，这个动作意味着操作系统主动让出CPU使用权</p><p>用户态切换到内核态：由中断引发，由<strong>硬件</strong>自动完成变态过程，触发中断信号意味着操作系统强行夺回CPU的使用权</p><hr><h3 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h3><p>中断分为<strong>内中断和外中断</strong></p><p>内中断与当前执行的指令有关，<strong>中断信号来源于CPU内部，又称异常</strong></p><ul><li>故障（fault），由错误条件引起，可能被内核程序修复。内核程序修复后会把CPU使用权还给应用程序，让它继续执行下去</li><li>终止（abort），由致命错误引起，内核程序无法修复该错误，因此直接终止该应用程序</li><li>陷入（trap），由陷入指令引发，应用程序想请求操作系统内核的服务，此时会执行一条特殊的指令–陷入指令，执行陷入指令意味着主动将CPU控制权还给操作系统</li></ul><p>外中断与当前执行的指令无关，中断信号来源于CPU外部，即是狭义的中断</p><ul><li>时钟中断，时钟部分每隔一个时间给CPU发送一个时钟中断信号</li><li>I/O中断，当输入输出任务完成时，向CPU发送中断信号</li></ul><hr><p>中断机制的基本原理</p><p>不同的中断信号，需要用不同的中断处理程序来处理，当CPU检测到中断信号后，会根据中断信号的类型去查询中断向量表，以此来找到相应的中断处理程序在内存中的存放位置</p><p>中断机制的处理过程</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/2bWiltvMROuH3FV.png" alt="image-20211228220130496"></p><p>子程序调用会在保存断点步骤中保存程序计数器保存</p><p>中断处理程序会保存程序计数器，程序状态字以及某些通用寄存器的内容</p><hr><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>系统调用是操作系统提供给应用程序使用的接口，可以理解为一种可供应用程序调用的特殊函数，<strong>应用程序可以通过系统调用来请求获得系统内核的服务</strong></p><p>应用程序通过<strong>系统调用</strong>请求操作系统的服务，而系统中的共享资源都由操作系统统一掌管，因此凡是与<strong>共享资源有关</strong>的操作，都必须通过系统调用的方式向操作系统的内核发出<strong>服务请求</strong>，这样可以保证系统的稳定性和安全性</p><p>操作系统的功能都要通过<strong>系统调用</strong>的形式实现，比如：</p><ul><li>设备管理</li><li>文件管理</li><li>进程控制</li><li>进程通信</li><li>内存管理</li></ul><p><strong>系统调用的过程：</strong></p><p>传递系统调用参数—&gt;执行陷入指令(用户态)—&gt; 执行相应的内核程序处理系统调用（核心态）—&gt;返回应用程序</p><hr><h3 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h3><p>内存可以存放数据，程序执行前需要先放到内存中才能被CPU处理，最后将其再转变为一个可以执行的程序，通常要经过以下几个步骤</p><ol><li>编译：由编译程序对用户源程序进行编译，形成若干个目标模块（此过程形成了逻辑地址）</li><li>链接：由链接程序将编译后形成的一组目标模块和它们所需要的库函数链接在一起，形成一个完整的转入模块</li><li>装入：由装入程序将装入模块装入内存</li></ol><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/zWMPFZitN59jOYo.png" alt="image-20210801151654153"></p><hr><p><strong>程序的链接</strong></p><p>源程序经过编译后，可得到一组目标模块，<strong>链接</strong>程序的功能是将这组模块以及它们所需要的库函数装配成一个完整的装入模块</p><ul><li>静态链接方式</li></ul><p>在程序运行前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件，之后不再拆开</p><ul><li>装入时动态链接</li></ul><p>将各目标模块装入内存时，边装入边链接的链接方式</p><ul><li>运行时动态链接</li></ul><p>在程序执行过程中需要该目标模块时，才对它进行链接，其优点是便于修改和更新，便于实现对目标模块的共享</p><hr><p><strong>程序的装入</strong></p><p>为了解释方便，假设一个无需链接的单个目标模块的装入过程，该目标模块也就是装入模块，根据<strong>装入的时间</strong>，可以有如下<strong>三种装入方式</strong></p><ul><li>绝对装入方式</li></ul><p>在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码，装入程序按照装入模块中的地址，将程序和数据装入内存</p><ul><li>静态重定位</li></ul><p>静态重定位：又称可重定位装入，编译，链接后的装入模块的地址都是从0开始的，指令中使用的地址，数据存放的地址都是相对于起始地址而言的逻辑地址。可以根据内存的当前情况，将装入模块装入到内存的适当位置。<strong>装入时对地址进行重定位，将逻辑地址变换为物理地址</strong></p><p>静态重定位的特点是在一个作业装入内存时，<strong>必须分配其要求的全部内存空间</strong>，如果没有足够的内存，就不能装入该作业，作业一旦进入内存后，在运行期间不能移动</p><ul><li>动态重定位</li></ul><p>动态重定位：又称动态运行时装入。编译，链接后的装入模块的地址都是从0开始的，装入程序把装入模块装入内存后，并不会立即将逻辑地址转换为物理地址，而是把<strong>地址转换推迟到程序真正要执行时才进行</strong>，因此装入内存后所有的地址依然是逻辑地址，这种方式需要一个<strong>重定位寄存器</strong>的支持</p><hr><h2 id="操作系统的体系结构"><a href="#操作系统的体系结构" class="headerlink" title="操作系统的体系结构"></a>操作系统的体系结构</h2><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/stMKlxA7Cu8pZ1r.png" alt="image-20211228220105434" style="zoom:80%;" /></p><p>时钟管理：利用时钟中断实现计时功能</p><p><strong>原语：是一种特殊的程序，这种程序必须被执行完成，不能被中断</strong></p><hr><h3 id="宏内核"><a href="#宏内核" class="headerlink" title="宏内核"></a>宏内核</h3><p>将操作系统的主要功能模块都作为了系统内核，运行在核心态</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220704171853233.png" alt="image-20220704171853233" style="zoom:67%;" /></p><p>优点：高性能，内核内部各种功能可以直接调用    </p><p>缺点：内核代码庞大，结构混乱，难以维护</p><hr><h3 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h3><p>只把最基本的功能保留在内核</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220704173351063.png" alt="image-20220704173351063" style="zoom: 80%;" /></p><p>优点：内核功能少，结构清晰   </p><p>缺点：状态切换频繁，性能低，模块不能直接相互调用，只能通过内核的消息传递来间接通信</p><hr><h3 id="分层结构"><a href="#分层结构" class="headerlink" title="分层结构"></a>分层结构</h3><p>操作系统的内核会分为多层，每层可单向调用更低一层的接口</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220704171035881.png" alt="image-20220704171035881" style="zoom:67%;" /></p><p>优点：便于调试和验证，容易扩充和维护，调用接口清晰</p><p>缺点：效率低，不可以跨层调用</p><hr><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>将内核划分为多个模块，各模块之间相互协作</p><p>主模块：只负责核心功能，如进程调度，内存管理</p><p>可加载内核模块：可以动态加载新模块到内核，而无需重新编译整个模块</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220704172308591.png" alt="image-20220704172308591" style="zoom:67%;" /></p><p>优点</p><ul><li>模块间逻辑清晰，易于维护，确定模块间接口后可多模块同时开发</li><li>支持动态加载新的内核模块，增加操作系统适应性</li><li>任何模块都可以直接调用其他模块，效率高</li></ul><p>缺点</p><ul><li>模块之间相互依赖，调试困难</li></ul><hr><h3 id="外核"><a href="#外核" class="headerlink" title="外核"></a>外核</h3><p>内核负责进程调度，进程通信等功能，外核负责为用户进程分配未经抽象的硬件资源，负责保证资源使用安全</p><p>优点</p><ul><li>外核可直接给用户进程分配不虚拟，不抽象的硬件资源，使用户进程可以更灵活的使用硬件</li><li>减少了虚拟硬件资源的映射，提升效率</li></ul><p>缺点</p><ul><li>降低了系统的一致性</li><li>使系统变得复杂</li></ul><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220704191719378.png" alt="image-20220704191719378" style="zoom:80%;" /></p><hr><h2 id="操作系统的引导"><a href="#操作系统的引导" class="headerlink" title="操作系统的引导"></a>操作系统的引导</h2><p>操作系统会将一整块磁盘分为若干分区</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220704141922953.png" alt="image-20220704141922953"></p><p>主引导记录（MBR，Master Boot Record）：包含了磁盘引导记录和分区表</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220704150228939.png" alt="image-20220704150228939"> </p><p>引导记录(PBR，Partition Boot Record) ：负责记录根目录中的启动管理器</p><p>在CPU的内存中，ROM中有BIOS系统，会找到磁盘中的MBR，MBR在内存运行后会找到PBR，PBR运行后会找到根目录里面的启动管理器，从而实现开机</p><hr><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><p>使用虚拟机技术，将一台物理机器虚拟化为多台虚拟机器(Virtual Machine，VM)，每个虚拟机器都有独立运行一个操作系统</p><p>第一类VM直接运行在硬件上，每台虚拟机可以直接享用硬件资源</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220704182615199.png" alt="image-20220704182615199"></p><p>第二类VM运行在宿主操作系统上</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220704190759697.png" alt="image-20220704190759697"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220704191609229.png" alt="image-20220704191609229" style="zoom:80%;" /></p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python面向对象</title>
      <link href="/post/18440.html"/>
      <url>/post/18440.html</url>
      
        <content type="html"><![CDATA[<h1 id="Python面向对象"><a href="#Python面向对象" class="headerlink" title="Python面向对象"></a>Python面向对象</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;盒子类，实现了开门、关门方法&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_door</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_door</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IceBox</span>(<span class="params">Box</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;冰箱&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ice</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;制冷&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 这里的Box()是一个类，具有开关的功能，而IceBox通过继承了Box这个类，也具有了开关的功能，同时在其基础之上添加了制冷的功能</span></span><br></pre></td></tr></table></figure><p>面向对象的思想主要是以对象为主，将一个问题抽象出具体的对象，并且将抽象出来的对象和对象的属性和方法封装成一个类。</p><hr><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>类</strong>是多个类似事物组成的群体的统称</p><p><strong>对象</strong>，又称为实例，由类创造的一个具体可操作结构</p><p>在<code>python</code>中，一切都是对象，所以之前已经接触过非常多的对象了，比如各种数据类型，使用<code>type()</code>函数，可以输出对象的类(数据类型)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">1220</span>))  <span class="comment"># 输出&lt;class &#x27;int&#x27;&gt;  说明1220这个对象，是int这个类的对象，由int类创造</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="string">&#x27;candle&#x27;</span>)) <span class="comment"># 输出&lt;class &#x27;str&#x27;&gt;  说明&#x27;candle&#x27;这个对象，是str这个类的对象，由str类创造</span></span><br></pre></td></tr></table></figure><hr><h3 id="创建类和对象"><a href="#创建类和对象" class="headerlink" title="创建类和对象"></a>创建类和对象</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Candle</span>(<span class="params"><span class="built_in">object</span></span>) :</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">candle=Candle() <span class="comment">#创建Candle类的对象 candle</span></span><br></pre></td></tr></table></figure><p>创建一个类的语法相对简单，一般类中有多个函数，把类中的函数称为 <strong>对象的方法</strong></p><p><code>实例名=类名()</code> 将类赋值一个变量，这个变量就是类的对象(实例)</p><hr><h3 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> (<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    love=<span class="string">&#x27;money&#x27;</span></span><br></pre></td></tr></table></figure><p>直接写在类里面的变量被称为：<strong>类的属性</strong>，在代码中，每个通过<code>Person</code>类生成的对象，都有<code>love</code>的值，为<code>&#39;money&#39;</code></p><p>类的属性可以被直接修改，比如<code>Person.love=&#39;light&#39;</code>，之后创建的类的love属性就变成了<code>light</code></p><hr><h3 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a>对象属性</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> (<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">   love=<span class="string">&#x27;money&#x27;</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,gender</span>):</span></span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&quot;当创建对象时候，会自动执行这个函数&quot;</span>)</span><br><span class="line">       self.name=name</span><br><span class="line">       self.gender=gender</span><br><span class="line">       </span><br><span class="line">candle=Person(<span class="string">&quot;candle&quot;</span>,<span class="string">&quot;man&quot;</span>)</span><br></pre></td></tr></table></figure><p><code>__init__(self, ...)</code>是一个<strong>特殊方法</strong>，在创建对象时进行初始化操作，它会自动执行，他的第一个参数永远都是<code>self</code>，代表实例本身。</p><p><code>__init__</code>其中的<code>name,gender</code>规定了<strong>对象的属性</strong>，即创建的对象<strong>必须传入</strong>这两个属性，比如<code>candle=Person(&quot;candle&quot;,&quot;man&quot;)</code>，我们就创建了一个<code>name</code>为<code>candle</code>，<code>gender</code>为<code>man</code>的对象</p><p>而之所以需要这个<code>self</code>参数，是因为必须先有实例，才能对实例的属性进行修改，也就是说，必须有<code>self</code>指代类中的对象，才能给通过<code>self.name=name</code> 给对象赋予它传入的名字！</p><div class="note primary flat"><p><code>self</code>在类中表示的是对象本身。在类的内部，通过这个参数访问自己内部的属性和方法</p></div><hr><h3 id="类中方法"><a href="#类中方法" class="headerlink" title="类中方法"></a>类中方法</h3><p>上文提到过，类中的函数称为<strong>方法</strong>，而类中的方法主要分为以下3种</p><h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><p>是最普遍的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> (<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    love=<span class="string">&#x27;money&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,gender</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;当创建对象时候，会自动执行这个函数&quot;</span>)</span><br><span class="line">        self.name=name</span><br><span class="line">        self.gender=gender</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;my name is &#x27;</span>,self.name)</span><br><span class="line">        </span><br><span class="line">candle=Person(<span class="string">&quot;candle&quot;</span>,<span class="string">&quot;man&quot;</span>)</span><br><span class="line">candle.info()  <span class="comment">#输出my name is candle</span></span><br></pre></td></tr></table></figure><p><code>info</code>方法就是普通的实例方法，<code>self</code>指代实例，对象在调用该方法的时候，会自动把对象本身传入进去，这种方式称为 <strong>隐式传输</strong></p><p><code>candle.info()</code>会输出<code>my name is candle</code>，括号里并不需要传入什么参数</p><hr><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>使用关键字<code>@staticmethod</code> 创建</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> (<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,gender</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;当创建对象时候，会自动执行这个函数&quot;</span>)</span><br><span class="line">        self.name=name</span><br><span class="line">        self.gender=gender</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info</span>(<span class="params">self</span>):</span>           <span class="comment">#实例方法</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;my name is &#x27;</span>,self.name)</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod            </span><span class="comment">#静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span>(<span class="params">name</span>):</span> </span><br><span class="line">        <span class="built_in">print</span>(name,<span class="string">&#x27;want eat&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">Candle=Person(<span class="string">&quot;candle&quot;</span>,<span class="string">&quot;man&quot;</span>)</span><br><span class="line">Candle.info()</span><br><span class="line">Candle.eat(<span class="string">&#x27;candle&#x27;</span>)  <span class="comment">#输出结果 candle want eat</span></span><br></pre></td></tr></table></figure><p>可以发现，静态方法本质上，就是一个只能由对象使用的函数罢了！</p><div class="note primary flat"><p>而静态方法和函数的唯一区别就是，静态方法的作用空间在类中，而函数的作用空间在整个程序中</p></div><p>所以，在编程中，基本不会使用到静态方法</p><hr><h4 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h4><p>在<code>python</code>中，一切皆是对象，虽然对象是由类创建的，但是类本身也是一个对象</p><p>原则上，类方法是将<strong>类本身</strong>作为对象进行操作的方法，使用<code>@classmethod</code>这一关键字</p><div class="note primary flat"><p>而类方法的作用是，<strong>让类本身可以记录信息</strong>，换言之，<strong>类方法可以修改类属性</strong></p></div><p>比如我想知道类被调用了几次，而类本身作为一个模版，是不会记录数据的，所以此时需要类方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span>:</span></span><br><span class="line">    <span class="built_in">id</span> = <span class="number">0</span>  <span class="comment"># 类的属性</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.<span class="built_in">id</span> = self.id_number()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">id_number</span>(<span class="params">cls</span>):</span>   <span class="comment">#和self一样，我们规定传入类方法的参数为cls</span></span><br><span class="line">        cls.<span class="built_in">id</span> += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cls.<span class="built_in">id</span></span><br><span class="line"></span><br><span class="line">a = Man(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.<span class="built_in">id</span>)          <span class="comment">#1</span></span><br><span class="line">b = Man(<span class="string">&#x27;B&#x27;</span>)    </span><br><span class="line"><span class="built_in">print</span>(b.<span class="built_in">id</span>)          <span class="comment">#2</span></span><br></pre></td></tr></table></figure><p>类方法<code>id_number</code>的作用是让类属性<code>id+1</code>，然后返回类属性，赋予给对象属性，从而每次创建对象时，都实现了类属性<code>id+1</code></p><hr><h3 id="动态绑定属性"><a href="#动态绑定属性" class="headerlink" title="动态绑定属性"></a>动态绑定属性</h3><p>在已经创建对象之后，可以给对象添加类中不存在的属性，以及使用类中不存在的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> (<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,gender</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;当创建对象时候，会自动执行这个函数&quot;</span>)</span><br><span class="line">        self.name=name</span><br><span class="line">        self.gender=gender</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info</span>(<span class="params">self</span>):</span>           <span class="comment">#实例方法</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;my name is &#x27;</span>,self.name)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">candle=Person(<span class="string">&quot;candle&quot;</span>,<span class="string">&quot;man&quot;</span>)</span><br><span class="line">candle.love=<span class="string">&quot;rain&quot;</span>   <span class="comment">#给candle这个对象设置其他属性</span></span><br><span class="line"><span class="built_in">print</span>(candle.love)  <span class="comment">#可以输出rain</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;output&#x27;</span>)</span><br><span class="line">candle.show=show   <span class="comment">#将show这个函数绑定在candle上</span></span><br><span class="line">candle.show()   <span class="comment">#一样可以调用show这个函数</span></span><br></pre></td></tr></table></figure><p>需要注意的是，动态绑定的属性or函数，仅绑定的对象能用，类创建的其他对象是无法使用的</p><hr><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p><strong>封装</strong>：把客观事物封装成抽象的类，隐藏属性和方法的实现细节，仅对外公开接口。</p><p>实际上，通过类这一结构，我们可以通过创建对象就实现类中的方法，而并不需要关注类中的具体细节</p><p><strong>私有变量</strong></p><p>私有变量是一种在<code>Python</code>中实现封装的方式，它可以保护类中的数据不被外部访问或修改。私有变量的命名规则是以两个下划线开头，但不以两个下划线结尾，例如<code>__name</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> (<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,gender</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;当创建对象时候，会自动执行这个函数&quot;</span>)</span><br><span class="line">        self.name=name</span><br><span class="line">        self.gender=gender</span><br><span class="line">        self.__love=<span class="string">&#x27;rain&#x27;</span></span><br><span class="line">        </span><br><span class="line"> candle=Person(<span class="string">&#x27;candle&#x27;</span>,<span class="string">&#x27;man&#x27;</span>)</span><br><span class="line"> <span class="built_in">print</span>(candle.love) <span class="comment">#程序会报错,因为是私有变量</span></span><br></pre></td></tr></table></figure><p>私有变量的用途不是为了让外部访问，而是为了让类的内部使用。私有变量可以存储类的一些重要的信息，比如状态、属性、配置等，这些信息只有类自己知道，不需要让外部知道。</p><hr><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承：子类可以使用父类的所有功能，并且对这些功能进行扩展。继承的过程，就是从一般到特殊的过程。</p><p>继承的作用是实现代码的可复用性，提供工作效率</p><p>实现形式是：<code>class name (father1,father2):</code>，在创建类的时候，在后面括号中添加父类的名字，<code>python</code>是支持<strong>多继承</strong>的</p><p>如果一个子类没有继承任何类，会默认继承<code>object</code>类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>(<span class="params"><span class="built_in">object</span></span>):</span> <span class="comment"># 定义一个动物类，继承自object类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span> <span class="comment"># 定义初始化方法，设置name和age属性</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span>(<span class="params">self</span>):</span> <span class="comment"># 定义一个叫的方法</span></span><br><span class="line">        <span class="built_in">print</span>(self.name, <span class="string">&#x27;会叫&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>(<span class="params">Animal</span>):</span> <span class="comment"># 定义一个猫类，继承自动物类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, gender</span>):</span> <span class="comment"># 定义初始化方法，设置gender属性，并调用父类的初始化方法</span></span><br><span class="line">        <span class="built_in">super</span>(Cat, self).__init__(name, age) <span class="comment"># 使用super函数来调用父类的初始化方法</span></span><br><span class="line">        self.gender = gender</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span>(<span class="params">self</span>):</span> <span class="comment"># 重写父类的叫的方法，改变叫声</span></span><br><span class="line">        <span class="built_in">print</span>(self.name, <span class="string">&#x27;会“喵喵”叫&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在定义子类的属性的时候，必须在构造函数中调用父类的构造函数(<code>__init__</code>)</p><p>注意这里使用了<code>super()</code>方法来<strong>创建</strong>了一个父类的对象，以<strong>调用</strong>父类的构造函数</p><p><code>super</code>本身其实就是一个类，<code>super()</code>其实就是这个类的实例化对象，它需要接收两个参数 <code>super(class, obj)</code>,它返回的是<code>obj</code>的继承顺序中<code>class</code>类的父类(比如C继承了A,B,则C的继承顺序就是C—&gt;A—&gt;B，<code>super(A,c)</code>指的就是B)</p><p>实际上在简单的继承关系中，可以<strong>不写</strong><code>super()</code>的内置参数，默认指的是当前对象的父类</p><hr><p><strong>object类</strong></p><p><code>object</code>类是所有类的父类，因此所有类都有<code>object</code>类的属性和方法</p><p><code>object</code>类有一个<code>__str__()</code>方法，用于返回一个对于“对象的描述”，默认是输出对象的内存地址，但是我们可以重写<code>__str__()</code>方法，使之返回我们想要的信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> (<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,gender</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;当创建对象时候，会自动执行这个函数&quot;</span>)</span><br><span class="line">        self.name=name</span><br><span class="line">        self.gender=gender</span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;my name is <span class="subst">&#123;self.name&#125;</span>,gender is <span class="subst">&#123;self.gender&#125;</span>&#x27;</span></span><br><span class="line">        <span class="comment">#改写了__str()__方法，使之不输出内存地址，而是输出基本信息</span></span><br><span class="line"> </span><br><span class="line">candle=Person(<span class="string">&#x27;candle&#x27;</span>,<span class="string">&#x27;man&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(candle)    <span class="comment">#my name is candle,gender is man</span></span><br></pre></td></tr></table></figure><hr><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p><code>Python</code>中的多态是一种面向对象编程的特性，它指的是不同类型的对象可以对同一个方法或函数产生不同的响应。多态的好处是可以提高代码的灵活性和可扩展性，也可以实现不同对象的自定义行为。</p><p><code>Python</code>中的多态有两种形式：</p><ul><li>鸭子类型（duck typing）：这种形式不依赖于继承关系，而是依赖于对象的属性和方法。只要对象具有相同的属性或方法，就可以被视为同一类型，而不管它们实际上属于什么类。</li><li>继承和重写（inheritance and overriding）：这种形式是基于继承关系的，子类可以继承父类的属性和方法，并且可以重写父类的方法，以实现自己的功能。这样，当调用父类的方法时，会根据对象的实际类型，执行相应的子类的方法。这种形式也叫做多态性</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个动物类，有一个叫的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;动物会叫&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个狗类，继承自动物类，重写叫的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">Animal</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;狗会汪汪叫&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个猫类，继承自动物类，重写叫的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>(<span class="params">Animal</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;猫会喵喵叫&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个函数，接受一个对象作为参数，调用它的叫的方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">obj</span>):</span></span><br><span class="line">    obj.call()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个狗的实例</span></span><br><span class="line">dog = Dog()</span><br><span class="line"><span class="comment"># 调用函数，传入狗的对象</span></span><br><span class="line">func(dog)</span><br><span class="line"><span class="comment"># 输出结果：狗会汪汪叫</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个猫的实例</span></span><br><span class="line">cat = Cat()</span><br><span class="line"><span class="comment"># 调用函数，传入猫的对象</span></span><br><span class="line">func(cat)</span><br><span class="line"><span class="comment"># 输出结果：猫会喵喵叫</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>尽管<code>cat</code>和<code>dog</code>完全不是一个类型，但是函数<code>func()</code>却可以执行他们的<code>call()</code>方法，这就是动态语言的优势</p><hr><h2 id="特殊"><a href="#特殊" class="headerlink" title="特殊"></a>特殊</h2><h3 id="特殊属性"><a href="#特殊属性" class="headerlink" title="特殊属性"></a>特殊属性</h3><p><code>__dict__</code>  属性可以获得类对象或实例对象所绑定的<strong>所有</strong>属性和方法的字典</p><p><code>__class__</code>属性可以返回当前对象是哪个类的实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>():</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,age</span>):</span></span><br><span class="line">       self.name=name</span><br><span class="line">       self.age=age</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">candle=Person(<span class="string">&#x27;candle&#x27;</span>,<span class="number">22</span>)</span><br><span class="line"><span class="built_in">print</span>(candle.__dict__)   <span class="comment">#输出：&#123;&#x27;name&#x27;: &#x27;candle&#x27;, &#x27;age&#x27;: 22&#125;</span></span><br><span class="line"><span class="built_in">print</span>(candle.__class__)  <span class="comment">#输出： &lt;class &#x27;__main__.Person&#x27;&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="特殊方法"><a href="#特殊方法" class="headerlink" title="特殊方法"></a>特殊方法</h3><p><code>__new__(cls, *args, **kwargs)</code></p><p>之前在上文讲过，<code>__init__(self, ...)</code>是一个<strong>特殊方法</strong>，在创建对象时进行初始化操作</p><p>那么，随之而来有一个问题，既然<code>__init__</code>是方法，会自动执行，那么是什么对象在创建新对象的时候调用了<code>__init__</code>方法呢？此时就需要用到<code>__new__(cls, *args, **kwargs)</code>这个特殊方法，</p><p>只要是面向对象的编程语言，类的实例化都一定包含两个步骤： </p><ol><li>在内存中创建对象，即开辟一块内存空间来存放类的实例    ( new ）</li><li>初始化对象，即给实例的属性赋予初始值，例如全部填 0    ( init )</li></ol><p>先分析一下<code>new</code>函数的内部</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">super</span>(Person, cls).__new__(cls)</span><br></pre></td></tr></table></figure><p>这里的<code>super(Person, cls)</code>的意思就是调用<code>person</code>类的父类，以调用<code>new</code>方法，在上文解释过<code>super</code>方法的用法，在简单的继承关系可以不写</p><p>可以看到，<code>__new__</code>方法的参数是<code>cls, *args, **kwargs</code>，这表示它可以接受任意数量和类型的参数，但是它并不会使用这些参数，而是直接传递给父类的<code>__new__</code>方法。这样可以保证<code>Person</code>类的<code>__new__</code>方法和<code>object</code>类的<code>__new__</code>方法的兼容性，也可以让<code>Person</code>类的<code>__init__</code>方法自由地定义和使用参数</p><p>在 <code>python</code> 中，第一步由 <strong>new</strong> 函数负责，第二步由 <strong>init</strong> 函数负责。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;__new__ called.&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>(Person, cls).__new__(cls)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;__init__ called.&#x27;</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;my name is <span class="subst">&#123;self.name&#125;</span>,age is <span class="subst">&#123;self.age&#125;</span>&#x27;</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">candle = Person(<span class="string">&#x27;Candle&#x27;</span>, <span class="number">24</span>)</span><br><span class="line"><span class="built_in">print</span>(candle)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"> 输出结果：</span></span><br><span class="line"><span class="string">__new__ called.</span></span><br><span class="line"><span class="string">__init__ called.</span></span><br><span class="line"><span class="string">my name is Candle,age is 24</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>通过运行这段代码，我们可以看到，<code>new</code>方法的调用是发生在<code>init</code>之前的。其实当 你实例化一个类的时候，具体的执行逻辑是这样的：</p><ol><li><code>p = Person(name, age)</code></li><li>首先执行使用<code>name</code>和<code>age</code>参数来执行<code>Person</code>类的<code>new</code>方法，这个<code>new</code>方法会 返回<code>Person</code>类的一个实例（通常情况下是使用 <code>super(Persion, cls).__new__(cls)</code> 这样的方式），</li><li>然后利用这个实例来调用类的<code>__init__</code>方法，上一步里面<code>__new__</code>产生的实例也就是<code>__init__</code>里面的的 <code>self</code></li></ol><p>所以，<code>__init__</code>和 <code>__new__</code>最主要的区别在于：</p><ul><li><code>__init__</code>通常用于初始化一个新实例，控制这个初始化的过程，比如添加一些属性， 做一些额外的操作，发生在类实例被创建完以后。它是实例级别的方法。</li><li><code>__new__</code>通常用于控制生成一个新实例的过程。它是类级别的方法。</li></ul><hr><h2 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h2><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>可以使用<code>copy</code>模块的<code>copy</code>函数来创建一个新的对象，该对象是原始对象的浅层副本。下面是一个浅拷贝的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个列表</span></span><br><span class="line">original_list = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用浅拷贝创建一个新的列表</span></span><br><span class="line">new_list = copy.copy(original_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改新列表中的元素</span></span><br><span class="line">new_list[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印原始列表和新列表</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;原始列表:&quot;</span>, original_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;新列表:&quot;</span>, new_list)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行上述代码，输出如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原始列表: [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">新列表: [[<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br></pre></td></tr></table></figure><p><code>copy.copy(x):</code> 返回对象<code>x</code>的浅拷贝。这个函数创建一个新的对象，该对象是原始对象的浅层副本。新对象的一些属性会直接引用原始对象的属性，而不是创建新的属性。</p><p>因此，如果原始对象的属性是可变的，则新对象的属性也将是可变的，并且对新对象的更改将反映在原始对象中。如果原始对象的属性是不可变的，则新对象的属性也将是不可变的，因此对新对象的更改不会影响原始对象</p><hr><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>深拷贝是一种对象复制的方式，它会创建一个新的对象，该对象是原始对象的递归副本。深拷贝<strong>复制了原始对象的所有属性</strong>，包括所有嵌套对象和子对象，而不是仅仅复制引用。这意味着，如果我们修改新对象的属性，原始对象的属性不会受到影响</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个列表</span></span><br><span class="line">original_list = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用深拷贝创建一个新的列表</span></span><br><span class="line">new_list = copy.deepcopy(original_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改新列表中的元素</span></span><br><span class="line">new_list[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印原始列表和新列表</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;原始列表:&quot;</span>, original_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;新列表:&quot;</span>, new_list)</span><br></pre></td></tr></table></figure><p>运行上述代码，输出如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原始列表: [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">新列表: [[<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br></pre></td></tr></table></figure><p>可以看到，只改变了新列表的属性，原来列表的属性没有被修改</p><hr><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>在<code>Python</code>中，模块就是一个<code>Python</code>文件，以<code>.py</code>结尾，包含了<code>Python</code>对象定义和<code>Python</code>语句。</p><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><p>可以使用<code>import module_name</code> 的形式在模块A中导入模块B，从而在模块A中使用模块B里面的函数，类以及方法等</p><p>具体的方法是：</p><p>在定义好模块之后，我们可以使用<code>import</code>语句来引入模块。例如，要引用名为<code>math</code>的模块，可以在文件的顶部使用<code>import math</code>来引入。在调用<code>math</code>模块中的函数时，需要使用<strong>模块名.函数名</strong>的语法。</p><p>如果一个模块在当前的搜索路径中，当解释器遇到<code>import</code>语句时，该模块将被导入。搜索路径是解释器在搜索模块时首先查找的目录列表。如果要导入模块<code>math.py</code>，需要将命令放在脚本的顶部</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math </span><br><span class="line"><span class="built_in">print</span>(math.pi)  <span class="comment">#调用math的属性，需要用math.pi</span></span><br><span class="line"><span class="built_in">print</span>(math.<span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">3</span>)) <span class="comment">#调用math的pow方法</span></span><br></pre></td></tr></table></figure><hr><h3 id="主程序"><a href="#主程序" class="headerlink" title="主程序"></a>主程序</h3><p>在<code>Python</code>中，如果一个模块不是被导入到其他程序中执行，那么它可能在<strong>解释器的顶级模块</strong>中执行，这种情况下，该模块被视为主程序。</p><p>在每个模块的定义中都包括一个记录模块名称的变量<code>__name__</code>，程序可以检查该变量，以确定它们在哪个模块中执行。如果一个模块是主程序，那么它的<code>__name__</code>变量的值为<code>__main__</code>。因此，我们可以使用以下代码来检查一个模块是否是主程序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 这里是主程序的代码</span></span><br></pre></td></tr></table></figure><p>这个代码块只有在该模块<strong>作为主程序</strong>运行时才会执行。如果该模块被导入到其他程序中执行，那么这个代码块将不会执行</p><hr><h3 id="常用模块"><a href="#常用模块" class="headerlink" title="常用模块"></a>常用模块</h3><p><code>Python</code>中有一些常用的<strong>内置</strong>模块，方便导入使用</p><p>以下是一些常用的<code>Python</code>标准库模块：</p><ul><li>os模块：提供了与操作系统交互的函数，例如创建、移动和删除文件和目录，以及访问环境变量等</li><li>sys模块：提供了与Python解释器和系统相关的功能，例如解释器的版本和路径，以及与stdin、stdout和stderr相关的信息</li><li>time模块：提供了处理时间的函数，例如获取当前时间、格式化日期和时间、计时等</li><li>random模块：提供了生成随机数的函数，例如生成随机整数、浮点数、序列等</li><li>math模块：提供了数学函数，例如三角函数、对数函数、指数函数、常数等</li></ul><p>还有一些很好用的第三方模块，可以使用 <code>pip install....</code> 的方式安装到本地上</p><hr><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>包是一组<code>Python</code>模块的<strong>集合</strong>，它们被组织在一个目录层次结构中。一个包是一个包含一个或多个模块的目录，其中还包含一个名为<code>__init__.py</code>的文件，用于区分包和仅包含一堆<code>Python</code>脚本的目录。</p><p>包可以嵌套到任意深度，只要相应的目录包含自己的<code>__init__.py</code>文件即可。模块和包的区别似乎仅在文件系统级别上存在。当您导入一个模块或包时，<code>Python</code>创建的相应对象始终是模块类型的对象。导入一个包时，只有<code>__init__.py</code>文件中的变量/函数/类是直接可见的，而不是子包或模块。</p><p>在其他<code>Python</code>文件中使用这个包时，您可以使用<code>import</code>语句来导入包中的模块。例如，要使用<code>mypackage</code>包中的<code>module1.py</code>模块中的函数，可以使用以下语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mypackage <span class="keyword">import</span> module1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用module1中的函数</span></span><br><span class="line">module1.my_function()</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python数据分析</title>
      <link href="/post/12550.html"/>
      <url>/post/12550.html</url>
      
        <content type="html"><![CDATA[<h1 id="Python数据分析"><a href="#Python数据分析" class="headerlink" title="Python数据分析"></a>Python数据分析</h1><h2 id="NumPy"><a href="#NumPy" class="headerlink" title="NumPy"></a>NumPy</h2><hr><h3 id="NumPy简介"><a href="#NumPy简介" class="headerlink" title="NumPy简介"></a>NumPy简介</h3><p><code>NumPy</code>是一个开源的<code>Python</code>科学计算基础库</p><ul><li>一个强大的N维数据数组对象  <code>ndarray</code></li><li>广播功能函数</li><li>线性代数，傅里叶变换，随机数生成等功能</li></ul><p><br/></p><p><code>NumPy</code>是<code>SciPy</code>，<code>Pandas</code>等数据处理或科学计算库的基础</p><hr><h3 id="数据的维度"><a href="#数据的维度" class="headerlink" title="数据的维度"></a>数据的维度</h3><p>维度：是一组数据的组织形式</p><p>一维数据</p><ul><li>定义：由对等关系的有序或无序数据构成，采用线性方式组织</li><li><strong>有序</strong>一维结构：列表(<code>list[ ]</code>)，元组( <code>tuple( )</code> )，<strong>数组</strong></li><li><strong>无序</strong>一维结构：字典(<code>dict&#123; : &#125;</code>)，集合(<code>set&#123; &#125;</code>)   </li></ul><p><br/></p><p>二维数据</p><ul><li>定义：二维数据由多个一维数据构成，是一维数据的组合</li><li>在<code>python</code>中，列表的元素也可以是另外一个列表，这样的嵌套就形成了一个二维数据</li></ul><p><br/></p><p>高维数据</p><ul><li>定义：<code>python</code>中，字典就表示的是高维数据，由<strong>键值对</strong>存储信息</li></ul><hr><h3 id="数组对象-ndarray"><a href="#数组对象-ndarray" class="headerlink" title="数组对象 ndarray"></a>数组对象 ndarray</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><strong>数组</strong>：是一种一维有序数据结构，要求数据结构里的所有数据类型<strong>必须相同</strong></p><p><code>ndarray</code>：就是<code>NumPy</code>库所提供的一个多维数组对象，要求所有元素类型相同，数据的下标从0开始</p><p><code>ndarray.array()</code>函数：生成一个<code>ndarray</code>数组，是[ ]形式，元素由空格分割</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ndarray.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])  </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">创建了一个二维数组：</span></span><br><span class="line"><span class="string">[[1 2 3]</span></span><br><span class="line"><span class="string"> [5 4 3]]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p><br/></p><p><code>Python</code>中虽然有数据结构<code>list</code>存储有序数据，但是其不支持<strong>矢量化计算</strong>，运算效率很低</p><p>而<code>Numpy</code>库提供了很多用于矢量化运算的函数和方法。</p><blockquote><p> 矢量化运算是指对数组中的每个元素进行相同的操作，而不需要使用循环。这样可以提高代码的效率和简洁性。</p></blockquote><p><br/></p><p>以下举例说明<code>NumPy</code>相比<code>list</code>的优势：</p><p>假设A和B是元素个数相同的数组，求$A^2+B^3$ ：  </p><p> 在使用<code>NumPy</code>前，需要声明要引入<code>Numpy</code>这个包，并可以重命名为<code>np</code>这个简写</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231028200932805.png" alt="image-20231028200932805"></p><p><br/></p><p>可以看到，用<code>list</code>计算，需要经过循环，而引入<code>NumPy</code>计算，可以直接计算得出结果</p><hr><h4 id="对象的属性"><a href="#对象的属性" class="headerlink" title="对象的属性"></a>对象的属性</h4><p>轴(<code>axis</code>)：保存数据的维度     秩(<code>rank</code>)：轴的数量</p><p>假设我们通过<code>np.array()</code>函数生成了一个<code>ndarray</code>对象，命名为<code>a</code>  </p><div class="table-container"><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>a.ndim</td><td>秩，即维度的数量，或者说，数组的行数n</td></tr><tr><td>a.shape</td><td>对象的尺度，数组的n行m列</td></tr><tr><td>a.size</td><td>元素的个数，相当于shape中n*m的值</td></tr><tr><td>a.dtype</td><td>元素类型</td></tr><tr><td>a.itemsize</td><td>每个元素的大小，以字节为单位</td></tr><tr><td>a.T</td><td>a数组的转置</td></tr></tbody></table></div><p><br/></p><p>例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a=np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>]])</span><br><span class="line"><span class="built_in">print</span>(a)   <span class="comment"># 输出数组</span></span><br><span class="line"><span class="built_in">print</span>(a.ndim)   <span class="comment">#输出数组的维度 </span></span><br><span class="line"><span class="built_in">print</span>(a.shape)  <span class="comment">#输出数组的尺度</span></span><br><span class="line"><span class="built_in">print</span>(a.size)   <span class="comment">#输出元素个数</span></span><br><span class="line"><span class="built_in">print</span>(a.dtype)  <span class="comment">#输出元素类型</span></span><br><span class="line"><span class="built_in">print</span>(a.itemsize) <span class="comment">#输出元素大小</span></span><br><span class="line"><span class="built_in">print</span>(a.T)   <span class="comment">#输出数组的转置</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">5</span> <span class="number">4</span> <span class="number">3</span>]]</span><br><span class="line"><span class="number">2</span>  <span class="comment">#维度为2</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>)  <span class="comment"># 2行3列数组</span></span><br><span class="line"><span class="number">6</span>  <span class="comment">#个数为6</span></span><br><span class="line">int32  <span class="comment">#元素是int32类型</span></span><br><span class="line"><span class="number">4</span>     <span class="comment">#元素大小为4字节</span></span><br><span class="line">[[<span class="number">1</span> <span class="number">5</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">4</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">3</span>]]</span><br></pre></td></tr></table></figure><hr><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><div class="table-container"><table><thead><tr><th>数据类型</th><th>说明</th></tr></thead><tbody><tr><td>bool</td><td>布尔类型，True或False</td></tr><tr><td>int8</td><td>字节长度的整数，取值:[-128,127]</td></tr><tr><td>int16</td><td>16位长度整数，取值在$[-2^{15}, 2^{15}-1]$</td></tr><tr><td>int32</td><td>32位长度整数，取值在$[-2^{31}, 2^{31}-1]$</td></tr><tr><td>int64</td><td>64位长度整数，取值在$[-2^{63}, 2^{63}-1]$</td></tr><tr><td>uint8</td><td>8位无符号整数，取值在[0,255]</td></tr><tr><td>uint16</td><td>16位无符号整数，取值在$[0,2^{16}-1]$</td></tr><tr><td>uint32</td><td>32位无符号整数，取值在$[0,2^{32}-1]$</td></tr><tr><td>float16</td><td>16位半精度浮点数：1位符号位，5位指数，10位尾数</td></tr><tr><td>complex64</td><td>复数类型，实部和虚部都是32位浮点数</td></tr></tbody></table></div><p><code>Python</code>基本语法只能支持整数，浮点数和复数，<code>ndarray</code>所支持的数据类型更加丰富</p><hr><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>一共4种方法</p><ol><li>从Python中的列表，元组等类型创建ndarray数组</li><li>使用Numpy中函数创建ndarray数组，如：arrange，ones等</li><li>从字节流中创建</li><li>从文件中读取特定格式</li></ol><p><br/></p><ul><li>从<code>Python</code>中的列表，元组等类型创建<code>ndarray</code>数组</li></ul><p>使用<code>Numpy</code>中的<code>array</code>函数，<code>a=np.array(list/tuple,dtype=np.int16)</code>，表示将列表/元组转换为<code>ndarray</code>数组，数据类型是<code>int16</code></p><p>如果不指定<code>dtype</code>的话，<code>Numpy</code>会根据数据情况关联一个<code>dtype</code>类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])  <span class="comment">#从列表中创建数组</span></span><br></pre></td></tr></table></figure><p><br/></p><ul><li>使用<code>Numpy</code>中函数创建<code>ndarray</code>数组</li></ul><p><code>np.arrange(n)</code>函数：类似<code>range()</code>函数，返回<code>ndarray</code>类型，元素从0到n-1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.arange(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出：[0 1 2 3 4 5 6 7 8 9]</span></span><br></pre></td></tr></table></figure><p><br/></p><p><code>np.ones(shape)</code>函数：根据<code>shape</code>生成一个全1数组，<code>shape</code>是元组类型，用于指定数组的行列数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.ones((<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">输出：[[1. 1.]    一个2行2列的全1二维数组</span></span><br><span class="line"><span class="string">      [1. 1.]]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p><br/></p><p><code>np.zeros(shape)</code>函数：根据<code>shape</code>生成一个全0数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.zeros((<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">输出：[[0. 0.]    一个2行2列的全0二维数组</span></span><br><span class="line"><span class="string">      [0. 0.]]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p><br/></p><p><code>np.full(shape,val)</code>函数：根据<code>shape</code>生成一个数组，每个元素值都是val</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.full((<span class="number">2</span>,<span class="number">2</span>),<span class="number">6</span>))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">输出：[[6. 6.]    一个2行2列的全6二维数组</span></span><br><span class="line"><span class="string">      [6. 6.]]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p><br/></p><p><code>np.eye(n)</code>函数：创建一个$n*n$的单位数组，对角线为1，其余为0</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.eye(<span class="number">2</span>))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">输出：[[1. 0.]    一个2行2列的单位矩阵</span></span><br><span class="line"><span class="string">      [0. 1.]]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p><br/></p><p><code>np.linspace(start,end,num)</code>函数：根据起止数据等间距地填充数据，形成数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.linspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">5</span>))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">输出：[ 1.   3.25  5.5   7.75   10.  ]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p><br/></p><p><strong>总结</strong>：</p><div class="table-container"><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>np.arange(n)</td><td>类似range()函数，返回ndarray类型，元素从0 到 n ‐ 1</td></tr><tr><td>np.ones(shape)</td><td>根据shape生成一个全1数组，shape是元组类型</td></tr><tr><td>np.zeros(shape)</td><td>根据shape生成一个全0数组，shape是元组类型</td></tr><tr><td>np.full(shape,val)</td><td>根据shape生成一个数组，每个元素值都是val</td></tr><tr><td>np.eye(n)</td><td>创建一个正方的n*n单位数组，对角线为1，其余为0</td></tr><tr><td>np.linspace()</td><td>根据起止数据等间距地填充数据，形成数组</td></tr></tbody></table></div><hr><h4 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h4><ul><li>维度变换</li></ul><p><code>ndarray.reshape(shape)</code>方法：不改变数组元素，返回一个<code>shape</code>形状数组，原数组不变</p><p>你可以直接在shape里面输入-1，表示该维度的大小应该由数组的总大小和其他维度的大小<strong>自动计算</strong>得出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">x=np.ones((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line">y=x.reshape(<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">x是2行3列的数组</span></span><br><span class="line"><span class="string">[[1. 1. 1.]</span></span><br><span class="line"><span class="string"> [1. 1. 1.]]</span></span><br><span class="line"><span class="string">y是3行2列的数组</span></span><br><span class="line"><span class="string">[[1. 1.]</span></span><br><span class="line"><span class="string"> [1. 1.]</span></span><br><span class="line"><span class="string"> [1. 1.]]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p><br/></p><p><code>ndarray.resize(shape)</code>方法：与<code>reshape</code>功能一致，但修改原数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">x=np.ones((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line">x.resize(<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">x是2行3列的数组</span></span><br><span class="line"><span class="string">[[1. 1. 1.]</span></span><br><span class="line"><span class="string"> [1. 1. 1.]]</span></span><br><span class="line"><span class="string">修改后的x是3行2列的数组</span></span><br><span class="line"><span class="string">[[1. 1.]</span></span><br><span class="line"><span class="string"> [1. 1.]</span></span><br><span class="line"><span class="string"> [1. 1.]]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p><br/></p><p><code>ndarray.swapaxes(ax1,ax2)</code>方法：将数组<code>n</code>个维度中的两个维度进行调换</p><p><code>flattern()</code>：对数组进行降维，返回折叠后的一维数组，原数组不变</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">x=np.ones((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line">y=x.flatten()</span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">x是2行3列的数组</span></span><br><span class="line"><span class="string">[[1. 1. 1.]</span></span><br><span class="line"><span class="string"> [1. 1. 1.]]</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">y是一维的数组</span></span><br><span class="line"><span class="string">[1. 1. 1. 1. 1. 1.]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p><br/></p><ul><li>类型变换</li></ul><p><code>ndarray.astype(dtype)</code>方法：会创建一个dytpe类型的新的数组，数据和原数组一致</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=np.ones((<span class="number">2</span>,<span class="number">2</span>),dtype=np.<span class="built_in">int</span>)</span><br><span class="line">b=a.astype(np.<span class="built_in">float</span>)</span><br></pre></td></tr></table></figure><p><br/></p><p><code>ndarray.tolist()</code>方法：创建一个列表,列表元素和数组一致</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x=np.ones((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line">lst=x.tolist()</span><br><span class="line"><span class="built_in">print</span>(lst) </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[[1. 1. 1.]</span></span><br><span class="line"><span class="string"> [1. 1. 1.]]</span></span><br><span class="line"><span class="string">[[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p><br/></p><p>总结：</p><div class="table-container"><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>.reshape(shape)</td><td>不改变数组元素，返回一个shape形状的数组，原数组不变</td></tr><tr><td>.resize(shape)</td><td>与.reshape()功能一致，但修改原数组</td></tr><tr><td>.swapaxes(ax1,ax2)</td><td>将数组n个维度中两个维度进行调换</td></tr><tr><td>.flatten()</td><td>对数组进行降维，返回折叠后的一维数组，原数组不变</td></tr></tbody></table></div><hr><h4 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h4><p>数组与标量之间的运算作用于数组的每一个元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a=np.arrange(<span class="number">10</span>).reshape(<span class="number">2</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">a=a*<span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[[0 1 2 3 4]</span></span><br><span class="line"><span class="string"> [5 6 7 8 9]]</span></span><br><span class="line"><span class="string">[[ 0  2  4  6  8]</span></span><br><span class="line"><span class="string"> [10 12 14 16 18]]</span></span><br></pre></td></tr></table></figure><p>可以看到，每个元素都乘以2了</p><p><br/></p><p>一元函数</p><div class="table-container"><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>np.sort(x)</td><td>排序，并返回一个排序后的数组</td></tr><tr><td>np.abs(x)</td><td>计算数组各元素的绝对值</td></tr><tr><td>np.sqrt(x)</td><td>计算数组各元素的平方根</td></tr><tr><td>np.square(x)</td><td>计算数组元素各元素的平方</td></tr><tr><td>np.log(x)</td><td>计算数组各元素的自然对数</td></tr><tr><td>np.rint(x)</td><td>计算数组各元素的四舍五入的值</td></tr><tr><td>np.cos(x)</td><td>计算数组各元素的余弦函数</td></tr><tr><td>np.exp(x)</td><td>计算数组各元素的指数值</td></tr><tr><td>np.sign(x)</td><td>计算数组各元素的符号值 1,0,-1</td></tr></tbody></table></div><p><br/></p><p>二元函数</p><div class="table-container"><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>+ - * /</td><td>两个数组各元素进行对应运算</td></tr><tr><td>@</td><td>两个数组进行矩阵乘法</td></tr><tr><td>np.power(x,y)</td><td>求元素的幂</td></tr><tr><td>np.maximum(x,y)</td><td>求元素的最大值</td></tr><tr><td>np.mod(x,y)</td><td>元素级的模运算</td></tr><tr><td>np.copysign(x,y)</td><td>将数组y中各元素符号赋值给x</td></tr><tr><td>&gt; &lt;  == !=</td><td>算术比较，比产生一个布尔型数组</td></tr></tbody></table></div><p><br/></p><p>这里讲一下元素乘法<code>*</code>和矩阵乘法<code>@</code>之间的区别</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">X = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line">theta = np.array([<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"><span class="built_in">print</span>(X @ theta)  <span class="comment"># 输出：[ 50 122]</span></span><br><span class="line"><span class="built_in">print</span>(X * theta)  </span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># [[ 7 16 27]</span></span><br><span class="line"><span class="comment">#  [28 40 54]]</span></span><br></pre></td></tr></table></figure><p>对于<code>X @ theta</code>（矩阵乘法），结果是一个一维数组，其元素是<code>X</code>的每一行和<code>theta</code>的点积：这里，<code>50 = 1*7 + 2*8 + 3*9</code>，<code>122 = 4*7 + 5*8 + 6*9</code>。</p><p>对于<code>X * theta</code>（元素级别的乘法），结果是一个二维数组，其元素是<code>X</code>和<code>theta</code>的对应元素的乘积：这里，第一行<code>[7, 16, 27]</code>是<code>[1, 2, 3]</code>和<code>[7, 8, 9]</code>的元素级别的乘积，第二行<code>[28, 40, 54]</code>是<code>[4, 5, 6]</code>和<code>[7, 8, 9]</code>的元素级别的乘积。</p><hr><h4 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a><strong>矩阵</strong></h4><p><code>ndarray</code>中的<code>array</code>只是数组，进行矩阵运算，比如求逆矩阵之类的，很复杂，将<code>ndarray</code>的<code>array</code>数组转换为<code>matrix</code>矩阵形式，可以很快的求解逆矩阵</p><p><code>np.matrix()</code>方法：创建方法和<code>np.array()</code>类似</p><p><br/></p><p><code>matrix</code>对象有如下属性：</p><div class="table-container"><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>I</td><td>返回矩阵的逆矩阵，必须是方阵</td></tr><tr><td>H</td><td>返回矩阵的共轭转置矩阵，必须是方阵</td></tr><tr><td>T</td><td>返回矩阵的转置矩阵</td></tr><tr><td>A</td><td>返回矩阵的数组视图</td></tr></tbody></table></div><p>例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">m=np.matrix([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line"><span class="built_in">print</span>(m.A)  <span class="comment">#展示矩阵</span></span><br><span class="line"><span class="built_in">print</span>(m.T)  <span class="comment">#求矩阵m的转置</span></span><br><span class="line"><span class="built_in">print</span>(m.I)  <span class="comment">#求矩阵m的逆矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[[1 2]</span></span><br><span class="line"><span class="string"> [3 4]]</span></span><br><span class="line"><span class="string">[[1 3]</span></span><br><span class="line"><span class="string"> [2 4]]</span></span><br><span class="line"><span class="string">[[-2.   1. ]</span></span><br><span class="line"><span class="string"> [ 1.5 -0.5]]</span></span><br><span class="line"><span class="string"> &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><hr><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><p><strong>插入</strong></p><p><code>np.insert(x,place,element,axis)</code> 函数：</p><ul><li><code>x</code>：被插入元素的数组名称</li><li><code>place</code>：插入的位置</li><li><code>element</code>：插入的元素</li><li><code>axis</code>：指定插入的轴(维度)，如果是0，表示按行删除；如果是1，表示按列删除</li></ul><p>最后会返回一个<strong>新的</strong>数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A = np.array ([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]])</span><br><span class="line">B = np.insert (A, <span class="number">2</span>, [<span class="number">4</span>, <span class="number">5</span>], axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span> (B)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[[1 2 4 3]</span></span><br><span class="line"><span class="string"> [6 7 5 8]]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>具体到例子中来，<code>A</code>表示要被插入的数组，<code>2</code>表示插入的位置第2个，<code>[4,5]</code>表示插入的元素，而最后的<code>axis=1</code>表示，在第1个维度上插入，也就是列，所以最后会把[4,5]插入到第2列之后去</p><p>再写一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">A=np.arange(<span class="number">6</span>).reshape((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line">B=np.zeros((<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">C=np.insert(A,<span class="number">0</span>,B,<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(C)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[[0 1 2]</span></span><br><span class="line"><span class="string"> [3 4 5]]</span></span><br><span class="line"><span class="string">[[0 0 0]</span></span><br><span class="line"><span class="string"> [0 1 2]</span></span><br><span class="line"><span class="string"> [3 4 5]]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p><code>np.insert(A,0,B,0)</code>表示，把B插入到A中，在第0个位置，并且维度是0，也就是第0行</p><p><br/></p><hr><p><strong>拼接</strong></p><p><code>np.concatenate((tuple),axis)</code> 函数：</p><ul><li><code>tuple</code>：要连接的数组的元组()，如果是(a,b)，代表将a和b连接在一起</li><li><code>axis</code>：指定连接的维度</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A = np.array ([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]])</span><br><span class="line">B = np.array ([[<span class="number">4</span>], [<span class="number">5</span>]])</span><br><span class="line">C = np.concatenate ((A, B), axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span> (C)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[[1 2 3 4]</span></span><br><span class="line"><span class="string"> [6 7 8 5]]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p><code>np.concatenate ((A, B), axis=1</code>)表示，要把数组A和B链接起来，并且维度是1，也就是列</p><p><br/></p><hr><p><strong>删除</strong></p><p><code>np.delete(x,place,axis)</code>：</p><ul><li><code>x</code> ：要删除元素的数组</li><li><code>place</code>：删除的位置或索引</li><li><code>axis</code>：指定按行或列删除</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line">A = np.delete(A, <span class="number">1</span>, axis=<span class="number">1</span>) <span class="comment"># 删除第二列</span></span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[[1 3]</span></span><br><span class="line"><span class="string"> [4 6]</span></span><br><span class="line"><span class="string"> [7 9]]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p><br/></p><hr><p><strong>分割</strong></p><p>在使用函数之前，使用<code>python</code>自带的切片语法是最方便的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data=np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[[1 2 3]</span></span><br><span class="line"><span class="string"> [4 5 6]</span></span><br><span class="line"><span class="string"> [7 8 9]]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p><code>data[a:b,c:d]</code>：切片的语法，其中<code>a,b,c,d</code>代表了行和列的起始和终止的位置，也就是取<code>[a,b)</code>行，<code>[c,d)</code>列，注意是左闭右开的范围，如果<code>a,c</code>省略，则默认是最开始的位置，<code>b,d</code>省略了，这默认是最末尾的位置</p><p><br/></p><p>例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">data=np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line">a=data[<span class="number">0</span>:<span class="number">1</span>,<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">b=data[:<span class="number">2</span>,<span class="number">2</span>:]</span><br><span class="line">c=data[:,<span class="number">0</span>:<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[[1 2 3]</span></span><br><span class="line"><span class="string"> [4 5 6]</span></span><br><span class="line"><span class="string"> [7 8 9]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">a:[[2 3]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">b:[[3]</span></span><br><span class="line"><span class="string">   [6]]</span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string">c:[[1]</span></span><br><span class="line"><span class="string">   [4]</span></span><br><span class="line"><span class="string">   [7]]</span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><br/></p><p><code>data[0:1,1:3]</code>表示的是：取<code>[0,1)</code>行，切片第0行在数组表示中也就是第1行，取<code>[1,3)</code>列，也就是第2,3列，那么结果是第1行的第2,3列的元素集合</p><p><code>data[:2,2:]</code>表示的是：取<code>[0,2)</code>行，也就是数组的第1,2行，取[2,3)列，也就是第3列，那么结果是第1，2行和第3列的元素结合</p><p><code>c=data[:,0:1]</code>表示的是：取<code>[0,3)</code>行，也就是所有行，0表示第1列，所以会取出第1列的所有元素</p><p><br/></p><p>可以观察到，b和c都是二维数组，保留了其二维结构，如果我们想要取出列后，将其变成1维数组，那么可以省略后一个冒号<code>:</code></p><p>以下是例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">data=np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line">c=data[:,<span class="number">0</span>:<span class="number">1</span>]</span><br><span class="line">d=data[:,<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[[1 2 3]</span></span><br><span class="line"><span class="string"> [4 5 6]</span></span><br><span class="line"><span class="string"> [7 8 9]]</span></span><br><span class="line"><span class="string">c:[[1]</span></span><br><span class="line"><span class="string">   [4]</span></span><br><span class="line"><span class="string">   [7]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">d: [1 4 7]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，在省略后一个冒号<code>:</code>之后，提取出来的列变为了1维数组，更方便计算</p><p><br/></p><p><code>np.split(x,place,axis)</code> ：</p><ul><li><code>x</code>：要分割的数组</li><li><code>place</code>：分割的<strong>位置或份数</strong></li><li><code>axis</code>：指定分割的维度</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line">B = np.split(A, <span class="number">3</span>, axis=<span class="number">0</span>) <span class="comment"># 按行分割</span></span><br><span class="line"><span class="built_in">print</span>(B[<span class="number">1</span>]) <span class="comment"># 打印第二行</span></span><br><span class="line"><span class="comment">#结果是：[[4 5 6]]</span></span><br></pre></td></tr></table></figure><p><code>np.split(A, 3, axis=0)</code>的意思是，按行分割，把数组切割成3份，形成3个新数组，并把数组装进一个<strong>列表B</strong>中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line">B = np.split(A, [<span class="number">1</span>], axis=<span class="number">0</span>) <span class="comment"># 按行分割</span></span><br><span class="line"><span class="built_in">print</span>(B[<span class="number">1</span>]) <span class="comment"># 打印第二行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#结果是：[array([[1, 2, 3]]), array([[4, 5, 6],[7, 8, 9]])]</span></span><br></pre></td></tr></table></figure><p><code>np.split(A, [1], axis=0)</code>的意思是，按行分割，在第1行和第2行之间切割，把数组分成了2部分，装入列表B中</p><p><br/></p><p>也可以使用<code>hsplit</code>函数切割横向，<code>vsplit</code>函数切割纵向，这样就不用写第三个<code>axis</code>参数了</p><hr><h3 id="统计函数"><a href="#统计函数" class="headerlink" title="统计函数"></a>统计函数</h3><div class="table-container"><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>np.sum(a, axis)</td><td>根据给定轴axis计算数组a相关元素之和</td></tr><tr><td>np.mean(a, axis=None)</td><td>根据给定轴axis计算数组a相关元素的算术平均值</td></tr><tr><td>np.average(a,axis=None,weights=None)</td><td>根据给定轴axis计算数组a相关元素的加权平均值</td></tr><tr><td>np.std(a, axis=None)</td><td>根据给定轴axis计算数组a相关元素的标准差</td></tr><tr><td>np.var(a, axis=None)</td><td>根据给定轴axis计算数组a相关元素的方差</td></tr><tr><td>np.min(a) max(a)</td><td>计算数组a中元素的最小值、最大值</td></tr><tr><td>np.ptp(a)</td><td>计算数组a中元素最大值与最小值的差</td></tr><tr><td>np.median(a)</td><td>计算数组a中元素的中位数（中值）</td></tr><tr><td>np.unravel_index(index, shape)</td><td>根据shape将一维下标index转换成多维下标</td></tr></tbody></table></div><p><br/></p><p>以下举例说明用法：</p><p><code>np.sum(a,axis)</code>：用于计算数组元素之和的函数</p><ul><li><code>a</code>是要求和的数组，可以是一维或多维的</li><li><code>axis</code>是指定求和的维度，可以是整数或元组，例如<code>0</code>或<code>(0,1)</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">              [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">              [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">sum</span>(a))  <span class="comment">#会输出所有元素的和：78</span></span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">sum</span>(a,axis=<span class="number">1</span>))  </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">输出一个一维数组[10, 26, 42]</span></span><br><span class="line"><span class="string">表示第一行的和是10，第二行的和是26，第三行的和是42</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>注意：<code>numpy</code>中<code>axis=1</code>指定的是行，而在<code>Pandas</code>中，<code>axis=1</code>指定的是列，两者截然相反</p><p><br/></p><hr><h3 id="随机数函数"><a href="#随机数函数" class="headerlink" title="随机数函数"></a>随机数函数</h3><p>numpy中的随机数函数都是基于np.random的方法</p><div class="table-container"><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>rand(d0,d1….dn)</td><td>根据d0-dn的范围创建随机数数组，在0到1之间均匀分布</td></tr><tr><td>randn(d0,d1….dn)</td><td>根据d0-dn的范围创建随机数数组，标准正态分布</td></tr><tr><td>seed(s)</td><td>随机数种子，s是给定的种子值</td></tr></tbody></table></div><p><code>print(np.random.randn(2,5))</code>的意思是生成一个2行5列的二维数组，每个元素都是一个服从标准正态分布的随机数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[ <span class="number">0.75238979</span> -<span class="number">0.05053056</span> -<span class="number">0.77662364</span> -<span class="number">1.4862594</span>   <span class="number">0.55068062</span>]</span><br><span class="line"> [ <span class="number">0.54593743</span>  <span class="number">1.02283708</span>  <span class="number">0.64404996</span>  <span class="number">1.52941035</span>  <span class="number">0.4409481</span> ]]</span><br></pre></td></tr></table></figure><p>补充一个<code>numpy.random.choice(a, size=None, replace=True)</code>函数</p><ul><li><code>a</code>:数据范围<ul><li>如果是数组，表示从中进行随机抽样。</li><li>如果是整数，表示范围是 <code>[0, a)</code>。</li></ul></li><li><code>size</code>: 输出的大小。如果是整数，表示输出的是一维数组，如果是元组，表示输出的是多维数组。</li><li><code>replace</code>: 表示是否允许有放回地抽样。如果为 <code>True</code>，则允许重复抽样，如果为 <code>False</code>，则不允许重复抽样。</li></ul><p><br/></p><hr><h2 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>matplotlib</code>是一个<code>Python</code>的绘图库，它可以用来创建各种类型的图表和可视化。它有很多功能和参数，可以让你自定义图形的样式和效果。它也可以和其他的<code>Python</code>库如<code>numpy</code>和<code>scipy</code>一起使用，进行科学计算和数据分析。</p><p><code>Matplotlib</code>库由各种可视化类构成，内部结构复杂，受<code>Matlab</code>启发，<code>matplotlib.pyplot</code>是绘制各类可视化图形的命令子库，相当于快捷方式</p><p><code>import Matplotlib.pyplot as plt</code></p><hr><h3 id="plot函数"><a href="#plot函数" class="headerlink" title="plot函数"></a>plot函数</h3><p><code>plot(x, y, format, data=None, **kwargs)</code>：是绘制二维图形的一个常用函数，它可以接受多种参数来控制图形的样式和效果</p><ul><li><code>x</code>：表示X轴的数据，可以是列表，数组或者其他可迭代的对象</li><li><code>y</code>：表示Y轴的数据，可以是列表，数组或者其他可迭代的对象</li><li><code>format</code>：是一个可选的字符串，用来指定颜色，字符，标记等</li></ul><div class="table-container"><table><thead><tr><th>字符串</th><th>说明</th><th>字符串</th><th>说明</th></tr></thead><tbody><tr><td>‘b’</td><td>蓝色</td><td>‘r’</td><td>红色</td></tr><tr><td>‘g’</td><td>绿色</td><td>‘y’</td><td>黄色</td></tr><tr><td>‘#008000’</td><td>RGB颜色</td><td>‘0.8’</td><td>灰度值</td></tr><tr><td>‘-‘</td><td>实线</td><td>‘—‘</td><td>破折线</td></tr><tr><td>‘:’</td><td>虚线</td><td>‘’’’</td><td>无线条</td></tr><tr><td>‘.’</td><td>点标记</td><td>‘o’</td><td>实心圆</td></tr><tr><td>‘v’</td><td>倒三角</td><td>‘^’</td><td>上三角</td></tr></tbody></table></div><ul><li><code>data</code>：是一个可选的参数，用来传入一个对象数据类型，比如字典</li><li><code>**kwargs</code>：是一些关键字参数，可以设置第二组或更多的<code>(x,y,format)</code>，或者是用来设置图形的其他属性，比如标题，标签，刻度</li></ul><p>如果<code>plot</code>函数只有<strong>一个</strong>列表或数组输入，参数会被当做<code>y</code>轴，<code>x</code>轴以索引自动生成，也就是说，如果你输入一个数组$a=[a_0, a_1, a_2, …, a_n]$，那么<code>plot</code>函数会绘制出<code>n+1</code>个点，它们的坐标分别是$(0, a_0), (1, a_1), (2, a_2), …, (n, a_n)$。然后用线段连接这些点，形成一条曲线</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.plot([<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>])</span><br><span class="line">plt.show</span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231031024211178.png" alt="image-20231031024211178" style="zoom:67%;" /></p><p><br/></p><p>输入多个数组会将两个相邻数组看做x，y轴的数据，从而绘制出曲线</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a=np.arange(<span class="number">10</span>)</span><br><span class="line">plt.plot(a,a*<span class="number">1.5</span>,<span class="string">&#x27;r&#x27;</span>,a,a*<span class="number">2.5</span>,<span class="string">&#x27;c&#x27;</span>,,a,a*<span class="number">3.5</span>,<span class="string">&#x27;b&#x27;</span>,a,a*<span class="number">4.5</span>,<span class="string">&#x27;g&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231031025635206.png" alt="image-20231031025635206" style="zoom:67%;" /></p><p>实际上，我觉得这样写更好，虽然麻烦一些，但是可读性高：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=np.arange(<span class="number">10</span>)</span><br><span class="line">plt.plot(a,a*<span class="number">1.5</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">plt.plot(a,a*<span class="number">2.5</span>,<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">plt.plot(a,a*<span class="number">3.5</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">plt.plot(a,a*<span class="number">4.5</span>,<span class="string">&#x27;g&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><br/></p><hr><h3 id="文本显示"><a href="#文本显示" class="headerlink" title="文本显示"></a>文本显示</h3><div class="table-container"><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>plt.xlabel()</td><td>对 X轴增加文本标签</td></tr><tr><td>plt.ylabel()</td><td>对 Y轴增加文本标签</td></tr><tr><td>plt.title()</td><td>对图形整体增加文本标签</td></tr><tr><td>plt.grid(bool)</td><td>True代表显示网格</td></tr><tr><td>plt.axis()</td><td>规定坐标轴的起始范围</td></tr><tr><td>plt.legend()</td><td>指定图例的位置和字体大小</td></tr></tbody></table></div><p><br/></p><p>这里注意，<code>pyplot</code>默认是无法显示中文的，如果要用中文输出的话，增加一个属性：<code>fontproperties</code>，后面的<code>&#39;SimHei&#39;</code>表示用的是黑体</p><p><br/></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a=np.arange(<span class="number">0</span>,<span class="number">5.0</span>,<span class="number">0.02</span>)</span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">&#x27;横轴：时间&#x27;</span>,fontproperties=<span class="string">&#x27;SimHei&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;纵轴：振幅&#x27;</span>,fontproperties=<span class="string">&#x27;SimHei&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;振幅图像&#x27;</span>,fontproperties=<span class="string">&#x27;SimHei&#x27;</span>)</span><br><span class="line">plt.plot(a,np.cos(<span class="number">2</span>*np.pi*a),<span class="string">&#x27;r--&#x27;</span>,label=<span class="string">&#x27;cosx&#x27;</span>)  <span class="comment">#设置图例名字叫cosx</span></span><br><span class="line">plt.plot(a,np.sin(<span class="number">2</span>*np.pi*a),<span class="string">&#x27;b--&#x27;</span>,label=<span class="string">&#x27;sinx&#x27;</span>)  <span class="comment">#设置图例名字叫sinx</span></span><br><span class="line">plt.legend(loc=<span class="string">&#x27;best&#x27;</span>,fontsize=<span class="number">10</span>)   <span class="comment">#展示图例，位置为最佳，大小为10</span></span><br><span class="line">plt.grid(<span class="string">&#x27;True&#x27;</span>)  <span class="comment"># 开启网格</span></span><br><span class="line">plt.axis([-<span class="number">1</span>,<span class="number">6</span>,-<span class="number">2</span>,<span class="number">2</span>])  <span class="comment">#指定坐标轴范围</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231031061422811.png" alt="image-20231031061422811"></p><hr><h3 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h3><p>直接使用<code>plt.scatter()</code>函数就可以绘制散点图，例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(<span class="number">10</span>*np.random.randn(<span class="number">100</span>),<span class="number">10</span>*np.random.randn(<span class="number">100</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231031050028841.png" alt="image-20231031050028841" style="zoom:80%;" /></p><p>生成了100个服从正态分布的随机数，并放大10倍，同时参数为<code>&#39;o&#39;</code>，即实心圆点</p><p><br/></p><p>还有一种面向对象的散点图绘制方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fig,ax=plt.subplots()</span><br><span class="line">ax.scatter(<span class="number">10</span>*np.random.randn(<span class="number">100</span>),<span class="number">10</span>*np.random.randn(<span class="number">100</span>))</span><br><span class="line">plt.show() <span class="comment"># 显示图形窗口</span></span><br></pre></td></tr></table></figure><p>一样可以绘制散点图，实际上，这种方法是官方推荐的办法，因为创建了<code>plt</code>的对象，让操作更加方便</p><p><code>fig,ax=plt.subplots()</code>：</p><ul><li><p><code>fig</code>是图形窗口对象，代表整个绘图区域，包括子图、图表标题、轴标签等</p></li><li><p><code>ax</code>则是子图对象的一个列表，用于设置每个子图的属性和绘制图形</p></li><li><code>subplots()</code>表示创建了一个子图</li></ul><p><br/></p><p>以下是一些子图对象<code>ax</code>的绘制方法，<code>plt</code>也能直接调用这些方法</p><div class="table-container"><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>ax.plot</td><td>曲线图</td></tr><tr><td>ax.bar</td><td>柱状图</td></tr><tr><td>ax.pie</td><td>饼状图</td></tr><tr><td>ax.scatter</td><td>散点图</td></tr></tbody></table></div><p>以散点图<code>scatter</code>为例，解释一下绘制图形时的参数</p><p><code>ax.scatter(x, y, s=None, c=None, marker=None, cmap=None,data,**kwargs)</code></p><ul><li><code>x</code>和<code>y</code>是表示横纵坐标的数据，它们可以是列表、数组或其他可迭代的对象。</li><li><code>s</code>是表示点的大小的参数，</li><li><code>c</code>是表示点的颜色的参数，</li><li><code>marker</code>是表示点的形状的参数，</li><li><code>cmap</code>是表示颜色映射的参数，</li><li><code>data</code>是表示传入对象数据类型的参数，</li><li><code>**kwargs</code>是表示其他关键字参数</li></ul><p>可以看到，可以调整的参数远比<code>plot</code>函数多</p><p><br/></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个图形窗口和一个子图</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"></span><br><span class="line">ax.scatter(<span class="number">10</span>*np.random.randn(<span class="number">50</span>), <span class="number">10</span>*np.random.randn(<span class="number">50</span>),c=<span class="string">&#x27;r&#x27;</span>,s=<span class="number">30</span>)</span><br><span class="line">ax.scatter(<span class="number">10</span>*(np.random.randn(<span class="number">50</span>)+<span class="number">5</span>), <span class="number">10</span>*(np.random.randn(<span class="number">50</span>)+<span class="number">5</span>),c=<span class="string">&#x27;g&#x27;</span>,s=<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">ax.set_title(<span class="string">&#x27;图表&#x27;</span>,fontproperties=<span class="string">&#x27;SimHei&#x27;</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;X轴&#x27;</span>,fontproperties=<span class="string">&#x27;SimHei&#x27;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;Y轴&#x27;</span>,fontproperties=<span class="string">&#x27;SimHei&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示图形窗口</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231031061700412.png" alt="image-20231031061700412"></p><p>这里设置标题的方法和<code>plot</code>有所不同，不过差别很小</p><hr><h2 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a>Pandas</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p><code>Pandas</code> 是一个用于数据分析的 <code>Python</code> 库，它基于 <code>NumPy</code> 和 <code>matplotlib</code>，提供了高效、易用的数据结构和数据处理工具</p><p><code>Pandas</code> 的主要数据结构是<code>Series</code>（一维数据）和 <code>DataFrame</code>（二维数据），它们可以方便地对数据进行分组、聚合、合并、透视等操作</p><p><code>import pandas as pd</code></p><p><br/></p><hr><h3 id="Series类型"><a href="#Series类型" class="headerlink" title="Series类型"></a>Series类型</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p><code>Series</code>类型由一组数据及与之相关的数据<strong>索引</strong>组成</p><p>使用方法和<code>NumPy</code>的数组类似，不同之处在于，<code>Series</code>会给数据生成一个索引</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231101035942794.png" alt="image-20231101035942794" style="zoom:67%;" /></p><p><code>s = pd.Series(data, index, name=, dtype=)</code></p><ul><li><code>data</code>：必要的参数，表示数据</li><li><code>index</code>：可选的参数，表示数据的索引，默认是从0开始增加</li><li><code>name</code>：可选的参数，表示<code>Series</code>的名字</li><li><code>dtype</code>：可选的参数，指定数据类型</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </span><br><span class="line"></span><br><span class="line">data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">index1 = (<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>)</span><br><span class="line">s = pd.Series(data, index1, name=<span class="string">&quot;example&quot;</span>, dtype=<span class="built_in">int</span>)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">输出结果：</span></span><br><span class="line"><span class="string">a    1</span></span><br><span class="line"><span class="string">b    2</span></span><br><span class="line"><span class="string">c    3</span></span><br><span class="line"><span class="string">d    4</span></span><br><span class="line"><span class="string">Name: example, dtype: int32</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p><code>a,b,c,d</code>就是指定的索引，如果不写，那么就是<code>0,1,2,3</code></p><p><br/></p><hr><h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h4><p><code>Series</code>可以由多种数据类型创建，以下类型比较常见：</p><ul><li><code>Python</code>列表：<code>index</code>与列表元素个数一致</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">index1 = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>]</span><br><span class="line">s1 = pd.Series(data) <span class="comment"># 使用默认索引</span></span><br><span class="line">s2 = pd.Series(data, index1) <span class="comment"># 使用指定索引</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">0    1</span></span><br><span class="line"><span class="string">1    2</span></span><br><span class="line"><span class="string">2    3</span></span><br><span class="line"><span class="string">3    4</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">a    1</span></span><br><span class="line"><span class="string">b    2</span></span><br><span class="line"><span class="string">c    3</span></span><br><span class="line"><span class="string">d    4</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><ul><li>标量值：<code>index</code>表达<code>Series</code>类型的尺寸</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = <span class="number">5</span></span><br><span class="line">index1 = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>]</span><br><span class="line">s5 = pd.Series(data, index1) <span class="comment"># 使用标量值作为数据，重复填充到每个索引位置</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">a    5</span></span><br><span class="line"><span class="string">b    5</span></span><br><span class="line"><span class="string">c    5</span></span><br><span class="line"><span class="string">d    5</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>Python</code>字典：键是索引，值是数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>, <span class="string">&quot;c&quot;</span>: <span class="number">3</span>, <span class="string">&quot;d&quot;</span>: <span class="number">4</span>&#125;</span><br><span class="line">s3 = pd.Series(data) <span class="comment"># 使用字典的键作为索引</span></span><br><span class="line">s4 = pd.Series(data, index = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;e&quot;</span>]) <span class="comment"># 使用指定索引，只保留字典中的&quot;a&quot;和&quot;b&quot;，&quot;e&quot;对应的值为NaN</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">a    1</span></span><br><span class="line"><span class="string">b    2</span></span><br><span class="line"><span class="string">c    3</span></span><br><span class="line"><span class="string">d    4</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">a    1.0</span></span><br><span class="line"><span class="string">b    2.0</span></span><br><span class="line"><span class="string">e    NaN</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><ul><li>使用其他<code>Series</code>对象作为数据，可以指定索引标签，也可以使用原<code>Series</code>对象的索引</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>])</span><br><span class="line">s6 = pd.Series(data) <span class="comment"># 使用原Series对象的索引和数据</span></span><br><span class="line">s7 = pd.Series(data, index = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;e&quot;</span>]) <span class="comment"># 使用指定索引，只保留原Series对象中的&quot;a&quot;和&quot;b&quot;，&quot;e&quot;对应的值为NaN</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">a    1.0</span></span><br><span class="line"><span class="string">b    2.0</span></span><br><span class="line"><span class="string">e    NaN</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><hr><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><div class="table-container"><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>index</td><td>返回 Series 对象的索引，可以是字符串、数字或其他类型</td></tr><tr><td>values</td><td>返回 Series 对象的数据，以 numpy 数组的形式</td></tr><tr><td>dtype</td><td>返回 Series 对象的数据类型，可以是 int、float、str</td></tr><tr><td>size</td><td>回 Series 对象的个数</td></tr><tr><td>name</td><td>返回 Series 对象的名称，可以自定义或默认为 None</td></tr><tr><td>empty</td><td>返回一个布尔值，表示 Series 对象是否为空</td></tr></tbody></table></div><p><br/></p><p>可以通过<code>Series</code>对象的<code>index</code>属性和<code>values</code>属性直接输出<code>Series</code>中的数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </span><br><span class="line"></span><br><span class="line">data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">index1 = (<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>)</span><br><span class="line">s = pd.Series(data, index1)</span><br><span class="line"><span class="built_in">print</span>(s.index)</span><br><span class="line"><span class="built_in">print</span>(s.values)</span><br><span class="line"><span class="built_in">print</span>(s.shape)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Index([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;], dtype=&#x27;object&#x27;)</span></span><br><span class="line"><span class="string">[1 2 3 4]</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p><br/></p><hr><h4 id="Index索引"><a href="#Index索引" class="headerlink" title="Index索引"></a>Index索引</h4><p>正如上面的代码，执行<code>index</code>属性会返回<code>Series</code>对象的索引类型，类型名称就叫<code>Index</code>类型，<code>Index</code>类型是一个<strong>无法修改</strong>的类型</p><p><code>index</code>索引有很多函数，方便直接修改索引</p><div class="table-container"><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>.append(idx)</td><td>连接另一个Index对象</td></tr><tr><td>.diff(idx)</td><td>计算差集</td></tr><tr><td>.intersection(idx)</td><td>计算交集</td></tr><tr><td>.union(idx)</td><td>计算并集</td></tr><tr><td>.delete(loc)</td><td>删除loc位置处的元素</td></tr><tr><td>.insert(loc,e)</td><td>在loc位置增加一个元素e</td></tr></tbody></table></div><p>注意，由于<code>index</code>无法修改，以上操作都会返回一个新的<code>index</code>对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">index1 = (<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>)</span><br><span class="line">s = pd.Series(data, index1)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">a    1</span></span><br><span class="line"><span class="string">b    2</span></span><br><span class="line"><span class="string">c    3</span></span><br><span class="line"><span class="string">d    4</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">index2 = s.index.insert(<span class="number">1</span>, <span class="string">&#x27;e&#x27;</span>) </span><br><span class="line"><span class="comment"># 使用Index.insert方法在索引的第1个位置插入&#x27;e&#x27;，返回一个新的Index对象</span></span><br><span class="line">s1 = pd.Series(s, index2) </span><br><span class="line"><span class="comment"># 使用新的Index对象创建一个新的Series对象，数据为s的值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">a    1.0</span></span><br><span class="line"><span class="string">e    NaN</span></span><br><span class="line"><span class="string">b    2.0</span></span><br><span class="line"><span class="string">c    3.0</span></span><br><span class="line"><span class="string">d    4.0</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">index3=s1.index.delete(<span class="number">4</span>)  </span><br><span class="line"><span class="comment"># 使用Index.delete方法在索引的第4个位置删除d，返回一个新的Index对象</span></span><br><span class="line">s2=pd.Series(s1,index3)</span><br><span class="line">s2</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">a    1.0</span></span><br><span class="line"><span class="string">e    NaN</span></span><br><span class="line"><span class="string">b    2.0</span></span><br><span class="line"><span class="string">c    3.0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><hr><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><p>不难看出，<code>Series</code>对象本质上是<code>ndarray</code>对象和<code>Python</code>中自带的字典类型的结合体，所以<code>ndarray</code>和字典能用的函数，<code>Series</code>基本上都能使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">data = [<span class="number">8</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>]</span><br><span class="line">index = (<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>)</span><br><span class="line">s = pd.Series(data, index)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.square(s))  <span class="comment">#输出s的values值的平方</span></span><br><span class="line"><span class="built_in">print</span>(s[:<span class="number">3</span>])  <span class="comment">#输出s的前三个数据</span></span><br><span class="line"><span class="built_in">print</span>(s[s&gt;np.median(s)])  <span class="comment">#输出s中比s中位数大的数据</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">平方后：</span></span><br><span class="line"><span class="string">a    64</span></span><br><span class="line"><span class="string">b    81</span></span><br><span class="line"><span class="string">c    25</span></span><br><span class="line"><span class="string">d    16</span></span><br><span class="line"><span class="string">dtype: int64</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">前2个数据：</span></span><br><span class="line"><span class="string">a    8</span></span><br><span class="line"><span class="string">b    9</span></span><br><span class="line"><span class="string">dtype: int64</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">比中位数大的数据</span></span><br><span class="line"><span class="string">a    8</span></span><br><span class="line"><span class="string">b    9</span></span><br><span class="line"><span class="string">c    5</span></span><br><span class="line"><span class="string">dtype: int64</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>都是经典的<code>ndarray</code>数组操作，<code>Series</code>对象一样适用</p><p><br/></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">data = [<span class="number">8</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>]</span><br><span class="line">index = (<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>)</span><br><span class="line">s = pd.Series(data, index)</span><br><span class="line"><span class="built_in">print</span>(s[<span class="string">&#x27;a&#x27;</span>])    <span class="comment">#字典操作，根据key值寻找value</span></span><br><span class="line"><span class="built_in">print</span>(s.get(<span class="string">&#x27;e&#x27;</span>))  <span class="comment">#利用get方法，输入key值寻找对应的value</span></span><br><span class="line"><span class="built_in">print</span>( <span class="number">5</span> <span class="keyword">in</span> s)   <span class="comment"># 判断5是否在value中</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">8</span></span><br><span class="line"><span class="string">None</span></span><br><span class="line"><span class="string">False</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p><br/></p><hr><h3 id="DataFrame类型"><a href="#DataFrame类型" class="headerlink" title="DataFrame类型"></a>DataFrame类型</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p><code>DataFrame</code>类型由共用相同索引的一组列组成</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231101193850145.png" alt="image-20231101193850145"></p><p><code>DataFrame</code>是一个表格型的数据类型，每列值类型可以不同，既有行索引，也有列索引</p><p>可以看到，<code>DataFrame</code>类型类似于<code>excel</code>格式，常用于表达二维数据，但可以表达多维数据</p><p><br/></p><hr><h4 id="创建-2"><a href="#创建-2" class="headerlink" title="创建"></a>创建</h4><ul><li>可以从二维的<code>ndarray</code>对象来创建</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">pd.DataFrame(np.arange(<span class="number">10</span>,<span class="number">0</span>,-<span class="number">1</span>).reshape(<span class="number">5</span>,<span class="number">2</span>))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">输出结果:</span></span><br><span class="line"><span class="string">    01</span></span><br><span class="line"><span class="string">0109</span></span><br><span class="line"><span class="string">187</span></span><br><span class="line"><span class="string">265</span></span><br><span class="line"><span class="string">343</span></span><br><span class="line"><span class="string">421</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>可以看到，行索引和列索引都是自动生成的，是从0开始的整数</p><p><br/></p><ul><li>从一维的<code>ndarray</code>对象字典创建</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dt=&#123;<span class="string">&#x27;one&#x27;</span>:pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],index=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]),<span class="string">&#x27;two&#x27;</span>:pd.Series([<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>],index=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>])&#125;</span><br><span class="line">d=pd.DataFrame(dt)</span><br><span class="line">d</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">   one  two</span></span><br><span class="line"><span class="string">a  1.0    9</span></span><br><span class="line"><span class="string">b  2.0    8</span></span><br><span class="line"><span class="string">c  3.0    7</span></span><br><span class="line"><span class="string">d  NaN    6</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>可以看到，我们用<code>index</code>指定了<code>DataFrame</code>对象的行索引，系统会将字典的<code>key</code>当做是列索引，同时，会自动对齐格式，如果有缺失的项，会用<code>NaN</code>表示空</p><p><br/></p><ul><li>直接从列表类型的字典创建</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dl=&#123;<span class="string">&#x27;one&#x27;</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],<span class="string">&#x27;two&#x27;</span>:[<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>]&#125;</span><br><span class="line">d=pd.DataFrame(dl,index=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>])</span><br><span class="line">d</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">   one  two</span></span><br><span class="line"><span class="string">a    1    9</span></span><br><span class="line"><span class="string">b    2    8</span></span><br><span class="line"><span class="string">c    3    7</span></span><br><span class="line"><span class="string">d    4    6</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><hr><h4 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h4><p><br/></p><p><strong>定位</strong></p><p><code>df.head(n)</code>方法：查看<code>DataFrame</code>对象的前<code>n</code>行，默认是前5行</p><p><code>df.tail(n)</code>方法：查看<code>DataFrame</code>对象的最后<code>n</code>行，默认是后5行</p><p><br/></p><p>使用<code>df.loc</code>方法和<code>df.iloc</code>方法可以<strong>访问并修改</strong><code>DataFrame</code>中的任意行列数据</p><ul><li><code>loc</code>是基于<strong>标签</strong>（<code>label</code>）来选择数据，即行索引和列索引的名称。例如，<code>df.loc[‘A’:‘C’, ‘c1’:‘c3’]</code>表示选择行索引为A到C（包含C），列索引为c1到c3（包含c3）的数据</li><li><code>iloc</code>是基于<strong>位置</strong>（<code>index</code>）来选择数据，即行索引和列索引的整数位置。例如，<code>df.iloc[1:3, 2:4]</code>表示选择第1行到第3行（不包含第3行），第2列到第4列（不包含第4列）的数据</li></ul><p><code>loc</code>和<code>iloc</code>实现了<code>ndarray</code>中的<strong>切片</strong>操作</p><p><br/></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;name&#x27;</span>: [<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Charlie&#x27;</span>, <span class="string">&#x27;David&#x27;</span>, <span class="string">&#x27;Eve&#x27;</span>],</span><br><span class="line">                   <span class="string">&#x27;age&#x27;</span>: [<span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>],</span><br><span class="line">                   <span class="string">&#x27;gender&#x27;</span>: [<span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;F&#x27;</span>],</span><br><span class="line">                   <span class="string">&#x27;score&#x27;</span>: [<span class="number">90</span>, <span class="number">80</span>, <span class="number">70</span>, <span class="number">60</span>, <span class="number">50</span>]&#125;)</span><br><span class="line">df.index = [<span class="string">&#x27;a1&#x27;</span>, <span class="string">&#x27;a2&#x27;</span>, <span class="string">&#x27;a3&#x27;</span>, <span class="string">&#x27;a4&#x27;</span>, <span class="string">&#x27;a5&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">nameagegenderscore</span></span><br><span class="line"><span class="string">a1Alice25F    90</span></span><br><span class="line"><span class="string">a2Bob    30M    80</span></span><br><span class="line"><span class="string">a3Charlie35M    70</span></span><br><span class="line"><span class="string">a4David40M    60</span></span><br><span class="line"><span class="string">a5Eve    45F    50</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p><br/></p><p><code>df.loc[&#39;a2&#39;:&#39;name&#39;]</code>：输出Bob</p><p><code>df.loc[:,&#39;name&#39;,&#39;gender&#39;]</code>：会输出<code>name</code>和<code>gender</code>列的所有数据</p><p><code>df.loc[&#39;a1:&#39;a3&#39;,:]</code>：会输出<code>a1</code>到<code>a3</code>列的所有数据</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Bob</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">namegender</span></span><br><span class="line"><span class="string">a1AliceF</span></span><br><span class="line"><span class="string">a2Bob  M</span></span><br><span class="line"><span class="string">a3CharlieM</span></span><br><span class="line"><span class="string">a4DavidM</span></span><br><span class="line"><span class="string">a5Eve     F</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">nameagegenderscore</span></span><br><span class="line"><span class="string">a1Alice25 F   90</span></span><br><span class="line"><span class="string">a2Bob    30M   80</span></span><br><span class="line"><span class="string">a3Charlie35M   70</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p><br/></p><p><code>df.iloc[0,2]</code>：会直接输出Charlie</p><p><code>df.iloc[:,[0,-1]]</code>：会输出第1列和最后一列，注意这里的<code>-1</code>表示最后一列</p><p><code>df.iloc[0:3,:]</code>：会输出第1行到第3行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       name  score</span></span><br><span class="line"><span class="string">a1    Alice     90</span></span><br><span class="line"><span class="string">a2      Bob     80</span></span><br><span class="line"><span class="string">a3  Charlie     70</span></span><br><span class="line"><span class="string">a4    David     60</span></span><br><span class="line"><span class="string">a5      Eve     50</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">nameagegenderscore</span></span><br><span class="line"><span class="string">a1Alice25F90</span></span><br><span class="line"><span class="string">a2Bob    30M80</span></span><br><span class="line"><span class="string">a3Charlie35M70</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>以上就是如果定位到DataFrame对象中的数据，修改就不必多说了，因为能够定位，就能够修改，比如：</p><p><code>df.iloc[3,1:3]=(&#39;55&#39;,&#39;F&#39;,&#39;100&#39;)</code></p><p>执行该语句会将<code>df</code>中的第4行的第2个数据到第4个数据依次改为55，F，100</p><p><br/></p><hr><p><strong>插入</strong></p><p><code>DataFrame.insert(loc,column,value)</code>用于在指定位置插入<strong>新列</strong>,它的主要参数如下:</p><ul><li><code>loc</code> - 插入列的索引位置,从0开始</li><li><code>column</code> - 新插入列的列名</li><li><code>value</code> - 新插入列的值,可以是标量、列表、数组等</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">&#x27;A&#x27;</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="string">&#x27;B&#x27;</span>:[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在索引位置0的位置插入新列C</span></span><br><span class="line">df.insert(<span class="number">0</span>, <span class="string">&#x27;C&#x27;</span>, [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]) </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">   C  A  B</span></span><br><span class="line"><span class="string">0  7  1  4</span></span><br><span class="line"><span class="string">1  8  2  5</span></span><br><span class="line"><span class="string">2  9  3  6</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><hr><p><strong>重新索引</strong></p><p><code>df.reindex(index or columns  fill_value,method,copy)</code>：</p><ul><li><code>index or columns</code> ：新的行列索引</li><li><code>fill_value</code> ：如果有缺失值的填充值，默认为<code>NaN</code></li><li><code>method</code>: 填充缺失值的方法，<code>ffill</code>当前值向前填充，<code>bfill</code>向后填充</li><li><code>copy</code>：默认为<code>True</code>，生成新的对象，<code>False</code>时，新旧相等不复制</li></ul><p><br/></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;name&#x27;</span>: [<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Charlie&#x27;</span>, <span class="string">&#x27;David&#x27;</span>, <span class="string">&#x27;Eve&#x27;</span>],</span><br><span class="line">                   <span class="string">&#x27;age&#x27;</span>: [<span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>],</span><br><span class="line">                   <span class="string">&#x27;gender&#x27;</span>: [<span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;F&#x27;</span>],</span><br><span class="line">                   <span class="string">&#x27;score&#x27;</span>: [<span class="number">90</span>, <span class="number">80</span>, <span class="number">70</span>, <span class="number">60</span>, <span class="number">50</span>]&#125;)</span><br><span class="line"></span><br><span class="line">df.index = [<span class="string">&#x27;a1&#x27;</span>, <span class="string">&#x27;a2&#x27;</span>, <span class="string">&#x27;a3&#x27;</span>, <span class="string">&#x27;a4&#x27;</span>, <span class="string">&#x27;a5&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">nameagegenderscore</span></span><br><span class="line"><span class="string">a1Alice25F    90</span></span><br><span class="line"><span class="string">a2Bob    30M    80</span></span><br><span class="line"><span class="string">a3Charlie35M    70</span></span><br><span class="line"><span class="string">a4David40M    60</span></span><br><span class="line"><span class="string">a5Eve    45F    50</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">a=df.reindex(index = [<span class="string">&#x27;a2&#x27;</span>, <span class="string">&#x27;a1&#x27;</span>, <span class="string">&#x27;a3&#x27;</span>, <span class="string">&#x27;a4&#x27;</span>, <span class="string">&#x27;a5&#x27;</span>])</span><br><span class="line">b=a.reindex(columns= [<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>, <span class="string">&#x27;score&#x27;</span>])</span><br><span class="line">b</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">agenamegenderscore</span></span><br><span class="line"><span class="string">a230Bob     M    80</span></span><br><span class="line"><span class="string">a125AliceF    90</span></span><br><span class="line"><span class="string">a335CharlieM    70</span></span><br><span class="line"><span class="string">a440DavidM    60</span></span><br><span class="line"><span class="string">a545Eve  F    50</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>其中<code>a</code>就是<code>df</code>交换了<code>a1</code>，<code>a2</code>两行所生成的新对象，<code>b</code>是在<code>a</code>的基础上交换了<code>age</code>列和<code>name</code>列所生成的新对象</p><p><br/><div class="note primary flat"><p><code>reindex</code>可以通过改变<code>Index</code>这一索引类型，从而实现简便的操作，而这也是<code>Pandas</code>数据类型的核心思想</p></div></p><hr><p><strong>索引的增删</strong></p><p>使用<code>Index</code>索引的<code>insert</code>和<code>delete</code>方法可以实现索引的<strong>增加</strong>或者<strong>删除</strong>，这在<code>Series</code>类型的<code>Index</code>索引这一小节中有所提及</p><p><br/></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;name&#x27;</span>: [<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Charlie&#x27;</span>, <span class="string">&#x27;David&#x27;</span>, <span class="string">&#x27;Eve&#x27;</span>],</span><br><span class="line">                   <span class="string">&#x27;age&#x27;</span>: [<span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>],</span><br><span class="line">                   <span class="string">&#x27;gender&#x27;</span>: [<span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;F&#x27;</span>],</span><br><span class="line">                   <span class="string">&#x27;score&#x27;</span>: [<span class="number">90</span>, <span class="number">80</span>, <span class="number">70</span>, <span class="number">60</span>, <span class="number">50</span>]&#125;)</span><br><span class="line"></span><br><span class="line">df.index = [<span class="string">&#x27;a1&#x27;</span>, <span class="string">&#x27;a2&#x27;</span>, <span class="string">&#x27;a3&#x27;</span>, <span class="string">&#x27;a4&#x27;</span>, <span class="string">&#x27;a5&#x27;</span>]</span><br><span class="line"></span><br><span class="line">columns1 = df.columns.delete(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 删除gender列</span></span><br><span class="line">index1 = df.index.insert(<span class="number">3</span>, <span class="string">&#x27;a6&#x27;</span>) </span><br><span class="line"><span class="comment"># 在第3个位置插入&#x27;a6&#x27;索引</span></span><br><span class="line">data1 = df.reindex(index = index1, columns = columns1，fill_value=<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line"><span class="comment"># 使用新的索引和列，不指定填充方法,默认值为0</span></span><br><span class="line">data1.iloc[<span class="number">3</span>,<span class="number">0</span>:<span class="number">3</span>]=(<span class="string">&#x27;Frank&#x27;</span>,<span class="string">&#x27;50.0&#x27;</span>,<span class="string">&#x27;100.0&#x27;</span>)</span><br><span class="line"><span class="comment">#将第4行，第1个数据到第3个数据依次改为Frank，50，100</span></span><br><span class="line">data1</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       name   age  score</span></span><br><span class="line"><span class="string">a1    Alice  25.0   90.0</span></span><br><span class="line"><span class="string">a2      Bob  30.0   80.0</span></span><br><span class="line"><span class="string">a3  Charlie  35.0   70.0</span></span><br><span class="line"><span class="string">a6    Frank  50.0   100.0</span></span><br><span class="line"><span class="string">a4    David  40.0   60.0</span></span><br><span class="line"><span class="string">a5      Eve  45.0   50.0</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p><br/></p><p><strong>删除</strong>指定的行或者列，更推荐使用<code>drop</code>方法</p><p><code>drop(name,axis)</code></p><ul><li><code>name</code>：指要删除的行列名称</li><li><code>axis</code>：要删除的轴，默认是删除行，如果要删除列，则修改为1</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;name&#x27;</span>: [<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Charlie&#x27;</span>, <span class="string">&#x27;David&#x27;</span>, <span class="string">&#x27;Eve&#x27;</span>],</span><br><span class="line">                   <span class="string">&#x27;age&#x27;</span>: [<span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>],</span><br><span class="line">                   <span class="string">&#x27;gender&#x27;</span>: [<span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;F&#x27;</span>],</span><br><span class="line">                   <span class="string">&#x27;score&#x27;</span>: [<span class="number">90</span>, <span class="number">80</span>, <span class="number">70</span>, <span class="number">60</span>, <span class="number">50</span>]&#125;)</span><br><span class="line"></span><br><span class="line">df.index = [<span class="string">&#x27;a1&#x27;</span>, <span class="string">&#x27;a2&#x27;</span>, <span class="string">&#x27;a3&#x27;</span>, <span class="string">&#x27;a4&#x27;</span>, <span class="string">&#x27;a5&#x27;</span>]</span><br><span class="line"></span><br><span class="line">df.drop(<span class="string">&#x27;age&#x27;</span>,axis=<span class="number">1</span>) <span class="comment">#删除age列</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">namegenderscore</span></span><br><span class="line"><span class="string">a1AliceF90</span></span><br><span class="line"><span class="string">a2Bob M80</span></span><br><span class="line"><span class="string">a3CharlieM70</span></span><br><span class="line"><span class="string">a4DavidM60</span></span><br><span class="line"><span class="string">a5Eve F50</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p><br/></p><hr><h4 id="运算-1"><a href="#运算-1" class="headerlink" title="运算"></a>运算</h4><p>算术运算是根据行列索引，补齐后运算，运算默认产生浮点数，补齐时缺项填充<code>NaN</code></p><p>可以直接使用<code>+-*/</code>进行运算，不过推荐使用算术方法</p><div class="table-container"><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>.add(d,**argws)</td><td>加</td></tr><tr><td>.sub(d,**argws)</td><td>减</td></tr><tr><td>.mul(d,**argws)</td><td>乘</td></tr><tr><td>.div(d,**argws)</td><td>除</td></tr></tbody></table></div><p><br/></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建两个DataFrame对象</span></span><br><span class="line">df1 = pd.DataFrame(np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>, <span class="number">3</span>),</span><br><span class="line">                   columns=[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>])</span><br><span class="line">df2 = pd.DataFrame(np.arange(<span class="number">12</span>).reshape(<span class="number">4</span>, <span class="number">3</span>),</span><br><span class="line">                   columns=[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;D&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df1)</span><br><span class="line"><span class="built_in">print</span>(df2)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string">   A  B  C</span></span><br><span class="line"><span class="string">0  0  1  2</span></span><br><span class="line"><span class="string">1  3  4  5</span></span><br><span class="line"><span class="string">2  6  7  8</span></span><br><span class="line"><span class="string">   A   B   D</span></span><br><span class="line"><span class="string">0  0   1   2</span></span><br><span class="line"><span class="string">1  3   4   5</span></span><br><span class="line"><span class="string">2  6   7   8</span></span><br><span class="line"><span class="string">3  9  10  11</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 使用方法进行算术运算，指定填充值为0</span></span><br><span class="line"><span class="built_in">print</span>(df1.add(df2, fill_value = <span class="number">0</span>)) <span class="comment"># 相加，用0替换NaN</span></span><br><span class="line"><span class="built_in">print</span>(df1.mul(df2, fill_value = <span class="number">0</span>)) <span class="comment"># 相乘，用0替换NaN</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string">     A     B    C     D</span></span><br><span class="line"><span class="string">0  0.0   2.0  2.0   2.0</span></span><br><span class="line"><span class="string">1  6.0   8.0  5.0   5.0</span></span><br><span class="line"><span class="string">2  12.0  14.0  8.0   8.0</span></span><br><span class="line"><span class="string">3  9.0  10.0  0.0  11.0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">     A    B    C    D</span></span><br><span class="line"><span class="string">0  0.0  1.0  0.0  0.0</span></span><br><span class="line"><span class="string">1  9.0  16.0  0.0  0.0</span></span><br><span class="line"><span class="string">2  36.0  49.0  0.0  0.0</span></span><br><span class="line"><span class="string">3  0.0   0.0  0.0  0.0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p><br/></p><hr><h4 id="数据排序"><a href="#数据排序" class="headerlink" title="数据排序"></a>数据排序</h4><p><code>sort_index(ascending,axis)</code>方法：按照<strong>索引</strong>（行或列）的顺序进行排序</p><ul><li><code>ascending</code>：默认是升序排列<code>True</code>，如果是降序排列，可改成<code>asceding=False</code></li><li><code>axis</code>：默认是按行索引排序，如果要改成列索引，可改成<code>axis=1</code>，被</li></ul><p><br/></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 创建一个DataFrame对象</span></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;name&#x27;</span>: [<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Charlie&#x27;</span>, <span class="string">&#x27;David&#x27;</span>, <span class="string">&#x27;Eve&#x27;</span>],</span><br><span class="line">                   <span class="string">&#x27;age&#x27;</span>: [<span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>],</span><br><span class="line">                   <span class="string">&#x27;gender&#x27;</span>: [<span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;F&#x27;</span>],</span><br><span class="line">                   <span class="string">&#x27;score&#x27;</span>: [<span class="number">90</span>, <span class="number">80</span>, <span class="number">70</span>, <span class="number">60</span>, <span class="number">50</span>]&#125;)</span><br><span class="line">df</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">      name  age gender  score</span></span><br><span class="line"><span class="string">0    Alice   25      F     90</span></span><br><span class="line"><span class="string">1      Bob   30      M     80</span></span><br><span class="line"><span class="string">2  Charlie   35      M     70</span></span><br><span class="line"><span class="string">3    David   40      M     60</span></span><br><span class="line"><span class="string">4      Eve   45      F     50</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">df.sort_index(axis=<span class="number">1</span>, ascending=<span class="literal">False</span>) </span><br><span class="line"><span class="comment"># 按照列索引降序排序，即按字母表顺序降序</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">   score     name gender  age</span></span><br><span class="line"><span class="string">0     90    Alice      F   25</span></span><br><span class="line"><span class="string">1     80      Bob      M   30</span></span><br><span class="line"><span class="string">2     70  Charlie      M   35</span></span><br><span class="line"><span class="string">3     60    David      M   40</span></span><br><span class="line"><span class="string">4     50      Eve      F   45</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p><br/></p><p><code>sort_values(by=name,ascending)</code>，根据<code>values</code>的值进行排序，默认是升序排列</p><ul><li><code>by</code>：后面添加要排序的行列的名称</li><li><code>ascending</code>：选择是升序还是降序</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">df.sort_values(by=<span class="string">&#x27;name&#x27;</span>, ascending=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 按照name列降序排序</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">nameagegenderscore</span></span><br><span class="line"><span class="string">4Eve 45F50</span></span><br><span class="line"><span class="string">3David40M60</span></span><br><span class="line"><span class="string">2Charlie35M70</span></span><br><span class="line"><span class="string">1Bob    30M80</span></span><br><span class="line"><span class="string">0Alice25F90</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p><br/></p><hr><h3 id="CSV文件"><a href="#CSV文件" class="headerlink" title="CSV文件"></a>CSV文件</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>CSV文件是一种存储和表示表格数据的纯文本文件，它的全称是逗号分隔值（Comma-Separated Values）</p><p>CSV文件的特点是每行代表一条记录，每个数据用逗号分隔，如果数据中含有逗号，就用引号包围。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231030044615325.png" alt="image-20231030044615325"></p><p><br/></p><hr><h4 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h4><p><code>to_csv</code>是<code>pandas</code>库中的一个方法，它可以将一个<code>DataFrame</code>或<code>Series</code>对象写入到一个<code>csv</code>文件中，或者返回一个<code>csv</code>格式的字符串</p><p><code>pd.to_csv(path,sep,na_rep,columns,header,index,index_label)</code>：</p><ul><li><code>path</code>：这个参数指定了写入的目标，可以是一个文件路径，一个文件对象，或者None</li><li><code>sep</code>：这个参数指定了字段之间的分隔符，默认是逗号（,）</li><li><code>na_rep</code>：这个参数指定了缺失值的表示方式，默认是空字符串（‘’）。可以根据需要修改为其他字符串，例如’NA’或’NULL’</li><li><code>columns</code>：这个参数指定了要写入的列，可以是一个列名的列表。如果不指定，那么会写入所有的列</li><li><code>header</code>：这个参数指定了是否写入列名，可以是一个布尔值或者一个字符串的列表。如果是True，那么会写入默认的列名。如果是False，那么不会写入列名</li><li><code>index</code>：这个参数指定了是否写入行索引，可以是一个布尔值。如果是True，那么会写入行索引。如果是False，那么不会写入行索引</li><li><code>index_label</code>：这个参数指定了行索引的列名，可以是一个字符串或者一个字符串的列表。如果是None，那么会使用默认的行索引名。如果是False，那么不会写入行索引名</li></ul><p><br/></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;name&#x27;</span>: [<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Charlie&#x27;</span>], <span class="string">&#x27;age&#x27;</span>: [<span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>], <span class="string">&#x27;gender&#x27;</span>: [<span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;M&#x27;</span>]&#125;)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    nameagegender</span></span><br><span class="line"><span class="string">0Alice25F</span></span><br><span class="line"><span class="string">1Bob    30M</span></span><br><span class="line"><span class="string">2Charlie35M</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">df.to_csv(<span class="string">&#x27;example.csv&#x27;</span>, sep=<span class="string">&#x27;,&#x27;</span>, na_rep=<span class="string">&#x27;NA&#x27;</span>, index=<span class="literal">False</span>, header=<span class="literal">True</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>表示：将这个<code>DataFrame</code>对象写入到一个<code>csv</code>文件中，文件名是<code>example.csv</code>，分隔符是逗号（,），缺失值表示为’<code>NA</code>’，不写入行索引，但写入列名</p><p><br/></p><p>最后会得到内容如下表的<code>example.csv</code>文件</p><div class="table-container"><table><thead><tr><th>name</th><th>age</th><th>gender</th></tr></thead><tbody><tr><td>Alice</td><td>25</td><td>F</td></tr><tr><td>Bob</td><td>30</td><td>M</td></tr><tr><td>Charlie</td><td>35</td><td>M</td></tr></tbody></table></div><p><br/></p><hr><h4 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h4><p><code>read_csv</code>是<code>Pandas</code>库中的一个函数，它可以从一个文件或网址中读取逗号分隔值（csv）格式的数据，返回一个<code>DataFrame</code>对象</p><p><code>pd.read_csv(path,sep,header,names,index_col,usecol,dtype)</code></p><ul><li><code>path</code>：文件或网址的位置，可以是任何有效的字符串路径或URL</li><li><code>sep</code>：分隔符，用来指定数据中的每个值之间的字符或正则表达式，默认为逗号，如果<code>`sep=None</code>，会从第一行有效的数据中推断出分隔符</li><li><code>header</code>：列号或列号的序列，用来指定包含列名的行和数据的开始位置，从0开始计数，默认把第一行看做列名</li><li><code>names</code>：列名的列表或字典，用来自定义列名，如果传入了<code>names</code>，那么<code>header=None</code>，不使用文件中的任何行作为列名，如果传入了字典，那么键是列的索引，值是列的名称</li><li><code>index_col</code>：行号或行号的序列，用来指定作为行索引的列，从0开始计数，如果为<code>None</code>，那么没有行索引，只有默认的数字索引</li><li><code>usecols</code>：列号或列名的列表，用来指定要读取的列，从0开始计数，可以传入一个函数来过滤列</li><li><code>dtype</code>：数据类型，用来指定每列数据的类型，可以是一个类型</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df = pd.read_csv(<span class="string">&#x27;example.csv&#x27;</span>, sep=<span class="string">&#x27;,&#x27;</span>, header=<span class="literal">None</span>,name=[<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;y&#x27;</span>], index_col=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>表示：将这个<code>csv</code>文件读取为一个<code>DataFrame</code>对象，文件名是<code>data.csv</code>，分隔符是逗号，不将第一行看做是列名，自定义列名为<code>x</code>和<code>y</code>，不使用任何列作为行索引</p><p><br/></p><hr><h4 id="统计分析"><a href="#统计分析" class="headerlink" title="统计分析"></a>统计分析</h4><p><code>Pandas</code>数据类型可以直接使用<code>NumPy</code>中的统计函数</p><p><code>Pandas</code>自带了<code>describe</code>()函数，可以很方便的展示信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个NumPy数组</span></span><br><span class="line">arr = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将NumPy数组转换为Pandas的DataFrame对象</span></span><br><span class="line">df = pd.DataFrame(arr,columns=[<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>],index=[<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ABC</span></span><br><span class="line"><span class="string">A123</span></span><br><span class="line"><span class="string">B456</span></span><br><span class="line"><span class="string">C789</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 调用describe函数，返回一个新的DataFrame对象，显示统计结果</span></span><br><span class="line">df.describe()</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line">        ABC</span><br><span class="line">count<span class="number">3.0</span><span class="number">3.0</span><span class="number">3.0</span></span><br><span class="line">mean<span class="number">4.0</span><span class="number">5.0</span><span class="number">6.0</span></span><br><span class="line">std    <span class="number">3.0</span><span class="number">3.0</span><span class="number">3.0</span></span><br><span class="line"><span class="built_in">min</span>    <span class="number">1.0</span><span class="number">2.0</span><span class="number">3.0</span></span><br><span class="line"><span class="number">25</span>%    <span class="number">2.5</span><span class="number">3.5</span><span class="number">4.5</span></span><br><span class="line"><span class="number">50</span>%  <span class="number">4.0</span><span class="number">5.0</span><span class="number">6.0</span></span><br><span class="line"><span class="number">75</span>%    <span class="number">5.5</span><span class="number">6.5</span><span class="number">7.5</span></span><br></pre></td></tr></table></figure><ul><li><code>count</code>: 非空值的数量，即有效的观测值的个数。</li><li><code>mean</code>: 所有数值的平均值，即算术平均值。</li><li><code>std</code>: 所有数值的标准差，即数据的离散程度。</li><li><code>min</code>: 最小值，即数据的最低点。</li><li><code>25%</code>: 第一四分位数，即数据的下四分位数，表示25%的数据低于或等于这个值。</li><li><code>50%</code>: 第二四分位数，即数据的中位数，表示50%的数据低于或等于这个值。</li><li><code>75%</code>: 第三四分位数，即数据的上四分位数，表示75%的数据低于或等于这个值。</li><li><code>max</code>: 最大值，即数据的最高点。</li></ul><p><br/></p><p><strong>相关性分析</strong></p><div class="table-container"><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>.cov()</td><td>计算协方差矩阵</td></tr><tr><td>.corr(method，min_periods)</td><td>计算相关系数矩阵</td></tr></tbody></table></div><p><code>method</code>：相关性计算方法，可选值为’<code>pearson</code>’（默认）、‘<code>kendall</code>’和’<code>spearman</code>’。</p><ul><li><p><code>pearson</code>：表示使用皮尔逊相关系数衡量相关性，该系数是最常用的相关性度量，适用于线性相关的情况；</p></li><li><p><code>kendall</code>：使用肯德尔相关系数衡量相关性，适合非线性但单调递增或递减的相关关系；</p></li><li><p><code>spearman</code>：使用斯皮尔曼相关系数衡量相关性，也适用于非线性但单调递增或递减的相关关系。</p></li></ul><p><code>min_periods</code>：计算相关系数所需的最小观测值数，即样本量，缺失值不计入样本量。</p><hr><h4 id="Plot绘图"><a href="#Plot绘图" class="headerlink" title="Plot绘图"></a>Plot绘图</h4><p><code>Pandas</code>的<code>plot</code>函数是一个用来绘制<code>DataFrame</code>或<code>Series</code>对象中的数据的方法，它可以根据不同的参数选择绘制的图形类型，如折线图、柱状图、饼图、散点图等，它也可以根据数据的索引和列名自动添加图例和标签，方便数据的可视化和分析。</p><p>可以说：<code>Pandas</code>中的<code>plot</code>函数是基于<code>matplotlib</code>库的一个封装</p><p><code>DataFrame.plot(x=None, y=None, kind=‘line’, ax=None, layout=None, figsize=None,label=None, color=None,title=None, grid=None, legend=True)</code></p><ul><li><code>x</code>和<code>y</code>：表示标签或者位置的<strong>名称</strong>(必须），用来指定显示的索引，默认为<code>None</code></li><li><code>kind</code>：表示绘图的类型，默认为<code>line</code>，折线图，还可以选择其他类型，如柱状图<code>bar</code>，直方图<code>hist</code>，饼状图<code>pie</code>，<strong>散点图</strong><code>scatter</code>等</li><li><code>ax</code>：表示<code>matplotlib</code>的子图对象，用来在同一个画布上绘制多个图形，默认为<code>None</code></li><li><code>layout</code>：表示子图的行列布局，(<code>rows</code>, <code>columns</code>)的形式，默认为<code>None</code></li><li><code>figsize</code>：表示图形的尺寸大小，(<code>width</code>, <code>height</code>)的形式，默认为<code>None</code></li><li><code>label</code>：这个参数的值将作为图例中的标签</li><li><code>color</code>：这个参数的值将决定图表的颜色</li><li><code>title</code>：表示图形的标题，字符串类型，默认为<code>None</code></li><li><code>grid</code>：表示是否显示网格线，默认为<code>None</code></li><li><code>legend</code>：表示是否显示图例，默认为<code>True</code></li></ul><p><br/></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x1 = <span class="number">10</span>*np.random.randn(<span class="number">50</span>)</span><br><span class="line">y1 = <span class="number">10</span>*np.random.randn(<span class="number">50</span>)</span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;x1&#x27;</span>: x1, <span class="string">&#x27;y1&#x27;</span>: y1&#125;) </span><br><span class="line">df.plot(kind=<span class="string">&#x27;scatter&#x27;</span>, x=<span class="string">&#x27;x1&#x27;</span>, y=<span class="string">&#x27;y1&#x27;</span>,title=<span class="string">&#x27;graph&#x27;</span>,label=<span class="string">&#x27;Group 1&#x27;</span>,grid=<span class="literal">True</span>,legend=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>这段代码的意思是在df中创建一个散点图，其中<code>x1</code>是x轴，<code>y1</code>是y轴，标题是<code>&#39;graph&#39;</code>，图例的标签是<code>&#39;Group 1&#39;</code>，并且显示网格和图例。这个图将显示<code>df</code>中<code>x1</code>和<code>y1</code>列的数据分布</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231105082024530.png" alt="image-20231105082024530"></p><p><code>Pandas</code>和<code>matplotlib</code>中的<code>plot</code>函数比较</p><div class="table-container"><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">matplotlib</th><th>Pandas</th></tr></thead><tbody><tr><td style="text-align:left"><strong>数据输入</strong></td><td style="text-align:left">可以接受各种格式的数据，包括列表、numpy数组、pandas对象等</td><td><strong>必须</strong>是DataFrame或Series对象中的数据</td></tr><tr><td style="text-align:left"><strong>灵活性</strong></td><td style="text-align:left">提供了更多的<strong>灵活性</strong>，可以让你更加精细地控制图形的各个方面</td><td>灵活性较低，但对于基本的图形创建非常<strong>方便</strong></td></tr><tr><td style="text-align:left"><strong>代码复杂性</strong></td><td style="text-align:left">代码可能会比较复杂，特别是对于复杂的图形</td><td>代码通常更<strong>简洁</strong>，特别是当数据已经存储在DataFrame中时</td></tr><tr><td style="text-align:left"><strong>适用情况</strong></td><td style="text-align:left">当你需要对数据进行<strong>复杂的操作或者转换</strong>，或者需要精细地控制图形的各个方面时，matplotlib可能会更加方便</td><td>当你的数据已经存储在DataFrame中，且你需要创建基本的图形时，Pandas的plot函数可能会更加方便</td></tr></tbody></table></div><p><br/></p><hr><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>比如现在有一个名叫<code>ex1data1.txt</code>的文件，里面有两列数据，要求绘制散点图</p><p>操作如下：</p><ul><li>导入<code>NumPy</code>和<code>Pandas</code>库</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure><ul><li>利用<code>pd.read_csv()</code>函数读取文件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df=pd.read_csv(<span class="string">&#x27;ex1data1.txt&#x27;</span>,header=<span class="literal">None</span>,names=[<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>])</span><br><span class="line"><span class="comment">#读入ex1data1的数据，将x和y作为第1列和第2列的名称</span></span><br></pre></td></tr></table></figure><ul><li>利用<code>df.plot()</code>函数绘制散点图</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.plot(x=<span class="string">&#x27;x&#x27;</span>,y=<span class="string">&#x27;y,kind=&#x27;</span>scatte<span class="string">r&#x27;)</span></span><br><span class="line"><span class="string">#x轴的数据为x列，y轴的数据为y列，类型是散点图，其余参数默认</span></span><br></pre></td></tr></table></figure><p>这样就可以生成散点图</p><p><br/></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.整数反转</title>
      <link href="/post/32892.html"/>
      <url>/post/32892.html</url>
      
        <content type="html"><![CDATA[<h1 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7.整数反转"></a>7.整数反转</h1><p>给你一个 32 位的有符号整数 <code>x</code> ，返回将 <code>x</code> 中的数字部分反转后的结果。</p><p>如果反转后整数超过 32 位的有符号整数的范围 <code>[−231, 231 − 1]</code> ，就返回 0。</p><p><strong>假设环境不允许存储 64 位整数（有符号或无符号）。</strong></p><p><strong>示例 1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = <span class="number">123</span></span><br><span class="line">输出：<span class="number">321</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rev &lt; Integer.MIN_VALUE / <span class="number">10</span> || rev &gt; Integer.MAX_VALUE / <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> digit = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            rev = rev * <span class="number">10</span> + digit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>50.Pow(x,n)</title>
      <link href="/post/65279.html"/>
      <url>/post/65279.html</url>
      
        <content type="html"><![CDATA[<h1 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50.Pow(x,n)"></a>50.Pow(x,n)</h1><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数，即，x^n^ </p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = <span class="number">2.00000</span>, n = <span class="number">10</span></span><br><span class="line">输出： <span class="number">1024.00000</span></span><br></pre></td></tr></table></figure><p><strong>Solution</strong>：递归</p><p>​                                                  x^77^=<em>x</em>→<em>x</em>^2^→<em>x</em>^4^→<em>x</em>^9^→<em>x</em>^19^→<em>x</em>^38^→<em>x</em>^77^</p><p>如果要计算一个数的N次幂，可以将其N/2，结果需要向下取整，如果N为奇数，就需要再乘一个x</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? quickMul(x, N) : <span class="number">1.0</span> / quickMul(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> y = quickMul(x, N / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> N % <span class="number">2</span> == <span class="number">0</span> ? y * y : y * y * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Solution1</strong>：迭代</p><p>由于递归需要使用额外的栈空间，我们试着将递归转写为迭代。在方法一中，我们也提到过，从左到右进行推导是不容易的，因为我们不知道是否需要额外乘 <em>x</em>。但我们不妨找一找规律，看看哪些地方额外乘了 <em>x</em>，并且它们对答案产生了什么影响。</p><p>​                                  x^77^=<em>x</em>→<em>x</em>^2^→<em>x</em>^4^→<em>x</em>^9^→<em>x</em>^19^→<em>x</em>^38^→<em>x</em>^77^</p><p>77的二进制表示是      77=1   0     0     1     1      0      1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> <span class="keyword">long</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1.0</span>;</span><br><span class="line">        <span class="comment">// 贡献的初始值为 x</span></span><br><span class="line">        <span class="keyword">double</span> x_contribute = x;</span><br><span class="line">        <span class="comment">// 在对 N 进行二进制拆分的同时计算答案</span></span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果 N 二进制表示的最低位为 1，那么需要计入贡献</span></span><br><span class="line">                ans *= x_contribute;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将贡献不断地平方</span></span><br><span class="line">            x_contribute *= x_contribute;</span><br><span class="line">            <span class="comment">// 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可</span></span><br><span class="line">            N /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? quickMul(x, N) : <span class="number">1.0</span> / quickMul(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>372.超级次方</title>
      <link href="/post/19997.html"/>
      <url>/post/19997.html</url>
      
        <content type="html"><![CDATA[<h1 id="372-超级次方"><a href="#372-超级次方" class="headerlink" title="372.超级次方"></a>372.超级次方</h1><p>你的任务是计算 a^b^<code>对</code>1337<code>取模，</code>a<code>是一个正整数，</code>b` 是一个非常大的正整数且会以数组形式给出。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：a = <span class="number">2</span>, b = [<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">8</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：a = <span class="number">1</span>, b = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>首先需要知道模运算满足交换律，再配合<code>50.Pow(x,n)</code>里面的快速降幂</p><p>   (<em>a</em>⋅<em>b</em>)mod<em>m</em>=[(<em>a</em>·mod<em>m</em>)⋅(<em>b</em>·mod<em>m</em>)]·mod<em>m</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOD = <span class="number">1337</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superPow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = b.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            ans = (<span class="keyword">int</span>) ((<span class="keyword">long</span>) ans * pow(a, b[i]) % MOD);</span><br><span class="line">            a = pow(a, <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                res = (<span class="keyword">int</span>) ((<span class="keyword">long</span>) res * x % MOD);</span><br><span class="line">            &#125;</span><br><span class="line">            x = (<span class="keyword">int</span>) ((<span class="keyword">long</span>) x * x % MOD);</span><br><span class="line">            n /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode链表相关</title>
      <link href="/post/7321.html"/>
      <url>/post/7321.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h3><div class="table-container"><table><thead><tr><th>题目</th><th>难度</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists">21. 合并两个有序链表</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list">83. 删除排序链表中的重复元素</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/linked-list-cycle">141. 环形链表</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists">160. 相交链表</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/remove-linked-list-elements">203. 移除链表元素</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/reverse-linked-list">206. 反转链表</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/palindrome-linked-list">234. 回文链表</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list">237. 删除链表中的节点</a></td><td>简单</td></tr></tbody></table></div><hr><h3 id="技巧与分析"><a href="#技巧与分析" class="headerlink" title="技巧与分析"></a>技巧与分析</h3><p>对于链表，双指针可以说是基础中的基础了，因为链表本身就是由指针所链接的</p><p>而合并两个有序链表(注意备份)，删除链表中的元素(<code>p-&gt;next=p-&gt;next-&gt;next</code>)，是非常基本操作</p><p>环形链表中的快慢指针判断成环的方法让人眼前一亮</p><p>相交链表中的双指针遍历双链表有点意想不到</p><p>反转链表中的备份也十分关键</p><p>而<a href="https://leetcode-cn.com/problems/palindrome-linked-list">234. 回文链表</a>可以说是链表题目中的精髓，先用快慢指针确定中间节点，然后反转链表再比较，一气呵成</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Leetcode总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode栈与队列总结</title>
      <link href="/post/18347.html"/>
      <url>/post/18347.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h3><div class="table-container"><table><thead><tr><th>题目</th><th>难度</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/valid-parentheses">20. 有效的括号</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/min-stack">155. 最小栈</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/implement-stack-using-queues">225. 用队列实现栈</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks">232. 用栈实现队列</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/next-greater-element-i">496. 下一个更大元素 I</a></td><td>简单</td></tr></tbody></table></div><hr><h3 id="技巧与分析"><a href="#技巧与分析" class="headerlink" title="技巧与分析"></a>技巧与分析</h3><p>栈和队列相对来说应用较少，栈一般用来解决成对元素消去的问题</p><p>栈还有一种用途就是单调栈，可以实现下一个更大元素的查找</p><p>逆序遍历数组，并入栈，根据规则出栈并赋值到另一个数组中，即可完成查找</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Leetcode总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode数组相关</title>
      <link href="/post/38638.html"/>
      <url>/post/38638.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h3><div class="table-container"><table><thead><tr><th>题目</th><th>难度</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/two-sum">1. 两数之和</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array">26. 删除有序数组中的重复项</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/remove-element">27. 移除元素</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/search-insert-position">35. 搜索插入位置</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/merge-sorted-array">88. 合并两个有序数组</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/pascals-triangle">118. 杨辉三角</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/pascals-triangle-ii">119. 杨辉三角 II</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted">167. 两数之和 II - 输入有序数组</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/majority-element">169. 多数元素</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/contains-duplicate">217. 存在重复元素</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/contains-duplicate-ii">219. 存在重复元素 II</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/summary-ranges">228. 汇总区间</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/missing-number">268. 丢失的数字</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/first-bad-version">278. 第一个错误的版本</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/move-zeroes">283. 移动零</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/range-sum-query-immutable">303. 区域和检索 - 数组不可变</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays">349. 两个数组的交集</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii">350. 两个数组的交集 II</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/third-maximum-number">414. 第三大的数</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array">448. 找到所有数组中消失的数字</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements">453. 最小操作次数使数组元素相等</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/assign-cookies">455. 分发饼干</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/island-perimeter">463. 岛屿的周长</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/teemo-attacking">495. 提莫攻击</a></td><td>简单</td></tr></tbody></table></div><hr><h3 id="技巧与分析"><a href="#技巧与分析" class="headerlink" title="技巧与分析"></a>技巧与分析</h3><p>若是单纯对数组的线性操作，利用List或者Map等数据结构和它们的各种方法，能够实现空间换时间(1,217,219,349)</p><p>但是题目往往没有那么简单，对于数组中各个元素的对比，移动，交换能操作，一般都会用到<strong>双指针</strong>，有时候会将数组先排序后再利用双指针。</p><p>双指针在数组中的应用非常普遍，比如</p><ul><li>对比或交换数组元素的位置(26,27,88,283,453,495)</li><li>缩小范围，直至确定位置(167)</li></ul><p>有些问题可以直接用排序或者是二分查找解决，属于是简单题中的简单题了(35,169,268,278)</p><hr><p>重点思想：</p><p><a href="https://leetcode-cn.com/problems/summary-ranges">228. 汇总区间</a>中的双指针技巧有效的避免的复杂的边界讨论，设置<code>i</code>，然后用<code>low=i</code>，<code>high=i-1</code>来设置，这种思想在<a href="https://leetcode-cn.com/problems/teemo-attacking">495. 提莫攻击</a>中再一次被应用，在寻找一个区间时，尤其好用</p><p><a href="https://leetcode-cn.com/problems/range-sum-query-immutable">303. 区域和检索 - 数组不可变</a>中的确定数组中任意两个元素的差值，所涉及的<strong>前缀和</strong>思想，可以说是非常巧妙</p><p><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii">350. 两个数组的交集 II</a>中的记录数字出现次数，和字符串出现次数可以说是一模一样了</p><p><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array">448. 找到所有数组中消失的数字</a>中的思想，非常重要，可以说是空间换时间的典范，直接用本身的数组就可以起到记录信息的作用</p><p><a href="https://leetcode-cn.com/problems/island-perimeter">463. 岛屿的周长</a>中是第一次遍历矩阵的问题，注意单向遍历，注意不要增加多的空间</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Leetcode总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode字符串相关</title>
      <link href="/post/46225.html"/>
      <url>/post/46225.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h3><div class="table-container"><table><thead><tr><th>题目</th><th>难度</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/roman-to-integer">13. 罗马数字转整数</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/longest-common-prefix">14. 最长公共前缀</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/implement-strstr">28. 实现 strStr()</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/length-of-last-word">58. 最后一个单词的长度</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/valid-palindrome">125. 验证回文串</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/isomorphic-strings">205. 同构字符串</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/valid-anagram">242. 有效的字母异位词</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/word-pattern">290. 单词规律</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/reverse-string">344. 反转字符串</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string">345. 反转字符串中的元音字母</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/ransom-note">383. 赎金信</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string">387. 字符串中的第一个唯一字符</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-the-difference">389. 找不同</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/is-subsequence">392. 判断子序列</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/longest-palindrome">409. 最长回文串</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/fizz-buzz">412. Fizz Buzz</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/number-of-segments-in-a-string">434. 字符串中的单词数</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/repeated-substring-pattern">459. 重复的子字符串</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/license-key-formatting">482. 密钥格式化</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/keyboard-row">500. 键盘行</a></td><td>简单</td></tr></tbody></table></div><hr><h3 id="技巧与分析"><a href="#技巧与分析" class="headerlink" title="技巧与分析"></a>技巧与分析</h3><p>在字符串的题目中，最经典也反复被使用的就是利用<code>HashMap</code>来统计字符串中单词的出现次数，当然，如果统计的是小写字母，也可以创建一个大小为26的数组，利用<code>cnt[c-&#39;a&#39;]</code>来储存字符的出现次数</p><p>经典的题有：<code>242,383,387,409</code></p><p>当涉及到字符串的遍历的时候，一般可以使用字符串的<code>charAt</code>或者<code>toCharArray</code>函数，但有些时候，字符串会以空格分开，这个时候，使用<code>split(&quot; &quot;)</code>函数会有奇效,比如在<code>434</code>中</p><p>哈希表在字符串操作中的用法不止是记录出现次数，在映射关系的题中，哈希表一再出现简化运算，比如在<code>13,205,290</code>中</p><p>而涉及到具体字符的操作，就和数组中一样，使用双指针更加方便，比如在<code>344,345,392</code>中</p><p>而字符串匹配的相关问题，KMP算法一定要掌握，比如在<code>28,459</code>中</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Leetcode总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode动态规划</title>
      <link href="/post/11404.html"/>
      <url>/post/11404.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h3><div class="table-container"><table><thead><tr><th>题目</th><th>难度</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子数组和</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/climbing-stairs/">70. 爬楼梯</a></td><td>简答</td></tr><tr><td><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/max-consecutive-ones">485. 最大连续 1 的个数</a></td><td>简单</td></tr></tbody></table></div><hr><h3 id="技巧与分析"><a href="#技巧与分析" class="headerlink" title="技巧与分析"></a>技巧与分析</h3><p>动态规划的核心思想就是这个回合的行动取决于之前的结果，所以在代码中常会存储临时变量来进行比较，比如在<code>53</code>中的<code>pre=Math.max(pre,x)</code>这种代码，关键在于看出动态规划的形式</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Leetcode总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode位运算与数学</title>
      <link href="/post/50122.html"/>
      <url>/post/50122.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h3><div class="table-container"><table><thead><tr><th>题目</th><th>难度</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/reverse-integer">7. 整数反转</a></td><td>中等</td></tr><tr><td><a href="https://leetcode-cn.com/problems/palindrome-number">9. 回文数</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/powx-n">50. Pow(x, n)</a></td><td>中等</td></tr><tr><td><a href="https://leetcode-cn.com/problems/plus-one">66. 加一</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/add-binary">67. 二进制求和</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/sqrtx">69. Sqrt(x)</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/single-number">136. 只出现一次的数字</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/excel-sheet-column-title">168. Excel表列名称</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/excel-sheet-column-number">171. Excel 表列序号</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/reverse-bits">190. 颠倒二进制位</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/number-of-1-bits">191. 位1的个数</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/happy-number">202. 快乐数</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/power-of-two">231. 2 的幂</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/add-digits">258. 各位相加</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/ugly-number">263. 丑数</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/nim-game">292. Nim 游戏</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/power-of-three">326. 3 的幂</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/counting-bits">338. 比特位计数</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/power-of-four">342. 4的幂</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/valid-perfect-square">367. 有效的完全平方数</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/super-pow">372. 超级次方</a></td><td>中等</td></tr><tr><td><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower">374. 猜数字大小</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/binary-watch">401. 二进制手表</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal">405. 数字转换为十六进制数</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/add-strings">415. 字符串相加</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/arranging-coins">441. 排列硬币</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/hamming-distance">461. 汉明距离</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/number-complement">476. 数字的补数</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/construct-the-rectangle">492. 构造矩形</a></td><td>简单</td></tr></tbody></table></div><hr><h3 id="技巧与分析："><a href="#技巧与分析：" class="headerlink" title="技巧与分析："></a>技巧与分析：</h3><p>关于数学相关的题，一般涉及到<strong>进制转换</strong>，以及<strong>位数颠倒</strong>之类的技巧</p><p>在<code>7.整数反转</code>中就是经典的颠倒顺序，是基本操作需要掌握</p><hr><p>而对于数字的基本运算，需要利用到模拟的思想，用程序<strong>模仿</strong>手算</p><p>比如：</p><ul><li><p><code>66.加1</code>中的运算，就和手算一样，有进位上一位就+1，没有就直接输出</p></li><li><p><code>67.二进制求和</code>中，模拟进位，从低位到高位，也是这一思想的体现，相同的思路在<code>415 字符串相加</code>中再次体现</p></li><li><p><code>168,171</code>中，实际上是模拟26进制与10进制之间的转换</p></li></ul><hr><p>而在<code>202 快乐数</code>中，数字会进入循环，而快慢指针判断成环的方法，从链表应用到数学，非常巧妙</p><p>有些题是无聊的二分查找，比如<code>69,367,374,441,492</code></p><p>还有些题是脑筋急转弯，比如<code>258,292</code></p><hr><p>对于位运算，涉及到的是对具体位的修改与统计，还有异或操作的妙用</p><p>在<code>136 只出现一次的数字</code>中，<strong>异或</strong>操作第一次出现</p><p>在<code>190 颠倒二进制位</code>中n保留最后一位，又逐位反转的方法很有效</p><p>对于<code>n&amp;n-1</code>能让n的最低位1反转这一技巧，被反复用到</p><p>比如在<code>191,231,338,342,461</code>中都有用到</p><p>而构造掩码也是一个技巧，在<code>342.4的幂</code>和<code>476.数字的补数</code>中就是通过巧妙的构造了掩码来简化运算</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Leetcode总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode二叉树</title>
      <link href="/post/45354.html"/>
      <url>/post/45354.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h3><div class="table-container"><table><thead><tr><th>题目</th><th>难度</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal">94. 二叉树的中序遍历</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/same-tree">100. 相同的树</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/symmetric-tree">101. 对称二叉树</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree">104. 二叉树的最大深度</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree">108. 将有序数组转换为二叉搜索树</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/balanced-binary-tree">110. 平衡二叉树</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree">111. 二叉树的最小深度</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/path-sum">112. 路径总和</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal">144. 二叉树的前序遍历</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal">145. 二叉树的后序遍历</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/invert-binary-tree">226. 翻转二叉树</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree">235. 二叉搜索树的最近公共祖先</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/binary-tree-paths">257. 二叉树的所有路径</a></td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/sum-of-left-leaves">404. 左叶子之和</a></td><td>简单</td></tr></tbody></table></div><hr><h3 id="分析与总结"><a href="#分析与总结" class="headerlink" title="分析与总结"></a>分析与总结</h3><p>二叉树的操作，三种递归遍历以及非递归遍历是基本常识</p><p>涉及到二叉树的操作，一般都和递归有关，需要根据题目要求涉设计递归函数，难度有点高</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Leetcode总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.0.机器学习系统的设计</title>
      <link href="/post/45376.html"/>
      <url>/post/45376.html</url>
      
        <content type="html"><![CDATA[<h1 id="机器学习系统的设计"><a href="#机器学习系统的设计" class="headerlink" title="机器学习系统的设计"></a>机器学习系统的设计</h1><h2 id="误差分析"><a href="#误差分析" class="headerlink" title="误差分析"></a>误差分析</h2><p>构建一个学习算法的推荐方法为：</p><ol><li>从一个简单的能快速实现的算法开始，实现该算法并用交叉验证集数据测试这个算法</li><li>绘制学习曲线，决定是增加更多数据，或者添加更多特征，还是其他选择</li><li>进行误差分析：人工检查交叉验证集中我们算法中产生预测误差的样本，看看这些样本是否有某种系统化的趋势</li></ol><p>以我们的垃圾邮件过滤器为例，误差分析要做的既是检验交叉验证集中我们的算法产生错误预测的所有邮件，看：是否能将这些邮件按照类分组。例如医药品垃圾邮件，仿冒品垃圾邮件或者密码窃取邮件等。然后看分类器对哪一组邮件的预测误差最大，并着手优化。<br>    <br/><br>思考怎样能改进分类器。例如，发现是否缺少某些特征，记下这些特征出现的次数。<br>例如记录下错误拼写出现了多少次，异常的邮件路由情况出现了多少次等等，然后从出现次数最多的情况开始着手优化。<br><br/><br>误差分析并不总能帮助我们判断应该采取怎样的行动。有时我们需要尝试不同的模型，然后进行比较，在模型比较时，用数值来判断哪一个模型更好更有效，通常我们是看交叉验证集的误差。</p><hr><h2 id="类偏斜的误差度量"><a href="#类偏斜的误差度量" class="headerlink" title="类偏斜的误差度量"></a>类偏斜的误差度量</h2><p>类偏斜情况表现为我们的训练集中有非常多的同一种类的样本，只有很少或没有其他类的样本。</p><p>例如我们希望用算法来预测癌症是否是恶性的，在我们的训练集中，只有0.5%的实例是恶性肿瘤。假设我们编写一个非学习而来的算法，在所有情况下都预测肿瘤是良性的，那么误差只有0.5%。然而我们通过训练而得到的神经网络算法却有1%的误差。这时，误差的大小是不能视为评判算法效果的依据的。</p><p>对此，提出来了两个概念：<strong>查准率</strong>(Precision)和<strong>查全率</strong>(Recall)</p><p>我们将算法预测的结果分成四种情况：</p><ol><li><strong>阳性</strong>（<strong>True Positive,TP</strong>）：预测为真，实际为真</li><li><strong>阴性</strong>（<strong>True Negative,TN</strong>）：预测为假，实际为假</li><li><strong>假阳性</strong>（<strong>False Positive,FP</strong>）：预测为真，实际为假</li><li><strong>假阴性</strong>（<strong>False Negative,FN</strong>）：预测为假，实际为真</li></ol><p>$查准率=\frac{TP}{TP+FP}$，即在所有我们预测有恶性肿瘤的病人中，实际上有恶性肿瘤的病人的百分比，越高越好。</p><p>$查全率=\frac{TP}{TP+FN}$，即在所有实际上有恶性肿瘤的病人中，成功预测有恶性肿瘤的病人的百分比，越高越好。</p><p><br/></p><p>这样，对于我们刚才那个总是预测病人肿瘤为良性的算法，其查全率是0，显然是不好的算法</p><p><br/></p><hr><h2 id="权衡度量"><a href="#权衡度量" class="headerlink" title="权衡度量"></a>权衡度量</h2><p>一般来说，我们在设计算法的时候，查准率和查全率越高越好，然而，在大多数情况下，二者不可得兼</p><p>在肿瘤预测问题中，如果我们希望只在非常确信的情况下预测为真（肿瘤为恶性），即我们希望更高的查准率，我们可以使用比0.5更大的阀值，如0.7，0.9。这样做我们会减少错误预测病人为恶性肿瘤的情况，同时却会增加未能成功预测肿瘤为恶性的情况。</p><p>如果我们希望提高查全率，尽可能地让所有有可能是恶性肿瘤的病人都得到进一步地检查、诊断，我们可以使用比0.5更小的阀值，如0.3。</p><p>我们可以将不同阀值情况下，查全率与查准率的关系绘制成图表，曲线的形状根据数据的不同而不同：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231122032146348.png" alt="image-20231122032146348"></p><p>希望有一个帮助我们选择这个阀值的方法。一种方法是计算<strong>F1 值</strong>（<strong>F1 Score</strong>），其计算公式为：</p><script type="math/tex; mode=display">{F_{1}}Score:2\frac{PR}{P+R}</script><p>我们选择使得<strong>F1</strong>值最高的阀值。</p><p><br/></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python入门</title>
      <link href="/post/21062.html"/>
      <url>/post/21062.html</url>
      
        <content type="html"><![CDATA[<h1 id="Python入门"><a href="#Python入门" class="headerlink" title="Python入门"></a>Python入门</h1><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><hr><h3 id="print-函数"><a href="#print-函数" class="headerlink" title="print()函数"></a><code>print()</code>函数</h3><ul><li>输出可以是数字 <code>print(1220)</code></li><li>输出可以是字符串<code>print(&#39;candle&#39;)</code>，字符串需要用单引号或者双引号括起来</li><li>输出可以直接输出操作数之间的运算结果<code>print(12*20)</code></li></ul><p><code>print()</code>函数有一个内置参数<code>end</code>，使用<code>print()</code>函数时默认<code>end=&#39;\n&#39;</code>，如果不想每次执行玩<code>print()</code>函数后换行，可以修改<code>end</code>的参数，比如<code>print(&#39;*&#39;,end=&#39;&#39;)</code>，此时参数为空字符，就不会换行了</p><hr><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>即用反斜杠<code>\</code>+字母实现某些功能</p><p>比如</p><ul><li>输出特殊字符：<code>print(&#39;\&#39;&#39;)</code>，需要在引号前加一个反斜杠表示转义</li><li>实现功能：<code>\n</code>换行  <code>\b</code>退格   <code>\r</code>将光标回到开头，光标之前的数据会被覆盖</li></ul><p>也可以在字符串前加上<code>r</code>，让字符串种的转义字符不起作用</p><p>比如<code>print(r&#39;hello\nworld&#39;)</code>会输出<code>\n</code></p><hr><h3 id="编码与进制转换"><a href="#编码与进制转换" class="headerlink" title="编码与进制转换"></a>编码与进制转换</h3><p><code>ord()</code>函数用来返回单个字符的<code>ASCII</code>码值，或者是<code>unicode</code>数值</p><p><code>chr()</code>函数用来返回整数(0~255)的<code>ASCII</code>符号</p><p><code>bin()</code>函数将其他数转换为二进制数</p><p><code>oct()</code>函数将其他数转换为八进制数</p><p><code>hex()</code>函数将其他数转换为十六进制数</p><p><code>int(number,type)</code>函数将其他进制转换为十进制，第一个参数填数字，第二格填进制类型</p><hr><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>定义上来说是数据的一个标签</p><p><code>candle=1220</code></p><p>变量由三个部分组成，分别是：</p><ul><li>标识：表示对象所存储的内存地址，使用函数<code>id(obj)</code>获取</li><li>类型：表示对象的数据类型，使用函数<code>type(obj)</code>获取</li><li>值：表示对象所存储的具体数据，使用<code>print(obj)</code>可以直接输出</li></ul><hr><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><code>int</code>整数类型</p><ul><li>英文全称为<code>integer</code>，简写为<code>int</code>，可以表示正负数</li></ul><p><code>float</code>浮点数类型</p><ul><li>由整数部分和小数部分组成，为了保证浮点运算的精度，可以导入<code>decimal</code>模块</li></ul><p><code>bool</code>布尔类型</p><ul><li>表示真or假的值，<code>True</code>表示真，数值为1，<code>False</code>表示假，数值为0</li></ul><p><code>str</code>字符串类型</p><ul><li>称为不可变的字符序列,可以使用单引号,双引号,三引号定义</li></ul><hr><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>为了将不同数据类型的数据拼接在一起，所以需要进行类型转换</p><p><code>int</code>之间的除法是会产生<code>float</code>的，<code>54/10=5.4</code></p><p><code>str()</code>函数可以将其他类型转换为<code>str</code>类型，也可以直接用引号转换</p><p><code>int()</code>函数可以将其他类型转为<code>int</code>类型，注意<code>float</code>转换都<code>int</code>时，会抹零</p><hr><h3 id="函数Input"><a href="#函数Input" class="headerlink" title="函数Input()"></a>函数<code>Input()</code></h3><p>作用：接收来自用户的输入   </p><p>返回值类型：输入值类型为<code>str</code>，如果要进行运算请先转换</p><p>值的存储：设置一个<strong>变量</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">candle=<span class="built_in">input</span>(<span class="string">&#x27;write something&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(candle)</span><br></pre></td></tr></table></figure><p><code>input()</code>函数内可以写字符串，以提示信息</p><hr><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><p><code>a=20,b=10</code></p><div class="table-container"><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">+</td><td style="text-align:left">加 - 两个对象相加</td><td style="text-align:left">a + b 输出结果 30</td></tr><tr><td style="text-align:left">-</td><td style="text-align:left">减 - 得到负数或是一个数减去另一个数</td><td style="text-align:left">a - b 输出结果 -10</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">乘 - 两个数相乘或是返回一个被重复若干次的字符串</td><td style="text-align:left">a * b 输出结果 200</td></tr><tr><td style="text-align:left">/</td><td style="text-align:left">除 - x除以y</td><td style="text-align:left">b / a 输出结果 2</td></tr><tr><td style="text-align:left">%</td><td style="text-align:left">取模 - 返回除法的余数</td><td style="text-align:left">b % a 输出结果 0</td></tr><tr><td style="text-align:left">**</td><td style="text-align:left">幂 - 返回x的y次幂</td><td style="text-align:left">a**b 为10的20次方， 输出结果 100000000000000000000</td></tr><tr><td style="text-align:left">//</td><td style="text-align:left">取整除 - 返回商的整数部分（<strong>向下取整</strong>）</td><td style="text-align:left">9//2=4     -9//2 =-5</td></tr></tbody></table></div><hr><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p>以下假设变量a为10，变量b为20：</p><div class="table-container"><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">==</td><td style="text-align:left">等于 - 比较对象是否相等</td><td style="text-align:left">(a == b) 返回 False</td></tr><tr><td style="text-align:left">!=</td><td style="text-align:left">不等于 - 比较两个对象是否不相等</td><td style="text-align:left">(a != b) 返回 True</td></tr><tr><td style="text-align:left">&gt;</td><td style="text-align:left">大于 - 返回x是否大于y</td><td style="text-align:left">(a &gt; b) 返回 False</td></tr><tr><td style="text-align:left">&lt;</td><td style="text-align:left">小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量 True 和 False 等价</td><td style="text-align:left">(a &lt; b) 返回 True</td></tr><tr><td style="text-align:left">&gt;=</td><td style="text-align:left">大于等于 - 返回x是否大于等于y</td><td style="text-align:left">(a &gt;= b) 返回 False</td></tr><tr><td style="text-align:left">&lt;=</td><td style="text-align:left">小于等于 - 返回x是否小于等于y</td><td style="text-align:left">(a &lt;= b) 返回 True</td></tr><tr><td style="text-align:left">is</td><td style="text-align:left">判断两个对象的标识是否一样</td></tr></tbody></table></div><p>实际上，<code>python</code>了提高内存利用效率对于一些简单的对象，如一些数值较小的<code>int</code>对象，<code>python</code>采取重用对象内存的办法，如指向<code>a=2，b=2</code>时，由于2作为简单的<code>int</code>类型且数值小，<code>python</code>不会两次为其分配内存，而是只分配一次，然后将<code>a</code>与<code>b</code>同时指向已分配的对象,从而导致<code>a is b =True</code></p><hr><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20:</p><div class="table-container"><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">逻辑表达式</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">and</td><td style="text-align:left">x and y</td><td style="text-align:left">布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值</td><td style="text-align:left">(a and b) 返回 20</td></tr><tr><td style="text-align:left">or</td><td style="text-align:left">x or y</td><td style="text-align:left">布尔”或” - 如果 x 是非 0，它返回 x 的计算值，否则它返回 y 的计算值</td><td style="text-align:left">(a or b) 返回 10</td></tr><tr><td style="text-align:left">not</td><td style="text-align:left">not x</td><td style="text-align:left">布尔”非” - 如果 x 为 True，返回 False 如果 x 为 False，它返回 True</td><td style="text-align:left">not(a and b) 返回 False</td></tr></tbody></table></div><hr><h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><p>按位运算符是把数字看作二进制来进行计算的。Python中的按位运算法则如下：</p><p>下表中变量 a 为 60，b 为 13，二进制格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = 0011 <span class="number">1100</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">0000</span> <span class="number">1101</span></span><br><span class="line"></span><br><span class="line">-----------------</span><br><span class="line"></span><br><span class="line">a&amp;b = <span class="number">0000</span> <span class="number">1100</span></span><br><span class="line"></span><br><span class="line">a|b = 0011 <span class="number">1101</span></span><br><span class="line"></span><br><span class="line">a^b = 0011 0001</span><br><span class="line"></span><br><span class="line">~a  = <span class="number">1100</span> 0011</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">&amp;</td><td style="text-align:left">按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0</td><td style="text-align:left">(a &amp; b) 输出结果 12 ，二进制解释： 0000 1100</td></tr><tr><td style="text-align:left">丨</td><td style="text-align:left">按位或运算符：只要对应的两个二进位有一个为1时，结果位就为1。</td><td style="text-align:left">(a丨b)输出结果 61 ，二进制解释： 0011 1101</td></tr><tr><td style="text-align:left">^</td><td style="text-align:left">按位异或运算符：当两对应的二进位相异时，结果为1</td><td style="text-align:left">(a ^ b) 输出结果 49 ，二进制解释： 0011 0001</td></tr><tr><td style="text-align:left">~</td><td style="text-align:left">按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1 。<strong>~x</strong> 类似于 <strong>-x-1</strong></td><td style="text-align:left">(~a ) 输出结果 -61 ，二进制解释： 1100 0011，在一个有符号二进制数的补码形式。</td></tr><tr><td style="text-align:left">&lt;&lt;</td><td style="text-align:left">左移动运算符：运算数的各二进位全部左移若干位，由 <strong>&lt;&lt;</strong> 右边的数字指定了移动的位数，高位丢弃，低位补0。</td><td style="text-align:left">a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000</td></tr><tr><td style="text-align:left">&gt;&gt;</td><td style="text-align:left">右移动运算符：把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，<strong>&gt;&gt;</strong> 右边的数字指定了移动的位数</td><td style="text-align:left">a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111</td></tr></tbody></table></div><hr><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><h3 id="对象的布尔值"><a href="#对象的布尔值" class="headerlink" title="对象的布尔值"></a>对象的布尔值</h3><p>Python中一切都是对象，所有对象都有一个布尔值</p><p>可以使用<code>bool()</code>函数获取布尔值，以下对象的布尔值为False</p><ul><li>False</li><li>0</li><li>空字符串  空列表  空字典  空集合</li></ul><hr><h3 id="if-else结构"><a href="#if-else结构" class="headerlink" title="if-else结构"></a>if-else结构</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 判断条件：</span><br><span class="line">    执行语句……</span><br><span class="line"><span class="keyword">else</span>：</span><br><span class="line">    执行语句……</span><br></pre></td></tr></table></figure><p>当有多个值要判断时，可以使用<code>if</code>的嵌套结构</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 判断条件<span class="number">1</span>:</span><br><span class="line">    执行语句<span class="number">1</span>……</span><br><span class="line"><span class="keyword">elif</span> 判断条件<span class="number">2</span>:</span><br><span class="line">    执行语句<span class="number">2</span>……</span><br><span class="line"><span class="keyword">elif</span> 判断条件<span class="number">3</span>:</span><br><span class="line">    执行语句<span class="number">3</span>……</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    执行语句<span class="number">4</span>……</span><br></pre></td></tr></table></figure><p><code>elif</code>是<code>else if</code>的缩写</p><p><strong>条件表达式</strong></p><p>语法如下, 将<code>if</code>和<code>else</code>写到一行, 先执行<code>condition_expr</code>， 若执行结果为<code>True</code>则执行 <code>expr1</code>, 执行结果为<code>False</code>则执行<code>expr2</code></p><p><code>m = a if a &lt; b else b</code></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20230924214109860.png" alt="image-20230924214109860"></p><hr><h3 id="range函数"><a href="#range函数" class="headerlink" title="range函数"></a>range函数</h3><p>用于生成一个整数序列，有三种创建方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">range</span>(<span class="number">10</span>)  <span class="comment">#默认从0开始  [0,1,2,3,4,5,6,7,8,9]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>)  <span class="comment">#指定了其起始值，从1开始，到10结束(不包括10)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>)  </span><br><span class="line"><span class="comment">#指定了起始值，最终值，步长，从1开始，间隔为2，输出[1,3,5,7,9]</span></span><br></pre></td></tr></table></figure><p>如果想要倒序输出，则将步长设置为-1，比如<code>range(10,-1,-1)</code>，则实现了从10到0的倒序输出了</p><p>用 <code>in</code> 判断指定的整数是否在序列中，会返回<code>True or False</code></p><p><code>print (9 in r) #返回值为 True</code></p><hr><h3 id="for-in-循环"><a href="#for-in-循环" class="headerlink" title="for in 循环"></a>for in 循环</h3><p>for循环可以遍历任何序列的项目，如一个列表或者一个字符串。</p><p>结构如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sequence:</span><br><span class="line">   statements(s)</span><br></pre></td></tr></table></figure><p><code>sequence</code>可以是一个<code>range</code>函数，也可以是一个字符串或列表</p><p>如果循环体不需要使用自定义变量，那么可以写成下划线 “__”</p><hr><h3 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h3><p>执行<code>break</code>会跳出整个循环</p><p>执行<code>continue</code>只会跳出这一次循环</p><hr><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>相当于是其他语言中的数组，线性结构存储数据</p><p>但是和其他语言不同的是，<code>python</code>中的列表中元素，可以<strong>不是同一个数据类型</strong></p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul><li><p>中括号</p><p><code>lst=[&#39;candle&#39;,&#39;rainrain&#39;,1220,0420]</code></p></li><li><p>使用内置函数<code>list()</code></p><p><code>lst2=list([&#39;candle&#39;,&#39;rainrain&#39;,1220,0420])</code>，<code>list()</code>函数也可以把其他的数据结构转换为列表，比如<code>lst=list(range(6))</code></p></li></ul><p>本质上，列表<code>list</code>存储的只是列表对象的地址，<code>lst</code>存储的是列表的地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lst=[<span class="string">&#x27;candle&#x27;</span>,<span class="string">&#x27;rainrain&#x27;</span>,<span class="number">1220</span>,<span class="number">420</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(lst))  <span class="comment"># 列表的地址</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(lst[<span class="number">0</span>]))  <span class="comment"># 列表元素的地址</span></span><br></pre></td></tr></table></figure><hr><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>列表元素按顺序有序排序</li><li>索引映射唯一一个数据</li><li>列表可以存储重复数据</li><li>任意数据类型混合存储</li><li>根据需要动态分配和回收内存</li></ul><hr><h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p>与字符串的索引一样，列表索引从 <strong>0</strong> 开始，第二个索引是 <strong>1</strong>，依此类推。</p><p>通过索引列表可以进行截取、组合等操作。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20230925165933458.png" alt="image-20230925165933458"></p><p>索引也可以从尾部开始，最后一个元素的索引为 <strong>-1</strong>，往前一位为 <strong>-2</strong>，以此类推。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20230925165955922.png" alt="image-20230925165955922"></p><p>使用下标索引来访问列表中的值，同样你也可以使用方括号 <strong>[]</strong> 的形式截取字符，参数为<code>list[start:stop:step]</code></p><p>比如想输出第1到第5个元素，可以写成<code>nums[0:5]</code>，默认步长为1</p><p>输出列表中奇数位元素，可以写成<code>nums[1::2]</code></p><p>甚至可以用<code>nums[::-1]</code>实现数组的<strong>逆序访问</strong></p><hr><h3 id="寻找"><a href="#寻找" class="headerlink" title="寻找"></a>寻找</h3><p>可以简单地使用<code>in</code>来判断元素是否在列表中，会输出<code>True or False</code></p><p><code>print(candle in lst)   #True</code></p><p>通过<code>list.index(value)</code><strong>方法</strong>查询</p><ul><li>如果列表中存在N个相同元素，只返回第一个元素的索引</li><li>如果查询的元素不存在，则会抛出<code>ValueError</code></li><li>可以指定参数，在一定的范围内查找</li></ul><hr><h3 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h3><p><code>list.append(value)</code>方法</p><ul><li>在列表的末尾添加一个元素</li></ul><p><code>list.extend(seq)</code>方法</p><ul><li>在列表的末尾<strong>至少</strong>添加一个元素，可以直接给列表添加另一个列表<code>lst1.extend(lst2)</code></li></ul><p><code>list.insert(place,value)</code>方法</p><ul><li>在列表的<strong>任意</strong>位置添加一个元素，前一个参数指定添加的位置，后一个参数指定要添加的元素</li></ul><p>可以用<strong>切片</strong>的方法直接替换掉元素</p><ul><li>比如<code>lst1[1:]=lst2</code>，执行该语句后，<code>lst1</code>列表中第一个元素以后的数据都被<code>lst2</code>所替换了</li></ul><hr><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><code>list.remove(value)</code>的方法</p><ul><li>从列表中移除一个元素，如果有重复元素，只移除第一个</li></ul><p><code>list.pop(place)</code>的方法</p><ul><li>从列表中移除<strong>指定位置</strong>的元素，如果没指定位置，会删除最后一个元素】</li></ul><p>切片</p><ul><li>可以直接用<code>lst[start:stop]=[]</code>的方法，将列表在<code>(start,stop]</code>区间元素进行删除</li></ul><p><code>list.clear()</code>的方法</p><ul><li>直接删除列表中所有元素</li></ul><hr><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p><code>list.sort()</code>方法</p><ul><li>可以实现列表元素内部的排序，默认是升序排列</li><li>可以添加参数，<code>list.sort(reverse=True)</code>，实现降序排列</li></ul><p><code>sorted(seq)</code>函数</p><ul><li>会产生一个新的列表对象，<code>newlist=sorted(list)</code>，也可以指定参数实现降序排序，<code>newlist=sorted(list,reverse=True)</code></li></ul><hr><h3 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h3><p>语法格式为  <code>newlist=[元素表达式  for  自定义变量  in  可迭代对象]</code></p><p>比如：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20230925203214108.png" alt="image-20230925203214108"></p><p>会在列表中生成<code>[1,4,9..]</code>的序列</p><hr><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>字典是另一种可变容器模型，且可存储任意类型对象。</p><p>字典的每个键值 <strong>key=&gt;value</strong> 对用冒号 <strong>:</strong> 分割，每个对之间用逗号(<strong>,</strong>)分割，整个字典包括在花括号 <strong>{}</strong> 中 ,格式如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;key1 : value1, key2 : value2, key3 : value3 &#125;</span><br></pre></td></tr></table></figure><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20230926012716965.png" alt="image-20230926012716965"></p><p>键必须是<strong>唯一</strong>的，但值则不必。</p><p>值可以取任何数据类型，但键必须是<strong>不可变</strong>的，如字符串，数字。</p><p>字典在计算机中是<strong>无序存放</strong>的，通过寻找<strong>key</strong>从而来找到<strong>value</strong></p><hr><h3 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h3><p>使用花括号</p><ul><li>例如：<code>good=&#123;&#39;candle&#39;:1220,&#39;rainrain&#39;:420&#125;</code></li></ul><p>使用内置函数<code>dict()</code></p><ul><li><code>dict(name=&#39;candle&#39;,age=1220)</code></li></ul><hr><h3 id="访问-1"><a href="#访问-1" class="headerlink" title="访问"></a>访问</h3><p>直接输入键来访问值</p><ul><li><code>print(good[&#39;candle&#39;])  #输出 1220</code>，如果查找的键不存在会报错</li></ul><p>通过<code>dict.get(key)</code>方法</p><ul><li><code>print (good.get(&#39;candle&#39;))</code>，如果查找的键不存在，会返回<code>None</code>，也可以人为指定不存在时返回的默认值</li></ul><hr><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>查询</p><ul><li>可以使用<code>in</code>查询键是否在字典中存在</li></ul><p>删除</p><ul><li>使用<code>del dict[key]</code>来删除指定的键值对</li></ul><p>添加</p><ul><li>直接进行添加即可 <code>good[&#39;new&#39;]=&#39;newnew&#39;</code></li></ul><hr><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>获取<code>key</code></p><ul><li>使用<code>dict.keys()</code>方法可以获取字典中的所有<code>key</code></li><li>可以使用<code>list()</code>内置函数将输出的<code>key</code>转化为列表，<code>lst=list(good.keys())</code></li></ul><p>获取<code>value</code></p><ul><li>使用<code>dict.values()</code>方法可以获取字典中的所有<code>value</code></li></ul><p>获取<code>key-value</code>对</p><ul><li>使用<code>dict.items()</code>方法可以获取字典中所有的<code>key-value</code>对</li></ul><p>字典和<code>range</code>函数，列表一样，都是一个可迭代的对象，可以用<code>for...in...</code>结构遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> good</span><br><span class="line">    <span class="built_in">print</span>(item)  <span class="comment">#遍历输出所有的键</span></span><br><span class="line">    <span class="built_in">print</span>(good[item]) <span class="comment">#遍历输出所有的值</span></span><br><span class="line">    <span class="built_in">print</span>(good.get(item))<span class="comment">#另一种输出值的方式</span></span><br></pre></td></tr></table></figure><p>还可以同时遍历字典的<code>key</code>和<code>value</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> good.items():</span><br><span class="line">    <span class="built_in">print</span>(k,v)</span><br></pre></td></tr></table></figure><hr><h3 id="生成-1"><a href="#生成-1" class="headerlink" title="生成"></a>生成</h3><p>通过<code>zip()</code>函数生成</p><p>语法格式为  <code>newdict=[key表达式:value表达式  for  key自定义变量：value自定义变量  in  zip(可迭代对象)]</code></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20230926165024322.png" alt="image-20230926165024322"></p><hr><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>Python 的元组与列表类似，不同之处在于元组的元素不能修改。</p><p>元组使用小括号 <strong>( )</strong>，列表使用方括号 <strong>[ ]</strong>。</p><p>元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20230926165642268.png" alt="image-20230926165642268"></p><p>元组中存储的是对象的<strong>引用</strong></p><ul><li>如果元组中对象本身不可变，则不能再引用其他对象</li><li>如果元组中的对象是可变对象，这可变对象的引用不允许改变，但数据是可变的，比如：假设元组里面有一个列表，则列表里面的数据是可以改变的</li></ul><hr><h3 id="创建-2"><a href="#创建-2" class="headerlink" title="创建"></a>创建</h3><p>使用小括号</p><ul><li><code>a=(&#39;candle&#39;,&#39;rain&#39;)</code></li></ul><p>使用内置函数<code>tuple()</code></p><ul><li><code>a=tuple((&#39;candle&#39;,&#39;rain&#39;))</code></li></ul><p>只包含一个元组的元素需要使用逗号和小括号</p><ul><li><code>a=(&#39;candle&#39;,)</code>不加逗号会被识别成字符串</li></ul><hr><h3 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h3><p>元组是可迭代对象，所以可以用<code>for ... in...</code>遍历</p><hr><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合（set）是一个无序的不重复元素序列。</p><p>集合中的元素不会重复，并且可以进行交集、并集、差集等常见的集合操作。</p><div class="note primary flat"><p>某种意义上说，集合是没有<code>value</code>的字典</p></div><hr><h3 id="创建-3"><a href="#创建-3" class="headerlink" title="创建"></a>创建</h3><p>直接使用花括号{}</p><ul><li><code>s=&#123;1,2,3,4&#125;</code></li></ul><p>使用内置函数<code>set()</code></p><ul><li><code>s=set(range(6))</code>,<code>set()</code>函数也可以把其他的数据结构转换为集合，比如<code>s=set(lst)</code></li></ul><hr><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><p><code>set.add(key)</code>方法</p><ul><li>一次可以添加一个元素，<code>s.add(&#39;candle&#39;)</code></li></ul><p><code>set.update(seq)</code>方法</p><ul><li>一次<strong>至少</strong>添加一个元素，可以添加一个列表之类的，<code>s.update(lst)</code></li></ul><p>和列表是类似的</p><hr><h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><p><code>set.remove(key)</code>方法</p><ul><li>一次删除一个指定元素，如果不存在就异常</li></ul><p><code>set.discard(key)</code>方法</p><ul><li>一次删除一个指定元素，如果不存在也不会异常</li></ul><p><code>set.pop()</code>方法</p><ul><li>一次删除一个任意元素</li></ul><hr><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><p>正如数学中的集合一样，<code>python</code>中的集合有各种关系</p><p><strong>相等</strong></p><ul><li>可以使用运算符== 判断</li></ul><p><strong>子集</strong></p><ul><li>调用<code>set.issubset(set)</code>方法判断，如果<code>a.issubset(b)</code>是<code>True</code>，那么<code>a</code>是<code>b</code>的子集</li></ul><p><strong>交集</strong></p><ul><li>调用方法<code>set.isdisjoint(set)</code>判断,如果有交集，会输出<code>True</code>，</li><li>调用方法<code>intersection()</code>可以直接返回集合的交集，或者用<code>&amp;</code>运算符，<code>s1.intersection(s2)</code>等价于<code>s1 &amp; s2</code></li></ul><p><strong>并集</strong></p><ul><li>调用方法<code>set.union(set)</code>可以合并两个集合，相同元素会被舍弃，或者用<code>|</code>运算符</li></ul><p><strong>差集</strong></p><ul><li>调用方法<code>set.difference(set)</code>可以出两个集合的差集，或者用<code>-</code>运算符</li></ul><hr><h3 id="数据结构总结"><a href="#数据结构总结" class="headerlink" title="数据结构总结"></a>数据结构总结</h3><div class="table-container"><table><thead><tr><th>数据结构</th><th>是否可变</th><th>是否重复</th><th>是否有序</th><th>定义符号</th></tr></thead><tbody><tr><td>列表(list)</td><td>可变</td><td>可重复</td><td>有序</td><td>[  ]</td></tr><tr><td>元组(tuple)</td><td>不可变</td><td>可重复</td><td>有序</td><td>(  )</td></tr><tr><td>字典(dict)</td><td>可变</td><td>key不可重复</td><td>无序</td><td>{key:value}</td></tr><tr><td>集合(set)</td><td>可变</td><td>不可重复</td><td>无序</td><td>{  }</td></tr></tbody></table></div><hr><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串本身就是一个<strong>字符数组</strong>，这意味着你可以通过范围下标的方式来访问字符串的单个字符，比如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s=<span class="string">&#x27;candle&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">1</span>]) <span class="comment">#结果会输出&#x27;a&#x27;</span></span><br></pre></td></tr></table></figure><div class="note danger flat"><p>但是字符串是不可变类型，对字符串的修改会产生<strong>新的</strong>字符串对象，这点和列表不同</p></div><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p><code>str.index(str)</code>方法</p><ul><li>查询子串<code>substr</code>第一次出现的<strong>位置</strong>，如果不存在，就抛出异常</li></ul><p><code>str.rindex(str)</code>方法</p><ul><li>查询子串<code>substr</code>最后一次出现的<strong>位置</strong>，如果不存在，抛出异常</li></ul><p><code>str.find(str)</code>方法</p><ul><li>查询子串<code>substr</code>第一次出现的<strong>位置</strong>，如果不存在，则返回-1</li></ul><hr><h3 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h3><p><code>str.split()</code>方法</p><ul><li>从字符串的左边开始劈分，默认的劈分字符是<strong>空格</strong>字符串，返回的值都是一个<strong>列表</strong>  <code>print(s.split())</code></li><li><p>可以指定参数，比如<code>sep</code>参数，可以选择劈分的依据 <code>s.split(seq=&#39;|&#39;)</code>会以字符<code>|</code>分界点进行分割 </p></li><li><p><code>split()</code>方法的返回结果是一个<strong>列表</strong></p></li><li><p>如果想要字符串分割成<strong>单独的字符</strong>，用<code>list()</code>方法就行了</p></li></ul><hr><h3 id="替换与合并"><a href="#替换与合并" class="headerlink" title="替换与合并"></a>替换与合并</h3><p><code>str.replace(old,new)</code>方法</p><ul><li><code>replace()</code> 方法把字符串中的 <code>old</code>（旧字符串） 替换成 <code>new</code>(新字符串)</li></ul><p><code>str.join(seq)</code> 方法</p><ul><li>将列表或元组中的字符串合并成一个字符串，效果是会在<code>seq</code>序列中间以<code>str</code>为间隔</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1=<span class="string">&#x27;-&#x27;</span></span><br><span class="line">s2=<span class="string">&#x27;candle&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s1.join(s2)) </span><br><span class="line"><span class="comment">#会输出：c-a-n-d-l-e</span></span><br></pre></td></tr></table></figure><hr><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>和列表一样，字符串也可以通过切片的方式截取，遵循左闭右开的原则</p><p>比如<code>print(s[1:5])</code>，会输出字符串第2个到第5个元素</p><hr><h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><ul><li><p>使用花括号{}</p><p>字符串中可以用{ }作为占位符，里面输入整数作为次序，调用format方法，实现格式化字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name=<span class="string">&#x27;candle&#x27;</span></span><br><span class="line">key=<span class="string">&#x27;rain&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;my name is &#123;0&#125;,love &#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(name,key))</span><br><span class="line"><span class="comment">#会输出 my name is candle,love rain</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>使用<code>f-string</code></p><p>在字符串之前加字符 <code>f</code> ，说明之后的字符串可以直接使用变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name=<span class="string">&#x27;candle&#x27;</span></span><br><span class="line">key=<span class="string">&#x27;rain&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;my name is <span class="subst">&#123;name&#125;</span>,love<span class="subst">&#123;key&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">name</span><span class="params">(parameter)</span> :</span></span><br><span class="line"><span class="function">    <span class="title">function</span></span></span><br><span class="line"><span class="function">    <span class="params">(<span class="keyword">return</span>)</span> </span></span><br></pre></td></tr></table></figure><hr><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>和其他语言不同的是，<code>python</code>允许多个返回值，结果为<strong>元组</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    a=<span class="number">2</span></span><br><span class="line">    b=<span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> a,b</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(test()) <span class="comment">#会输出(2,3)元组，可以用list()变成列表</span></span><br></pre></td></tr></table></figure><hr><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p><strong>默认参数</strong></p><p>函数定义时，给形参设置默认值，只有与默认值不符的时候才需要传递参数</p><p><code>def fun (a,b=10)</code>的意思是，如果只传一个参数，默认<code>b=10</code>，如果传了两个参数，这<code>b</code>的值被替换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span> (<span class="params">a,b=<span class="number">10</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> a,b</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(fun(<span class="number">20</span>))  <span class="comment"># 会返回(20,10)，b的值是默认值</span></span><br><span class="line"><span class="built_in">print</span>(fun(<span class="number">20</span>,<span class="number">30</span>)) <span class="comment"># 会返回(20,30)，b的值被修改</span></span><br></pre></td></tr></table></figure><hr><p><strong>位置传参</strong></p><p>如果想要将列表中的每个元素当做位置参数传入的话，如果在传入时加<code>*</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>(<span class="params">a,b,c</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(a,b,c)</span><br><span class="line">    </span><br><span class="line">lst=[<span class="string">&#x27;candle&#x27;</span>,<span class="number">1220</span>,<span class="number">420</span>]</span><br><span class="line">fun(*lst)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果不加<code>*</code>会报错，因为相当于只传入列表的首地址，也就是第一个元素</p><hr><p><strong>关键字传参</strong></p><p>如果想要将字典中的每个键值对当做位置参数传入的话，如果在传入时加<code>**</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>(<span class="params">a,b,c</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;a=&#x27;</span>,a)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;b=&#x27;</span>,b)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;c=&#x27;</span>,c)</span><br><span class="line"></span><br><span class="line">dic = &#123;<span class="string">&#x27;c&#x27;</span>:<span class="number">1220</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">420</span>,<span class="string">&#x27;a&#x27;</span>:<span class="number">520</span>&#125;</span><br><span class="line">fun(**dic)</span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="note primary flat"><p>传入的键值对的键(key)必须是和函数参数<strong>对应的字符</strong>，否则会报错</p></div><hr><p><strong>个数可变的参数</strong></p><p>定义函数时，如果无法事先确认传递的位置实参个数时，使用可变的位置参数，用<code>*</code>定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>(<span class="params">*args</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line">    </span><br><span class="line">fun(<span class="number">10</span>)</span><br><span class="line">fun(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line">fun(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>)</span><br></pre></td></tr></table></figure><p>输出的结果都是 <strong>元组</strong></p><hr><p><strong>个数可变的关键字参数</strong></p><p>定义函数时，如果无法事先确认传递的关键字个数时，使用可变的关键字参数，用<code>**</code>定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>(<span class="params">**args</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line">    </span><br><span class="line">fun(a=<span class="number">10</span>)</span><br><span class="line">fun(a=<span class="number">10</span>,b=<span class="number">20</span>)</span><br></pre></td></tr></table></figure><p>输出的结果为 <strong>字典</strong></p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.0.数二历年真题解析</title>
      <link href="/post/12103.html"/>
      <url>/post/12103.html</url>
      
        <content type="html"><![CDATA[<h1 id="数学真题"><a href="#数学真题" class="headerlink" title="数学真题"></a>数学真题</h1><h2 id="函数，极限，连续"><a href="#函数，极限，连续" class="headerlink" title="函数，极限，连续"></a>函数，极限，连续</h2><h3 id="选"><a href="#选" class="headerlink" title="选"></a>选</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221212180348711.png" alt="image-20221212180348711"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：</p><p>分母：$sin\pi x$在$x$为整数时$\to 0$，</p><p>分子在$x=0,x=1,x=-1$时也为0，</p><p>依次将0，-1，1代入求极限，可以得到，这三点都是可去间断点，所以选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221212182127670.png" alt="image-20221212182127670"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：</p><ol><li>直接用$x-sinx \sim \frac{1}{6}x^3$这个结论 </li><li>洛必达法则</li></ol><p>所以选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213202658040.png" alt="image-20221213202658040"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：可能点有三个：$1,-1,0，x=1$时，可以直接约去，$x=0$时，极限为1，故只有$x=-1$一个点，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221214205920761.png" alt="image-20221214205920761"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：用$x-sinx \sim \frac{1}{6}x^3$代换，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221214210130670.png" alt="image-20221214210130670"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：将极限拆开，考察的是导数的定义，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215131133064.png" alt="image-20221215131133064"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：首先有水平渐近线，故无斜渐近线，还有1条垂直渐近线，故有2条</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215132040982.png" alt="image-20221215132040982"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：$S_{n+1}-S_{n}=a_{n+1}$，所以如果$S_n$有界，那么$a_n$肯定会收敛到0，而$a_n$收敛，假设$a_n=\frac{1}{n}$，那么$S_n$不收敛，所以是充分非必要条件，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215232239545.png" alt="image-20221215232239545"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：等价代换之后，很明显选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216142755192.png" alt="image-20221216142755192"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：等价代换后即可，B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217015514021.png" alt="image-20221217015514021"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：简单代换后，分别是 $2 ，\frac{5}{6}，1$,所以选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217191742135.png" alt="image-20221217191742135"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：只有D满足，不会有正负抵消的情况</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217220549904.png" alt="image-20221217220549904"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：$e^{x}$泰勒展开即可</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217220817534.png" alt="image-20221217220817534"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218145553479.png" alt="image-20221218145553479"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：显然是3，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218200803605.png" alt="image-20221218200803605"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：算出结果来，选D</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218201049074.png" alt="image-20221218201049074"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219112946451.png" alt="image-20221219112946451"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：2(3+1)=8，所以是高阶无穷小，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219120125535.png" alt="image-20221219120125535"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：$secx$是偶函数，所以$a=0$，而$secx$在零点附近是大于1的，所以$b&gt;0$，选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219153648785.png" alt="image-20221219153648785"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：首先1,4是对的，重点关注3，其中$o(a(x))$表示的是$a(x)$的高阶无穷小，当然成立，所以选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219153953906.png" alt="image-20221219153953906"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：本质上是看$a_n$的上限与下限，$a_1&gt;1$而$a_2<1$,又$n\to \infty$ 时 $a_n=1$，所以$a_1>a_n&gt;a_2$,有最大值，也有最小值</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219163657405.png" alt="image-20221219163657405"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：AB都错，因为$cosx_n$是偶函数，C也错，$x_n$一定存在，D正确</p></div></div><hr><h3 id="填"><a href="#填" class="headerlink" title="填"></a>填</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221214224728633.png" alt="image-20221214224728633"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：用$1^{\infty}$的常见做法即可</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221214225147766.png" alt="image-20221214225147766"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215161823447.png" alt="image-20221215161823447"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：用定积分定义：<img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215161937277.png" alt="image-20221215161937277"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216001312395.png" alt="image-20221216001312395"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：用$1^{\infty}$的方法即可</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216004343788.png" alt="image-20221216004343788"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217150404952.png" alt="image-20221217150404952"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：定积分的定义</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217150544446.png" alt="image-20221217150544446"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217231144815.png" alt="image-20221217231144815"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：直接用$arctanx$的运算公式简化运算，或者是拉格朗日定理</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217231422358.png" alt="image-20221217231422358"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218154704162.png" alt="image-20221218154704162"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：用$1^{\infty}$的结论</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218155301641.png" alt="image-20221218155301641"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218225031812.png" alt="image-20221218225031812"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：把$x$次幂提出来更好算</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218225304320.png" alt="image-20221218225304320"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218225414350.png" alt="image-20221218225414350"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：证明$g’(x)$连续，那么要证明在不可导点的导数和常规的导数一致</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218234917936.png" alt="image-20221218234917936"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219165133972.png" alt="image-20221219165133972"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：$1^{\infty}$方法</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219170454488.png" alt="image-20221219170454488"></p></div></div><hr><h3 id="综"><a href="#综" class="headerlink" title="综"></a>综</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213164402503.png" alt="image-20221213164402503"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：本题难度较低，分母可以直接化成$x^4$，然后$1-cos\sim\frac{1}{2}x^2,x-ln(1+x)\sim\frac{1}{2}x^2$，可以很轻松的求出是$\frac{1}{4}$</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221214231545953.png" alt="image-20221214231545953"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：分别求极限即可</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221214232442490.png" alt="image-20221214232442490"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215000840844.png" alt="image-20221215000840844"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：第一问好证明，第二问需要观察到$x&gt;ln(1+x)$，将所有$x$替换成$ln(1+x)$证明其有下界</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215002654007.png" alt="image-20221215002654007"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215165743090.png" alt="image-20221215165743090"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：重复用洛必达法则即可求解：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215174011147.png" alt="image-20221215174011147"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215183214087.png" alt="image-20221215183214087"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>第一问可用求和公式+单调性解决，而第二问需要用到单调有界法则证明极限存在</p><p>第二问解法将$x_{n}$带入到了$f_NaN$的序列中去，从而判断出$x_n&gt;x_{n+1}$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215190320502.png" alt="image-20221215190320502"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215190450019.png" alt="image-20221215190450019"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216011555804.png" alt="image-20221216011555804"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：这种题直接泰勒展开</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216012227342.png" alt="image-20221216012227342"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216024223160.png" alt="image-20221216024223160"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：第1问只要算导数即可，第2问最难的是找到$x_n$的上界</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216025025845.png" alt="image-20221216025025845"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216165646152.png" alt="image-20221216165646152"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：到等价无穷小的代换以及洛必达法则</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216165918978.png" alt="image-20221216165918978"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216182116978.png" alt="image-20221216182116978"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：先求出$f_{n}(x)$的表达式，然后算出$S_n$的表达式，然后求极限</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216184101798.png" alt="image-20221216184101798"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216231242416.png" alt="image-20221216231242416"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：泰勒展开到三阶即可</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216232755845.png" alt="image-20221216232755845"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217154257056.png" alt="image-20221217154257056"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：泰勒展开即可</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217154542174.png" alt="image-20221217154542174"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217195515635.png" alt="image-20221217195515635"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：先处理积分，再用洛必达法则</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217201842171.png" alt="image-20221217201842171"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218005247609.png" alt="image-20221218005247609"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：这里用了一个非常很重要的方法，把1代换为$e^{0}$，这样就可以用中值定理，算出$e^{\xi}$，从而知道单调性。并且从0点开始，也暗示了下界</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218025015931.png" alt="image-20221218025015931"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218164617841.png" alt="image-20221218164617841"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：这题非常难，因为$sinx$是周期性函数，所以需要将积分分周期表示出来，最后要根据等比数列求和公式计算出积分</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218174351069.png" alt="image-20221218174351069"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219150228088.png" alt="image-20221219150228088"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：各种方法都行</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219150545581.png" alt="image-20221219150545581"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219172216503.png" alt="image-20221219172216503"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：先算出$f(0)=0$，之后用导数定义即可</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219172343000.png" alt="image-20221219172343000"></p></div></div><hr><h2 id="微分学"><a href="#微分学" class="headerlink" title="微分学"></a>微分学</h2><h3 id="选-1"><a href="#选-1" class="headerlink" title="选"></a>选</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221212183331175.png" alt="image-20221212183331175"></p><p>重点在于对曲率圆方程的处理</p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>对方程$x^2+y^2=2$两端对$x$求导，得$2x+2yy’=0,y’(1)=-1$</p><p>再求导得$2+2(y’)^2+2yy’’=0，y’’(1)=-2$</p><p>所以$f’(1)&lt;0，f’’(1)&lt;0$，$f(x)$在（1,2）上单调减少，无极值</p><p>而$f(1)=1&gt;0，f(2)=f’(\xi)+f(1)&lt;f’(1)+1=0$</p><p>由零点定理得必有零点，故选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213204757073.png" alt="image-20221213204757073"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>很常规的一道题：<img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213204835711.png" alt="image-20221213204835711" style="zoom:80%;" /></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221214210403764.png" alt="image-20221214210403764"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：先将$f(x)$拆开后，求导$f’(x)=0$即可得出结论</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221214221526009.png" alt="image-20221214221526009"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221214221817328.png" alt="image-20221214221817328"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：对$z$求二阶导，要求其二阶导&gt;0，显然选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215131627099.png" alt="image-20221215131627099"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：把$f(x)$拆成$(e^x-1)g(x)$即可，选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215233218499.png" alt="image-20221215233218499"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：先带入$x=0$算出$f’(0)$，然后用导数定义求解</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215233450267.png" alt="image-20221215233450267"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216143108179.png" alt="image-20221216143108179"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：首先排除水平渐进线和垂直渐进线，逐个验证其斜渐近线，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216143237805.png" alt="image-20221216143237805"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：首先注意到$g(1)=f(1)$，$g(0)=f(0)$这个条件，再对两端求导，发现$g‘(x)$是一个常数，即$g(x)$是一条直线，则$f’’(x)&gt;0$时，满足条件，选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216150727383.png" alt="image-20221216150727383"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：注意是曲率半径$\frac{1}{r}$，而不是曲率</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216150820927.png" alt="image-20221216150820927"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216150857243.png" alt="image-20221216150857243"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：本质上是将$\xi$用$x$表示之后，在等价代换即可</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216151201795.png" alt="image-20221216151201795"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216195441355.png" alt="image-20221216195441355"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：极限为$e^t$，$x=0$时肯定有间断点，可去</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216195721750.png" alt="image-20221216195721750"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：首先是确保$x^a$的$a≥0$才连续，然后$f’(x)$在0点和0点周围要连续</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216200706480.png" alt="image-20221216200706480"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216200732183.png" alt="image-20221216200732183"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：图中正负发生改变的点，即是拐点，所以有2个，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217032505421.png" alt="image-20221217032505421"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：图中正负号发生变化的是极值点，零点是拐点，故选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217032654836.png" alt="image-20221217032654836"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：画图有助于解决此类问题，比较二阶导即可</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217033454798.png" alt="image-20221217033454798"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217190547248.png" alt="image-20221217190547248"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：在0点的极限相等</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217190642764.png" alt="image-20221217190642764"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217190704710.png" alt="image-20221217190704710"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：画图可以清晰的看到，积分是小于0的，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217194621621.png" alt="image-20221217194621621"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：常规题</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217194723271.png" alt="image-20221217194723271"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217220838009.png" alt="image-20221217220838009"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：就按定义计算导数</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217221126930.png" alt="image-20221217221126930"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217221142174.png" alt="image-20221217221142174"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：处理好交界点的连续性即可</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217221457660.png" alt="image-20221217221457660"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218145650791.png" alt="image-20221218145650791"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：需要观察，在$x=0$和$x=\pi$的时候都为0，所以需要验证</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218145844362.png" alt="image-20221218145844362"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218151403761.png" alt="image-20221218151403761"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：相切且曲率相等的前提是$y’$相等，$|y’’|$也相等，条件可以推出$y’$和$y’’$相等，是充分条件，但是$|y’’|$相等推不出$y’’$相等，所以选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218201112540.png" alt="image-20221218201112540"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：可能的点有1,2，-1,0四个点，带入计算</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218201420662.png" alt="image-20221218201420662"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218201809290.png" alt="image-20221218201809290"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：展开$ln(1-x)$的泰勒公式最为简单，也可以求三阶导然后带入</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218202846985.png" alt="image-20221218202846985"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218203503496.png" alt="image-20221218203503496"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：可以假设$f(x)$是$e^{ax}(a&gt;1)$类型的函数，所以只能证明$e^{a}&gt;e$，所以选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219113655243.png" alt="image-20221219113655243"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：肯定连续，可导要判别$f’(0)$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219114004770.png" alt="image-20221219114004770"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219114026303.png" alt="image-20221219114026303"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：写出体积和表面积的公式，再对半径和高求导，其实是多元函数</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219114916682.png" alt="image-20221219114916682"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219114941817.png" alt="image-20221219114941817"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：将$\frac{b}{a}$设为一个变量，然后画出图形</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219115801977.png" alt="image-20221219115801977"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219161940836.png" alt="image-20221219161940836"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：有二阶导数说明$f’(x)$是连续的，所以能说明在领域内单调增加，选B</p></div></div><hr><h3 id="填-1"><a href="#填-1" class="headerlink" title="填"></a>填</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213011633181.png" alt="image-20221213011633181"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：首先要注意：$x=0,y=0$,那么$t=1$，然后分别求导，求出$y’$，最后写出方程</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213155955635.png" alt="image-20221213155955635"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213163651505.png" alt="image-20221213163651505"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：利用对数求导法求出$y’$，然后根据$y’=0$，求出$x$的值，带入即最小值</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213163946401.png" alt="image-20221213163946401"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213163045005.png" alt="image-20221213163045005"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：首先$x=0$，可以求出$y=0$，然后对方程两端求一次导，求出$y’$,然后再求一次导，带入$x,y,y’,$即可求出$y’’$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213163353745.png" alt="image-20221213163353745"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213231914010.png" alt="image-20221213231914010"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：首先排除水平渐进线和垂直渐近线，可以计算出a和b的值</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213232136330.png" alt="image-20221213232136330"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213232153577.png" alt="image-20221213232153577"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：对$ln(1-2x)$求导以归纳规律</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213232725669.png" alt="image-20221213232725669"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213233042278.png" alt="image-20221213233042278"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：首先写出对角线关于$l$和$w$的方程，然后再求导，即是对角线增加的速率</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213233830719.png" alt="image-20221213233830719"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215161405774.png" alt="image-20221215161405774"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：对方程求二次导即可</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215161800245.png" alt="image-20221215161800245"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215162235810.png" alt="image-20221215162235810"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：将x，y地位互换</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215164831247.png" alt="image-20221215164831247"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215164902974.png" alt="image-20221215164902974"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：带入公式可计算：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215165122966.png" alt="image-20221215165122966"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216004416618.png" alt="image-20221216004416618"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：由$y$的值推出$x$的值</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216004654514.png" alt="image-20221216004654514"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216005316489.png" alt="image-20221216005316489"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>常规题</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216010146478.png" alt="image-20221216010146478"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216163042466.png" alt="image-20221216163042466"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：常规题</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216163157621.png" alt="image-20221216163157621"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216224916834.png" alt="image-20221216224916834"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：常规题</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216224939556.png" alt="image-20221216224939556"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216224957305.png" alt="image-20221216224957305"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：多项式定理</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216225858246.png" alt="image-20221216225858246"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217150133012.png" alt="image-20221217150133012"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：常规题</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217150339450.png" alt="image-20221217150339450"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217151024090.png" alt="image-20221217151024090"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：归纳法</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217151955760.png" alt="image-20221217151955760"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217152731600.png" alt="image-20221217152731600"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：先列出$v_0$和$l$的关系，在求导算出变化率</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217152900251.png" alt="image-20221217152900251"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217193705564.png" alt="image-20221217193705564"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：常规题</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217194557935.png" alt="image-20221217194557935"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217231449493.png" alt="image-20221217231449493"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：常规题</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217231514426.png" alt="image-20221217231514426"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217232040889.png" alt="image-20221217232040889"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：求出$y’$和$y’’$即可</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217232504629.png" alt="image-20221217232504629"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218155320329.png" alt="image-20221218155320329"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：求出斜率，找到点，列方程，求截距</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218160419838.png" alt="image-20221218160419838"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218221534575.png" alt="image-20221218221534575"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：常规题</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218221643623.png" alt="image-20221218221643623"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219122215645.png" alt="image-20221219122215645"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219122226883.png" alt="image-20221219122226883"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219170513892.png" alt="image-20221219170513892"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219170609373.png" alt="image-20221219170609373"></p></div></div><hr><h3 id="综-1"><a href="#综-1" class="headerlink" title="综"></a>综</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213183338813.png" alt="image-20221213183338813"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>引进辅助函数即可证明：</p><script type="math/tex; mode=display">F(x)=f(x)-f(a)-\frac{f(b)-f(a)}{b-a}(x-a)</script><p>因为$F(a)=F(b)$，由罗尔定理$F’(\xi)=0$，即可证明拉格朗日定理</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213184429655.png" alt="image-20221213184429655"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221214031442391.png" alt="image-20221214031442391"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：本质是微分方程求解，$\psi(1)$和$\psi’(1)$都是条件</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221214032502346.png" alt="image-20221214032502346"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221214032548932.png" alt="image-20221214032548932"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221214201728076.png" alt="image-20221214201728076"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：设原函数$F(x)=f(x)-\frac{x^3}{3}$，用微分中值定理即可证明</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221214202109669.png" alt="image-20221214202109669"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221214232522683.png" alt="image-20221214232522683"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：常规题，特别要注意的是算出$t$的值后，要把$x,y$的值也带入算出来</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221214232939863.png" alt="image-20221214232939863"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215182905140.png" alt="image-20221215182905140"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：组成一个新的函数，求其最小值大于等于0即可</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215183154060.png" alt="image-20221215183154060"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216013544180.png" alt="image-20221216013544180"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：奇函数隐含$f(0)=0$，第1问用拉格朗日定理即可</p><p>第2问需要设置$F(x)$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216023000021.png" alt="image-20221216023000021"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217003022011.png" alt="image-20221217003022011"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：求出$x_0$后，用拉格朗日定理可以很好求解</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217005155291.png" alt="image-20221217005155291"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217202326284.png" alt="image-20221217202326284"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：$y’=0$求出可能的$x$的点，然后求出$y$的值，再求$y’’$的值来判断极大或极小</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217202545234.png" alt="image-20221217202545234"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217202729970.png" alt="image-20221217202729970"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：问1可由保号性证明，而问2的关键在于判断出原函数后，证明3点同值即可</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217202819301.png" alt="image-20221217202819301"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217205127751.png" alt="image-20221217205127751"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：利用条件列出微分方程，然后求解</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217205735384.png" alt="image-20221217205735384"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218003758167.png" alt="image-20221218003758167"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：$k$单独表示，然后求导</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218004159607.png" alt="image-20221218004159607"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218004924014.png" alt="image-20221218004924014"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：先求解出用$P$点$x$表示$S$的面积，再对$x$求导，即是$S$的变化率</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218005129144.png" alt="image-20221218005129144"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218162201588.png" alt="image-20221218162201588"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：尤其注意连接点的导数</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218163647060.png" alt="image-20221218163647060"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218163656060.png" alt="image-20221218163656060"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218163713871.png" alt="image-20221218163713871"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：用待定系数法做，注意$x^2+x+1$对应的系数我$Ax+B$</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218174500615.png" alt="image-20221218174500615"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：第1问由积分中值定理+拉格朗日中值定理可证，第2问需要假设出原函数后，反复用中值定理</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218175555732.png" alt="image-20221218175555732"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219003105441.png" alt="image-20221219003105441"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：第1问用零点定理好证明，第2问，需要看出$ln1$和$f(1)$都为0，所以是用柯西中值定理</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219003750666.png" alt="image-20221219003750666"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219150609955.png" alt="image-20221219150609955"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219150634440.png" alt="image-20221219150634440"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219175052827.png" alt="image-20221219175052827"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：必要性的证明方法在之前的选择题中有所体现</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219175302178.png" alt="image-20221219175302178"></p></div></div><hr><h2 id="积分学"><a href="#积分学" class="headerlink" title="积分学"></a>积分学</h2><h3 id="选-2"><a href="#选-2" class="headerlink" title="选"></a>选</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221212234009006.png" alt="image-20221212234009006"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：在$[-1,0]$阶段，$f(x)=1$，显然是$y=x$曲线，所以排除AC</p><p>而在$[2,3]$时，$f(x)=0$，所以$F(x)$的值不会在$[2,3]$增长，选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213204914386.png" alt="image-20221213204914386"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：有两个暇点需要讨论，在$x\to 0$时比较好计算，而在$x\to1$ 时需要用到比较审敛法</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213210437457.png" alt="image-20221213210437457"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221214222103899.png" alt="image-20221214222103899"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：在$[0,\frac{\pi}{4}]$区间，显然$sinx<cosx$，所以$K>I$，而$sinx<1$，故$cotx>cosx$，所以$J&gt;K&gt;I$，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215133417715.png" alt="image-20221215133417715"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：该题的被积函数一样，积分区域不一样，所以用让积分相减比大小</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215155413621.png" alt="image-20221215155413621"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215233537223.png" alt="image-20221215233537223"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：根据总结的上限积分规律，$x=\pi$ 是$f(x)$的跳跃间断点，则$F(x)$连续但不可导，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215233833883.png" alt="image-20221215233833883"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：从两个方向考虑：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215234107130.png" alt="image-20221215234107130"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216195245825.png" alt="image-20221216195245825"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解系：可以逐个计算，结果选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217030535972.png" alt="image-20221217030535972"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：首先原函数要连续，其次，导数为$lnx$，选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217193124969.png" alt="image-20221217193124969"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：很明显会在$t=25$的时候追上</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217221515497.png" alt="image-20221217221515497"></p><p>重点：对泰勒公式进行积分的思路令人眼前一亮</p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217221833734.png" alt="image-20221217221833734"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217221927755.png" alt="image-20221217221927755"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：找到了$M=\pi$的中间桥梁</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217223614025.png" alt="image-20221217223614025"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218201437945.png" alt="image-20221218201437945"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：熟悉$arcsinx$的导数即可</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218201757998.png" alt="image-20221218201757998"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219120941868.png" alt="image-20221219120941868"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：如果是$\frac{1}{n}$，那么里面也要被分成$n$份，只有B符合条件</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219162205214.png" alt="image-20221219162205214"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：更改次序后方便计算</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219162321470.png" alt="image-20221219162321470"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219163111142.png" alt="image-20221219163111142"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：直接带1进去，发现$p≠1$，排除B和D，在$x\to 1$的时候，$lnx\sim 1-x$，所以$-p<1,p>-1$选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219164113024.png" alt="image-20221219164113024"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：$ln(1+x)&gt;\frac{x}{2}$，$I_2&gt;I_1$，而$1+sinx<1+cosx ,2x>ln(1+x)$，所以$I_3&gt;I_2$，选A</p></div></div><hr><h3 id="填-2"><a href="#填-2" class="headerlink" title="填"></a>填</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213160307276.png" alt="image-20221213160307276"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：积分函数是偶函数，同时积分区间关于原点对称，所以可以算$[0,+\infty]$积分即可</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213161745287.png" alt="image-20221213161745287"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221214225358721.png" alt="image-20221214225358721"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：拆成$[-\infty,0]$和$[0,+\infty]$两个区间，$x<0$时为0，$x>0$时，积分为$\frac{1}{\lambda}\int_0^{+\infty}te^{-t}dt=\frac{1}{\lambda}$，所以答案为$\frac{1}{\lambda}$</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221214230235081.png" alt="image-20221214230235081"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：先用弧长公式，再用积分公式可得结论</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221214230615767.png" alt="image-20221214230615767"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213162549463.png" alt="image-20221213162549463"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：主要就是考察分部积分法的计算，属于是纯计算问题，按优先级先将$sinnx$积进去</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213163004435.png" alt="image-20221213163004435"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213232740732.png" alt="image-20221213232740732"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>根据极坐标方程的弧长公式可轻松求解</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213233013163.png" alt="image-20221213233013163"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216004714305.png" alt="image-20221216004714305"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：和之前的$r=1+cos\theta$的题很相似，注意要乘上$r$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216005249824.png" alt="image-20221216005249824"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216160727593.png" alt="image-20221216160727593"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216163020612.png" alt="image-20221216163020612"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216163433381.png" alt="image-20221216163433381"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：转化为$x,y$，并根据参数方程的形式求出$y’$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216164316789.png" alt="image-20221216164316789"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216225931364.png" alt="image-20221216225931364"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：常规题</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216230141073.png" alt="image-20221216230141073"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217194741525.png" alt="image-20221217194741525"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：分部积分法：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217194906718.png" alt="image-20221217194906718"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217231532981.png" alt="image-20221217231532981"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：直接拆开即可</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217232012880.png" alt="image-20221217232012880"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218161021838.png" alt="image-20221218161021838"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218161458290.png" alt="image-20221218161458290"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218221656309.png" alt="image-20221218221656309"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：交换积分次序</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218221959275.png" alt="image-20221218221959275"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218222320147.png" alt="image-20221218222320147"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：画出图后，用微元法分析：</p><p>其中积分距离是$x$，而因为是等腰三角形，积分区域=$2(a-x)$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218224725133.png" alt="image-20221218224725133"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219121958647.png" alt="image-20221219121958647"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219122137537.png" alt="image-20221219122137537"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219170632510.png" alt="image-20221219170632510"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219170953570.png" alt="image-20221219170953570"></p></div></div><hr><h3 id="综-2"><a href="#综-2" class="headerlink" title="综"></a>综</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213164724749.png" alt="image-20221213164724749"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>首先将根式化为$t$，然后正好用分部积分法，然后用待定系数法求解积分即可，最后结果记得$+C$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213170338941.png" alt="image-20221213170338941"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213235742055.png" alt="image-20221213235742055"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：先对函数$f(x)$求导，然后根据$f’(x)=0$的点判断单调区间与极值</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221214030235887.png" alt="image-20221214030235887"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221214030321400.png" alt="image-20221214030321400"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221214030349591.png" alt="image-20221214030349591"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：显然$t&gt;ln(1+t)$，所以第一问易证，证明出第一问的结论后，直接夹逼定理可得出极限</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221214030755355.png" alt="image-20221214030755355"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221214030930182.png" alt="image-20221214030930182"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221214032805361.png" alt="image-20221214032805361"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：此题实际上就是其阴影部分面积，下半部分椭圆面积为$\frac{1}{2}\pi ab$，而上半部分的面积需要用定积分计算</p><p>首先椭圆的公式为$\frac{x^2}{a^2}+\frac{y^2}{b^2}=1$，将$y$用$x$表示，最后将$y=bsinx$代换即可算出上半部分面积</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221214035615037.png" alt="image-20221214035615037"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216172529411.png" alt="image-20221216172529411"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：第1问用积分中值定理易证，第2问用单调性</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216181955342.png" alt="image-20221216181955342"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216182040783.png" alt="image-20221216182040783"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217000449913.png" alt="image-20221217000449913"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：不需要算出具体的值，只需要判断&gt;0or&lt;0即可</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217001121534.png" alt="image-20221217001121534"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217154557168.png" alt="image-20221217154557168"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：对$x$的取值分类讨论</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217154902189.png" alt="image-20221217154902189"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217233437347.png" alt="image-20221217233437347"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：根式设为$t$即可</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217234530874.png" alt="image-20221217234530874"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217234543607.png" alt="image-20221217234543607"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：其实是一个微分方程</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217235104955.png" alt="image-20221217235104955"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219150648646.png" alt="image-20221219150648646"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：计算量大</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219150920706.png" alt="image-20221219150920706"></p></div></div><hr><h2 id="常微分"><a href="#常微分" class="headerlink" title="常微分"></a>常微分</h2><h3 id="选-3"><a href="#选-3" class="headerlink" title="选"></a>选</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213203053921.png" alt="image-20221213203053921"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：分别将$\lambda y_1+\mu y_2$和$\lambda y_1-\mu y_2$带入方程，即可得到$\lambda+\mu=1,\lambda=\mu$的结论，故选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221214221556648.png" alt="image-20221214221556648"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：$\lambda$ 和 $-\lambda$就是特征方程的两个解，根据叠加原理，答案为C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217191941010.png" alt="image-20221217191941010"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：算出$r$,然后设特解</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217192853353.png" alt="image-20221217192853353"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218150243297.png" alt="image-20221218150243297"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：说明有齐次方程是$r=-1$的重根，算出齐次方程后带入$e^x$解出c</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218150713416.png" alt="image-20221218150713416"></p></div></div><hr><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：</p></div></div><hr><h3 id="填-3"><a href="#填-3" class="headerlink" title="填"></a>填</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213230925422.png" alt="image-20221213230925422"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>直接列特征方程然后拆项，$(r-2)(r^2+1)=0$，故可以写出通解$C_1e^{2x}+C_2sinx+C_3cosx$</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221214225201213.png" alt="image-20221214225201213"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：直接带入公式即可得到，$y=e^{-x}sinx$</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216010205541.png" alt="image-20221216010205541"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：可以看出$e^x$和$e^{3x}$是齐次解，而$-xe^{2x}$是特解，根据条件解出$C$即可</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216010616967.png" alt="image-20221216010616967"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217150559136.png" alt="image-20221217150559136"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：先相减算出齐次方程的通解，求出齐次方程后，带入特解，求出其他项</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217151001858.png" alt="image-20221217151001858"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218224844765.png" alt="image-20221218224844765"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：算出$y$后，进行积分即可</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218224928863.png" alt="image-20221218224928863"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219122437159.png" alt="image-20221219122437159"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：写出微分方程，然后根据重根写出通解</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219122537360.png" alt="image-20221219122537360"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219171005672.png" alt="image-20221219171005672"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219171042866.png" alt="image-20221219171042866"></p></div></div><hr><h3 id="综-3"><a href="#综-3" class="headerlink" title="综"></a>综</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213175753271.png" alt="image-20221213175753271"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：本题隐含了很多条件：<strong>光滑曲线$\implies$ 曲线连续且在连接处导数连续</strong></p><p>首先将曲线分成两段来算，在$[-\pi,0]$段，列出法线方程，就可以得到一个微分方程并解出</p><p>在$[0,\pi]$段，可以直接求解方程，加上光滑曲线这一隐含条件$y(0)$和$y’(0)$都要一致，求出完整方程</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213182740998.png" alt="image-20221213182740998"></p><p>注意法线方程的写法，$YX$表示的是变量，而$yx$表示的是曲线上某个点</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221214233457618.png" alt="image-20221214233457618"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：$tana=\frac{dy}{dx}$，对该式两边求导得出微分方程</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215000448809.png" alt="image-20221215000448809"></p><p>注意$\int cot dx=ln|sinx|+C$</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215181628323.png" alt="image-20221215181628323"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>求出$f(x)$后带入求$y’’=0$，猜出点即可</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215182841900.png" alt="image-20221215182841900"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216165933145.png" alt="image-20221216165933145"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216170805681.png" alt="image-20221216170805681"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217001135277.png" alt="image-20221217001135277"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：很经典的题，主要是要将变化率设为$-k$，$y’=-k(y-20)$，虽然算式中没有$x$，但是最终的结果和微分方程一样，会有$x$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217002836651.png" alt="image-20221217002836651"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217161207709.png" alt="image-20221217161207709"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：计算量很大，将$u(x)e^x$带入方程中创造出另外一个微分方程</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217162257752.png" alt="image-20221217162257752"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218163848391.png" alt="image-20221218163848391"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：解微分方程算出$y(x)$，之后轻松算出$V$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218163959150.png" alt="image-20221218163959150"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218235913041.png" alt="image-20221218235913041"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：把$\frac{1}{x}$和$x$互换写出微分方程，然后解微分方程</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219000145537.png" alt="image-20221219000145537"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219004356952.png" alt="image-20221219004356952"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219005445478.png" alt="image-20221219005445478"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219151034532.png" alt="image-20221219151034532"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：单纯计算量大</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219151104198.png" alt="image-20221219151104198"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219172400243.png" alt="image-20221219172400243"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：常规题</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219172429299.png" alt="image-20221219172429299"  /></p></div></div><hr><h2 id="多元微分"><a href="#多元微分" class="headerlink" title="多元微分"></a>多元微分</h2><h3 id="选-4"><a href="#选-4" class="headerlink" title="选"></a>选</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221212182419440.png" alt="image-20221212182419440"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：$dx$前面就是$x$的偏微分，$dy$前面是$y$的偏微分，所以(0,0)这个点是极小值，选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213210516154.png" alt="image-20221213210516154"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>重点是求偏导</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213210928295.png" alt="image-20221213210928295" style="zoom:80%;" /></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215155526056.png" alt="image-20221215155526056"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：当成两个一元函数即可，选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215234124654.png" alt="image-20221215234124654"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：常规计算</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215234441817.png" alt="image-20221215234441817"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216151600393.png" alt="image-20221216151600393"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：$f_{xx}×f_{yy}$必＜0，而$f_{xy}×f_{yx}$必＞0，故内部无最大最小值，选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216201513063.png" alt="image-20221216201513063"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：将$x，y$用$u，v$表示</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216202649669.png" alt="image-20221216202649669"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217033529570.png" alt="image-20221217033529570"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：基础题</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217033559182.png" alt="image-20221217033559182"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217193001588.png" alt="image-20221217193001588"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：显然$x$单增，$y$单减，所以选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218202922891.png" alt="image-20221218202922891"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：除了2，其他都对</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218203435449.png" alt="image-20221218203435449"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219120424933.png" alt="image-20221219120424933"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：写出$f(x,y)$的表达式即可</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219120924050.png" alt="image-20221219120924050"></p></div></div><hr><h3 id="填-4"><a href="#填-4" class="headerlink" title="填"></a>填</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215162021095.png" alt="image-20221215162021095"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：方程两边求导即可：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215162208577.png" alt="image-20221215162208577"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216163230560.png" alt="image-20221216163230560"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：先算出$z$，然后分别对$x$和$y$求偏导</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216163408413.png" alt="image-20221216163408413"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216230203631.png" alt="image-20221216230203631"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：常规题</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216230232790.png" alt="image-20221216230232790"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216230308399.png" alt="image-20221216230308399"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：分别求偏导即可</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216231120702.png" alt="image-20221216231120702"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217195054402.png" alt="image-20221217195054402"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：根据$x,y$的偏导推出$f(x,y)$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217195251771.png" alt="image-20221217195251771"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217232526858.png" alt="image-20221217232526858"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：对$x$求偏导数再代入即可</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217233309812.png" alt="image-20221217233309812"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218160811665.png" alt="image-20221218160811665"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：常规题</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218161008511.png" alt="image-20221218161008511"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218222018166.png" alt="image-20221218222018166"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：先代后求，简化运算</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218222306402.png" alt="image-20221218222306402"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219122244822.png" alt="image-20221219122244822"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：常规题</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219122316683.png" alt="image-20221219122316683"></p></div></div><hr><h3 id="综-4"><a href="#综-4" class="headerlink" title="综"></a>综</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213170414937.png" alt="image-20221213170414937"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：分别求出$x$和$y$的偏微分即可求出$dz$，而对$x$的偏微分再对$y$求导即可得出答案</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213171149652.png" alt="image-20221213171149652"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213171205341.png" alt="image-20221213171205341"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221214035704885.png" alt="image-20221214035704885"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：将$x$和$y$分别用$\xi$和$\eta$表示，然后简化</p><p>结果过于复杂，莫名奇妙</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221214232958080.png" alt="image-20221214232958080"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：常规题</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221214233426247.png" alt="image-20221214233426247"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215174045136.png" alt="image-20221215174045136"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：先确定关于x和y的偏导数为0</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215174515864.png" alt="image-20221215174515864"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216023208257.png" alt="image-20221216023208257"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：可以设$z=x^2+y^2$，用拉格朗日乘数法来计算，同时注意曲线的端点</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216024148189.png" alt="image-20221216024148189"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216171422606.png" alt="image-20221216171422606"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216172515067.png" alt="image-20221216172515067"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216233542536.png" alt="image-20221216233542536"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：根据条件求出$f(x,y)$，再求极值</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216234136231.png" alt="image-20221216234136231"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217154932150.png" alt="image-20221217154932150"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：算出$x，y，z$的关系，将其统一为一个一元方程，算出具体的点</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217160023774.png" alt="image-20221217160023774"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217201856341.png" alt="image-20221217201856341"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：常规题</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217202055000.png" alt="image-20221217202055000"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218004212218.png" alt="image-20221218004212218"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：题目不难，计算量极大，分给圆的长度为$x$，给正方形$y$，给三角形$z$，$x+y=z=2$ 用拉格朗日乘数法求解</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218004822026.png" alt="image-20221218004822026"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218004839559.png" alt="image-20221218004839559"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218174410853.png" alt="image-20221218174410853"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：题目不难，计算复杂</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218174447210.png" alt="image-20221218174447210"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218235142575.png" alt="image-20221218235142575"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：常规题</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218235421782.png" alt="image-20221218235421782"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219173744182.png" alt="image-20221219173744182"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219174942649.png" alt="image-20221219174942649"></p></div></div><hr><h2 id="多元积分"><a href="#多元积分" class="headerlink" title="多元积分"></a>多元积分</h2><h3 id="选-5"><a href="#选-5" class="headerlink" title="选"></a>选</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221212183041475.png" alt="image-20221212183041475"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>画出积分区域：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221212183256563.png" alt="image-20221212183256563" style="zoom:67%;" /></p><p>选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213224913594.png" alt="image-20221213224913594"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：根据定积分的定义，选D</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213225204713.png" alt="image-20221213225204713"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215155606527.png" alt="image-20221215155606527"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：根据对称性，实际上就是算图形的面积</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215160246955.png" alt="image-20221215160246955"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215234501021.png" alt="image-20221215234501021"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：画出积分区域，在$y&gt;0，x&lt;0$的情况下能保证最后的结果＞0，选B</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215234846528.png" alt="image-20221215234846528"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216202712701.png" alt="image-20221216202712701"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：甚至不需要画出积分区域即可做出来，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217030821395.png" alt="image-20221217030821395"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：从$0^{-}$逼近和从$0^{+}$逼近是不同的</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217032303944.png" alt="image-20221217032303944"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217223722109.png" alt="image-20221217223722109"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：画出积分区域后化简求值</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217223810208.png" alt="image-20221217223810208"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218145922925.png" alt="image-20221218145922925"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：可以用排除法，ABC都是对的，所以选D，也可以用比较法来判断</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218150731433.png" alt="image-20221218150731433"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：积分区域一样，比较被积函数，都是偶函数，比较第一象限内函数即可，$x&gt;sinx$，故1&gt;2，而3可能为负数，所以1&gt;2&gt;3</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218151341725.png" alt="image-20221218151341725"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219162400069.png" alt="image-20221219162400069"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：拆分出来求导就是了</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219163042796.png" alt="image-20221219163042796"></p></div></div><hr><h3 id="填-5"><a href="#填-5" class="headerlink" title="填"></a>填</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221214230643322.png" alt="image-20221214230643322"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：画出积分区域后用极坐标代替运算：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221214231202289.png" alt="image-20221214231202289"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217195303256.png" alt="image-20221217195303256"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：交换积分顺序后求解</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217195439704.png" alt="image-20221217195439704"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218161517302.png" alt="image-20221218161517302"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：经典的改变积分次序简化，但是要注意正负号！</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218162021745.png" alt="image-20221218162021745"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219122335094.png" alt="image-20221219122335094"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：改变次序后，再求导</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219122416339.png" alt="image-20221219122416339"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219171114837.png" alt="image-20221219171114837"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219171406614.png" alt="image-20221219171406614"></p></div></div><hr><h3 id="综-5"><a href="#综-5" class="headerlink" title="综"></a>综</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213171249889.png" alt="image-20221213171249889"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>首先是需要解一个微分方程，其中题目暗含两个条件：$y(x)$过(0,0)和D的面积为2，可以完整的求出$y(x)$，然后按旋转体体积公式进行计算</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213175028118.png" alt="image-20221213175028118"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213175101635.png" alt="image-20221213175101635"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：此题是标准的平移题，只要将$x-1=u,y-1=v$,即可极大程度简化运算</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213175717649.png" alt="image-20221213175717649"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221214195309236.png" alt="image-20221214195309236"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：本题是考察极坐标转换为普通坐标，画出积分区域求解</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221214200912761.png" alt="image-20221214200912761"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215002826432.png" alt="image-20221215002826432"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：第一问就是求旋转体体积，按对称性计算较简单  </p><p>第二问需要以截面为微元，即 $\pi x^2dy$，以$(2-y)$为距离进行积分</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215011240024.png" alt="image-20221215011240024"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215011327534.png" alt="image-20221215011327534"></p><p>结果是$\frac{27}{8}\pi pg$</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215011440112.png" alt="image-20221215011440112"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：多次应用换元法解出答案</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215013021947.png" alt="image-20221215013021947"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215174544649.png" alt="image-20221215174544649"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：先求出切点，然后选面积和体积</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215175018202.png" alt="image-20221215175018202"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215175214611.png" alt="image-20221215175214611"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：主要是确定$r$和$\theta$的范围，以及$xy$与极坐标的转化</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215181554534.png" alt="image-20221215181554534"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216012245277.png" alt="image-20221216012245277"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：常规计算题</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216013225761.png" alt="image-20221216013225761"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216013244876.png" alt="image-20221216013244876"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：画出积分区域，分成两块计算即可</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216013432512.png" alt="image-20221216013432512"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216025106677.png" alt="image-20221216025106677"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：常规计算，注意形心公式</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216025505368.png" alt="image-20221216025505368"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216164343937.png" alt="image-20221216164343937"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：算形心坐标：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216164729261.png" alt="image-20221216164729261"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216170838675.png" alt="image-20221216170838675"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：由对称性简化后求解</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216171346017.png" alt="image-20221216171346017"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216184130845.png" alt="image-20221216184130845"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：主要是写出具体的公式，$2\pi\int_1^2dx\int_{-1}^{f(x)}(y+1)dy$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216190804524.png" alt="image-20221216190804524"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216190821333.png" alt="image-20221216190821333"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216232814406.png" alt="image-20221216232814406"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：常规题</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216233512185.png" alt="image-20221216233512185"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216234200666.png" alt="image-20221216234200666"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：首先对称性简化，然后用常规方法解题</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217000319919.png" alt="image-20221217000319919"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217160114480.png" alt="image-20221217160114480"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：本题的特殊之处在于，用常规方程和极坐标方程都可以</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217160951404.png" alt="image-20221217160951404"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217162321922.png" alt="image-20221217162321922"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：要分别算出体积和表面积，体积是$V_1-V_2$，而表面积是$S_1+S_2$</p><p>对于参数方程来说，直接把公式中的$x，y$替换成参数计算即可</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217164626894.png" alt="image-20221217164626894"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217164741387.png" alt="image-20221217164741387"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：第一问需要二重积分交换次序，第二问需要用单调性</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217165828517.png" alt="image-20221217165828517"  /></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217165850317.png" alt="image-20221217165850317"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217202118199.png" alt="image-20221217202118199"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：利用定积分的定义化成定积分，再用分部积分法求解</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217202237908.png" alt="image-20221217202237908"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217202830884.png" alt="image-20221217202830884"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：常规题，注意点火公式的应用</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217204900075.png" alt="image-20221217204900075"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217235122807.png" alt="image-20221217235122807"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：和参数方程一样，根本不需要知道$g(x)$的具体表示，在$dx=x’dt$的时候，$g(x)$也换元成了$g(t)$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218003641058.png" alt="image-20221218003641058"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218164015947.png" alt="image-20221218164015947"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：本质上是算$sin\theta$的高次幂</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218164448014.png" alt="image-20221218164448014"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219000508252.png" alt="image-20221219000508252"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：前几年求$sin\theta$的高次幂，这次求$sec\theta$的高次幂了，实际上可以将$sec^3\theta dx$ 看做$secx dtan\theta$，即$\sqrt{1+tan^2x}dtanx$，$\int\sqrt{1+x^2}dx$可以由分部积分法计算出</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219001657363.png" alt="image-20221219001657363"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219151123519.png" alt="image-20221219151123519"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：注意$\theta$的变化范围要和$\rho$一致，所以并不是题目上的$0\sim\frac{\pi}{2}$，而是让$cos2\theta&gt;0$，所以是$0\sim \frac{\pi}{4}$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219151857590.png" alt="image-20221219151857590"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219173633483.png" alt="image-20221219173633483"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219173649433.png" alt="image-20221219173649433"></p></div></div><hr><h2 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h2><h3 id="选-6"><a href="#选-6" class="headerlink" title="选"></a>选</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221212234550994.png" alt="image-20221212234550994"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：首先求出分块矩阵的行列式的值，然后根据$A^<em>A=|A|E$，求出$A^</em>$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221212234902336.png" alt="image-20221212234902336"></p><p>选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221212235047369.png" alt="image-20221212235047369"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：首先将$Q^T$和$Q$用$P^T$和$P$和另外一个初等矩阵之积表达出来，然后进行运算</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213002615661.png" alt="image-20221213002615661"></p><p>选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213225229912.png" alt="image-20221213225229912"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：<img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213230247143.png" alt="image-20221213230247143"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213230403684.png" alt="image-20221213230403684"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：A的秩为3，那么必有一个特征值为0，然后要符合$\lambda^2+\lambda=O$，$\lambda=-1$符合这个条件，所以选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221214222528476.png" alt="image-20221214222528476"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：实际上是$P_2(AP_1)=E$，所以$A=P_2^{-1}P_1^{-1}$，而$P_2^{-1}=P_2$，所以选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221214223502796.png" alt="image-20221214223502796"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：首先判断出$r(A)=3$，则$r(A^<em>)=1$，所以有三个基础解系，$AA^</em>=O$，故$A$是一组解，而$A$中的$a_1$和$a_3$线性相关，故选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215160311353.png" alt="image-20221215160311353"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：$a_3+a_4$，可以直接得到$a_1$，所以选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215160812265.png" alt="image-20221215160812265"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：先写出PQ关系，再带入换算，选B</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215161333547.png" alt="image-20221215161333547"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215234904972.png" alt="image-20221215234904972"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：$B$可逆，相当于$A$经过初等列变化变为了$C$，所以选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215235217091.png" alt="image-20221215235217091"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：<img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216001209692.png" alt="image-20221216001209692"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216151755924.png" alt="image-20221216151755924"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：选一行直接展开即可</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216160525906.png" alt="image-20221216160525906"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216160542537.png" alt="image-20221216160542537"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：直接代入特殊值，$k,l=0$时，可知是必要非充分条件，选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216203208521.png" alt="image-20221216203208521"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：首先$|A|=0$，其次$r(A)=r(B)$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216210438243.png" alt="image-20221216210438243"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216210529324.png" alt="image-20221216210529324"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：和$P$对应即可，选A</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216210719810.png" alt="image-20221216210719810"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217033642383.png" alt="image-20221217033642383"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：将选项带入$P^{-1}XP$中，C明显不符合</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217033821799.png" alt="image-20221217033821799"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：可以直接算出特征值，也可以取$a=0$看是否符合条件，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217193351699.png" alt="image-20221217193351699"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：可以看出特征值就0,1,2,并且对应，所以选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217193515773.png" alt="image-20221217193515773"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：特征值一样的情况下，看特征值对应的矩阵的秩，明显$AC$相似，和$B$不与$C$相似，选$B$</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217223904945.png" alt="image-20221217223904945"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：首先可以看出特征值和行列式的值都一致，所以直接看特征值对应的矩阵的秩是否一致</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217224032114.png" alt="image-20221217224032114"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217224824309.png" alt="image-20221217224824309"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：$(A,B)$的写法意思是：把$AB$矩阵拼在一起，所以对$A$进行初等列变化不会改变分块矩阵的秩，选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218154235535.png" alt="image-20221218154235535"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：如果$A$的秩为2，那么$A^*$的秩为0</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218154338442.png" alt="image-20221218154338442"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：根据方程算出两个特征值，根据行列式算出最后一个特征值，写出规范性</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218154644412.png" alt="image-20221218154644412"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218215701990.png" alt="image-20221218215701990"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：$A_{12}≠0$，说明$A$的秩为3，$A^{*}$的秩为1,而且$A_{12}≠0$还表示第1,3,4列线性不相关，所以选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218220315387.png" alt="image-20221218220315387"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：$AX=\lambda X$，所以选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219121041834.png" alt="image-20221219121041834"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：全部算出来，然后看特征值</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219121505655.png" alt="image-20221219121505655"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219121520111.png" alt="image-20221219121520111"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：$r(B)≥r(A)$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219121804877.png" alt="image-20221219121804877"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219121823978.png" alt="image-20221219121823978"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：全部带进去算</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219121928615.png" alt="image-20221219121928615"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219164354868.png" alt="image-20221219164354868"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：按照可逆矩阵的定义，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219164756807.png" alt="image-20221219164756807"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：写出增广矩阵</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219165007160.png" alt="image-20221219165007160"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219165036014.png" alt="image-20221219165036014"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：写出这个两个矩阵，等价说明秩相同</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219165116971.png" alt="image-20221219165116971"></p></div></div><hr><h3 id="填-6"><a href="#填-6" class="headerlink" title="填"></a>填</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213164008857.png" alt="image-20221213164008857"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：根据秩为1的矩阵性质：</p><script type="math/tex; mode=display">l=\beta^{T}\alpha=\alpha^{T}\beta=∑a_{ii}</script><p>可以快速算出其值为2</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213233844935.png" alt="image-20221213233844935"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：原式拆成$|B^{-1}(A^{-1}+B)A|$，可以得到值为$\frac{1}{2}×2×3=3$</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221214231231639.png" alt="image-20221214231231639"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：求出特征值即可</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221214231510817.png" alt="image-20221214231510817"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215165144426.png" alt="image-20221215165144426"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：$|B|=-|A|$,而$|A^*|$的值也好求</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215165719091.png" alt="image-20221215165719091"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216010634859.png" alt="image-20221216010634859"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：最主要的是，$A^{T}=-A^{*}$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216011531034.png" alt="image-20221216011531034"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216164758028.png" alt="image-20221216164758028"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：负惯性系数为1$\implies$其行列式的值$≤0$ </p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216165548448.png" alt="image-20221216165548448"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216165628636.png" alt="image-20221216165628636"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216231130622.png" alt="image-20221216231130622"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：把特征值带入方程即可</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216231221345.png" alt="image-20221216231221345"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217152928462.png" alt="image-20221217152928462"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：秩要相同，算出a的可能取值，再排除一个</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217154235448.png" alt="image-20221217154235448"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217194925372.png" alt="image-20221217194925372"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：$AX=\lambda X$，算出$a$的值</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217195035795.png" alt="image-20221217195035795"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217233334776.png" alt="image-20221217233334776"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：写出矩阵，计算特征值即可</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217233417188.png" alt="image-20221217233417188"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218162043060.png" alt="image-20221218162043060"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：单纯计算题</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218162137971.png" alt="image-20221218162137971"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218224940886.png" alt="image-20221218224940886"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：化简之后计算即可</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218225011350.png" alt="image-20221218225011350"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219122553083.png" alt="image-20221219122553083"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：利用逆序数解题</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219122629192.png" alt="image-20221219122629192"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219171501163.png" alt="image-20221219171501163"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：只要算出$A$矩阵的迹，就可以知道$A^{-1}$的迹</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219172204115.png" alt="image-20221219172204115"></p></div></div><hr><h3 id="综-6"><a href="#综-6" class="headerlink" title="综"></a>综</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213184623466.png" alt="image-20221213184623466"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：第1问是单纯的基础解系问题，至于第2问，需要列出通式，利用$A\xi_1=0$这个条件化简从而得出结论</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213185042568.png" alt="image-20221213185042568"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213185100079.png" alt="image-20221213185100079"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213185118909.png" alt="image-20221213185118909"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>只要求出了特征值以后，保证两个特征值&gt;0，剩下一个特征值为0即可求出$a$的值</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213190047942.png" alt="image-20221213190047942"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221213190103073.png" alt="image-20221213190103073"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221214202135886.png" alt="image-20221214202135886"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：存在多个解肯定不满秩，所以可以求出$\lambda$和$a$的值</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221214202708650.png" alt="image-20221214202708650"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221214202726707.png" alt="image-20221214202726707"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：根据$AX=\lambda X$求解出$a$，然后算出其他特征值，求解出基础解系，正交化后写出$Q$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221214205835253.png" alt="image-20221214205835253"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221214205848687.png" alt="image-20221214205848687"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215013052528.png" alt="image-20221215013052528"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：$\beta_1，\beta_2，\beta_3$组成的矩阵的行列式的值肯定为0，可以直接算出$a$</p><p>然后按求解方程组的办法表示$\beta_1，\beta_2，\beta_3$，因为$a_1,a_2,a_3$是满秩矩阵，所以化简得到矩阵的列向量即是答案</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215013931511.png" alt="image-20221215013931511"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215014121267.png" alt="image-20221215014121267"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：特征值很好求，特征向量可以根据正交矩阵的特质求出</p><p>重点是第二问，需要按相似矩阵的方式，$P^{-1}AP=\Lambda$，这样求出矩阵$A$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215014950526.png" alt="image-20221215014950526"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215015004605.png" alt="image-20221215015004605"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215015025080.png" alt="image-20221215015025080"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215190831463.png" alt="image-20221215190831463"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：有无穷多解的前提是行列式为0，根据$a$的值的可能性，化简矩阵，得到正确答案</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215203939344.png" alt="image-20221215203939344"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215203956940.png" alt="image-20221215203956940"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：$A^T$和$A$的秩是一样的，所以可以求出$A$的值，然后对$AA^T$矩阵求特征值，正交化特征向量即可</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215204330425.png" alt="image-20221215204330425"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221215204403855.png" alt="image-20221215204403855"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216031244396.png" alt="image-20221216031244396"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：先把C矩阵假设出来，再带入列出方程，按照方程组有解的情况算出a，b，再解基础解系即可</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216032152498.png" alt="image-20221216032152498"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216032337171.png" alt="image-20221216032337171"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216032356363.png" alt="image-20221216032356363"></p><p>根据二次型的定义解决第1问，根据特征向量的定义解出第2问</p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216033542978.png" alt="image-20221216033542978"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216190849652.png" alt="image-20221216190849652"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：注意给最后一行添0后计算，针对第二个问，假设B为3个列向量，相当于解3个基础解系，可以一起算</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216191958436.png" alt="image-20221216191958436"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216192028788.png" alt="image-20221216192028788"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：求出第1个矩阵的特征值即可，要把每列的值加在第一列，提出来可化简，发现特征值和第2个矩阵一样</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221216194433980.png" alt="image-20221216194433980"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217005255883.png" alt="image-20221217005255883"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：$|A|=0$，算出a，然后化简方程就可以求出$X$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217014429981.png" alt="image-20221217014429981"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217014446974.png" alt="image-20221217014446974"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217014630065.png" alt="image-20221217014630065"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：根据迹相等和行列式值相等就可以算出来$a，b$的值了，之后算A的对角矩阵属于常规题</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217014913778.png" alt="image-20221217014913778"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217165928658.png" alt="image-20221217165928658"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：无解说明$r(B)&gt;r(A)$，算出A的值</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217170110022.png" alt="image-20221217170110022"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217170129206.png" alt="image-20221217170129206"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：求A的高次幂，需要用相似矩阵求$P^{-1}A^{99}P=\Lambda^{99}$，所以求出$P$和$\Lambda$即可</p><p>$B^{100}=BA^{99}$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217170650014.png" alt="image-20221217170650014"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217170710141.png" alt="image-20221217170710141"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217205909046.png" alt="image-20221217205909046"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：因为$a_3$能被其他表示出来，所以$r<3$，因为3个不同的特征值，所以$r>1$，是2</p><p>第2问相当于在求基础解系,显然$(1,1,1)$是特解，找到通解即可</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217210439510.png" alt="image-20221217210439510"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217210458269.png" alt="image-20221217210458269"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：标准形只有2个系数说明有一个特征值为0，所以矩阵的行列式为0求出$a$，然后就是常规方法求正交矩阵</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217210901681.png" alt="image-20221217210901681"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221217210916211.png" alt="image-20221217210916211"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218025052572.png" alt="image-20221218025052572"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：得用配方法表示括号里面的数，构造一个矩阵，说明矩阵内行列式为0</p><p>而第2问是重点，因为拉格朗日配方法是只有用于可逆矩阵中，所以必须$a≠2$时才能用，其表示的规范形就如题所示，本质上就是做了坐标变化，而当$a=2$时就不能用配方法，而是求特征值的方式，来算特征值</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218025256029.png" alt="image-20221218025256029"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218030222955.png" alt="image-20221218030222955"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218030315171.png" alt="image-20221218030315171"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：$AB$的秩肯定是一样的，所以可算出$a$，然后根据基础解系的方法，$AX=B$，相当于算三个基础解系，组合成一个矩阵，即是$P$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218030524562.png" alt="image-20221218030524562"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218175724910.png" alt="image-20221218175724910"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：等价也就是秩相等，算出$a$的可能取值，再带入验证，之后就是常规的解基础解系</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218175917619.png" alt="image-20221218175917619"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218175934426.png" alt="image-20221218175934426"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218180037012.png" alt="image-20221218180037012"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218180056074.png" alt="image-20221218180056074"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：第1问好求，而求解第2问，需要用等式$P^{-1}AP=Q^{-1}BQ$，则$(PQ^{-1})^{-1}A(PQ^{-1})=B$，最终但是$PQ^{-1}$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218180623172.png" alt="image-20221218180623172"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218180718790.png" alt="image-20221218180718790"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218180731527.png" alt="image-20221218180731527"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219011133607.png" alt="image-20221219011133607"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：$y$和$x$有相同的秩，可以求出$a$</p><p>根据$A^TXA=B^TYB$，$(AB^{-1})^{T}XAB^{-1}=Y$</p><p>但是因为两个矩阵的特征值不一样，只能用配方法求规范性</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219031732370.png" alt="image-20221219031732370"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219031751968.png" alt="image-20221219031751968"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219031812112.png" alt="image-20221219031812112"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：第1问易证</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219032630286.png" alt="image-20221219032630286"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219152539221.png" alt="image-20221219152539221"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：仅仅有2个不同的特征值，说明其特征值方程有重根，列出特征值方程，发现有2种情况，分类讨论即可</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219152941057.png" alt="image-20221219152941057"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219153010633.png" alt="image-20221219153010633"></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219174133914.png" alt="image-20221219174133914"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：常规解正交矩阵，而f(x)的最大值和最小值，取决于系数的最大最小值</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219174157476.png" alt="image-20221219174157476"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221219174239882.png" alt="image-20221219174239882"></p></div></div>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.660总结</title>
      <link href="/post/7676.html"/>
      <url>/post/7676.html</url>
      
        <content type="html"><![CDATA[<h1 id="660总结"><a href="#660总结" class="headerlink" title="660总结"></a>660总结</h1><p>极限与连续(重点题)：</p><p>4：等价无穷小代换</p><p>5：高阶根号下将x抽出来，根号要注意到$(1+x)^a-1\sim ax$的无穷小代换</p><p>6：泰勒公式</p><p>7：同5，高阶根号下的等价无穷小</p><p>8：在$\infty^0$的类似的形式，一般都是要进行$e^{lnf(x)}$的变换，所以将底数化成$1+g(x)$的形式，指数就是$ln(1+g(x))$，方便等价无穷小的替换</p><p>10：$a^x$的形式，优先考虑$a^x-1$的代换，同时也可以用中值定理求解</p><p>11：一个冷门极限的知识</p><p>12：和10一样，此题用中值定理最为方便</p><p>13：此题要用单调有界准则，首先证明是有界的，然后要证明其实单调的，就可以将$x_n$和$x_{n-1}$都转换为$x$</p><p>17：没有思路那就泰勒公式，注意要将$x$换为趋向于$0$的情况</p><p>18：对于$e^{x}$或$e^{\frac{1}{x}}$的形式的极限，最好还是通过变换，将让$e^x$趋向于$-\infty$，从而使之等于0</p><p>19：注意分母是$3^n$，所以不能用重要极限，因为要同时趋近于0，所以要用泰勒公式，不如说$(1+\frac{1}{n})^{n^2}=e^{n^2ln(1+\frac{1}{n})}$，然后泰勒公式$ln(1+\frac{1}{n})=\frac{1}{n}-\frac{1}{2n^2}$,最后结果是$n-\frac{1}{2}$</p><p>25：需要讨论$x$的值，同时要用到18题的技巧</p><p>123：极限的存在运算</p><p>127：注意泰勒公式</p><p>128：放缩常用的不等式：$1+x&lt;e^x$</p><p>131：$cosx$的减法，直接变换成加法，就可以消去了</p><p>132：非常经典的中值定理的应用</p><p>133：和19题可以说是一模一样了</p><p>137：有两个$n$在变，所以可以分别确定一个来放缩</p><p>427：灵活运用放缩</p><p>430：注意提取e出来</p><p>434：中值定理的应用</p><p>435：利用三角函数的内部周期，加上了$n\pi$，然后让函数内部能用等价无穷小代换</p><p>444：如果$sin\pi x$不是0的话，那就没有间断点了，所以间断点只能是让$sin\pi x$为0的点</p><p>465：众所周知，$x\to0\qquad ln(x+1)\to x$，而在这道题中是$x\to 1\qquad ln(x)\to x-1$</p><p>516：注意洛必达使用的条件</p><hr><p>一元函数微分学：</p><p>27：注意分段点的导数</p><p>30：需要从定义入手，很经典</p><p>33：将$x^2$抽出来，然后再求导</p><p>47：运用了一个结论：即有界函数$f(x)$在$(a,+\infty)$可导，的$\lim _{x\to+\infty} f’(x)=0$</p><p>154：讨论了$lim_{x \to x_0}f’(x)$和$f’(x)$，在连续的情况下：$lim_{x \to x_0}f’(x)$才有意义</p><p>157：需要应用到中值定理：已知$f(x)=0$：$f(x)=xf’(\xi)$，$0&lt;\xi&lt;x$</p><p>161：只须考察$f(x)$在$x = x_0$处的连续性及$f(x)$在$x = x_0$两侧$f’(x),f’’(x)$是否变号，而不须考虑$f’(x),f’’(x)$是否存在就可判定$x = x_0$是否是$f(x)$的极值点与拐点<br>$f(x)$在$x = x_0$不可导,$x = x_0$与$(x = f(x_0))$可以同时是$y=f(x)$的极值点与拐点，但对于可导函数，可以证明：若$(x = f(x_0))$是$y=f(x)$的拐点，则$x = x_0$不可能是$f(x)$的极值点.</p><p>449：反函数的二阶导</p><p>453：将e的指数化成方便计算的形式</p><p>459：找驻点</p><p>462：首先需要确定的是$f(1)$的值，然后就可以用定义去做了</p><p>466：分解因式法</p><p>536：注意泰勒公式，将$\frac{1}{2!}f’’(x)$展开成$f(x)-f’(a)(x-a)$是非常经典的展开，有助于判定极值，拐点的性质</p><p>538：关于导数的绝对值是否可导的结论</p><hr><p>积分：</p><p>52：$\int f(x)dx$形式，$f(x)$是一整个根式的话，可以将根式代换成另一个未知数$t$，再进行积分</p><p>53：如果$f(x)$的分式的分母是两个多项式相减或相加，考虑将其化为相乘的形式，再将其拆开</p><p>54：$f(x)$的分式的分母是一整个根式的话，那就考虑直接进行换元，因为很好化简</p><p>55：和53一样，将分母化成了相乘的形式</p><p>56：运用了此类积分的一个技巧</p><p>57：可以将$x$升阶</p><p>58：将定积分设为未知数求解</p><p>61：如果积分形式是$sinx$等三角函数，可以自由改变积分上下限，比如$x=\pi-s$之类的</p><p>64：难以处理的积分，考虑换元之后再相加</p><p>65：分段函数的积分，考虑对每段设置不同的原函数，利用连续性求解C</p><p>67：和57题一样的处理</p><p>69：遇到$e^x$在分子上，先直接积进去再说，然后分部积分求极限</p><p>183：这道选择题很难，其中BC选项用的是61题的方法，而AD用的是另外一种方法，即直接将1化成积分内部的函数形式来比较，这样就可以通过判断积分函数来判断其正负性</p><p>185：用183的方法好判断</p><p>187：在$[0,\pi]$区间上，$cosx$是不确定的，应该分为$[0,\pi/2]$和$[\pi/2,\pi]$上讨论</p><p>188：因为根式底部有$x^2$，可以将$x=sin^2t$,进行代换</p><p>189：和上题一样，可以直接用$x=sin^2t$代换</p><p>198：考虑代入法</p><p>203：考虑到不同类型的定积分求导</p><p>204：连续不一定收敛</p><p>467：直接凑微分把分母积分进去了</p><p>469：注意将$ln$拆开从而判定奇偶性</p><p>471：先是一个换元，然后对两侧积分就可解出</p><p>472：一个结论</p><p>478：从要求的函数入手，用分部积分法将其转换为$f(x)$和$f’(x)$的形式</p><p>479：将$f(x)=F’(x)$升阶，这样的话，就可以在等式两边积分，从而求出$F(x)^2$，$F(x)$和$F’(x)$了</p><p>480：用$tanx$代换，同时需要考虑到原函数连续的问题</p><p>485：将$ln$拆开，然后视作整体，用分部积分法</p><p>491：经典题</p><p>552：注意到导数的定义</p><p>558：关于极值点讨论的经典题</p><p>560：依旧是关于一阶导，二阶导和极值点的讨论</p><p>566：$f(x)+f’(x)$和$e^{x}f(x)$的导数即$e^x(f(x)+f’(x))$有相同的零点，然后去讨论其零点分布，思想很重要</p><p>568：导函数不一定连续，有可能有震荡间断点</p><p>575：注意到重要无穷积分</p><p>578：将$f(x)$视作$F’(x)$，即可将积分变成函数，即可假设其原函数了</p><p>580：直接将$x$的积分视作是$y$的导数了</p><p>585：观察到两个函数的构造，$cosx-xsinx$正是$xcos$的导数</p><p>587：这种题直接观察结构，$g(a+x)=-g(a-x)$，一看就是关于$a$点对称</p><p>591：$cosx$显然是$x$越接近$0$越大，而$sinx$是接近$\frac{\pi}{2}$</p><p>595：可以化成587题的形式，所以积分为0</p><p>599：复杂</p><p>600：无穷积分也有类似的经典题，将无穷积分视作是常数，然后对两端进行积分</p><hr><p>微分方程</p><p>212：周期积分的性质</p><p>213：$b,c$为正，则$r_1，r_2$为负，那都等于0</p><p>491：注意到$y/x$的形式</p><p>492：微分方程的特解，要带入到方程中求出具体的参数</p><p>498：先将积分化为极坐标形式，在两边求导即可得到微分方程</p><hr><p>多元函数的微积分学</p><p>92：将复合函数也看做一个整体的函数以简化运算</p><p>94：有绝对值的函数注意要分段求</p><p>97：因为符合标准的定义，所以可以全微分</p><p>98：和97不同的是等式右边的值是1，但是$x^2+y^2$是$\sqrt{x^2+y^2}$的高阶无穷小，所以最后仍然也可以看做是全微分的标准式咯</p><p>109：极坐标下的交换次序</p><p>111：遇到不好积分的函数，交换次序打开思路</p><p>113：经典的关于$y=x$对称图像</p><p>114：可以平移图形，让圆心处于原点</p><p>118：很经典，在一元函数的积分中也出现过，将等式右边的积分看做一个确定的值就行</p><p>231：判定重极限是否存在，使用放缩，或者假设一个参数以某种方式逼近，比如$y=kx$</p><p>235：和98类似，但是分母和$\sqrt{x^2+y^2}$是同阶的，那么就不符合可微的定义了，然后根据定义求偏导数是否连续</p><p>245：可以将不好求导的函数设为$g(x)$</p><p>249：要按隐函数求导的法则求出$y’’$</p><p>256：分成一个关于$x$对称的区域，和一个关于$y$对称的区域</p><p>260：交换次序方便求导</p><p>261：和114一样，平移之后再根据对称性做题</p><p>268：注意到$arctan\frac{y}{x}=\theta$</p><p>269：难点是求$\frac{1}{cos^3\theta}d\theta$的积分</p><p>270：都是一个形式的被积函数，就比较被积函数在区域中是否大于1</p><p>273：积分中值定理</p><p>274：和118一样</p><p>275：利用分部积分法                         </p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.多元函数微积分学</title>
      <link href="/post/1182.html"/>
      <url>/post/1182.html</url>
      
        <content type="html"><![CDATA[<h1 id="多元函数微积分学"><a href="#多元函数微积分学" class="headerlink" title="多元函数微积分学"></a>多元函数微积分学</h1><h2 id="多元函数"><a href="#多元函数" class="headerlink" title="多元函数"></a>多元函数</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>定义</p><p>假设$D$是二维向量$(x,y)$的集合，$D$上的$\color{Salmon}{二元函数}$$\ f$是一个映射法则，它对$D$内的每一个有序对$(x,y)$​指定唯一的一个实数：</p><script type="math/tex; mode=display">z=f(x,y),\quad (x,y)\in D</script><p>如果用$P$来代替$(x,y)$的话，也可以写作：</p><script type="math/tex; mode=display">z=f(P),\quad P\in D</script><p>$D$称为$f$的$\color{Salmon}{定义域}$，$x、y$（或$(x,y)$，或$P$）称为$f$的$\color{Salmon}{自变量}$，$z$称为$f$的$\color{Salmon}{因变量}$</p><hr><p>定义域</p><p>二元函数的定义域$D$是二维向量$(x,y)$的集合。因为二维向量$(x,y)$又代表了二维平面上的点，所以这样的集合也称为$\color{Salmon}{平面点集}$</p><hr><p>邻域</p><p>二维向量的邻域要比一维向量的复杂。对于二维向量$P_0(x_0,y_0)$而言，半径为$\delta\ \color{Salmon}{邻域}$可以表示为平面点集：</p><script type="math/tex; mode=display">U(P_0,\delta)=\{(x,y)\ |\ (x-x_0)^2 + (y-y_0)^2 < \delta^2\}</script><p>该$\delta$邻域代表的是，以$P_0(x_0,y_0)$为圆心，半径为$\delta$的圆内的点（注意不包含的圆的边界）：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220819164636137.png" alt="image-20220819164636137"></p><p>从$U(P_0,\delta)$中去掉中心$P_0(x_0,y_0)$，称为点$P_0(x_0,y_0)$的$\delta\ \color{Salmon}{去心邻域}$，记作：$\mathring{U}(P_0,\delta)$，可以图示为：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220819165400708.png" alt="image-20220819165400708"></p><hr><h3 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h3><p><strong>聚点</strong></p><p>如果对于任意给定的$\delta &gt; 0$，点P的去心邻域$\mathring{U}(P,\delta)$内总有平面点集E中的点，那么称点$P$为$E$的$\color{Salmon}{聚点}$。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220819165822021.png" alt="image-20220819165822021"></p><p>定义聚点是为了保证，从$P_0(x_0,y_0)$的某去心邻域内的某一点$P(x,y)$出发，至少能找到一串完全在$E$中的点来靠近$P_0$</p><p><strong>极限定义</strong>：</p><p>设二元函数$f(x,y)$的定义域为$D，P_0(x_0,y_0)$是$D$的聚点。如果存在常数$L$，对于任意给定的正数$\epsilon$，总存在正数$\delta$​，使得当点P(x,y)满足下列条件时：</p><script type="math/tex; mode=display">(x,y)\in D\cap \mathring{U}(P_0,\delta)</script><p>都有：</p><script type="math/tex; mode=display">|f(x,y)-L| < \epsilon</script><p>成立，那么就称常数$L$为函数$f(x,y)$当$(x,y)\to(x_0,y_0)$时的极限，记作：</p><script type="math/tex; mode=display">\lim_{(x,y)\to(x_0,y_0)}f(x,y)=L\quad 或\quad f(x,y)\to L\ \big(\ (x,y)\to(x_0,y_0)\ \big)</script><p>因为这是二元函数的极限，所以也称作$\color{Salmon}{二重极限}$。</p><script type="math/tex; mode=display">\begin{array}{c|c} \hline \quad 一元函数的极限 \quad&\quad 二元函数的极限\quad\\ \hline \\ \quad 函数f(x)在\mathring{U}(x_0)上有定义\quad&\quad 二元函数f(x,y)的定义域为D \quad \\ \quad 0 < |x - x_0| < \delta \quad&\quad (x,y)\in D\cap \mathring{U}(P_0,\delta) \quad\\ \\ \hline \end{array}</script><p>同一元函数的极限相同，随着$\epsilon$的缩小，始终能够找到合适的$\delta$，使得对应的函数值都在$\epsilon$规定的区间内</p><hr><p>求重极限的方法：</p><ol><li>利用极限性质(四则运算法则，夹逼原理)</li><li>消去分母中极限为0的因子</li><li>利用无穷小量与有界变量之积为无穷小量</li></ol><hr><h3 id="连续"><a href="#连续" class="headerlink" title="连续"></a>连续</h3><p>二元函数$f(x,y)$的定义域为$D，P_0(x_0,y_0)$是$D$的聚点，且$P_0\in D$​，如果：</p><script type="math/tex; mode=display">\lim_{(x,y)\to(x_0,y_0)}f(x,y)=f(x_0,y_0)</script><p>那么称函数$f(x,y)$在点$P_0(x_0,y_0)\ \color{Salmon}{连续}$。</p><p>性质：</p><ol><li>多元连续函数的和，差，积，商仍为连续函数</li><li>多元连续函数的复合函数也是连续函数</li><li>多元初等函数在其定义区域内连续</li><li>(最大值定理)：有界闭区间$D$上的连续函数在区域$D$上必能取得最大值和最小值</li><li>(介值定理)：有界闭区间$D$上的连续函数在区域$D$上必能取得介于最大值与最小值之间的任何值</li></ol><hr><h2 id="全微分"><a href="#全微分" class="headerlink" title="全微分"></a>全微分</h2><p>单变量微积分中，可以用$\color{Salmon}{切线}$来近似（“代替”）$x_0$点附近的曲线，在多变量函数中，需要找到一个平面来近似$(x_0,y_0)$附近的曲面</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220819181412491.png" alt="image-20220819181412491"></p><p>设函数$z=f(x,y)$在点$(x_0,y_0)$的某邻域内有定义，假设：</p><script type="math/tex; mode=display">\Delta x=x-x_0,\quad \Delta y=y-y_0</script><p>如果函数$z=f(x,y)$在点$(x_0,y_0)$的$\color{Salmon}{全增量}$：</p><script type="math/tex; mode=display">\Delta z=f(x_0+\Delta x, y_0+\Delta y)-f(x_0, y_0)</script><p>可以表示为：</p><script type="math/tex; mode=display">\Delta z=A\Delta x+B\Delta y+o(\rho)=A\Delta x+B\Delta y+\epsilon_1\Delta x+\epsilon_2\Delta y</script><p>其中$A、B$不依赖于$\Delta x、\Delta y$，且：</p><script type="math/tex; mode=display">\rho=\sqrt{(\Delta x)^2+(\Delta y)^2},\quad \lim_{\Delta x\to 0}\epsilon_1=0,\quad \lim_{\Delta y\to 0}\epsilon_2=0</script><p>那么称$z=f(x,y)$在点$(x_0,y_0)$处$\color{Salmon}{可微分}$，而$A\Delta x+B\Delta y$称为$z=f(x,y)$在点$(x_0,y_0)$处的$\color{Salmon}{全微分}$（或称为$\color{Salmon}{切平面}$），记作$\mathrm{d}z$，即：</p><script type="math/tex; mode=display">\mathrm{d}z=A\mathrm{d}x+B\mathrm{d}y</script><hr><p>核心是如下几点：</p><ul><li>平面方程为（也就是所谓的全微分）：</li></ul><script type="math/tex; mode=display">\mathrm{d}z=A\mathrm{d}x+B\mathrm{d}y</script><ul><li>曲面方程为（也就是所谓的全增量）：</li></ul><script type="math/tex; mode=display">\Delta z=f(x_0+\Delta x, y_0+\Delta y)-f(x_0, y_0)</script><ul><li>曲面方程和平面方程的关系如下，可见两者相差了一个高阶无穷小，并且越接近$(x_0,y_0)$，两者越近似：</li></ul><script type="math/tex; mode=display">\underbrace{\Delta z}_{\large 曲面方程}=\underbrace{A\Delta x+B\Delta y}_{\large 平面方程}+o(\rho)=A\Delta x+B\Delta y+\epsilon_1\Delta x+\epsilon_2\Delta y</script><script type="math/tex; mode=display">o(\rho)=o(\sqrt{(\Delta x)^2+(\Delta y)^2})</script><p>其中$\sqrt{(\Delta x)^2+(\Delta y)^2}$就是邻域内的点与$(x_0,y_0)$的距离。所以这个形式说明了，无论以什么方式靠近$(x_0,y_0)$，曲面和平面都会越来越接近（其差值趋于0）。</p><p>由于是平面，且是高阶无穷小，所以是$\color{Salmon}{最佳线性近似}$</p><hr><h2 id="偏导数"><a href="#偏导数" class="headerlink" title="偏导数"></a>偏导数</h2><h3 id="切平面"><a href="#切平面" class="headerlink" title="切平面"></a>切平面</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220821161419879.png" alt="image-20220821161419879"></p><p>已知曲面在$(x_0,y_0)$点的切平面存在的前提，需要得到该切平面的方程</p><p>求解方法就是：需要知道其中两条不重合切线的方程就可以求出平面的方程。</p><hr><p>$y=y_0$的交线</p><p>寻找最容易计算的两条切线。比如平面$y=y_0$和曲面$f(x,y)$相交的曲线如下：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220821161708378.png" alt="image-20220821161708378"></p><p>这个曲线的方程为：</p><script type="math/tex; mode=display">\begin{cases}    f(x,y)\\    y=y_0\end{cases}</script><p>也就说是，这个曲线的$y$自变量是固定的，是常数，因此曲线方程实际上相当于一元函数：</p><script type="math/tex; mode=display">\left.\begin{aligned}    f(x,y)\\    y=y_0\end{aligned}\right\}\implies f(x,y_0)</script><p>该一元函数在$x=x_0$点（相当于二元函数在(x_0,y_0)点）的导数可以如下计算，知道该导数后就可以计算该曲线的切线了（这里暂时不计算切线，后面再来讨论）：</p><script type="math/tex; mode=display">f_x(x_0,y_0)=\left.\frac{\mathrm{d}}{\mathrm{d}x}f(x,y_0)\right|_{x=x_0}</script><hr><p>$x=x_0$的交线</p><p>同样的还有平面$x=x_0$和曲面$f(x,y)$相交的曲线如下：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220821161837216.png" alt="image-20220821161837216"></p><p>这条曲线的x自变量是固定的，是常数，因此曲线方程也是一元函数：</p><script type="math/tex; mode=display">\left.\begin{aligned}    f(x,y)\\    x=x_0\end{aligned}\right\}\implies f(x_0,y)</script><p>该一元函数在$y=y_0$点（相当于二元函数在($x_0,y_0$)点）的导数可以如下计算，知道该导数也可以计算该曲线的切线了：</p><script type="math/tex; mode=display">f_y(x_0,y_0)=\left.\frac{\mathrm{d}}{\mathrm{d}y}f(x_0,y)\right|_{y=y_0}</script><p>$x=x_0$与$y=y_0$是两个正交的平面：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220821161943043.png" alt="image-20220821161943043"></p><p>因此两条切线必然不重合，所以根据其两条交线求出其切平面</p><hr><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>在点$(x_0,y_0)，f(x,y)\ \color{Salmon}{关于x的偏导数}$是：</p><script type="math/tex; mode=display">\left.\frac{\partial f}{\partial x}\right|_{(x_0,y_0)}=\left.\frac{\mathrm{d}}{\mathrm{d}x}f(x,y_0)\right|_{x=x_0}=\lim_{h\to 0}\frac{f(x_0+h,y_0)-f(x_0,y_0)}{h}</script><p>在点$(x_0,y_0)，f(x,y)\ \color{Salmon}{关于y的偏导数}$是：</p><script type="math/tex; mode=display">\left.\frac{\partial f}{\partial y}\right|_{(x_0,y_0)}=\left.\frac{\mathrm{d}}{\mathrm{d}y}f(x_0,y)\right|_{y=y_0}=\lim_{h\to 0}\frac{f(x_0,y_0+h)-f(x_0,y_0)}{h}</script><p>只要该极限存在。</p><p>这两个偏导数就是刚才找到的两根切线的导数，通过它们就可以得到这两根切线的方程，进而可以得到切平面的方程</p><script type="math/tex; mode=display">\mathrm{d}z=f_x(x_0,y_0)\mathrm{d}x+f_y(x_0,y_0)\mathrm{d}y</script><hr><h3 id="高阶偏导数"><a href="#高阶偏导数" class="headerlink" title="高阶偏导数"></a>高阶偏导数</h3><p>偏导数也是函数，所以可以继续对它求偏导数，所得结果可以称为$\color{Salmon}{二阶偏导数}$，根据求导次序不同有下列四种二阶偏导数：</p><script type="math/tex; mode=display">\begin{array}{l}{\frac{\partial}{\partial x}\left(\frac{\partial z}{\partial x}\right)=\frac{\partial^{2} z}{\partial x^{2}}=f_{x x}(x, y), \quad \frac{\partial}{\partial y}\left(\frac{\partial z}{\partial x}\right)=\frac{\partial^{2} z}{\partial x \partial y}=f_{x y}(x, y)} \\ {\frac{\partial}{\partial x}\left(\frac{\partial z}{\partial y}\right)=\frac{\partial^{2} z}{\partial y \partial x}=f_{y x}(x, y), \quad \frac{\partial}{\partial y}\left(\frac{\partial z}{\partial y}\right)=\frac{\partial^{2} z}{\partial y^{2}}=f_{yy}(x, y)}\end{array}</script><p>上面的第二、三个又称为$\color{Salmon}{混合偏导数}$，它们满足下列条件时相等：</p><p>如果函数$z=f(x,y)$的两个混合偏导数在区域$D$内连续，那么必有：</p><script type="math/tex; mode=display">f_{x y}(x, y)=f_{y x}(x, y),\quad (x,y)\in D</script><hr><h3 id="全微分与偏导数"><a href="#全微分与偏导数" class="headerlink" title="全微分与偏导数"></a>全微分与偏导数</h3><p>如果函数$z=f(x,y)$在点$(x_0,y_0)$可微分，那么该函数在点$(x_0,y_0)$的偏导数$f_x(x_0,y_0)$、$f_y(x_0,y_0)$必定存在，且$z=f(x,y)$在点$(x_0,y_0)$​的全微分为：</p><script type="math/tex; mode=display">\mathrm{d}z=f_x(x_0,y_0)\mathrm{d}x+f_y(x_0,y_0)\mathrm{d}y</script><div class="hide-toggle" style="border: 1px solid #66c3ee"><div class="hide-button toggle-title" style="background-color: #66c3ee;color: black"><i class="fas fa-caret-right fa-fw"></i><span>证明过程</span></div>    <div class="hide-content"><p>根据函数$z=f(x,y)$在点$P(x_0,y_0)$可微分，可以得到对于$P$点的某个邻域内任意一点$P’(x_0+\Delta x,y+\Delta y)$​有：</p><script type="math/tex; mode=display">\Delta z=A\Delta x+B\Delta y+o(\sqrt{(\Delta x)^2+(\Delta y)^2})</script><p>当$\Delta y=0$时，上式也成立，可以改写为：</p><script type="math/tex; mode=display">\Delta z=A\Delta x+o(|\Delta x|)</script><p>两边同时除以$\Delta x$。再令$\Delta x\to 0$，可得：</p><script type="math/tex; mode=display">f_x(x_0,y_0)=\lim_{\Delta x\to 0}\frac{f(x_0+\Delta x,y_0)-f(x_0,y_0)}{\Delta x}=A</script><p>即偏导数$f_x(x_0,y_0)$存在，同理可得：</p><script type="math/tex; mode=display">f_y(x_0,y_0)=\lim_{\Delta y\to 0}\frac{f(x_0,y_0+\Delta y)-f(x_0,y_0)}{\Delta y}=B</script><p>所以两个偏导数都存在，且这两个偏导就是我们想要找到的$A$和$B$，即：</p><script type="math/tex; mode=display">\mathrm{d}z=f_x(x_0,y_0)\mathrm{d}x+f_y(x_0,y_0)\mathrm{d}y</script></div></div><hr><p><strong>可微分的条件</strong></p><p>充分条件：导函数连续</p><p>已知函数$z=f(x,y)$的偏导数为$\frac{\partial f}{\partial x}$、$\frac{\partial f}{\partial y}$​，那么：</p><script type="math/tex; mode=display">\frac{\partial f}{\partial x}、\frac{\partial f}{\partial y}\ 在\ (x_0,y_0)\ 连续\implies f(x,y)\ 在\ (x_0,y_0)\ 点可微分</script><p>偏导数连续是指：</p><script type="math/tex; mode=display">\lim_{x\to x_0,y\to y_0}f_x(x,y)=f_x(x_0,y_0)\\\lim_{x\to x_0,y\to y_0}f_y(x,y)=f_y(x_0,y_0)</script><p>但是反过来是不行的</p><script type="math/tex; mode=display">\frac{\partial f}{\partial x}、\frac{\partial f}{\partial y}\ 在\ (x_0,y_0)\ 连续\mathrel{\rlap{\hskip .5em/}}\Longleftarrow f(x,y)\ 在\ (x_0,y_0)\ 点可微分</script><p>即导函数连续可以推出可微分</p><p>充要条件：</p><script type="math/tex; mode=display">\lim_{(\Delta x,\Delta y)\to(0,0)}\frac{\Delta z-[f_x(x_0,y_0)\Delta x+f_y(x_0,y_0)\Delta y]}{\sqrt{((\Delta x)^2)+(\Delta y)^2}}</script><p>该极限为$0$</p><p>显然，该极限的分母是邻域内的点与$(x_0,y_0)$的距离，而分子是$o(\rho)$，如果分子是高阶无穷小，则可以证明其可微性</p><p>常用的有界性技巧：</p><script type="math/tex; mode=display">\frac{\Delta x}{\sqrt{((\Delta x)^2)+(\Delta y)^2}}≤1\qquad 有界</script><p>根据此定义，如果</p><script type="math/tex; mode=display">\lim_{(\Delta x,\Delta y)\to(0,0)}\frac{f(x,y)-f(0,0)-[f_x(x_0,y_0)\Delta x+f_y(x_0,y_0)\Delta y]}{g(x)}=c</script><p>如果$g(x)$是$\sqrt{((\Delta x)^2)+(\Delta y)^2}$的高阶无穷小，那么就是可微的</p><hr><p><strong>可微与连续</strong></p><p>已知函数$z=f(x,y)$​，那么：</p><script type="math/tex; mode=display">f(x,y)\ 在\ (x_0,y_0)\ 点可微分\implies f(x,y)\ 在\ (x_0,y_0)\ 点连续</script><p>可以这么理解，全微分意味着切平面存在，切平面是对切点周围曲面的线性近似；切平面是连续的，所以被近似的曲面也是连续的。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220822155740394.png" alt="image-20220822155740394"></p><hr><h2 id="全导数"><a href="#全导数" class="headerlink" title="全导数"></a>全导数</h2><p>若$z=f(x,y)$是可微分的，而$x$和$y$是$t$的可导函数，则$z$是$t$的可导函数，并且：</p><script type="math/tex; mode=display">\frac{\mathrm{d}z}{\mathrm{d}t}=\frac{\partial z}{\partial x}\frac{\mathrm{d}x}{\mathrm{d}t}+\frac{\partial z}{\partial y}\frac{\mathrm{d}y}{\mathrm{d}t}</script><p>这个导数可以看作过切点的曲线的导数，所以又被称为$\color{Salmon}{全导数}$。</p><p>通过多元函数的<strong>链式法则</strong>进行计算</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/xcv.svg" alt="xcv" style="zoom:67%;" /></p><p>全微分形式不变性</p><p>设函数$z=f(x,y)$​具有连续偏导数，则有全微分：</p><script type="math/tex; mode=display">\mathrm{d}z=\frac{\partial z}{\partial x}\mathrm{d}x+\frac{\partial z}{\partial y}\mathrm{d}y</script><p>不论$x、y$是中间变量还是自变量，全微分都保持上述形式，这称为$\color{Salmon}{全微分形式不变性}$</p><p>若$P(x,y)$和$Q(x,y)$有一阶连续偏导数，且$P(x,y)dx+Q(x,y)dy$是某一函数的全微分，则</p><script type="math/tex; mode=display">\frac{\partial P}{\partial y}=\frac{\partial Q}{\partial x}</script><p>因为$P(x,y)$本来就是对$x$求导的偏导数了，而$Q(x,y)$也本来就是对$y$求导的偏导数了</p><p>如果知道一个函数的全微分形式：$\mathrm{d}z=\frac{\partial z}{\partial x}\mathrm{d}x+\frac{\partial z}{\partial y}\mathrm{d}y$，根据此形式求其原函数一般有两种方法：</p><ol><li>利用偏积分：$\frac{\partial z}{\partial x}\mathrm{d}x$的积分推出$z=f(x)+\phi(y)$的形式，$z_y=\frac{\partial z}{\partial y}$，求出$\phi’(y)$，然后积分，求出$\phi(y)$，最后就可以得到$z$的形式</li><li>直接凑微分</li></ol><hr><h2 id="隐函数"><a href="#隐函数" class="headerlink" title="隐函数"></a>隐函数</h2><p>假设$z=f(x,y)$在点$P_0(x_0,y_0)$​的某一邻域内具有连续偏导数，且：</p><script type="math/tex; mode=display">f(x_0,y_0)=0,\quad f_y(x_0,y_0)\ne 0</script><p>则方程$f(x,y)=0$在点$(x_0,y_0)$的某一邻域内恒能唯一确定一个连续且具有连续导数的函数$y=g(x)$，它满足条件$y_0=g(x_0)$，并有：</p><script type="math/tex; mode=display">\frac{\mathrm{d}y}{\mathrm{d}x}=-\frac{f_x}{f_y}</script><p>该定理称为$\color{Salmon}{隐函数存在定理}$</p><p>证明过程也很简单：对方程$F(x,y)=0$求$x$的偏导数</p><script type="math/tex; mode=display">f_x’+f_y’·y'=0\implies y'=-\frac{f_x}{f_y}</script><hr><p>如果是由$f(x,y,z)=0$确定的隐函数$z=z(x,y)$，满足$f(x_0,y_0,z_0)=0$，$f_z’(x_0,y_0,z_0)≠0$,则有：</p><script type="math/tex; mode=display">\frac{\partial z}{\partial x}=-\frac{f_x}{f_z}\qquad\frac{\partial z}{\partial y}=-\frac{f_y}{f_z}</script><hr><p>求全微分的方法一般有3种</p><ol><li>在$f(x,y,z)=0$的方程两端直接微分，然后代入具体的值</li><li>由隐函数求导公式直接求出$x$和$y$的偏导数</li><li>先将$x$单独代入到方程中，求$y$的偏导数，再反过来，最后得出全微分</li></ol><hr><p>证明$f(x,y)$可以表示为$g(ax+by)$，也就是证明$z=f(u,v)$这个多元函数与$v$无关</p><ol><li>将$u=ax+by,v=y$，把$x$用$u$的方式带入进$f(u,v)$</li><li>证明$f_v=0$即可</li></ol><hr><h2 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h2><h3 id="一元函数的梯度"><a href="#一元函数的梯度" class="headerlink" title="一元函数的梯度"></a>一元函数的梯度</h3><p>在解释梯度下降法之前，我们需要先从导数开始谈起</p><p>仅拥有一个自变量的函数称为一元函数，简记为 $y=f(x)$，我们一般通过导数的定义，求解$y$在$x_0$点处的变化率</p><p>定义如下：设函数$y=f(x)$在点$x_0$的某个邻域内有定义，当自变量$x$在$x_0$处取得增量$\Delta x$（点$x_0+\Delta x$仍在该邻域内）时，相应的，因变量取得增量$\Delta y=f(x_0+\Delta x)-f(x_0)$。如果$\Delta y$与$\Delta x$之比在$\Delta x\to 0$时的极限存在，那么称函数$y=f(x)$在点$x_0$处 可导 ，并称这个极限为函数$y=f(x)$在点$x_0$处的 导数 ，记为$f’(x_0)$，即：</p><script type="math/tex; mode=display">f'(x_0)=\lim_{\Delta x\to 0}\frac{\Delta y}{\Delta x}=\lim_{\Delta x\to 0}\frac{f(x_0+\Delta x)-f(x_0)}{\Delta x}</script><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typorav2-aad2460de5edbb636b1028e47957c5e1_b.webp" alt="动图"></p><p>由于一元函数仅仅具有一个自变量 $x$ ，因此这类函数仅且只能反应函数沿 $x$ 轴方向的<strong>变化率</strong></p><p><strong>梯度</strong>是一个数学概念，是一个向量（矢量），表示某一函数在该点处的方向导数沿着该方向取得<strong>最大值</strong>，即函数在该点处沿着该方向（此梯度的方向）<strong>变化最快，变化率最大</strong>。</p><p>在一元函数中，函数的方向只有一维，把$f’(x_0)$称为函数在$x_0$点处的变化率，即是该点的梯度</p><hr><h3 id="多元函数的梯度"><a href="#多元函数的梯度" class="headerlink" title="多元函数的梯度"></a>多元函数的梯度</h3><p>拥有多个自变量（≥2 ）的函数称为多元函数，以二元函数 $z=f(x,y)$ 为例讲解偏导数</p><p>由于二元函数具有两个自变量 $x,y$ ，因此函数图像为一个曲面。与一元函数类似，如何计算二元函数对曲面上一点 $(x_0,y_0)$ 的变化率呢？此处需要注意的是，因为过曲面上一点可以作出无数条切线，因此函数在该点也具有无数个变化率。为了简单起见，可以先考虑函数沿着两个坐标轴（ $x$ 轴， $y$ 轴）方向的变化率。</p><ul><li>当自变量$y$固定在$y_0$，函数在点$x_0$处的变化率称为函数在点$(x_0,y_0)$处对$x$的偏导数，记作$f_x(x_0,y_0)$。</li><li>当自变量 $x$ 固定在 $x_0$ ，函数在点 $y_0$ 处的变化率称为函数在点 $(x_0,y_0)$ 处对 $y$ 的偏导数，记作 $f_y(x_0,y_0)$ 。</li></ul><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231021034558968.png" alt="image-20231021034558968"></p><hr><p>那么，知道了偏导数的基本概念，之后所要考虑的就是，<strong>求出函数在点</strong> $(x_0,y_0)$ <strong>处沿某一方向的变化率</strong></p><p>假设某一方向的单位向量为 $e_l=(cos⁡α,sin⁡α)$ ， $α$ 为此向量与$x$轴正向夹角，显然<strong>根据</strong> $α$ <strong>的不同，此向量可以表示任意方向的单位向量。</strong>当点 $(x_0,y_0)$ 沿着该方向产生一个增量 $t$ 到达点 $(x_0+tcos⁡α,y_0+tsin⁡α)$ 时，函数 $z$ 也会产生一个增量 $Δz=f(x_0+tcos⁡α,y_0+tsin⁡α)−f(x_0,y_0)$ 。此时函数沿此方向的变化率为：</p><script type="math/tex; mode=display">\lim_{t \rightarrow 0^{+}} \frac{f(x_0+t \cos \alpha, y_0+t \sin \alpha)-f(x_0,y_0)}{t} \ = f_x(x_0,y_0) \cos \alpha + f_y(x_0,y_0) \sin \alpha</script><p>（此处证明略过）</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231021035604691.png" alt="image-20231021035604691"></p><p>在了解了多元函数的方向导数之后，一个很自然的问题是：既然函数在点 $(x_0,y_0)$ 处沿着任意的方向都有一个变化率，那么<strong>沿着哪个方向（</strong> α=? <strong>）函数的变化率最大呢？</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231021040336306.png" alt="image-20231021040336306" style="zoom:67%;" /></p><p>根据之前的介绍，函数 $z=f(x,y)$ 沿着任意方向（ α 取任意值）的变化率为： $f_x(x_0,y_0)cos⁡α+f_y(x_0,y_0)sin⁡α$ ，因此接下来只需求得使其达到<strong>最大值时的 α</strong> 便可解决上述问题</p><p>由于上式可以看成两个向量的<strong>内积</strong>(点积)</p><p>令：$\mathbf{g}=(f_x(x_0,y_0), f_y(x_0,y_0) ), \mathbf{e}_l=(\cos \alpha, \sin \alpha)$</p><p>则：$f_x(x_0,y_0) \cos \alpha + f_y(x_0,y_0) \sin \alpha = \mathbf{g} \cdot \mathbf{e}_l = |\mathbf{g}| |\mathbf{e}_l| \cos \theta = |\mathbf{g}| \cos \theta$</p><p>其中， $θ$ 为 $g$ 和 $e_l$ 的夹角。根据上式，可得出如下结论：</p><ul><li>当 $θ=0$ 时，即 $e_l$ 和 $g$ 方向相同时，函数变化率最大，且在点 $(x_0,y_0)$ 处呈上升趋势；</li></ul><p>最后，当点$(x_0,y_0)$确定后，向量$\mathbf{g}=(f_x(x_0,y_0), f_y(x_0,y_0) )$ 也随即确定,由于向量 $g$ 的方向为函数值<strong>增加</strong>最快的方向，而此方向经常被用于实际生活中，因此为便于表述，人们为其取了一个名字—<strong>梯度</strong>$\nabla f$</p><p>换而言之，<strong>多元函数在某一点的梯度是一个非常特殊的向量，其由多元函数对每个变量的偏导数组成（这即是为什么求梯度的时候需要对各个变量求偏导的原因），其方向为函数在该点增加最快的方向，大小为函数在该点的最大变化率。</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraimage-20231021040310497.png" alt="image-20231021040310497"></p><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><hr><h2 id="极值"><a href="#极值" class="headerlink" title="极值"></a>极值</h2><h3 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h3><p>设函数$z=f(x,y)$的定义域为$D，P_0(x_0,y_0)$是$D$的内点，则：<br>$f(x_0,y_0)$是$\color{Salmon}{极大值}$，当且仅当存在某个邻域$U(P_0)\subset D$，使得该邻域内所有异于$P_0$的点$(x,y)$​，都有：</p><script type="math/tex; mode=display">f(x,y) < f(x_0,y_0)</script><p>$f(x_0,y_0)$是$\color{Salmon}{极小值}$，当且仅当存在某个邻域$U(P_0)\subset D$，使得该邻域内所有异于$P_0$的点$(x,y)$​，都有：</p><script type="math/tex; mode=display">f(x,y) > f(x_0,y_0)</script><p>极大值和极小值都统称为$\color{Salmon}{极值}$，使得函数取得极值的点称为$\color{Salmon}{极值点}$。</p><hr><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><p>极值的必要条件：</p><p>设函数$z=f(x,y)$在点$(x_0,y_0)$处具有偏导数，且该点为极值点，则有：</p><script type="math/tex; mode=display">f_x(x_0,y_0)=f_y(x_0,y_0)=0</script><p>极值的充分条件：</p><p>设函数$z=f(x,y)$在点$(x_0,y_0)$的某邻域内连续且有一阶及二阶连续偏导数，则其二阶导数，即海森矩阵为：</p><script type="math/tex; mode=display">H=\frac{\partial^2 z}{\partial(x,y)^2}=\begin{pmatrix}f_{xx}&f_{xy}\\f_{yx}&f_{yy}\end{pmatrix}</script><p>如果又有：</p><script type="math/tex; mode=display">f_x(x_0,y_0)=f_y(x_0,y_0)=0</script><p>那么：</p><ol><li>$f(x_0,y_0)$为极大值，当$f_{xx} &lt; 0$且$|H| &gt; 0$；</li><li>$f(x_0,y_0)$为极小值，当$f_{xx} &gt; 0$且$|H| &gt; 0$；</li><li>$f(x_0,y_0)$非极值点，当$|H| &lt; 0$；</li><li>$f(x_0,y_0)$无法判断是否为极值点，当$|H| = 0$。</li></ol><hr><h3 id="拉格朗日乘数法"><a href="#拉格朗日乘数法" class="headerlink" title="拉格朗日乘数法"></a>拉格朗日乘数法</h3><p>拉格朗日乘数法用于求解在约束条件下的极值</p><p>要求约束下的最值问题：</p><script type="math/tex; mode=display">\begin{gather}    \min\max\  z=f(x,y)\\    s.t.\  g(x,y)=0\end{gather}</script><p>在极值点可以列出如下方程组：</p><script type="math/tex; mode=display">\begin{cases}\nabla f=\lambda\nabla g\\\\g(x,y)=0\end{cases}</script><p>其中$\nabla f$是函数的梯度</p><script type="math/tex; mode=display">\nabla f=\begin{pmatrix}f_x\\f_y\end{pmatrix}</script><p>$\nabla g$是约束条件的梯度向量</p><script type="math/tex; mode=display">\nabla g=\begin{pmatrix}g_x\\g_y\end{pmatrix}</script><p>$\nabla f=\lambda\nabla g$成立说明梯度向量平行</p><p>解该方程组可以求出极值点，这就是$\color{Salmon}{拉格朗日乘数法}$。</p><p>下面是三元函数，在两个约束下的最值问题：</p><script type="math/tex; mode=display">\begin{aligned}    \min\max\ w=f(x,y,z)\\    s.t.\         \begin{cases}            g_1(x,y,z)=0\\            g_2(x,y,z)=0        \end{cases}\end{aligned}</script><p>解法是：</p><script type="math/tex; mode=display">\begin{cases} \nabla f=\lambda\nabla g_1+\mu\nabla g_2\\ \\ g_1(x,y,z)=0\\ \\ g_2(x,y,z)=0\\ \end{cases}</script><p>拉格朗日乘数法可以用行列式来简化运算，方程有非零解的前提是行列式的值等于0</p><hr><p>求连续函数$f(x,y)$在有界闭区域$D$上的最大最小值</p><ol><li>求$f(x,y)$在$D$内部可能的极值点(导数=0的点)</li><li>求$f(x,y)$在$D$的边界上的最大最小值(拉格朗日乘数法找符合条件的点)</li><li>比较</li></ol><hr><h2 id="二重积分"><a href="#二重积分" class="headerlink" title="二重积分"></a>二重积分</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>设$f(x,y)$是有界闭区域$D$上的有界函数，将闭区域$D$任意分成$n$​个小闭区域：</p><script type="math/tex; mode=display">\Delta A_1,\Delta A_2,\cdots,\Delta A_i,\cdots,\Delta A_n</script><p>其中$\Delta A_i$表示第$i$个小闭区域，也表示它的面积，规定$\Delta A_i$中最长的直径（一个闭区域的直径是指区域上任意两点间距离的最大者）为$\lambda$，在每个$\Delta A_i$内任取一点$(x_i,y_i)$，可以得到级数：</p><script type="math/tex; mode=display">\sum_{i=0}^{n}f(x_i,y_i)\Delta A_i</script><p>如果当$\lambda\to 0$时，无论如何划分闭区域$D$，无论怎样选取$(x_i,y_i)$，该级数的极限总是存在，那么称此极限为函数$f(x,y)$在闭区域$D$上的$\color{Salmon}{二重积分}$，记作：</p><script type="math/tex; mode=display">\iint_\limits{D}f(x,y)\mathrm{d}A=\lim_{\lambda\to 0}\sum_{i=0}^{n}f(x_i,y_i)\Delta A_i</script><p>其中$f(x,y)$称为$\color{Salmon}{被积函数}$，$\mathrm{d}A$称为$\color{Salmon}{面积微分}$，$x$与$y$称为$\color{Salmon}{积分变量}$，$D$称为$\color{Salmon}{积分区域}$。</p><p>实际上就是说区域$D$上的函数$z=f(x,y)$：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220824201931137.png" alt="image-20220824201931137"></p><p>该曲面下的体积，可以通过任意的，无穷划分D后得到的柱体来计算</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220824202045350.png" alt="image-20220824202045350"></p><hr><p>对区域$D$进行矩形划分时，边长可记作$\Delta x_i、\Delta y_i$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220824202303941.png" alt="image-20220824202303941"></p><p>也就是说有：</p><script type="math/tex; mode=display">\Delta A_i=\Delta x_i\Delta y_i</script><p>所以$D$区域上的曲面$z=f(x,y)$下的体积可以表示为：</p><script type="math/tex; mode=display">\iint_\limits{D}f(x,y)\mathrm{d}A=\lim_{\lambda\to 0}\sum_{i=0}^{n}f(x_i,y_i)\Delta x_i\Delta y_i</script><p>因此二重积分有另外一种等价的表示形式：</p><script type="math/tex; mode=display">\iint_\limits{D}f(x,y)\mathrm{d}A=\iint_\limits{D}f(x,y)\mathrm{d}x\mathrm{d}y</script><p>因为在直角坐标系中，才进行矩形划分，所以$\mathrm{d}x\mathrm{d}y$也被称为$\color{Salmon}{直角坐标系中的面积微分}$</p><hr><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>设$f(x,y)$，$g(x,y)$都是有界闭区域D上的有界函数，$\alpha、\beta$为常数，则：</p><ul><li>齐次性：</li></ul><script type="math/tex; mode=display">\iint_\limits{D}\alpha f(x,y)\mathrm{d}A=\alpha\iint_\limits{D}f(x,y)\mathrm{d}A</script><ul><li>可加性：</li></ul><script type="math/tex; mode=display">\iint_\limits{D}\Big(f(x,y)+g(x,y)\Big)\mathrm{d}A=\iint_\limits{D}f(x,y)\mathrm{d}A+\iint_\limits{D}g(x,y)\mathrm{d}A</script><ul><li>区域可加性：</li></ul><script type="math/tex; mode=display">\iint_\limits{D}f(x,y)\mathrm{d}A=\iint_\limits{D_1}f(x,y)\mathrm{d}A+\iint_\limits{D_2}f(x,y)\mathrm{d}A</script><ul><li><p>不等式：</p><script type="math/tex; mode=display">f(x,y) \le g(x,y)\implies\iint_\limits{D}f(x,y)\mathrm{d}A \le \iint_\limits{D}g(x,y)\mathrm{d}A</script><p>假设$f(x,y)$在区域$D$中，下界为$m$，上界为$M$，即：</p><script type="math/tex; mode=display">m\le f(x,y)\le M</script><p>如果区域$D$的面积为$A$，那么根据上述定理可以得出：</p><script type="math/tex; mode=display">mA\le \iint_\limits{D}f(x,y)\mathrm{d}A \le MA</script></li><li><p>中值定理</p><p>设函数$f(x,y)$在闭区域$D$上连续，$A$是区域$D$的面积，则在$D$上至少存在一点$(\xi,\mu)$​，使得：</p><script type="math/tex; mode=display">\iint_\limits{D}f(x,y)\mathrm{d}A=f(\xi,\mu)A</script><p>中值定理本质是：定义在区域$D$上的函数$z=f(x,y)$，必然可以找到某点$(\xi,\mu)$，以该点的函数$f(\xi,\mu)$做一个平面，使得曲面下的体积和平面下的体积相等：</p></li></ul><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220824204759720.png" alt="image-20220824204759720"></p><hr><h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3><h4 id="常规坐标"><a href="#常规坐标" class="headerlink" title="常规坐标"></a>常规坐标</h4><p>$X$型区域：</p><p>比如区域$D$：</p><script type="math/tex; mode=display">D=\{(x,y)|a \le x \le b, g_1(x) \le y \le g_2(x)\}</script><p>区域$D$的特征是$x$在区间$[a,b]$上变化，而$y$的范围依赖于$x$的函数，这样的区域称为$\color{Salmon}{X型区域}$）。下面就是三种$X$型区域：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220824205044299.png" alt="image-20220824205044299"></p><p>截面面积为</p><script type="math/tex; mode=display">A(x_0)=\int_{g_1(x_0)}^{g_2(x_0)}f(x_0, y)\mathrm{d}y</script><p>体积为：</p><script type="math/tex; mode=display">V=\int_{a}^{b}A(x)\mathrm{d}x</script><p>二重积分为：</p><script type="math/tex; mode=display">V=\iint_\limits{D}f(x,y)\mathrm{d}A=\int_{a}^{b}\int_{g_1(x)}^{g_2(x)}f(x, y)\mathrm{d}y\mathrm{d}x</script><hr><p>$Y$型区域</p><p>比如区域$D$：</p><script type="math/tex; mode=display">D=\{(x,y)|c \le y \le d, h_1(y) \le x \le h_2(y)\}</script><p>区域$D$的特征是$y$在区间$[c,d]$上变化，而$x$的范围依赖于$y$的函数，这样的区域称为$\color{Salmon}{Y型区域}$。比如下面就是两种$Y$型区域：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220824210210122.png" alt="image-20220824210210122"></p><p>$Y$型区域上的体积为：</p><script type="math/tex; mode=display">V=\iint_\limits{D}f(x,y)\mathrm{d}A=\int_{c}^{d}\int_{h_1(y)}^{h_2(y)}f(x, y)\mathrm{d}x\mathrm{d}y</script><hr><p>总结：</p><p>若$f(x,y)$在区域$D$上连续：</p><ul><li><p>若区域$D$为$a \le x \le b, g_1(x) \le y \le g_2(x)$，其中$g_1、g_2$在$[a,b]$上连续，则：</p><script type="math/tex; mode=display">\iint_\limits{D}f(x,y)\mathrm{d}A=\int_{a}^{b}\Big[\int_{g_1(x)}^{g_2(x)}f(x, y)\mathrm{d}y\Big]\mathrm{d}x</script></li><li><p>若区域$D$为$c \le y \le d, h_1(y) \le x \le h_2(y)$，其中$h_1、h_2$在$[c,d]$上连续，则：</p><script type="math/tex; mode=display">\iint_\limits{D}f(x,y)\mathrm{d}A=\int_{c}^{d}\Big[\int_{h_1(y)}^{h_2(y)}f(x, y)\mathrm{d}x\Big]\mathrm{d}y</script></li></ul><p>当遇到不好积分的区域时，可以先画出积分区域，然后交换积分的次序，从而达到简化积分的效果</p><hr><h4 id="极坐标"><a href="#极坐标" class="headerlink" title="极坐标"></a>极坐标</h4><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220824210434037.png" alt="image-20220824210434037"></p><p>$\Delta A_i$在极坐标系下可以表示为：</p><script type="math/tex; mode=display">\Delta A_i=\{(\rho,\theta)|\rho_i\le\rho\le\rho_{i+1},\theta_i\le\theta\le\theta_{i+1}\}</script><p>可见该区域的$\rho、\theta$都在两个常数之间，所以称为$\color{Salmon}{极坐标矩形}$</p><p>$\Delta A_i$的面积可以看作两个大小扇形的面积差，其中$\Delta \theta_i=\theta_{i+1}-\theta_{i}$：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220824211739358.png" alt="image-20220824211739358"></p><p>两个扇形的面积分别为：</p><script type="math/tex; mode=display">大扇形=\frac{1}{2}\rho_{i+1}^2\Delta \theta_i,\quad 小扇形=\frac{1}{2}\rho_{i}^2\Delta \theta_i</script><p>所以：</p><script type="math/tex; mode=display">\begin{aligned}    \Delta A_i         &=大扇形-小扇形\\        \\        &=\frac{1}{2}\rho_{i+1}^2\Delta \theta_i-\frac{1}{2}\rho_{i}^2\Delta \theta_i\\        \\        &=\frac{\rho_{i+1}+\rho_{i}}{2}\cdot(\rho_{i+1}-\rho_{i})\cdot(\theta_{i+1}-\theta_{i})\\        \\        &=\overline{\rho_i}\cdot\Delta \rho_i\cdot\Delta\theta_i\end{aligned}</script><hr><p>而在极坐标下的二重积分可以这样表示：</p><p>该曲面下的体积可以用这些柱体的和来逼近：</p><script type="math/tex; mode=display">V\approx \sum_{i=1}^{n}f(\rho_i,\theta_i)\Delta A_i=\sum_{i=1}^{n}f(\rho_i,\theta_i)\overline{\rho_i}\cdot\Delta \rho_i\cdot\Delta\theta_i</script><p>假设$\lambda=\max(\Delta A_i)$，当$\lambda\to 0$时，就可以得到曲面下的体积：</p><script type="math/tex; mode=display">V=\lim_{\lambda\to 0}\sum_{i=1}^{n}f(\rho_i,\theta_i)\Delta A_i=\lim_{\lambda\to 0}\sum_{i=1}^{n}f(\rho_i,\theta_i)\overline{\rho_i}\cdot\Delta \rho_i\cdot\Delta\theta_i</script><p>写作二重积分的形式就是：</p><script type="math/tex; mode=display">V=\iint_\limits{D}f(\rho,\theta)\mathrm{d}A=\iint_\limits{D}f(\rho,\theta)\rho\mathrm{d}\rho\mathrm{d}\theta</script><p>其中，$\rho\mathrm{d}\rho\mathrm{d}\theta$称为$\color{Salmon}{极坐标系下的面积微分}$</p><p>计算：</p><p>若区域$D$为$\alpha \le \theta \le \beta, h_1(\theta) \le \rho \le h_2(\theta)$，其中$h_1、h_2$在$[\alpha,\beta]$上连续，则：</p><script type="math/tex; mode=display">\iint_\limits{D}f(x,y)\mathrm{d}A=\int_{\alpha}^{\beta}\Big[\int_{h_1(\theta)}^{h_2(\theta)}f(\rho, \theta)\rho\mathrm{d}\rho\Big]\mathrm{d}\theta</script><p>次序的先后取决于从零点引射线，先经过的曲线在前，后经过的在后</p><hr><p>常规坐标与极坐标</p><script type="math/tex; mode=display">\iint_\limits{D}f(x,y)\ \color{OrangeRed}{\mathrm{d}x\mathrm{d}y}\ =\iint_\limits{D}f(\rho,\theta)\ \color{ForestGreen}{\rho\mathrm{d}\rho\mathrm{d}\theta}</script><script type="math/tex; mode=display">x\implies \rho cos\theta\qquad y\implies\rho sin\theta\qquad dxdy=\rho\mathrm{d}\rho\mathrm{d}\theta</script><hr><p>可以利用极坐标来解某些周期性积分</p><p>比如</p><script type="math/tex; mode=display">\iint_\limits{D}|ax+by|dxdy\qquad (D(x,y)|x^2+y^2≤1)</script><p>可以化为如下形式：</p><script type="math/tex; mode=display">\int^{2\pi}_0d\theta \int^1_0|3rcos\theta+4rsin\theta|rdr</script><p>先把$r$算出来，然后利用辅助角公式变为如下形式：</p><script type="math/tex; mode=display">\frac{1}{3}×5×\int^{2\pi}_0|\frac{3}{5}cos\theta+\frac{4}{5}sin\theta|d\theta=\frac{5}{3}\int^{2\pi}_{0}|sin(\theta+\theta_0)|d\theta</script><p>将$\theta+\theta_0=t$带入，变为：</p><script type="math/tex; mode=display">\frac{5}{3}\int^{\theta_0+2\pi}_{\theta_0}|sint|dt=\frac{20}{3}</script><hr><p>面对极坐标方程时，还原成常规坐标方程时：</p><p>比如$r=1-cos\theta$</p><script type="math/tex; mode=display">\begin{align}x=rcos\theta\\y=rsin\theta\\\frac{dy}{dx}=\frac{dy}{d\theta}·\frac{d\theta}{dx}\end{align}</script><hr><h4 id="对称性"><a href="#对称性" class="headerlink" title="对称性"></a>对称性</h4><ol><li>积分域$D$关于$y$轴对称，如果$f(x,y)$是$x$的偶函数：<script type="math/tex; mode=display">\iint_\limits{D}f(x,y)dA=2\iint_\limits{D_{x>0}}f(x,y)dA</script>如果$f(x,y)$是$x$的奇函数，那么积分值为$0$</li></ol><ol><li>积分域$D$关于$x$轴对称，如果$f(x,y)$是$y$的偶函数：<script type="math/tex; mode=display">\iint_\limits{D}f(x,y)dA=2\iint_\limits{D_{y>0}}f(x,y)dA</script>如果$f(x,y)$是$y$的奇函数，那么积分值为$0$</li></ol><ol><li>积分域$D$关于$y=x$轴对称，则：<script type="math/tex; mode=display">\iint_\limits{D}f(x,y)dA=\iint_\limits{D}f(y,x)dA</script>此条性质常被用于如下变化：<script type="math/tex; mode=display">\iint_\limits{D}x^2dA=\frac{1}{2}\iint_\limits{D}x^2+y^2dA</script></li></ol><p>在利用区域对称性解题时，注意添加曲线让区域保持对称</p><hr><h3 id="形心"><a href="#形心" class="headerlink" title="形心"></a>形心</h3><script type="math/tex; mode=display">x_0=\frac{\int_a^b xf(x)dx}{\int_a^b f(x)dx}\qquad y_0=\frac{\frac{1}{2}\int_a^b f(x)^2dx}{\int_a^b f(x)dx}</script><p>推导过程</p><script type="math/tex; mode=display">x_0=\frac{\iint_D xdxdy}{\iint_D dxdy}=\frac{\int_a^bxdx\int_0^{f(x)}dy}{\int_a^bdx\int^{f(x)}_0dy}=\frac{\int_a^b xf(x)dx}{\int_a^b f(x)dx}</script><script type="math/tex; mode=display">y_0=\frac{\iint_D ydxdy}{\iint_D dxdy}=\frac{\int_a^bdx\int_0^{f(x)}ydy}{\int_a^bdx\int^{f(x)}_0dy}=\frac{\frac{1}{2}\int_a^b f(x)^2dx}{\int_a^b f(x)dx}</script><hr><h3 id="常见图形"><a href="#常见图形" class="headerlink" title="常见图形"></a>常见图形</h3><ul><li>双纽线</li></ul><p>$(x^2+y^2)^2=a^2(x^2-y^2)$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218003025339.png" alt="image-20221218003025339"></p><ul><li>摆线</li></ul><p>$x=a(t-sint)$ </p><p>$y=a(1-cost)$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218003127410.png" alt="image-20221218003127410"></p><ul><li>星形线</li></ul><p>$x=acos^3t$</p><p>$y=asin^3t$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221218003315807.png" alt="image-20221218003315807" style="zoom:50%;" /></p><ul><li>心形线</li></ul><p>$\rho=a(1+cos\theta)$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com//typoraa5c27d1ed21b0ef43b043c0a5777c8d380cb3e36.jpeg@f_auto" alt="img" style="zoom:80%;" /></p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.常微分方程</title>
      <link href="/post/6800.html"/>
      <url>/post/6800.html</url>
      
        <content type="html"><![CDATA[<h1 id="常微分方程"><a href="#常微分方程" class="headerlink" title="常微分方程"></a>常微分方程</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>含有未知函数及其导函数的方程称为$\color{Salmon}{微分方程}$：</p><script type="math/tex; mode=display">\begin{array}{c|c|c} \hline &\quad未知数\quad&\quad例子\quad\\\hline \quad\color{SkyBlue}{方程}\quad&\quad x\quad&\quad 2x+1=3\quad\quad\\ \hline \quad\color{orange}{微分方程}\quad&\quad y\quad&\quad\frac{\mathrm{d}y}{\mathrm{d}x}+xy=2x\quad\\ \hline \end{array}</script><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220808210846003.png" alt="image-20220808210846003"></p><p>微分方程中出现的导函数的最高阶数，叫做微分方程的$\color{Salmon}{阶}$</p><p>$n$阶微分方程的形式是：</p><script type="math/tex; mode=display">F(x,y,y',\cdots,y^{(n)})=0</script><p>这里必须指出在方程中，$y^{(n)}$是必须出现的，而$x,y,y’,\cdots,y^{(n-1)}$等变量则可以不出现。</p><hr><h2 id="可分离变量的微分方程"><a href="#可分离变量的微分方程" class="headerlink" title="可分离变量的微分方程"></a>可分离变量的微分方程</h2><p>如果一个一阶微分方程能写成：</p><script type="math/tex; mode=display">g(y)\mathrm{d}y=f(x)\mathrm{d}x</script><p>的形式，这就是$\color{Salmon}{可分离变量的微分方程}$。</p><p>对其两边求不定积分：</p><script type="math/tex; mode=display">\int g(y)\mathrm{d}y=\int f(x)\mathrm{d}x</script><p>分别得到$g(y)$和$f(x)$的原函数$G(y)$、$F(x)$，于是：</p><script type="math/tex; mode=display">G(y)=F(x)+C</script><p>为此微分方程的解。</p><hr><p>在解微分方程时，变量$x,y$地位可看做相同的，既可把$y$看作$x$的函数，又可把$x$看作$y$的函数</p><p>如果遇到复合函数，如$y’=cos(x+y)$的类型，考虑进行变量代换，将$x+y=u$，就变成了$u’=1+cosu$的形式，就是可分离变量的微分方程了</p><hr><h2 id="齐次方程"><a href="#齐次方程" class="headerlink" title="齐次方程"></a>齐次方程</h2><p>如果一阶微分方程可以写成：</p><script type="math/tex; mode=display">\frac{\mathrm{d}y}{\mathrm{d}x}=\varphi\left(\frac{y}{x}\right)</script><p>的形式，那么称此方程为$\color{Salmon}{齐次方程}$。这个方程是可以通过 <strong>换元变换</strong>为可分离变量的微分方程的。</p><p>设$\frac{y}{x}=u$，那么就化成了：</p><script type="math/tex; mode=display">u+x\frac{du}{dx}=\varphi(u)</script><p>最后换成是$\int udu=\int xdx$的形式</p><p>实际上，这种化简技巧并不局限于$\frac{y}{x}$的形式，比如$2yy’$的形式，就可以看做是$u=y^2，y’sec^2y$的形式，就可以看做是$u=tany$，根据导数形式灵活化简</p><p>方程</p><script type="math/tex; mode=display">xy''=y'+xsin\frac{y'}{x}</script><p>解题步骤是：</p><script type="math/tex; mode=display">\begin{aligned}y''=\frac{y'}{x}+sin\frac{y'}{x}\\p=y'\qquad \frac{dp}{dx}=\frac{p}{x}+sin\frac{p}{x}\\u=\frac{p}{x}\qquad u+x\frac{du}{dx}=u+sinu\\\int \frac{1}{sinu}du=\int\frac{1}{x}dx\\ln|tan\frac{u}{2}|=ln|x|+C'_1\end{aligned}</script><p>解出：</p><script type="math/tex; mode=display">\begin{aligned}tan\frac{u}{2}=C_1x\\tan\frac{y'}{2x}=C_1x\\y'=2xarctanC_1x\end{aligned}</script><p>再积分</p><script type="math/tex; mode=display">\begin{aligned}y=\int2xarctanC_1xdx+C_2=\int arctanC_1xdx^2+C_2\\=x^2arctanC_1x-\frac{1}{C_1}\int\frac{C_1^2x^2+1-1}{1+(C_1x)^2}+C_2\\=x^2arctanC_1x-\frac{x}{C_1}+\frac{1}{C^2_1}arctanC_1x+C_2\end{aligned}</script><p>如果$C_1=0$，则$y=C_2$</p><hr><h2 id="可降阶方程-两阶微分方程"><a href="#可降阶方程-两阶微分方程" class="headerlink" title="可降阶方程(两阶微分方程)"></a>可降阶方程(两阶微分方程)</h2><p>因为常系数非齐次二阶方程和变系数二阶微分方程不存在通解，所以可降阶方程主要针对的是$\color{salmon}{两阶微分方程}$类型</p><ol><li><p>$y’’=f(x)$类型</p><p>无论是齐次还是非齐次，对方程两边做两次积分即可解</p></li><li><p>$y’’=f(x,y’)$类型</p><p>需要讨论是常系数非齐次和变系数齐次or非齐次的类型</p><p>如果是变系数齐次方程，那么设$y’=P,y’’=\frac{dP}{dx}$，</p><script type="math/tex; mode=display">P'+f(x)P=0</script><p>将二阶降阶为了自变量为$P$的一阶方程，形式就是可分离变量的微分方程，解出$y’=P$，之后再对$y’$积分，求出$y$的通解</p></li></ol><hr><ol><li><p>$y’’=f(y,y’)$类型</p><p>设$y’=P,y’’=P\frac{dP}{dy}$</p><p>比如$3yy’’-2y’^2=0$</p><script type="math/tex; mode=display">\begin{aligned}3ypp’-2p^2=0\\3yp'-2p=0\\p'-\frac{2}{3y}p=0\\p=C_1e^{-\int-\frac{2}{3y}dy}=C_1y^\frac{2}{3}\\y^{-\frac{2}{3}}dy=C_1dx\\3y^\frac{1}{3}=C_1x+C_2\end{aligned}</script></li></ol><hr><h2 id="线性微分方程"><a href="#线性微分方程" class="headerlink" title="线性微分方程"></a>线性微分方程</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>对于微分方程：</p><script type="math/tex; mode=display">\mathcal{L}=a_0+a_1D+a_2D^2+a_3D^3+\cdots+a_nD^n</script><p>$D$指的是对$y$求导的阶数</p><p>下式：</p><script type="math/tex; mode=display">\mathcal{L}(y)=f(x)</script><p>称为$\color{Salmon}{线性微分方程}$。如果$f(x)$：</p><ul><li>等于0：<strong>齐次</strong>线性微分方程</li><li>不等于0：非齐次线性微分方程</li></ul><p>如果系数$a_0,a_1,\cdots,a_n$：</p><ul><li>是常数：<strong>常系数</strong>线性微分方程</li><li>是函数：变系数线性微分方程</li></ul><hr><h3 id="解的结构"><a href="#解的结构" class="headerlink" title="解的结构"></a>解的结构</h3><p>对于二维齐次线性微分方程$y’’+p(x)y’+q(x)y=0$，解空间很明显是一个平面：</p><blockquote><p>定理1：</p><p>如果$\boldsymbol{p_1},\boldsymbol{p_2},\cdots,\boldsymbol{p_n}$是$n$维齐次线性方程组：</p><script type="math/tex; mode=display">A\boldsymbol{x}=\boldsymbol{0}</script><p>的解，并且它们$\color{Salmon}{线性无关}$，那么线性组合：</p><script type="math/tex; mode=display">\boldsymbol{p}=C_1\boldsymbol{p_1}+C_2\boldsymbol{p_2}+\cdots+C_n\boldsymbol{p_n}(C_1,C_2,\cdots,C_n\in\mathbb{R})</script><p>是此方程组的$\color{Salmon}{通解}$。</p></blockquote><hr><p>非齐次线性函数$a_1x_1+a_2x_2=b,b\ne 0$和齐次线性函数$a_1x_1+a_2x_2=0$，或者说齐次线性方程组$A\boldsymbol{x}=\boldsymbol{0}$与非齐次线性方程组$A\boldsymbol{x}=\boldsymbol{b}$，是平行的直线：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220808220604308.png" alt="image-20220808220604308" style="zoom:80%;" /></p><p>任取$A\boldsymbol{x}=\boldsymbol{0}$上的点$\boldsymbol{p_1}$，也任取$A\boldsymbol{x}=\boldsymbol{b}$上的点$\boldsymbol{p_2}$：</p><p>两者相加：</p><script type="math/tex; mode=display">\boldsymbol{p_3}=\boldsymbol{p_1}+\boldsymbol{p_2}</script><p>也是$A\boldsymbol{x}=\boldsymbol{b}$上的点：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220808220657169.png" alt="image-20220808220657169" style="zoom:80%;" /></p><p>任意一个$A\boldsymbol{x}=\boldsymbol{0}$上的点，和$\boldsymbol{p_2}$相加，都是$A\boldsymbol{x}=\boldsymbol{b}$上的点：</p><blockquote><p>定理2：</p><p>如果：</p><script type="math/tex; mode=display">\boldsymbol{p}=C_1\boldsymbol{p_1}+C_2\boldsymbol{p_2}+\cdots+C_n\boldsymbol{p_n}(C_1,C_2,\cdots,C_n\in\mathbb{R})</script><p>是齐次线性方程组：$A\boldsymbol{x}=\boldsymbol{0}$的通解。</p><p>$\boldsymbol{p^*}$是非齐次线性方程组：$A\boldsymbol{x}=\boldsymbol{b}$的一个解，也称为$\color{Salmon}{特解}$，那么：</p><script type="math/tex; mode=display">\boldsymbol{p}+\boldsymbol{p^*}</script><p>是非齐次线性方程组的所有解。</p></blockquote><hr><blockquote><p>定理3：</p><p>非齐次方程的两个特解$p_1，p_2$相减是齐次微分方程的解</p><script type="math/tex; mode=display">p=p_1-p_2</script></blockquote><hr><h3 id="常系数线性微分方程"><a href="#常系数线性微分方程" class="headerlink" title="常系数线性微分方程"></a>常系数线性微分方程</h3><h4 id="齐次-一阶，二阶"><a href="#齐次-一阶，二阶" class="headerlink" title="齐次(一阶，二阶)"></a>齐次(一阶，二阶)</h4><p>一阶形式为：</p><script type="math/tex; mode=display">y'+py=0</script><p>将变系数线性微分方程的通解替换为常系数,通解为：</p><script type="math/tex; mode=display">\color{red}y=Ce^{-\int P(x)\mathrm{d}x}=Ce^{-px}\quad</script><hr><p>某二阶常系数齐次线性微分方程：</p><script type="math/tex; mode=display">y''+py'+qy=0</script><p>首先，欧拉发现不论$p、q是$什么，通解都具有以下形式：</p><script type="math/tex; mode=display">Y=C_1e^{r_1x}+C_2e^{r_2x}</script><p>$r_1、r_2$是复数。那么可以合理假设$y=e^{rx}$，得到：</p><script type="math/tex; mode=display">y'=re^{rx},\quad y''=r^2e^{rx}</script><p>回代到微分方程中，得到：</p><script type="math/tex; mode=display">(r^2+pr+q)e^{rx}=0</script><p>要使等式成立，显然要使下式成立：</p><script type="math/tex; mode=display">r^2+pr+q=0</script><p>这是一个一元二次方程，也被称为此微分方程的$\color{Salmon}{特征方程}$</p><p>可以用公式：</p><script type="math/tex; mode=display">r_{1,2}=\frac{-p\pm\sqrt{p^2-4q}}{2}</script><p>求出$r_1、r_2$。有三种情况：</p><ul><li>当$p^2-4q &gt; 0，r_1、r_2$是不相等的实根：</li></ul><script type="math/tex; mode=display">r_1=\frac{-p+\sqrt{p^2-4q}}{2},\quad r_2=\frac{-p-\sqrt{p^2-4q}}{2}</script><ul><li>当$p^2-4q = 0$：</li></ul><script type="math/tex; mode=display">r_1=r_2=-\frac{p}{2}</script><ul><li>当$p^2-4q &lt; 0$是不相等的复根：</li></ul><script type="math/tex; mode=display">r_1=\alpha+\beta i,\quad r_2=\alpha-\beta i</script><p>其中：</p><script type="math/tex; mode=display">\alpha=-\frac{p}{2},\quad \beta=\frac{\sqrt{4q-p^2}}{2}</script><p>因此微分方程的通解也分为三种情况。</p><hr><ol><li><p>当$r_1\ne r_2$且是实根时，$y_1=e^{r_1x}、y_2=e^{r_2x}$都是微分方程的解，而且$\frac{y_2}{y_1}=\frac{e^{r_2x}}{e^{r_1x}}$不是常数，那么这两个解线性无关。</p><p>根据，线性微分方程解的结构，此时通解为：</p><script type="math/tex; mode=display">Y=C_1e^{r_1x}+C_2e^{r_2x}</script></li><li><p>当$r_1=r_2=-\frac{p}{2}$时，只得到了一个解：</p><script type="math/tex; mode=display">y_1=e^{r_1x}</script><p>通解为：</p><script type="math/tex; mode=display">Y=(C_1+C_2x)e^{r_1x}</script><div class="hide-toggle" style="border: 1px solid #66c3ee"><div class="hide-button toggle-title" style="background-color: #66c3ee;color: black"><i class="fas fa-caret-right fa-fw"></i><span>证明过程</span></div>    <div class="hide-content"><p>因为要保证：</p><script type="math/tex; mode=display">\frac{y_2}{y_1}\ne 常数</script><p>所以，必然：</p><script type="math/tex; mode=display">\frac{y_2}{y_1}=u(x)\implies y_2=u(x)e^{r_1x}</script><p>现在就是要求出$u(x)$为多少。先求出：</p><script type="math/tex; mode=display">y_2'=e^{r_1x}\left(u'+r_1u\right),\quad y_2''=e^{r_1x}\left(u''+2r_1u'+r_1^2u\right)</script><p>所以代入微分方程有：</p><script type="math/tex; mode=display">e^{r_1x}\left[\left(u''+2r_1u'+r_1^2u\right)+p\left(u'+r_1u\right)+qu\right]=0</script><p>化简后得到：</p><script type="math/tex; mode=display">u''+(2r_1+p)u'+(r_1^2+pr_1+q)u=0</script><p>由于$r_1$为特征方程的根，所以$r_1^2+pr_1+q=0$。又$r_1=-\frac{p}{2}$，所以$2r_1+p=0$，所以：</p><script type="math/tex; mode=display">u''=0</script><p>随便选择一个满足此条件的函数，注意不能是常数函数，那就选$u(x)=x$吧，由此：</p><script type="math/tex; mode=display">y_2=xe^{r_1x}</script><p>所以通解为：</p><script type="math/tex; mode=display">Y=(C_1+C_2x)e^{r_1x}</script></div></div></li><li><p>当$r_1\ne r_2$且是复根时，$y_1=e^{(\alpha+\beta i)x}、y_2=e^{(\alpha-\beta i)x}$都是微分方程的解，只是这是复数函数。根据欧拉公式：</p><script type="math/tex; mode=display">y_1=e^{(\alpha+\beta i)x}=e^{\alpha x}e^{\beta xi}=e^{\alpha x}\left(\cos\beta x+i\sin\beta x\right)</script><script type="math/tex; mode=display">y_2=e^{(\alpha-\beta i)x}=e^{\alpha x}e^{-\beta xi}=e^{\alpha x}\left(\cos\beta x-i\sin\beta x\right)</script><p>$y_1、y_2$的线性组合依然是微分方程的解：</p><script type="math/tex; mode=display">\overline{y_1}=\frac{1}{2}\left(y_1+y_2\right)=e^{\alpha x}\cos\beta x</script><script type="math/tex; mode=display">\overline{y_2}=\frac{1}{2i}\left(y_1-y_2\right)=e^{\alpha x}\sin\beta x</script><p>$\overline{y_1}、\overline{y_2}$都是实值函数，且：</p><script type="math/tex; mode=display">\frac{\overline{y_1}}{\overline{y_2}}=\frac{e^{\alpha x}\cos \beta x}{e^{\alpha x}\sin \beta x}=\cot \beta x</script><p>并非常数，即两者线性无关，所以通解为：</p><script type="math/tex; mode=display">Y=e^{\alpha x}\left(C_1\cos\beta x+C_2\sin\beta x\right)</script><hr><p>二阶常系数齐次线性微分方程的通解为：</p><script type="math/tex; mode=display">\begin{array}{c|c}    \hline    &\quad通解\quad\\    \hline    \\    \quad 不相等的实根\ \ r_1,r_2\quad&\quad Y=C_1e^{r_1x}+C_2e^{r_2x}\quad \\    \quad 相等的实根\ \ r_1=r_2\quad&\quad Y=(C_1+C_2x)e^{r_1x}\quad\\    \quad 不相等的复根\ \ r_1,r_2\quad&\quad Y=e^{\alpha x}\left(C_1\cos\beta x+C_2\sin\beta x\right)\quad\\    \\    \hline\end{array}</script></li></ol><p>结论：已知特征方程为$\lambda ^2+b\lambda +c=0$，如果系数$b,c&gt;0$，那么最后解出的$\lambda&lt;0$，则$\lim_{x\to \infty} f(x)=0$</p><hr><h4 id="非齐次（一阶，特解二阶）"><a href="#非齐次（一阶，特解二阶）" class="headerlink" title="非齐次（一阶，特解二阶）"></a>非齐次（一阶，特解二阶）</h4><p>一阶：</p><script type="math/tex; mode=display">y’+py=f(x)</script><p>将变系数线性微分方程的通解替换为常系数：</p><script type="math/tex; mode=display">\color{red} y=\left(\int Q(x)e^{\int p\mathrm{d}x}\mathrm{d}x+C\right)e^{-\int p\mathrm{d}x}=\left(\int f(x)e^{px}\mathrm{d}x+C\right)e^{-px}</script><hr><p>二阶：</p><script type="math/tex; mode=display">y’’+py’+qy=f(x)</script><p>主要问题是解自由项为<strong>多项式、指数函数、正弦函数、余弦函数</strong>以及它们的和与积的二阶常系数非齐次线性微分方程</p><p>当自由项是指数函数时：$(ae^ {\lambda x})$，假设特解为$x^k (ae^ {\lambda x})$，$k$为$\lambda$ 的$k$重根，$a$的值需要带入方程中运算</p><p>当自由项为线性函数时：$(ax+b)$，假设和特解为$y^*=x^{k}(a x+b)$，将$ax+b$带入方程中可定出$a$和$b$，$k$指$\lambda(0)$是特征方程的$k$重根</p><p>当自由项是三角函数时：$(cos\beta x,sin\beta x)$，假设特解为$y^*=x^{k}(a cos\beta x+bsin\beta x)$，将$acos\beta x,bsin\beta x$带入方程可定出$a$和$b$，$k$的值取决于$\lambda(0)+\beta i$是特征方程的$k$重根</p><blockquote><p>其实线性函数和三角函数的都含有$e^{\lambda x}$，不过$\lambda$ 为0。如果出现$x^2e^x$的形式，说明微分方程至少是3阶</p></blockquote><p>当自由项为指数函数乘多项式时：$e^{\lambda x}P_m(x)$，假设特解$y^*=x^kQ_m(x)e^{\lambda x}$，$k$指$\lambda$是特征方程的$k$重根</p><p>当自由项是三角函数乘多项式时：$e^{ax}[P_l(x)cos\beta x+P_nsin\beta x]$，假设特解$y^*=x^ke^{ax}[R_m(x)cos\beta x+R_m(x)sin\beta x]$，$m$的值取决于$l$和$n$的最高次，$k$指$\alpha+\beta i$是特征方程的$k$重根</p><hr><h3 id="变系数线性微分方程"><a href="#变系数线性微分方程" class="headerlink" title="变系数线性微分方程"></a>变系数线性微分方程</h3><p>变系数线性微分方程的解不一定能求出来，下面介绍几种可解的。</p><p>一阶变系数线性微分方程经过变形之后都可以写成如下的形式：</p><script type="math/tex; mode=display">\frac{\mathrm{d}y}{\mathrm{d}x}+P(x)y=Q(x)</script><h4 id="齐次（一阶）"><a href="#齐次（一阶）" class="headerlink" title="齐次（一阶）"></a>齐次（一阶）</h4><p>先求它的齐次方程：</p><script type="math/tex; mode=display">\frac{\mathrm{d}y}{\mathrm{d}x}+P(x)y=0</script><p>的解，很显然可以分离变量：</p><script type="math/tex; mode=display">\frac{\mathrm{d}y}{y}=-P(x)\mathrm{d}x</script><p>两端积分，得：</p><script type="math/tex; mode=display">\ln|y|=-\int P(x)\mathrm{d}x+C_1</script><p>改写下就得到了齐次方程的通解：</p><script type="math/tex; mode=display">\color{red}y=Ce^{-\int P(x)\mathrm{d}x}\quad (C=\pm e^{C_1})</script><hr><h4 id="非齐次（一阶）"><a href="#非齐次（一阶）" class="headerlink" title="非齐次（一阶）"></a>非齐次（一阶）</h4><script type="math/tex; mode=display">\color{red} y=\left(\int Q(x)e^{\int P(x)\mathrm{d}x}\mathrm{d}x+C\right)e^{-\int P(x)\mathrm{d}x}</script><div class="hide-toggle" style="border: 1px solid #66c3ee"><div class="hide-button toggle-title" style="background-color: #66c3ee;color: black"><i class="fas fa-caret-right fa-fw"></i><span>证明过程</span></div>    <div class="hide-content"><p>求非齐次方程： </p><script type="math/tex; mode=display">\frac{\mathrm{d}y}{\mathrm{d}x}+P(x)y=Q(x)</script><p>的通解。假设：</p><script type="math/tex; mode=display">y=u(x)e^{-\int P(x)\mathrm{d}x}</script><p>则：</p><script type="math/tex; mode=display">\frac{\mathrm{d}y}{\mathrm{d}x}=u'e^{-\int P(x)\mathrm{d}x}-uP(x)e^{-\int P(x)\mathrm{d}x}</script><p>回代到非齐次方程中，得到：</p><script type="math/tex; mode=display">u'e^{-\int P(x)\mathrm{d}x}-uP(x)e^{-\int P(x)\mathrm{d}x}+P(x)ue^{-\int P(x)\mathrm{d}x}=Q(x)</script><p>消去之后可得：</p><script type="math/tex; mode=display">u'e^{-\int P(x)\mathrm{d}x}=Q(x)\implies u'=Q(x)e^{\int P(x)\mathrm{d}x}</script><p>两端积分，得：</p><script type="math/tex; mode=display">u(x)=\int Q(x)e^{\int P(x)\mathrm{d}x}\mathrm{d}x+C</script><p>因此，非齐次方程的通解为：</p><script type="math/tex; mode=display">y=\left(\int Q(x)e^{\int P(x)\mathrm{d}x}\mathrm{d}x+C\right)e^{-\int P(x)\mathrm{d}x}</script><p>一般拆开来写作：</p><script type="math/tex; mode=display">y=e^{-\int P(x)\mathrm{d}x}\int Q(x)e^{\int P(x)\mathrm{d}x}\mathrm{d}x+Ce^{-\int P(x)\mathrm{d}x}</script></div></div><hr><h2 id="常考题型"><a href="#常考题型" class="headerlink" title="常考题型"></a>常考题型</h2><p>最常见的题型如下：</p><p>已知$y’’+by’+cy=f(x)$，求其特解的形式，这种题求解的步骤的一般步骤是：</p><ol><li>根据特征方程算出特征根($r_1.r_2$)</li><li>根据特征根和$f(x)$的形式，确定特解的形式(比如$x^ke^x(Acos\beta x+Bsin\beta x)$)</li><li>将特解带入进方程，<strong>求出待定系数的值</strong>(如果$A$或者$B$是$0$的话，特解形式就会改变)</li></ol><p>其还有变种，有时候会给出$y’(0)$和$y’’(0)$的值，这种情况下，<strong>通解=特解+齐次解</strong>，然后将通解代入求出其通解</p><p>还有积分-微分方程的形式，如果对积分进行多次求导，将其化成微分方程的形式，然后根据积分的性质，得出初始条件，以求解最终的$C$值</p><hr><p>例如：$f(x+y)=\frac{f(x)+f(y)}{1-f(x)f(y)}$，$f(xy)=yf(x)+xf(y)$的形式，常常和导数有关，解决此类题，要从导数的定义入手</p><script type="math/tex; mode=display">f'(x)=\frac{f(x+\Delta x)-f(x)}{\Delta x}</script><p>其中$f(x+\Delta x)$根据题目给出的条件转换为对应的形式，然后就可求出$f’(x)$</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.一元函数积分学</title>
      <link href="/post/25276.html"/>
      <url>/post/25276.html</url>
      
        <content type="html"><![CDATA[<h1 id="一元函数积分学"><a href="#一元函数积分学" class="headerlink" title="一元函数积分学"></a>一元函数积分学</h1><h2 id="定积分"><a href="#定积分" class="headerlink" title="定积分"></a>定积分</h2><h3 id="曲边梯形面积"><a href="#曲边梯形面积" class="headerlink" title="曲边梯形面积"></a>曲边梯形面积</h3><p>从曲边梯形的面积讲起：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220804161623168.png" alt="image-20220804161623168"></p><p>如果要求该梯形面积，可以把$[0,a]$均分为$n$份，以每一份线段为底，以这一份线段的右侧的函数值为矩形高度：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220804161716412.png" alt="image-20220804161716412"></p><p>当$n\to\infty$的时候，矩形面积和就是曲面下的面积：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220804161734553.png" alt="image-20220804161734553"></p><hr><p>实际上，$[a,b]$不一定需要均分为$n$份，可以<strong>任意分割</strong>：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220804161839628.png" alt="image-20220804161839628"></p><p>很显然用于分割区间的点符合：</p><script type="math/tex; mode=display">a < x_1 < x_2 < \cdots < x_{n-1} < b</script><p>令$x_0=a,x_n=b$，那么集合：</p><script type="math/tex; mode=display">P=\{x_0, x_1, x_2, \cdots, x_{n}\}</script><p>称为$[a,b]$的一个$\color{Salmon}{划分}$。划分$P$定义了$n$个子区间：</p><script type="math/tex; mode=display">[x_0, x_1], [x_1, x_2], \cdots,[x_{k-1}, x_k],\cdots, [x_{n-1}, x_n]</script><p>$[x_0, x_1]$称为第$1$个子区间，更一般的$[x_{k-1},x_k]$被称为第$k$个子区间</p><p>第$k$个子区间的长度为$\Delta x_k=x_k-x_{k-1}$：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220804161952687.png" alt="image-20220804161952687"></p><hr><p>对于某一个划分$P$，在其第$k$个<strong>子区间</strong>内随便选一个数$\xi_k$：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220804162129383.png" alt="image-20220804162129383"></p><p>以$f(\xi_k)$作为矩形的高：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220804162151262.png" alt="image-20220804162151262"></p><p>那么矩形的高度也可以是任意的：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220804162205488.png" alt="image-20220804162205488"></p><hr><h3 id="黎曼和"><a href="#黎曼和" class="headerlink" title="黎曼和"></a>黎曼和</h3><p>根据以上的推导，可以得出这样的结论：</p><p>设函数$f(x)$在$[a,b]$上有定义，在$[a,b]$上任意插入若干个分点：</p><script type="math/tex; mode=display">a=x_0 < x_1 <x_2 ... < x_n =b</script><p>这些分点的集合：</p><script type="math/tex; mode=display">P=\{x_0, x_1, x_2, \cdots, x_{n}\}</script><p>称为$[a,b]$的一个$\color{Salmon}{划分}$。划分$P$定义了$n$个子区间：</p><script type="math/tex; mode=display">[x_0, x_1], [x_1, x_2], \cdots, [x_{n-1}, x_n]</script><p>它们的长度依次为：</p><script type="math/tex; mode=display">\Delta x_1=x_1-x_0,\Delta x_2=x_2-x_1,\cdots,\Delta x_n=x_n-x_{n-1}</script><p>在每个子区间$[x_{k-1},x_k]$上任取选取一个数$\xi_k，以[x_{k-1},x_k]$为底，$f(\xi_k)$为高构造矩形，这些矩形的和：</p><script type="math/tex; mode=display">A_n=\sum_{k=1}^{n}f(\xi_k)\Delta x_k</script><p>称为$f$在$[a,b]$上的$\color{Salmon}{黎曼和}$</p><p>随着$[a,b]$的划分不断变细，所有子区间的长度趋于$0$时，黎曼和不断地逼近曲边梯形的面积</p><hr><h3 id="严格定义"><a href="#严格定义" class="headerlink" title="严格定义"></a>严格定义</h3><p>设函数$f(x)$在$[a,b]$上有定义，对于$[a,b]$上的任意划分$P$，$\xi_k$为子区间$[x_{k-1},x_k]$上任意选取的数，子区间$[x_{k-1},x_k]$的长度为$\Delta x_k$，记：</p><script type="math/tex; mode=display">\lambda=max\{\Delta x_1,\Delta x_2,...,\Delta x_n\}</script><p>如果当$\lambda\to 0$时</p><script type="math/tex; mode=display">S=\sum_{i=1}^{n} f\left(\xi_{i}\right) \Delta x_{i}</script><p>的极限总是存在，且与闭区间$[a,b]$的分法及点$\xi_i$的取法<strong>无关</strong>，那么称这个极限$I$为函数$f(x)$在区间$[a,b]$上的定积分，记做$\int_{a}^{b}f(x)dx$,即</p><script type="math/tex; mode=display">\int_{a}^{b} f(x) \mathrm{d} x=I=\lim _{\lambda \rightarrow 0} \sum_{i=1}^{n} f\left(\xi_{i}\right) \Delta x_{i}</script><p>其中$a$为$\color{Salmon}{积分下限}$，$b为\color{Salmon}{积分上限}$，$I$为$f(x)$在$[a,b]$上的$\color{Salmon}{定积分}$，$x$为$\color{Salmon}{积分变量}$</p><p>$\lambda \to 0$的意思是$\Delta x\to 0$，让黎曼和等于曲边梯形的面积</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220804162756255.png" alt="image-20220804162756255"></p><hr><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>可积的充分条件：</p><ul><li>如果$f(x)$在$[a,b]$上连续，则$f(x)$在$[a,b]$上可积：</li><li>如果$f(x)$在$[a,b]$上有界，且只有有限个间断点，则$f(x)$在$[a,b]$上可积</li><li>如果$f(x)$在$[a,b]$上仅有有限个第一类间断点，则$f(x)$在$[a,b]$上可积</li></ul><p>所以连续一定可积，可积不一定连续</p><hr><p>齐次性：</p><script type="math/tex; mode=display">\int_{a}^{b}cf(x)\textrm{d}x=c\int_{a}^{b}f(x)\textrm{d}x,c\in\mathbb{R}</script><p>这点也不难理解，相同的划分、以及相同的方式选取$\xi_k$，让$f(\xi_k)$扩大了$c$倍，自然面积也会扩大$c$倍</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220804163322700.png" alt="image-20220804163322700"></p><hr><p>可加性：</p><script type="math/tex; mode=display">\int_{a}^{b}[f(x)+g(x)]\textrm{d}x=\int_{a}^{b}f(x)\textrm{d}x+\int_{a}^{b}g(x)\textrm{d}x</script><hr><p>面积的正负：</p><p>区间$[a,b]$上$f(x) &lt; 0$，那么：</p><script type="math/tex; mode=display">\int_{a}^{b}f(x)\textrm{d}x < 0</script><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220804164342809.png" alt="image-20220804164342809"></p><p>关于这点，可以延伸出来其他的形式，比如</p><script type="math/tex; mode=display">\int_{a}^{b}f(x)\textrm{d}x < c\qquad c是常数</script><p>可以将$c$积分成区间内的一个其他常数$d$，然后将其换位如下形式：</p><script type="math/tex; mode=display">\int_{a}^{b}f(x)-d\quad\textrm{d}x <0</script><p>这样就可以判断$f(x)-d$在区间$[a,b]$之间的单调性来判断其面积的正负了</p><hr><p>面积的大小：</p><p>设$a &lt; b$，如果在区间$[a,b]$上$f(x) &gt; g(x)$，那么：</p><script type="math/tex; mode=display">\int_{a}^{b}f(x)\textrm{d}x > \int_{a}^{b}g(x)\textrm{d}x</script><hr><p>面积的分解：</p><p>设$a &lt; c &lt; b$，则：</p><script type="math/tex; mode=display">\int_{a}^{b}f(x)\textrm{d}x=\int_{a}^{c}f(x)\textrm{d}x+\int_{c}^{b}f(x)\textrm{d}x</script><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220804164424444.png" alt="image-20220804164424444"></p><hr><p>交换积分上下限，符号改变</p><script type="math/tex; mode=display">\int_{a}^{b}f(x)\textrm{d}x = -\int_{b}^{a}f(x)\textrm{d}x</script><p>上下限一致，积分为0</p><script type="math/tex; mode=display">\int_{a}^{a}f(x)\textrm{d}x=0</script><hr><p>奇偶性</p><p>若$f(x)$是奇函数，则$\int^x_0f(t)dt$是偶函数，偶函数$\int^a_{-a}f(x)dx=2\int^a_0f(x)dx$</p><p>若$f(x)$是偶函数，则$\int^x_0f(t)dt$是奇函数 ，奇函数$\int^a_{-a}f(x)dx=0$</p><p>常见的奇函数有：$sinx，tanx，arcsinx，arctanx，ln\frac{1-x}{1+x}，ln(x+\sqrt{1+x^2})，\frac{e^x-1}{e^x+1}，f(x)-f(-x)$</p><p>常见的偶函数有：</p><p>$x^2，|x|，f(x)+f(-x)$</p><hr><p>不等式</p><script type="math/tex; mode=display">|\int^b_af(x)dx|≤\int^b_a|f(x)|dx</script><p>推导：</p><script type="math/tex; mode=display">(\int^a_bg(x)f(x)dx)^2≤\int^a_bg(x)^2dx·\int^a_bf(x)^2dx</script><hr><h3 id="积分中值定理"><a href="#积分中值定理" class="headerlink" title="积分中值定理"></a>积分中值定理</h3><p>设$a &lt; b$，$M$和$m$分别是函数$f(x$)是区间$[a,b]$​上的最大值和最小值，则：</p><script type="math/tex; mode=display">m\le\frac{1}{b-a}\int_{a}^{b}f(x)\textrm{d}x\le M</script><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220804164902935.png" alt="image-20220804164902935"></p><p>这是很显然的事实，故可以推导出，在$m(b-a)$到$M(b-a)$的过程中，必有一个矩形的面积和曲边梯形的面积相同</p><p>积分中值定理：</p><p>如果函数$f(x)$在积分区间$[a,b]$连续，那么在$[a,b]$上至少存在一点$\xi$​，使下式成立：</p><script type="math/tex; mode=display">\int_a^bf(x)dx=f(\xi)(b-a),\xi\in[a,b]</script><p>如果函数$f(x),g(x)$在$[a,b]$上连续，$g(x)$不变号，则：</p><script type="math/tex; mode=display">\int^b_af(x)g(x)dx=f(c)\int^b_ag(x)dx\qquad a≤c≤b</script><hr><h2 id="微积分基本定理"><a href="#微积分基本定理" class="headerlink" title="微积分基本定理"></a>微积分基本定理</h2><h3 id="积分上限函数"><a href="#积分上限函数" class="headerlink" title="积分上限函数"></a>积分上限函数</h3><p>如果一个定积分的上限不确定，而是一个可以改变的值</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220804165144356.png" alt="image-20220804165144356"></p><p>不同的$x$对应不同的$A$，所以这是一个面积函数$A(x)$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220804165256268.png" alt="image-20220804165256268"></p><p>这个面积函数又称为$\color{Salmon}{积分上限函数}$，可以用定积分表示如下：</p><script type="math/tex; mode=display">A(x)=\int_a^x f(t)\textrm{d}t</script><p><strong>连续性</strong>：只要$f(x)$在区间$[a,b]$上可积，则存在积分上限函数$F(x)=\int^x_af(t)dt$在$[a,b]$上连续</p><script type="math/tex; mode=display">f(x)连续\Longrightarrow f(x)可积\Longrightarrow 上限函数F(x)连续</script><p>如果$f(x)$在$[a,b]$上除点$x=x_0\in(a,b)$外均连续，则在点$x=x_0$处</p><p>如果<strong>连续</strong>，那么一定可导 $F’(x_0)=f(x_0)$  (符合原函数存在定理)</p><p>如果<strong>可去</strong>，那么一定可导  $F’(x_0)=\lim_{x\to x_0}f(x)$</p><p>如果<strong>跳跃</strong>，那么是连续但不可导，且$F’_+(x_0)=f(x_0^+)\qquad F’_-(x_0)=f(x_0^-)$</p><p>这和原函数存在定理并不冲突，只有$f(x_0)$连续的时候，$F(x_0)$才是原函数，在可去和跳跃间断点的情况下不是</p><p>如果$f(x)$是奇函数，则$\int_0^x f(t)\textrm{d}t$是偶函数</p><p>如果$f(x)$是偶函数，则$\int_0^x f(t)\textrm{d}t$是奇函数</p><p>积分上限函数的导数：$\int_0^{\phi(x)}f(t)dt$ ，$\phi (x)$是$n$阶，$f(t)$是$m$阶，这个积分就是$x$的$n+nm=n(m+1)$阶</p><hr><h3 id="第一基本定理"><a href="#第一基本定理" class="headerlink" title="第一基本定理"></a>第一基本定理</h3><p>如果函数$f(x)$在区间$[a,b]$上连续，那么积分上限的函数：</p><script type="math/tex; mode=display">\Phi(x)=\int_a^x f(t)dt</script><p>在$[a,b]$上可导，导数为：</p><script type="math/tex; mode=display">\Phi'(x)=\frac{d}{dx}\int_a^xf(t)dt=f(x),(a \leq x \leq b)</script><div class="hide-toggle" style="border: 1px solid #66c3ee"><div class="hide-button toggle-title" style="background-color: #66c3ee;color: black"><i class="fas fa-caret-right fa-fw"></i><span>证明过程</span></div>    <div class="hide-content"><p>对$\Phi(x)$的求导，也就是求面积函数的变化率，增量$\Delta x$对应的面积$\Delta\Phi$为：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220804171219671.png" alt="image-20220804171219671"></p><p>根据微积分的思想，当$\Delta x$足够小时，下面这个矩形面积约等于$\Delta\Phi$，即:</p><script type="math/tex; mode=display">f(x)\Delta x ≈\Delta \Phi</script><script type="math/tex; mode=display">\frac{\Delta\Phi}{\Delta x}\approx f(x)</script><p>进而两边取极限：</p><script type="math/tex; mode=display">\lim_{\Delta x \to 0}\frac{\Delta\Phi}{\Delta x}=\lim_{\Delta x \to 0}f(x)\implies \Phi'(x)=f(x)</script></div></div><p>此定理之所以叫做“微积分第一定理”，是因为它说明了，$f(x)$在$[a,b]$上连续时，积分与求导（或者说，与微分）之间是互逆的，奠定了微积分的基础：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220804171519402.png" alt="image-20220804171519402"></p><p>第一定理在积分和微分直接架起了桥梁，同样可写成</p><script type="math/tex; mode=display">f(x)=\int^x_a f'(x)dx</script><p>和微分中值定理一样，为证明题提供了方便的工具</p><hr><p>原函数：</p><p>如果在区间$I$上，可微函数$F(x)$都有：</p><script type="math/tex; mode=display">F'(x)=f(x)\quad或\quad \textrm{d}F(x)=f(x)\textrm{d}x</script><p>那么函数$F(x)$就称为$f(x)$（或$f(x)\textrm{d}x$）在区间$I$上的一个$\color{Salmon}{原函数}$</p><p>所以在满足微积分第一基本定理时有：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220804171722222.png" alt="image-20220804171722222"></p><hr><h3 id="第二基本定理"><a href="#第二基本定理" class="headerlink" title="第二基本定理"></a>第二基本定理</h3><p>也叫作牛顿—莱布尼茨公式：</p><p>$f(x)$在$[a,b]$上连续，$F(x)$是$f(x)$的一个原函数，那么：</p><script type="math/tex; mode=display">\int_a^b f(x)\textrm{d}x=F(b)-F(a)</script><p>也可以记作：</p><script type="math/tex; mode=display">\int_a^b f(x)\textrm{d}x=[F(x)]_a^b</script><hr><h2 id="不定积分"><a href="#不定积分" class="headerlink" title="不定积分"></a>不定积分</h2><h3 id="原函数存在定理"><a href="#原函数存在定理" class="headerlink" title="原函数存在定理"></a>原函数存在定理</h3><p>定理1：</p><p>如果函数$f(x)$在区间$[a,b]$上连续，那么积分上限的函数：</p><script type="math/tex; mode=display">\Phi(x)=\int_a^x f(t)dt</script><p>就是$f(x)$在$[a,b]$上的一个原函数。</p><p>这个定理说明了：</p><script type="math/tex; mode=display">连续函数 \implies 有原函数</script><p>但这不是充要条件，某些间断函数同样也能有原函数</p><hr><p>定理2：</p><p>如果$f(x)$在区间$[a,b]$上有第一类间断点，则$f(x)$在区间$I$上没有原函数</p><p>这个定理说明了：</p><script type="math/tex; mode=display">有第一类间断点\implies无原函数</script><blockquote><p>有原函数和可积之间并没有联系</p></blockquote><hr><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>如果改变积分的下限：积分区间从$[a,x]$，变为$[a’,x]$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220804174543796.png" alt="image-20220804174543796"></p><p>很显然有：</p><script type="math/tex; mode=display">\int_{a'}^x f(t)\textrm{d}t=\int_a^x f(t)\textrm{d}t-\int_a^{a'} f(t)\textrm{d}t</script><p>而定积分为一个常数：</p><script type="math/tex; mode=display">C=\int_a^{a'} f(t)\textrm{d}t</script><p>所以，调整下限之后的积分上限函数和$\Phi(x)$相差一个常数：</p><script type="math/tex; mode=display">\int_{a'}^x f(t)\textrm{d}t=\Phi(x)-C</script><p>根据求导法则：</p><script type="math/tex; mode=display">(\int_{a'}^x f(t)\textrm{d}t)'=(\Phi(x)-C)'=f(x)</script><p>依然是一个原函数。</p><hr><p>原函数有很多。把所有的原函数定义为：</p><p>如果$F(x)$是$f(x)$在区间$I$上的一个原函数，那么$F(x)+C$就是$f(x)$的$\color{Salmon}{不定积分}$，即：</p><script type="math/tex; mode=display">\int f(x)\textrm{d}x=F(x)+C,C\in\mathbb{R}</script><p>并且不定积分$\int f(x)dx$表示了$f(x)$的所有原函数</p><p>根据原函数存在定理，不定积分如果是分段函数，那么要考虑都在分段点的连续问题，需要设定符合条件的$C$</p><hr><h2 id="基本积分公式"><a href="#基本积分公式" class="headerlink" title="基本积分公式"></a>基本积分公式</h2><h3 id="三角函数的积分"><a href="#三角函数的积分" class="headerlink" title="三角函数的积分"></a>三角函数的积分</h3><script type="math/tex; mode=display">\int\cos x\textrm{d}x=\sin x+C\qquad\int\sin x\textrm{d}x=-\cos x+C\qquad</script><script type="math/tex; mode=display">{\color{red}{\int\tan x\textrm{d}x=\ln|\sec x|+C}=-ln|cosx|+C}\qquad \int\cot x\textrm{d}x=ln|sinx|+C</script><script type="math/tex; mode=display">{\color{red}\int\sec xdx=ln|secx+tanx|+C} \color{red}\qquad\int\csc xdx=ln|tan\frac{x}2{}|+C=ln|cscx-cotx|+C</script><script type="math/tex; mode=display">\int\sec^2x\textrm{d}x=\tan x+C\qquad\int\csc^2x\textrm{d}x=-\cot x+C\\</script><script type="math/tex; mode=display">\int\sec x\tan x\textrm{d}x=\sec x+C\qquad\int\csc x\cot x\textrm{d}x=-\csc x+C\quad\\</script><div class="hide-toggle" style="border: 1px solid #66c3ee"><div class="hide-button toggle-title" style="background-color: #66c3ee;color: black"><i class="fas fa-caret-right fa-fw"></i><span>推导过程</span></div>    <div class="hide-content"><script type="math/tex; mode=display">\begin{aligned}\int secxdx=\int \frac{cos}{1-sin^2x}dx=\int \frac{1}{(1+sinx)(1-sinx)}dsinx\\=\frac{1}{2}ln|\frac{1+sinx}{1-sinx}|+C\\=ln\sqrt\frac{1+sinx}{1-sinx}+C\\=ln\sqrt\frac{(1+sinx)^2}{1-sin^2x}+C\\=ln\frac{1+sinx}{cosx}+C\\=ln|secx+tanx|+C\\\end{aligned}</script><script type="math/tex; mode=display">\begin{aligned}\int\csc xdx=∫\frac{1}{sinx}dx=∫\frac{1}{2sin(\frac{x}{2})cos (\frac{x}{2})}dx\\=∫\frac{1}{sin(\frac{x}{2})cos (\frac{x}{2})}d(\frac{x}{2})\\=∫\frac{1}{tan\frac{x}{2}}·sec^2(\frac{x}{2})d(\frac{x}{2})\\=∫\frac{1}{tan(\frac{x}{2})}d(tan\frac{x}{2})\\=ln|tan\frac{x}{2}|+C\end{aligned}</script></div></div><hr><h3 id="指数函数的积分"><a href="#指数函数的积分" class="headerlink" title="指数函数的积分"></a>指数函数的积分</h3><script type="math/tex; mode=display">\int x^n\textrm{d}x=\frac{x^{n+1}}{n+1}+C,(n\neq -1)\\</script><script type="math/tex; mode=display">\int a^x\textrm{d}x=\frac{a^x}{\ln a}+C\\</script><script type="math/tex; mode=display">\int e^x\textrm{d}x=e^x+C\\</script><script type="math/tex; mode=display">\int\frac{1}{x}\textrm{d}x=\ln |x|+C</script><hr><h3 id="分式的积分"><a href="#分式的积分" class="headerlink" title="分式的积分"></a>分式的积分</h3><script type="math/tex; mode=display">\int\frac{1}{\sqrt{a^2-x^2}}\textrm{d}x=\arcsin \frac{x}{a}+C\qquad \\</script><script type="math/tex; mode=display">\color{red} \int\frac{1}{\sqrt{x^2+a^2}}\textrm{d}x=ln(x+\sqrt{x^2+a^2})+C\qquad \\</script><script type="math/tex; mode=display">\int\frac{1}{\sqrt{x^2-a^2}}\textrm{d}x=ln|x+\sqrt{x^2-a^2}|+C\qquad \\</script><script type="math/tex; mode=display">\int\frac{1}{a^2+x^2}\textrm{d}x=\frac{1}{a}\arctan\frac{x}{a}+C\qquad \\</script><script type="math/tex; mode=display">\color{red} \int\frac{1}{x^2-a^2}dx=\frac{1}{2a}ln|\frac{x-a}{x+a}|+C\qquad</script><script type="math/tex; mode=display">\color{red} \int\frac{1}{a^2-x^2}dx=\frac{1}{2a}ln|\frac{a+x}{a-x}|+C\qquad</script><script type="math/tex; mode=display">\color{red}{\int\sqrt{1+x^2}dx=\frac{1}{2}x\sqrt{1+x^2}+\frac{1}{2}ln|x+\sqrt{1+x^2}|+C}</script><div class="hide-toggle" style="border: 1px solid #66c3ee"><div class="hide-button toggle-title" style="background-color: #66c3ee;color: black"><i class="fas fa-caret-right fa-fw"></i><span>推导过程</span></div>    <div class="hide-content"><p>推导过程如下：</p><p>根据第二类换元法，$x=atant$</p><script type="math/tex; mode=display">\begin{align*}\int\frac{1}{\sqrt{x^2+a^2}}\textrm{d}x\\ &=\int\frac{d(atant)}{\sqrt{a^2tan^2t+a^2}}\\& =\int\frac{asec^2t}{a\sqrt{tan^2t+1}}dt\\\&=\int sectdt\\&=ln(sect+tant)+C\\& =ln(\sqrt{tant^2+1}+tant)+C\\& =ln(\sqrt{\frac{x^2}{a^2}+1}+\frac{x}{a})+C\\&=ln\frac{\sqrt{(x^2+a^2)+x}}{a}+C\\&=ln(\sqrt{x^2+a^2}+x)-lna+C\\&=ln(\sqrt{x^2+a^2}+x)+C\end{align*}</script><script type="math/tex; mode=display">\begin{align*}\int\frac{1}{x^2-a^2}dx=\int\frac{1}{(x-a)(x+a)}dx\\=\frac{1}{2a}\int\frac{1}{x-a}-\frac{1}{x+a}dx\\=\frac{1}{2a}ln|\frac{x-a}{x+a}|+C\end{align*}</script><script type="math/tex; mode=display">\begin{align*}\int\frac{1}{a^2-x^2}dx=\ \int\frac{\frac{1}{2a}[(a+x)(a-x)]}{(a-x)(a+x)}dx \\=\frac{1}{2a}\int\frac{1}{a-x}+\frac{1}{a+x}dx \\=\frac{1}{2a}ln|\frac{a+x}{a-x}|+C \end{align*}</script><script type="math/tex; mode=display">\begin{align*}{\color{red}{\int\sqrt{1+x^2}dx}}\\&=x\sqrt{1+x^2}-\int x·\frac{x}{\sqrt{1+x^2}}dx\\&=x\sqrt{1+x^2}-\int\frac{1+x^2-1}{\sqrt{1+x^2}}dx\\&=x\sqrt{1+x^2}-{\color{red}{\int\sqrt{1+x^2}dx}}+\int\frac{1}{\sqrt{1+x^2}}d\\&=\frac{1}{2}x\sqrt{1+x^2}+\frac{1}{2}ln|x+\sqrt{1+x^2}|+C\end{align*}</script></div></div><hr><p>分式积分$\int \frac{f(x)}{g(x)}dx$的常见类型</p><ul><li>$\frac{f(x)}{g(x)}$是一整个根式的话，可以将根式代换成另一个未知数$t$，再进行积分，如果是根号下$\sqrt{1-x}$之类的形式，可以用三角函数代换，比如用$x=sin^2t$</li><li>如果$g(x)$是两个多项式相减或相加，考虑将其化为相乘的形式，再将其拆开，比如$x^3-1=(x-1)(x^2+x+1)$，如果是相乘的形式，直接考虑拆开</li><li>如果$g(x)$是一整个根式的话，观察根式内未知数的形式，如果根式内只是$\sqrt{a+x}$考虑直接进行换元，因为很好化简，$d\sqrt{a+x}=\frac{1}{2\sqrt{a+x}{}}$，或者是说$e^x$在分子，也可以直接换元，如果根式内是$\sqrt{a+x^2}$的形式，那就考虑进行三角函数变换</li><li>如果$g(x)$是一整个根式，但是根式里面是多项式$\sqrt{x+x^2}$的形式，考虑将根号下化为完全平方式，再换元</li><li>如果$g(x)$是低次×高次的形式，可以将低次升阶到高次，从而使未知数的次统一，比如$\frac{1}{x\sqrt{x^4+1}}$，这个$x$很容易升阶为$x^4$，分子分母都乘$x^3$,然后将分子上的$x^3$积进去就行了然后将根式$\sqrt{1+x^4}=t$进行换元，即可求解</li><li>在区间$[0,1]$上使用三角代换可能有方便</li><li>针对无穷积分的换元法，考虑到$\frac{1}{t}$的代换</li></ul><hr><p>对于</p><script type="math/tex; mode=display">\int\frac{sinx或cosx}{asinx+bcosx}dx</script><p>形式的分式，可以使用如下技巧：</p><script type="math/tex; mode=display">sinx=a(sinx+cosx)+\beta(sinx+cosx)'=(a-\beta)sinx+(a+\beta)cosx</script><script type="math/tex; mode=display">\begin{cases}a-\beta=1\\ a+\beta=0 \end{cases}\implies a=\frac{1}{2},\beta=-\frac{1}{2}</script><p>所以可以分解成</p><script type="math/tex; mode=display">I=\int\frac{asinx+bcosx}{asinx+bcosx}dx+\int\frac{(asinx+bcosx)'}{asinx+bcosx}dx</script><p>的形式</p><hr><p>对于</p><script type="math/tex; mode=display">\int\frac{1}{asinx+bcosx}dx</script><p>的形式，利用辅助角公式：</p><script type="math/tex; mode=display">a\sin x+b\cos x=\sqrt{a^2+b^2}\sin(x+\alpha)\\其中\alpha=\arctan\frac{b}{a}\\</script><p>那么原式化为：</p><script type="math/tex; mode=display">I(a,b)=\frac{1}{\sqrt{a^2+b^2}}\int\frac{dx}{sin(x+\alpha)}=\frac{1}{\sqrt{a^2+b^2}}\int csc(x+\alpha)d(x+\alpha)</script><p>而已知：</p><script type="math/tex; mode=display">\int\csc xdx=ln|tan\frac{x}2{}|+C</script><p>故：</p><script type="math/tex; mode=display">I(a,b)=\frac{1}{\sqrt{a^2+b^2}}ln|tan\frac{x+\alpha}{2}|+C</script><hr><p>对于</p><script type="math/tex; mode=display">\int\frac{1}{a^2sin^2x+b^2cos^2x}dx</script><p>的形式</p><p>此时将分式上下同除一个$cos^2x$​，化为</p><script type="math/tex; mode=display">\int\frac{sec^2x}{a^2tan^2x+b^2}dx=\frac{1}{a}\int\frac{d(atanx)}{a^2tan^2x+b^2}</script><script type="math/tex; mode=display">I=\frac{1}{ab}arctan\frac{atanx}{b}+C</script><hr><p>分解因式法</p><p>当积分形式如下时,可以被分解因式：</p><script type="math/tex; mode=display">\int\frac{c}{f(x)^2g(x)}dx=\int \frac{A}{f(x)}+\frac{B}{f^2(x)}+\frac{C}{g(x)}dx</script><p>如果$g(x)$是$1$次方程假设为$C$，如果是$2$次，就假设为$Cx+D$</p><hr><h2 id="积分技巧"><a href="#积分技巧" class="headerlink" title="积分技巧"></a>积分技巧</h2><h3 id="第一类换元法"><a href="#第一类换元法" class="headerlink" title="第一类换元法"></a>第一类换元法</h3><p>设$f(u)$具有原函数$F(u)$，$u=u(x)$可导，则有换元公式：</p><script type="math/tex; mode=display">\int f[\underbrace{u(x)}_{\color{skyblue}{u}}]\underbrace{u'(x)\textrm{d}x}_{\color{salmon}{\textrm{d}u}}=\int f(\color{skyblue}{u})\color{salmon}{\textrm{d}u}=F(u)+C</script><h3 id="第二类换元法"><a href="#第二类换元法" class="headerlink" title="第二类换元法"></a>第二类换元法</h3><p>设$x=x(t)$是单调的可导函数，且$x’(t)\neq 0$，则$t$可以用$x$来表示，即有反函数：</p><script type="math/tex; mode=display">t=t(x)</script><p>如果有：</p><script type="math/tex; mode=display">\int f(x)\textrm{d}x\xrightarrow{\quad 换元x=x(t)\quad}\int f[x(t)]x'(t)\textrm{d}t=F(t)+C</script><p>则：</p><script type="math/tex; mode=display">\int f(x)\textrm{d}x=F(t(x))+C</script><p>常用的换元法有：</p><script type="math/tex; mode=display">\quad \qquad\sqrt{a^2-x^2}\qquad x=asint(acost)\\</script><script type="math/tex; mode=display">\sqrt{a^2+x^2}\qquad x=atant\\</script><script type="math/tex; mode=display">\sqrt{x^2-a^2}\qquad x=asect</script><p>区间简化公式：诀窍是$x-\frac{a+b}{2}=\frac{b-a}{2}sint$</p><script type="math/tex; mode=display">\int_{a}^{b}  \sqrt{(x-a)(b-x)}dx=\frac{(b-a)^2}{8}\pi</script><hr><h3 id="分部积分法"><a href="#分部积分法" class="headerlink" title="分部积分法"></a>分部积分法</h3><p>$f(x),g(x)$皆为可导函数，有：</p><script type="math/tex; mode=display">\int f(x)g'(x)dx=f(x)g(x)-\int g(x)f'(x)dx</script><p>或设$u=f(x),v=g(x)$，上式可以写作：</p><script type="math/tex; mode=display">\int udv=uv-\int vdu</script><p>多项式和<strong>指数或三角函数</strong>相乘，把三角函数和指数凑进去，即当做$g’(x)$</p><p>多项式和<strong>对数或反三角函数</strong>相乘，把多项式凑进去</p><hr><p>对于某些积分$I=\int^a_bf(x)dx$难以处理时，有时通过变形将$I$变为另一种形式$I=\int^a_bg(x)dx$的形式，然后把两者结合在一起：</p><script type="math/tex; mode=display">2I=\int^a_b[f(x)+g(x)]dx</script><p>若该积分易处理，则问题解决：</p><ul><li>类型1</li></ul><script type="math/tex; mode=display">I=\int^b_0f(x)dx\qquad 令x=b-t\implies\int_0^bf(b-t)dt=\int^b_0f(b-x)dx</script><script type="math/tex; mode=display">2I=\int^b_0[f(x)+f(b-x)]dx</script><ul><li><p>类型2</p><script type="math/tex; mode=display">I=\int^a_{-a}f(x)dx \quad 令x=-t\implies\int^a_{-a}f(-t)dt</script><script type="math/tex; mode=display">2I=\int^a_{-a}[f(x)+f(-x)]dx</script></li></ul><p>实际上以上方法都基于<strong>区间不变公式</strong>：</p><script type="math/tex; mode=display">\int_a^bf(x)dx\stackrel{x=a+b-t}{\longrightarrow}\int^b_af(a+b-t)dt</script><hr><h3 id="常见的可积函数积分"><a href="#常见的可积函数积分" class="headerlink" title="常见的可积函数积分"></a>常见的可积函数积分</h3><p>有理函数积分$\int R(x)dx$</p><p>一般是两个多项式的除法，常常将$R(x)$拆成两个真分式之和</p><hr><p>三角有理式积分$\int R(sinx,cosx)dx$</p><ol><li>一般方法是万能代换，令$tan\frac{x}{2}=t$</li></ol><script type="math/tex; mode=display">\int R(sinx,cosx)dx=\int R\left(\frac{2t}{1+t^2},\frac{1-t^2}{1+t^2}\right)\cdot\frac{2}{1+t^2}dt.</script><ol><li><p>特殊方法(变形，换元，分部)</p><p>如果$R(-sinx,cosx)=-R(sinx,cosx)$，则令$u=cosx$</p><p>如果$R(sinx,-cosx)=-R(sinx,cosx)$，则令$u=sinx$</p><p>如果$R(-sinx,-cosx)=-R(sinx,cosx)$，则令$u=tanx$</p></li></ol><hr><p>简单无理函数积分</p><p>对于不定积分 $\int R(x,\sqrt[n]\frac{ax+b}{cx+d})dx)$ ,令$\sqrt[n]\frac{ax+b}{cx+d}dx=t$</p><hr><p>计算公式：</p><script type="math/tex; mode=display">\int_{0}^{\frac{\pi}{2}}\sin^{n}x dx=\int_{0}^{\frac{\pi}{2}}\cos^{n}x dx=\begin{cases}\frac{n-1}{n}\frac{n-3}{n-2}\frac{n-5}{n-4}...\frac{1}{2}\frac{\pi}{2}(当n为偶数时)\\\\ \frac{n-1}{n}\frac{n-3}{n-2}\frac{n-5}{n-4}...\frac{2}{3}(当n为奇数时)\end{cases}</script><script type="math/tex; mode=display">\int^{\pi}_0cos^nxdx=\begin{cases}0\quad n为奇数\\ 2\int^{\frac{\pi}{2} }cos^nxdx \quad n为偶数\end{cases}</script><script type="math/tex; mode=display">\int^{2\pi}_0cos^nxdx=\int^{2\pi}_0sin^nxdx=\begin{cases}0\quad n为奇数\\ 4\int^{\frac{\pi}{2} }cos^nxdx \quad n为偶数\end{cases}</script><script type="math/tex; mode=display">\int_{0}^{\pi}xf(sinx) dx=\frac{\pi}{2}\int_{0}^{\pi}f(sinx) dx=\pi\int_0^{\pi/2}f(sinx)dx</script><hr><h2 id="反常积分"><a href="#反常积分" class="headerlink" title="反常积分"></a>反常积分</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>积分区间包含正负无穷的，统称为$\color{Salmon}{无穷限的反常积分}$：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220807231058267.png" alt="image-20220807231058267"></p><p>设函数$f(x)$在区间$(-\infty,a]$上连续，任取$t &lt; a$，定义：</p><script type="math/tex; mode=display">\int_{-\infty}^{a}f(x)\textrm{d}x=\lim_{t\to-\infty}\int_{t}^{a}f(x)\textrm{d}x</script><p>同样的，设函数$f(x)$在区间$[a,+\infty)$上连续，任取$t &gt; a$，定义:</p><script type="math/tex; mode=display">\int_{a}^{+\infty}f(x)\textrm{d}x=\lim_{t\to+\infty}\int_{a}^{t}f(x)\textrm{d}x</script><p>还有，设函数$f(x)$在区间$(-\infty,+\infty)$上连续，则：</p><script type="math/tex; mode=display">\int_{-\infty}^{+\infty}f(x)\textrm{d}x=\int_{-\infty}^{a}f(x)\textrm{d}x+\int_{a}^{+\infty}f(x)\textrm{d}x</script><hr><h3 id="审敛法"><a href="#审敛法" class="headerlink" title="审敛法"></a>审敛法</h3><script type="math/tex; mode=display">\int_a^{+\infty}\frac{1}{x^p}\textrm{d}x=\begin{cases}\frac{a^{1-p}}{p-1},&p > 1\quad 收敛\\ +\infty, &p\le 1\quad 发散\end{cases}</script><p>设函数$f(x)$在$[a,+\infty)$上连续，且$f(x) \ge 0$。</p><ul><li>如果$\exists p &gt; 1$，使得$\lim_{x\to+\infty}x^pf(x)=c &lt; +\infty$，那么$\int_a^{+\infty}f(x)\textrm{d}x$收敛；</li><li>如果$\lim_{x\to+\infty}xf(x)=d &gt; 0$或$\lim_{x\to+\infty}xf(x)=+\infty$，那么$\int_a^{+\infty}f(x)\textrm{d}x$发散。</li></ul><p>诀窍在于根据$f(x)$的阶数假设$p$的值</p><hr><h3 id="无界函数的反常积分"><a href="#无界函数的反常积分" class="headerlink" title="无界函数的反常积分"></a>无界函数的反常积分</h3><p>如果函数$f(x)$在点$a$的任一邻域内都无界，那么点$a$称为函数$f(x)$的$\color{Salmon}{瑕点}$（或称为无界间断点）：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220807233208863.png" alt="image-20220807233208863"></p><p>积分区间包含瑕点的积分称为$\color{Salmon}{无界函数的反常积分}$，又称为$\color{Salmon}{瑕积分}$：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220807233237104.png" alt="image-20220807233237104"></p><p>上述瑕积分定义如下。设函数$f(x)$在区间$[b,a)$上连续，点$a$为瑕点，任取$t &lt; a$，定义：</p><script type="math/tex; mode=display">\int_{b}^{a}f(x)dx=\lim_{t\to a^{-}}\int_{b}^{t}f(x)dx</script><p>同样的，设函数$f(x)$在区间$(a,c]$上连续，点$a$为瑕点，任取$t &gt; a$，定义:</p><script type="math/tex; mode=display">\int_{a}^{c}f(x)dx=\lim_{t\to a^{+}}\int_{t}^{c}f(x)dx</script><p>还有，设函数$f(x)$在区间$[b,a)\cup(a,c]$上连续，点$a$为瑕点，定义：</p><script type="math/tex; mode=display">\int_{b}^{c}f(x)dx=\int_{b}^{a}f(x)dx+\int_{a}^{c}f(x)dx</script><hr><h3 id="无界函数的审敛法"><a href="#无界函数的审敛法" class="headerlink" title="无界函数的审敛法"></a>无界函数的审敛法</h3><p>和无穷极限的反常积分的结论相反</p><p>设函数$f(x)$在$(a,b]$上连续，且$f(x) \ge 0，x=a$为瑕点。</p><ul><li>如果$\exists 0 &lt; q &lt; 1$，使得$\lim_{x\to a^+}(x-a)^qf(x)$存在，那么$\int_a^b f(x)\textrm{d}x$收敛；</li><li>如果$\lim_{x\to a^+}(x-a)f(x)=d &gt; 0$或$\lim_{x\to a^+}(x-a)f(x)=+\infty$，那么$\int_a^b f(x)\textrm{d}x$发散</li></ul><hr><h3 id="重要不定积分"><a href="#重要不定积分" class="headerlink" title="重要不定积分"></a>重要不定积分</h3><script type="math/tex; mode=display">\int_1^{+\infty}\frac{1}{x^pln^q x}dx=\begin{cases}p > 1\quad q<1\quad 收敛\\  其他情况\quad 发散\end{cases}</script><script type="math/tex; mode=display">\int_0^{+\infty}x^ke^{-\lambda x}dx=\begin{cases}\lambda > 0\quad 收敛\\  \lambda\le 0\quad 发散\end{cases}</script><p>证明：</p><script type="math/tex; mode=display">I=\int_1^{+\infty}\frac{dx}{x^pln^qx}=\int^e_1\frac{dx}{x^pln^qx}+\int^{+\infty}_e\frac{dx}{x^pln^qx}</script><script type="math/tex; mode=display">lnx=ln[1+(x-1)]\sim x-1(x \to 1)</script><script type="math/tex; mode=display">\lim_{x\to 1^+}\frac{\frac{dx}{x^pln^qx}}{\frac{dx}{(x-1)^q}}=1</script><p>所以</p><script type="math/tex; mode=display">\int^e_1\frac{dx}{x^pln^qx}和\int_1^e\frac{dx}{(x-1)^q}敛散性相同</script><p>所以$q&lt;1$时，收敛</p><p>至于</p><script type="math/tex; mode=display">\int^{+\infty}_e\frac{dx}{x^pln^qx}敛散性和\int^{+\infty}_e\frac{dx}{x^p}一致</script><p>所以$p&gt;1$时收敛</p><hr><p>$\Gamma$函数</p><p>$\Gamma$函数的定义：$Γ(\alpha)=\int_0^∞x^{a−1}e^{−x}dx\qquad a&gt;0$</p><p>$\Gamma$函数的性质为：$\Gamma(\alpha+1)=\alpha\Gamma(a)\qquad\Gamma(n+1)=n!\qquad\Gamma(\frac{1}{2})=\sqrt{\pi}\qquad\Gamma(1)=1$</p><div class="table-container"><table><thead><tr><th>f(x)</th><th>$\int^{+\infty}_0f(x)dx$</th><th>$\Gamma$</th></tr></thead><tbody><tr><td>$x^{-\frac{1}{2}}e^{-x}$</td><td>$\sqrt{\pi}$</td><td>$\Gamma(\frac{1}{2})$</td></tr><tr><td>$e^{-x}$</td><td>$1$</td><td>$ \Gamma(1) $</td></tr><tr><td>$x^{\frac{1}{2}}e^{-x}$</td><td>$\frac{\sqrt{\pi}}{2}$</td><td>$\Gamma(\frac{3}{2})=\Gamma(\frac{1}{2}+1)=\frac{1}{2}\Gamma(\frac{1}{2})$</td></tr><tr><td>$xe^{-x}$</td><td>$1$</td><td>$\Gamma(1+1)=\Gamma(1)$</td></tr><tr><td>$x^2e^{-x^2}$</td><td>$\frac{\sqrt{\pi}}{4}$</td><td>$\frac{1}{2}\Gamma(\frac{3}{2})$</td></tr><tr><td>$xe^{-x^2}$</td><td>$\frac{1}{2}$</td><td>$\frac{1}{2}\Gamma(1)$</td></tr><tr><td>$e^{-\frac{1}{2}x^2}$</td><td>$\frac{\sqrt{2\pi}}{2}$</td><td>$\sqrt{2}\Gamma(\frac{3}{2})$</td></tr></tbody></table></div><p>针对$f(x)=x^2e^{-x^2}$，可使用换元法，$x^2=t$，</p><script type="math/tex; mode=display">\int_0^{+\infty}te^{-t}d\sqrt{t}=\frac{1}{2}\int_0^{+\infty}t^{\frac{1}{2}}e^{-t}dt=\frac{1}{2}\Gamma(\frac{3}{2})=\frac{\sqrt{\pi}}{4}</script><p>因为$x^2$是偶函数，所以$\int_{-\infty}^{+\infty}f(x)dx=\frac{\sqrt{\pi}}{2}$</p><hr><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="平面图形的面积"><a href="#平面图形的面积" class="headerlink" title="平面图形的面积"></a>平面图形的面积</h3><p>直接用二重积分</p><script type="math/tex; mode=display">\iint_\limits{D}1\mathrm{d}A</script><p>表示的就是积分域上图形的面积</p><hr><h3 id="旋转体体积"><a href="#旋转体体积" class="headerlink" title="旋转体体积"></a>旋转体体积</h3><p>假设积分区域是$D$，绕直线$ax+by-c=0$旋转了一周</p><p>积分区域中心到直线的距离为：</p><script type="math/tex; mode=display">r(x,y)=\frac{|ax+by+c|}{\sqrt{a^2+b^2}}</script><p>旋转体的周长是$C=2\pi r$，那么旋转体的体积就是</p><script type="math/tex; mode=display">V=2\pi\iint_\limits{D}r(x,y)\mathrm{d}A</script><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220825180305731.png" alt="image-20220825180305731"></p><p>当区域$D$绕$x$轴旋转时，$r(x,y)=y$，体积为：</p><script type="math/tex; mode=display">V=2\pi\iint_\limits{D}r(x,y)\mathrm{d}A\implies2\pi\int_a^b dx\int _0^{f(x)}ydy\implies \pi\int_a^b f(x)^2dx</script><p>当区域$D$绕$y$轴旋转时，$r(x,y)=x$，体积为：</p><script type="math/tex; mode=display">V=2\pi\iint_\limits{D}r(x,y)\mathrm{d}A\implies2\pi\int_a^b dx\int _0^{f(x)}xdy\implies2\pi\int^b_axf(x)dx</script><hr><h3 id="弧长"><a href="#弧长" class="headerlink" title="弧长"></a>弧长</h3><p>如果函数$y=f(x)在[a,b]$上有一阶连续导函数，那么称$y=f(x)$在$[a,b]$上是$\color{Salmon}{光滑}$的。光滑函数$y=f(x)$在$[a,b]$上的弧长为：</p><script type="math/tex; mode=display">\overparen{ab}=\int_a^b \sqrt{1+(f'(x))^2}\textrm{d}x</script><p>定义$\color{Salmon}{弧微分}$：</p><script type="math/tex; mode=display">\textrm{d}s=\sqrt{1+(f'(x))^2}\textrm{d}x</script><p>那么上式可以简写为：</p><script type="math/tex; mode=display">\overparen{ab}=\int_a^b \textrm{d}s</script><div class="hide-toggle" style="border: 1px solid #66c3ee"><div class="hide-button toggle-title" style="background-color: #66c3ee;color: black"><i class="fas fa-caret-right fa-fw"></i><span>证明过程</span></div>    <div class="hide-content"><p>算弧线$y=f(x)$在$[a,b]$之间的长度，可以把它随机分为$n$个曲线段，用端点的连线来近似这些曲线段：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220825200713950.png" alt="image-20220825200713950"></p><p>观察某子区间$[x_{k-1},x_k]$的弧长$\overparen{P_{k-1}P_k}$：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220825200754745.png" alt="image-20220825200754745"></p><p>当$\Delta x_k=x_k-x_{k-1}$足够小的时候，$\overparen{P_{k-1}P_k}$近似等于$\overline{P_{k-1}P_k}$：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220825200952613.png" alt="image-20220825200952613"></p><p>即：</p><script type="math/tex; mode=display">\overparen{P_{k-1}P_k}\approx \overline{P_{k-1}P_k}=\sqrt{(\Delta x_k)^2+(\Delta y_k)^2}</script><p>$\overline{P_{k-1}P_k}$变换一下：</p><script type="math/tex; mode=display">\begin{aligned}\overline{P_{k-1}P_k}    &=\sqrt{(\Delta x_k)^2+(\Delta y_k)^2}\\    \\    &=\frac{\sqrt{(\Delta x_k)^2+(\Delta y_k)^2}}{\Delta x_k}\Delta x_k\\    \\    &=\sqrt{1+\left(\frac{\Delta y_k}{\Delta x_k}\right)^2}\Delta x_k \end{aligned}</script><p>如果$y=f(x)$可微，那么根据拉格朗日中值定理，可知有$\xi_k\in[x_{k-1},x_k]$，使得$f’(\xi_k)=\frac{\Delta y_k}{\Delta x_k}$（即$x=\xi_k$处的切线与$\overline{PQ}$平行）</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220825201111264.png" alt="image-20220825201111264"></p><p>所以：</p><script type="math/tex; mode=display">\overline{P_{k-1}P_k}=\sqrt{1+(f'(\xi_k))^2}\Delta x_k</script><p>所以可以推出弧长为：</p><script type="math/tex; mode=display">\overparen{ab}=\int_a^b\underbrace{\sqrt{1+\left(f'(x)\right)^2}\textrm{d}x}_{用于近似弧长的线段长}</script></div></div><hr><p>参数方程下的弧长：</p><p>参数方程：</p><script type="math/tex; mode=display">\begin{cases}    x=x(t)\\    y=y(t)\end{cases}</script><p>如果$x’(t)、y’(t)$在$\alpha\le t\le\beta$上存在且连续，那么$\alpha\le t\le\beta$上的弧长为：</p><script type="math/tex; mode=display">\int_\alpha^\beta\sqrt{\left(x'(t)\right)^2+\left(y'(t)\right)^2}\textrm{d}t</script><hr><p>极坐标方程下的弧长</p><p>当曲线弧由极坐标方程</p><script type="math/tex; mode=display">\rho=\rho(\theta) \quad(\alpha \leqslant \theta \leqslant \beta)</script><p>给出，其中$\rho(\theta)$在$[\alpha,\beta]$上具有连续导数，则由直角坐标与极坐标的关系可得</p><script type="math/tex; mode=display">\left\{\begin{array}{l}{x=x(\theta)=\rho(\theta) \cos \theta} \\ {y=y(\theta)=\rho(\theta) \sin \theta}\end{array}(\alpha \leqslant \theta \leqslant \beta)\right.</script><p>这就是以极角$\theta$为参数的曲线弧的参数方程。于是，弧长元素为</p><script type="math/tex; mode=display">\mathrm{d} s=\sqrt{x^{\prime 2}(\theta)+y^{\prime 2}(\theta)} \mathrm{d} \theta=\sqrt{\rho^{2}(\theta)+\rho^{\prime 2}(\theta)} \mathrm{d} \theta</script><p>从而所求弧长为</p><script type="math/tex; mode=display">s=\int_{\alpha}^{\beta} \sqrt{\rho^{2}(\theta)+\rho^{\prime 2}(\theta)} \mathrm{d} \theta</script><hr><h3 id="旋转体表面积"><a href="#旋转体表面积" class="headerlink" title="旋转体表面积"></a>旋转体表面积</h3><p>已知弧长是</p><script type="math/tex; mode=display">\overparen{ab}=\int_a^b\underbrace{\sqrt{1+\left(f'(x)\right)^2}\textrm{d}x}_{用于近似弧长的线段长}</script><p>那么可以用</p><script type="math/tex; mode=display">A=\int_a^b 2\pi f(x)\textrm{d}s=\int_a^b 2\pi f(x)\underbrace{\sqrt{1+(f'(x))^2}\textrm{d}x}_{弧微分\textrm{d}s}</script><p>表示旋转体的表面积</p><p>需要考虑到<strong>内曲面和外曲面</strong>的问题</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221107151944835.png" alt="image-20221107151944835"></p><p>这种图形的表面积$S$为：$S_{外}+S_{内}$，$S_{外}$指的是$y=0.5x$在$[0,2]$上的表面积，而$S_{内}$指的是$y=\sqrt{x-1}$在$[1,2]$上的表面积</p><hr><h3 id="几何体公式"><a href="#几何体公式" class="headerlink" title="几何体公式"></a>几何体公式</h3><p>椭圆面积：$S=\pi a b$</p><p>圆锥体积：$V=\frac{1}{3}\pi r^2 h$</p><p>圆锥表面积：$S=πr²+πrl$</p><p>球的体积：$V=\frac{4}{3}\pi r^3$</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.一元函数微分学</title>
      <link href="/post/14521.html"/>
      <url>/post/14521.html</url>
      
        <content type="html"><![CDATA[<h1 id="一元函数微分学"><a href="#一元函数微分学" class="headerlink" title="一元函数微分学"></a>一元函数微分学</h1><h2 id="导数与微分"><a href="#导数与微分" class="headerlink" title="导数与微分"></a>导数与微分</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="微分"><a href="#微分" class="headerlink" title="微分"></a>微分</h4><p>定义</p><p>设函数$y=f(x$)在某区间内有定义，$x_0$及$x_0+\Delta x$在此区间内，如果函数增量：</p><script type="math/tex; mode=display">\Delta y=f(x_0+\Delta x)-f(x_0)</script><p>可表示为：</p><script type="math/tex; mode=display">\Delta y=A\Delta x+o(\Delta x)</script><p>其中$A$是不依赖于$\Delta x$的常数，那么称函数$y=f(x)$在点$x_0$是 可微 的，而$A\Delta x$叫作函数$y=f(x)$在点$x_0$相应于自变量增量$\Delta x$的 微分 ，记作$\textrm{d}y$，即：</p><script type="math/tex; mode=display">\textrm{d}y=A\Delta x</script><p>通常令$\mathrm{d}x=\Delta x$，所以微分又可表示为$\textrm{d}y=A\mathrm{d}x$</p><hr><p>微分就是对某段函数曲线的<strong>线性近似</strong></p><div class="hide-toggle" style="border: 1px solid #66c3ee"><div class="hide-button toggle-title" style="background-color: #66c3ee;color: black"><i class="fas fa-caret-right fa-fw"></i><span>推导过程</span></div>    <div class="hide-content"><p>对于过$f(x_0)$点的某直线：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/4.png" alt="img" style="zoom:67%;" /></p><p>如果同样以曲线上的$f(x_0$)点为原点来建立新的坐标系，在该新坐标系中，上述直线的自变量为$\Delta x$，因变量让我们用$\mathrm{d}y$来表示：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220821160141487.png" alt="image-20220821160141487"></p><p>因为在新坐标系中上述直线过原点，根据以前的高中知识，其函数可以写作$\mathrm{d}y=A\Delta x$，其中$A$为该直线的斜率：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220731145216214.png" alt="image-20220731145216214"></p><p>微分定义中说如果有$\Delta y=A\Delta x+o(\Delta x)$，改写下就是如果有$\Delta y-A\Delta x=o(\Delta x)$，根据上面的分析，其实说的就是如果曲线和直线相差高阶无穷小$o(\Delta x)$：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220821160157162.png" alt="image-20220821160157162"></p><p>那么该直线就是$f(x_0)$点及其附近曲线的“线性近似”，其函数$\mathrm{d}y=A\Delta x$就是函数$y=f(x)$在点$x_0$的微分。通常会令$\mathrm{d}x=\Delta x$，所以微分又可以表示为$\textrm{d}y=A\mathrm{d}x$：</p><p>这样就通过微分实现了函数的线性近似</p></div></div><hr><h4 id="导数"><a href="#导数" class="headerlink" title="导数"></a>导数</h4><p>定义 </p><p>微分的表达式为$\textrm{d}y=A\mathrm{d}x$，那么$A$的具体计算过程如下：</p><p>根据微分的定义可知，有：</p><script type="math/tex; mode=display">\Delta y=A\Delta x+o(\Delta x)</script><p>其中$o(\Delta x)$是$x\to x_0$时$\Delta x$的高阶无穷小，所以可推出：</p><script type="math/tex; mode=display">\begin{aligned}    \Delta y=A\Delta x+o(\Delta x)        &\implies \frac{\Delta y}{\Delta x}=A+\frac{o(\Delta x)}{\Delta x}\\        &\implies \lim_{x\to x_0}\frac{\Delta y}{\Delta x}=\lim_{x\to x_0}\left(A+\frac{o(\Delta x)}{\Delta x}\right)\\        &\implies \lim_{x\to x_0}\frac{\Delta y}{\Delta x}=\lim_{x\to x_0}A+\lim_{x\to x_0}\frac{o(\Delta x)}{\Delta x}=A\\\end{aligned}</script><p>因为$\Delta x=x-x_0$，所以$x\to x_0$就是$\Delta x\to 0$；又因为$\Delta y=f(x_0+\Delta x)-f(x_0)$，所以上式可改写如下，也就是推出了$A$的计算式：</p><script type="math/tex; mode=display">\lim_{\Delta x\to 0}\frac{\Delta y}{\Delta x}=\lim_{\Delta x\to 0}\frac{f(x_0+\Delta x)-f(x_0)}{\Delta x}=A</script><p>即为导数的定义式</p><hr><p>严格定义：</p><p>设函数$y=f(x)$在点$x_0$的某个邻域内有定义，当自变量$x$在$x_0$处取得增量$\Delta x$（点$x_0+\Delta x$仍在该邻域内）时，相应的，因变量取得增量$\Delta y=f(x_0+\Delta x)-f(x_0)$。如果$\Delta y$与$\Delta x$之比在$\Delta x\to 0$时的极限存在，那么称函数$y=f(x)$在点$x_0$处 可导 ，并称这个极限为函数$y=f(x)$在点$x_0$处的 导数 ，记为$f’(x_0)$，即：</p><script type="math/tex; mode=display">f'(x_0)=\lim_{\Delta x\to 0}\frac{\Delta y}{\Delta x}=\lim_{\Delta x\to 0}\frac{f(x_0+\Delta x)-f(x_0)}{\Delta x}</script><p>也可记作$y’|_{x=x_0}，\left.\frac{\mathrm{d}y}{\mathrm{d}x}\right|_{x=x_0}，\left.\frac{\mathrm{d}f(x)}{\mathrm{d}x}\right|_{x=x_0}$或$\left.\frac{\mathrm{d}}{\mathrm{d}x}f(x)\right|_{x=x_0}$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220731150234799.png" alt="image-20220731150234799"></p><p>为了方便书写也常令$\Delta x=h$，将上述定义式改写为：</p><script type="math/tex; mode=display">f'(x_0)=\lim_{h\to 0}\frac{f(x_0+h)-f(x_0)}{h}</script><p>或者令$x=x_0+\Delta x$，相应的上述定义式改写为：</p><script type="math/tex; mode=display">f'(x_0)=\lim_{x\to x_0}\frac{f(x)-f(x_0)}{x-x_0}</script><p>从上面的几何意义可知，<strong>导数其实就是微分的斜率</strong>，因此如果微分存在，那么必然导数存在，反之亦然。所以说，<strong>可微即可导，可导即可微</strong>。</p><p>切线方程：$y-f(x_0)=f’(x_0)(x-x_0)$</p><p>法线方程：$y-f(x_0)=-\frac{1}{f’(x_0)}(x-x_0)$</p><hr><p>左导数与右导数</p><p>定义 ：</p><p>如下极限存在的话，则称之为函数$y=f(x)$在点$x_0$处的 左导数，记作$f’_-(x_0)$：</p><script type="math/tex; mode=display">f'_-(x_0)=\lim_{\Delta x\to 0^-}\frac{f(x_0+\Delta x)-f(x_0)}{\Delta x}</script><p>或如下极限存在的话，则称之为函数$y=f(x)$在点$x_0$处的 右导数，记作$f’_+(x_0)$：</p><script type="math/tex; mode=display">f'_+(x_0)=\lim_{\Delta x\to 0^+}\frac{f(x_0+\Delta x)-f(x_0)}{\Delta x}</script><p>如果函数在某点左导数和右导数存在，说明在左右两边都连续，则在该点连续</p><hr><p>可导的充要条件：<strong>左、右导数存在且相等</strong></p><p>所以$\Delta x$要能从左右两边都趋向于$0$，例如</p><script type="math/tex; mode=display">\lim_{h\to0}\frac{f(1-cosh)-f(0)}{1-cosh}</script><p>这种形式就不能判定在$x=0$处可导， 因为$cosh$在零点附近恒为正，所以$1-cosh≥0$，只能说明其右导数存在，不能说明左导数存在</p><p>同时$\Delta x≠0$</p><hr><h4 id="连续与可导"><a href="#连续与可导" class="headerlink" title="连续与可导"></a>连续与可导</h4><p>定理：如果函数$y=f(x)$在$x_0$点可导，则可推出该函数$y=f(x)$在$x_0$点连续</p><p>而连续$\nRightarrow$可导，因为即使在$x_0$处连续，其左右导数仍有可能不相等</p><p>连续且可导的函数，导函数一定是存在的，但导函数<strong>不一定</strong>连续，因为也可能含有<strong>振荡间断点</strong></p><p>设$f(x)$在$x=a$可导，关于$|f(x)|$在$x=a$是否可导有以下结论：</p><p>若$f(a)≠0$，则$|f(x)|$在$x=a$可导</p><p>若$f(a)=0$，则需要判定其导数$f’(a)$，若$f’(a)=0$，则$|f(x)|$在$x=a$可导，若$f’(a)≠0$，则不可导</p><p>如果是$\phi(x)|f(x)|$的形式，如果$f’(a)≠0$，但$\phi(a)=0$，最终结果是$0$，则还是可导的</p><p>如果反过来说，已知$|f(x)|$在$a$点可导，同时$f(x)$在$a$点连续，那么可以推出，$f(x)$在$x_0$处可导</p><p>可导+可导=可导</p><p>可导+不可导=不可导</p><p>不可导+不可导=不确定</p><hr><h3 id="导函数"><a href="#导函数" class="headerlink" title="导函数"></a>导函数</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>若函数$y=f(x)$在开区间$I$内的每点处都可导，则称函数$y=f(x)$在开区间$I$内 <strong>可导</strong> </p><p>此时对于任意$x\in I$，都对应着$f(x)$的一个确定的导数值，这就构成了新的函数，该函数叫作$y=f(x)$的 导函数 ，记作$y’$、$f’(x)$、$\frac{\textrm{d}y}{\textrm{d}x}$或$\frac{\textrm{d}f(x)}{\textrm{d}x}$，定义式为：</p><script type="math/tex; mode=display">y'=\lim_{\Delta x\to 0}\frac{f(x+\Delta x)-f(x)}{\Delta x}\quad\text{或}\quad f'(x)=\lim_{h\to 0}\frac{f(x+h)-f(x)}{h}</script><hr><h4 id="基本初等函数的求导公式"><a href="#基本初等函数的求导公式" class="headerlink" title="基本初等函数的求导公式"></a>基本初等函数的求导公式</h4><script type="math/tex; mode=display">\begin{array}{c|c|c} \hline \\ \quad常数函数\quad &\quad f(x)=C,C\in\mathbb{R} & f'(x)=0\\ \\ \hline \\ \quad幂函数\quad &\quad f(x)=x^\alpha,\alpha\in\mathbb{R} & f'(x)=\alpha x^{\alpha-1}\\ \\ \hline \\ \quad\quad &\quad f(x)=\sin x & f'(x)=\cos x\\ \quad三角函数\quad &\quad f(x)=\cos x & f'(x)=-\sin x\\ \quad\quad &\quad f(x)=\tan x & f'(x)=\sec^2 x\\ \quad\quad &\quad f(x)=\cot x & f'(x)=-\csc^2 x\\ \\ \hline \\ \quad\quad &\quad f(x)=\arcsin x & f'(x)=\frac{1}{\sqrt{1-x^2}}\\ \quad反三角函数\quad &\quad f(x)=\arccos x & f'(x)=-\frac{1}{\sqrt{1-x^2}}\\ \quad\quad &\quad f(x)=\arctan x & f'(x)=\frac{1}{1+x^2}\\ \quad\quad &\quad f(x)=\text{arccot} x & f'(x)=-\frac{1}{1+x^2}\\ \\ \hline \\ \quad\quad &\quad f(x)=a^x,a > 0, a\ne 1& f'(x)=a^x\ln a\\ \quad指数函数\quad &\quad f(x)=e^x & f'(x)=e^x\\ \\ \hline \\ \quad\quad &\quad f(x)=\log_a x,a > 0, a\ne 1& f'(x)=\frac{1}{x\ln a}\\ \quad对数函数\quad &\quad f(x)=\ln x & f'(x)=\frac{1}{x}\\ \\ \hline \end{array}</script><script type="math/tex; mode=display">(\sec x)'=\sec x\tan x \qquad (\csc x)'=-\csc x\cot x \qquad (\cot x)'=-csc^2 x\qquad</script><hr><h4 id="有理运算法则"><a href="#有理运算法则" class="headerlink" title="有理运算法则"></a>有理运算法则</h4><script type="math/tex; mode=display">\begin{aligned}\left[u(x)\pm v(x)\right]'=u'(x)\pm v'(x)\\\\\left[u(x)v(x)\right]'=u'(x)v(x)+u(x)v'(x)\\\\\left[\frac{u(x)}{v(x)}\right]'=\frac{u'(x)v(x)-u(x)v'(x)}{v^2(x)}\end{aligned}</script><hr><h4 id="复合函数求导"><a href="#复合函数求导" class="headerlink" title="复合函数求导"></a>复合函数求导</h4><p>定理（链式法则）：如果$u=g(x)$在$x$点可导，而$y=f(u)$在$u=g(x)$点可导，那么复合函数$y=f[g(x)]$在$x$点可导，其导数为：</p><script type="math/tex; mode=display">\frac{\textrm{d}y}{\textrm{d}x}=f'(u)g'(x)\quad\text{或}\quad\frac{\textrm{d}y}{dx}=\frac{\textrm{d}y}{\textrm{d}u}\cdot\frac{\textrm{d}u}{\textrm{d}x}</script><ol><li>如果链式法则能用，即$f’(u)$和$g’(x)$都存在,那么这个方法最简单</li><li>如果某一个函数导数不存在，也不能说明整个函数的导数不存在，需要将$g(x)$带入到$f(x)$中，形成完整的函数再判断</li></ol><hr><h4 id="隐函数求导法则"><a href="#隐函数求导法则" class="headerlink" title="隐函数求导法则"></a>隐函数求导法则</h4><script type="math/tex; mode=display">F(x,y)=0\qquad\frac{dy}{dx}=-\frac{F_x}{F_y}</script><p>求某点的隐函数时，先根据方程该该点的$y，x$都求出来在带进去，如果是二阶导，那把$y’(x_0)$也求出来</p><hr><h4 id="反函数求导"><a href="#反函数求导" class="headerlink" title="反函数求导"></a>反函数求导</h4><p>定理 .如果函数$x=f(y)$在区间$I_y$内严格单调、可导且$f’(y)\neq 0$，那么它的反函数$y=f^{-1}(x)$在区间$I_x=\{x|x=f(y), y\in I_y\}$内也可导。且：</p><script type="math/tex; mode=display">[f^{-1}(x)]'=\frac{1}{f'(y)}\quad\text{或}\quad\frac{\mathrm{d}y}{\mathrm{d}x}=\frac{1}{\frac{\mathrm{d}x}{\mathrm{d}y}}</script><p>二阶导数有 </p><script type="math/tex; mode=display">\frac{d}{dx}(\frac{dx}{dy})\frac{dx}{dy}=-\frac{f''(x)}{[f'(x)]^2}·\frac{1}{f'(x)}</script><p>题目会给出$y$的值，需要先换算成$x$，在带入方程中</p><hr><h4 id="参数方程求导"><a href="#参数方程求导" class="headerlink" title="参数方程求导"></a>参数方程求导</h4><p>对于参数方程$\begin{cases}x=\varphi(t)\\y=\psi(t)\end{cases}$，如果：</p><ul><li>存在严格单调且连续的反函数$t=\varphi^{-1}(x)$</li><li>存在函数$y=\psi(t)=\psi(\varphi^{-1}(x))$ ，$x=\varphi(t)$以及$y=\psi(t)$可导，且$\varphi’(t)\ne 0$<br>则</li></ul><script type="math/tex; mode=display">\frac{\textrm{d}y}{\textrm{d}x}=\frac{\psi'(t)}{\varphi'(t)}</script><p>二阶导数：</p><script type="math/tex; mode=display">\frac{\textrm{d}y^2}{\textrm{d}x^2}=\frac{d}{dt}(\frac{\psi'(t)}{\varphi'(t)})·\frac{1}{\varphi'(t)}</script><p>也就是</p><script type="math/tex; mode=display">\frac{y''(0)x'(0)-x''(0)y'(0)}{x'^3(0)}</script><hr><h4 id="对数求导法"><a href="#对数求导法" class="headerlink" title="对数求导法"></a>对数求导法</h4><p>适用于幂指函数$y=x^x$，$y=x^{sinx}$，以及多因子乘幂函数$\sqrt{x^2·sinx·(1-x^2)}$</p><p>通过对等式两边取对数，然后再同时对$x$求导，计算关于$y’$的方程</p><hr><h4 id="高阶导数"><a href="#高阶导数" class="headerlink" title="高阶导数"></a>高阶导数</h4><p>常见的高阶导数：</p><script type="math/tex; mode=display">\begin{aligned}(\sin x)^{(n)}=\sin(x+n\cdot\frac{\pi}{2})\\(\cos x)^{(n)}=\cos(x+n\cdot\frac{\pi}{2})\\(uv)^{(n)}=\sum_{k=0}^n{n\choose k}u^{(n-k)}v^{(k)}\end{aligned}</script><hr><h4 id="分段函数"><a href="#分段函数" class="headerlink" title="分段函数"></a>分段函数</h4><p>求形如</p><script type="math/tex; mode=display">f(x)=\left\{ \begin{aligned} \quad g(x)&,x≠x_0\\A&,x=x_0  \end{aligned} \right.</script><p>分段函数在分段点的导数一般要用定义来求，或函数在分段点连续的条件下求导数的极限，即用下面定理求分段函数在分段点的导数：</p><ol><li>$f(x)$在$x_0$处连续 </li><li>$f(x)$在$x_0$的某空心邻域内可导</li><li>$\lim_{x\to x_0}f’(x)$存在，则$f’(x)=lim_{x\to x_0}f’(x)$ </li></ol><p>在连续的情况下：$lim_{x \to x_0}f’(x)$才有意义</p><hr><h2 id="微分中值定理"><a href="#微分中值定理" class="headerlink" title="微分中值定理"></a>微分中值定理</h2><h3 id="费马引理"><a href="#费马引理" class="headerlink" title="费马引理"></a>费马引理</h3><p>设函数$f(x)$在点$x_0$的某邻域$U(x_0)$内有定义，且在$x_0$点可导，如果对任意的$x\in U(x_0)$​，有：</p><script type="math/tex; mode=display">f(x)\le f(x_0)\qquad（\text{或}\ f(x)\ge f(x_0）</script><p>即在$x_0$处取得极值，那么$f’(x_0)=0$</p><p>实际上可以简化为：</p><script type="math/tex; mode=display">\left. \begin{aligned} f(x_0)\ 为极值点\\ x=x_0\ 点可导 \end{aligned} \right\} \implies f'(x_0)=0</script><hr><h3 id="罗尔定理"><a href="#罗尔定理" class="headerlink" title="罗尔定理"></a>罗尔定理</h3><p>如果函数$y=f(x)$满足：</p><ul><li>在闭区间$[a,b]$上连续</li><li>在开区间$(a,b)$上可导</li><li>$f(a)=f(b)$</li></ul><p>那么$\exists\xi\in(a,b)$，使得$f’(\xi)=0$</p><p>罗尔定理的推论：若在区间$I$上$f^{n}(x)≠0$，则方程$f(x)=0$在$I$上<strong>最多$n$个实根</strong></p><p>求方程的根的个数时，最常用的方法就是</p><ol><li>单调性</li><li>罗尔定理推论</li></ol><p>罗尔定理的推论可以推出<strong>最多</strong>有多少个根，单调性可以判断<strong>至少</strong>有多少个根</p><p>在面对$x=kf(x)$类题目，求根的个数时，推荐将$k=\frac{x}{f(x)}$的形式，分离参数出来，根据分析$\frac{x}{f(x)}$的函数图像，可以通过k的取值来判断根的个数</p><p>注意题目中如果给出：$f’’(x)<0$或$>0$的情况，可以用<strong>泰勒公式</strong>：</p><script type="math/tex; mode=display">f(x)=f(x_0)+f'(x_0)(x-x_0)+\frac{f^{(2)}(\xi)}{(2)!}(x-x_0)^{2}</script><p>由于$(x-x_0)^2$是肯定$&gt;0$的，所以根据题目给出的二阶导的正负来判断$f(x),f’(x)$的正负，从而就可以判断整体的正负</p><hr><p>关于罗尔定理和单调性的联系，以下给出一些结论及证明</p><ol><li><p>如果$f(x)$在$[0,+\infty)$上有二阶导数，$f(0)=0,f_+’(0)<0,f''(x)≥M>0(x&gt;0)$，$f(x)=0$在$(0,+\infty)$内有唯一实根</p><p>显然$f_+’(0)&lt;0$说明在0的右邻域里面有$f(x_1)&lt;0$，由拉格朗日中值定理</p><p>$f’(x)=f’(0)+f’’(\xi_1)(x-0)≥f’(0)+Mx\to +\infty(x\to +\infty)$</p><p>其中$\xi$介于$0$与$x$之间，故存在充分大的$x_0 \in(0,+\infty)$，使得在$(x_0,+\infty)$内有$f’(x)&gt;1$</p><p>对$f(x)$用拉格朗日中值定理</p><p>$f(x)=f(x_0)+f’(\xi_2)(x-0)≥f(x_0)+(x-x_0)\to +\infty(x\to +\infty)$</p><p>其中$\xi_2$介于$x_0$与$x$之间，于是存在充分大的$x_2\in (x_0,+\infty)$，使得$f(x_2)&gt;0$,所以在$(0,+\infty)$至多有一个根</p><p>再根据罗尔定理的推论，$f’’(x)&gt;0$，故至多有$2$个根，所以在$(0,+\infty)$内有唯一实根</p><hr></li><li><p>设$f(x)$在区间$[a,b]$上有二阶导数，且$f(a)=f(b)=0,f_+’(a)f’_-(b)&gt;0$，在$(a,b)$存在两点$\xi,\eta$，使得$f(\xi)=0,f’’(\eta)=0$</p><p>证明：图像上容易看出来，证明$f(\xi)=0$，可以用反证法，假设不存在$f(\xi)=0$,</p><script type="math/tex; mode=display">f’_+(a)=\lim_{x \to a^+}\frac{f(x)-f(a)}{x-a}=\lim_{x \to a^+}\frac{f(x)}{x-a}≥0</script><script type="math/tex; mode=display">f’_-(b)=\lim_{x \to b^-}\frac{f(x)-f(b)}{x-b}=\lim_{x \to b^+}\frac{f(x)}{x-b}≤0</script><p>这样$f’_+(a)f’_-(b)≤0$,与题目矛盾，故必有解</p><p>$f(a)=f(\xi)=f(b)$，在$[a,\xi]$与$[\xi,b]$上对$f(x)$分别用罗尔定理，可以找出两点$f’(\eta_1),f’(\eta_2)=0$,在$[\eta_1,\eta_2]$上再用罗尔定理，即可证明$f’’(\eta)=0$</p></li></ol><hr><h3 id="拉格朗日中值定理"><a href="#拉格朗日中值定理" class="headerlink" title="拉格朗日中值定理"></a>拉格朗日中值定理</h3><p>如果函数$y=f(x)$满足：</p><ul><li>在闭区间$[a,b]$上连续</li><li>在开区间$(a,b)$上可导</li></ul><p>那么$\exists\xi\in (a,b)$，使得</p><script type="math/tex; mode=display">f'(\xi)=\frac{f(b)-f(a)}{b-a}</script><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220802131853388.png" alt="image-20220802131853388"></p><p>拉格朗日中值定理的意思是，$f(a)$、$f(b)$之间存在某点（甚至不止一点），其微分与$f(a)$、$f(b)$的连线平行</p><p>$\xi$ 为$(a,b)$中某点，也可以等价表述为$f’(a+\theta (b-a))$ $\theta\in{0,1}$</p><div class="hide-toggle" style="border: 1px solid #66c3ee"><div class="hide-button toggle-title" style="background-color: #66c3ee;color: black"><i class="fas fa-caret-right fa-fw"></i><span>证明过程</span></div>    <div class="hide-content"><p>引进辅助函数：</p><script type="math/tex; mode=display">F(x)=f(x)-f(a)-\frac{f(b)-f(a)}{b-a}(x-a)</script><p>容易知道，$F(x)$满足：</p><ul><li>在闭区间$[a,b]$上连续</li><li>在开区间$(a,b)$上可导</li><li>$F(a)=F(b)=0$</li></ul><p>所以根据罗尔中值定理可知，$\exists\xi\in(a,b)$使得$F’(\xi)=0$，即：</p><script type="math/tex; mode=display">F'(x)|_{x=\xi}=\left.f'(x)-\frac{f(b)-f(a)}{b-a}\right|_{x=\xi}=f'(\xi)-\frac{f(b)-f(a)}{b-a}=0</script><p>由此可得$f’(\xi)=\frac{f(b)-f(a)}{b-a}$。</p></div></div><hr><h3 id="柯西中值定理"><a href="#柯西中值定理" class="headerlink" title="柯西中值定理"></a>柯西中值定理</h3><p>如果函数$f(x)$及$g(x)$满足</p><ul><li>在闭区间$[a,b]$上连续</li><li>在开区间$(a,b)$上可导</li><li>$\forall x\in(a,b)$有$g’(x)\neq 0$</li></ul><p>那么$\exists\xi\in (a,b)$，使得</p><script type="math/tex; mode=display">\frac{f(b)-f(a)}{g(b)-g(a)}=\frac{f'(\xi)}{g'(\xi)}</script><div class="hide-toggle" style="border: 1px solid #66c3ee"><div class="hide-button toggle-title" style="background-color: #66c3ee;color: black"><i class="fas fa-caret-right fa-fw"></i><span>证明过程</span></div>    <div class="hide-content"><p>证明所需结论。构造辅助函数：</p><script type="math/tex; mode=display">F(x)=f(x)-\frac{f(b)-f(a)}{g(b)-g(a)}g(x)</script><p>容易知道，$F(x)$满足：</p><ul><li>在闭区间$[a,b]$上连续</li><li>在开区间$(a,b)$上可导</li><li>$F(a)=F(b)=\frac{g(b)f(a)-g(a)f(b)}{g(b)-g(a)}$</li></ul><p>所以根据罗尔中值定理，$\exists\xi\in(a,b)$使得$F’(\xi)=0$，即：</p><script type="math/tex; mode=display">F'(x)|_{x=\xi}=\left.f'(x)-\frac{f(b)-f(a)}{g(b)-g(a)}g'(x)\right|_{x=\xi}=f'(\xi)-\frac{f(b)-f(a)}{g(b)-g(a)}g'(\xi)=0</script><p>由此可得$\frac{f(b)-f(a)}{g(b)-g(a)}=\frac{f’(\xi)}{g’(\xi)}$</p></div></div><p>几何理解</p><p>假设有参数方程：</p><script type="math/tex; mode=display">\begin{cases}x=g(x)\\y=f(t)\end{cases}</script><p>上述参数方程描述的是某种运动轨迹，如下图所示。根据该参数方程可知，$a$时刻所在的位置为$[g(a), f(a)]$点，$b$时刻所在的位置为$[g(b), f(b)]$点：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220802150516166.png" alt="image-20220802150516166"></p><p>$[g(a), f(a)]$点到$[g(b), f(b)]$点的向量$\overline{\boldsymbol{s}}$指明了最终的运动方向：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220802150544874.png" alt="image-20220802150544874" style="zoom:67%;" /></p><p>根据常识可知，需要不断调整运动的方向，才能从$[g(a), f(a)]$点运动到$[g(b), f(b)]$点。也就是说，瞬时速度向量$\boldsymbol{v}$必然会在某个时刻与$\overline{\boldsymbol{s}}$平行：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220802150622983.png" alt="image-20220802150622983"></p><p>容易知道，向量$\overline{\boldsymbol{s}}$的斜率为$\frac{f(b)-f(a)}{g(b)-g(a)}$；而之前计算过瞬时速度向量$\boldsymbol{v}$的斜率为$\frac{f’(t)}{g’(t)}$。假设在$\xi\in(a,b)$时刻两者平行，那么就有：</p><script type="math/tex; mode=display">\frac{f(b)-f(a)}{g(b)-g(a)}=\frac{f'(\xi)}{g'(\xi)}</script><hr><h3 id="泰勒定理"><a href="#泰勒定理" class="headerlink" title="泰勒定理"></a>泰勒定理</h3><h4 id="牛顿插值法"><a href="#牛顿插值法" class="headerlink" title="牛顿插值法"></a>牛顿插值法</h4><p>知道某几个点的坐标，要求预测其他点的位置，这就是牛顿插值法需要解决的问题</p><p>在牛顿插值法里，是通过已知的点坐标，建立一个多项式，用来拟合曲线，则曲线上的点就是其他点的位置</p><p>多项式即：</p><script type="math/tex; mode=display">f_n(x)=f[x_0]+f[x_0,x_1](x-x_0)+\cdots+f[x_0,x_1,\ldots,x_n]\prod_{k=0}^{n-1}(x-x_k)</script><div class="hide-toggle" style="border: 1px solid #66c3ee"><div class="hide-button toggle-title" style="background-color: #66c3ee;color: black"><i class="fas fa-caret-right fa-fw"></i><span>证明过程</span></div>    <div class="hide-content"><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220802192429424.png" alt="image-20220802192429424"></p><p>假设已知的就是这4个点，需要通过牛顿插值法求该曲线的方程</p><p>首先，拿出第一个点$(x_0,f(x_0))$，可以构造一个函数：</p><script type="math/tex; mode=display">f_0(x)=f(x_0)</script><p>如果没有更多的信息，可以认为$f_0(x)=f(x)$，因为它符合所有已知的信息：</p><script type="math/tex; mode=display">f_0(x_0)=f(x_0)</script><p>其函数图像如下：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220802192532298.png" alt="image-20220802192532298"></p><p>曲线$f_0(x)$为过第一个点的拟合曲线函数</p><p>当然，这里还有第二个点$(x_1,f(x_1))$。为了把第二个点包含进来，我们在$f_0(x)$基础上增加一部分构造新的拟合曲线函数：</p><script type="math/tex; mode=display">f_1(x)=f_0(x)\color{red}{+b_1(x-x_0)}</script><p>该方程显然会穿过$(x_0，f(x_0))$，接下来需要计算$b_1$</p><p>$f_1(x)$穿过第二个点$(x_1,f(x_1))$，因此可以推出：</p><script type="math/tex; mode=display">f_1(x_1)=f(x_0)+b_1(x_1-x_0)=f(x_1)\implies b_1=\frac{f(x_1)-f(x_0)}{x_1-x_0}</script><p>综上可得：</p><script type="math/tex; mode=display">f_1(x)=f(x_0)+\frac{f(x_1)-f(x_0)}{x_1-x_0}(x-x_0)</script><p>新的拟合曲线如下：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220802193103786.png" alt="image-20220802193103786" style="zoom:80%;" /></p><p>为了把第三个点$(x_2,f(x_2))$也包含进来，我们再在$f_1(x)$的基础上增加一部分构造新的函数：</p><script type="math/tex; mode=display">f_2(x)=f_1(x){+b_2(x-x_0)(x-x_1)}</script><p>根据新增的信息求出$b_2$：</p><script type="math/tex; mode=display">b_2=\frac{\frac{f(x_2)-f(x_1)}{x_2-x_1}-\frac{f(x_1)-f(x_0)}{x_1-x_0}}{x_2-x_0}</script><p>加上刚才得到的$f_1(x)$，可知：</p><script type="math/tex; mode=display">\begin{aligned}f_2(x)=    &f(x_0)+\frac{f(x_1)-f(x_0)}{x_1-x_0}(x-x_0)+\frac{\frac{f(x_2)-f(x_1)}{x_2-x_1}-\frac{f(x_1)-f(x_0)}{x_1-x_0}}{x_2-x_0}(x-x_0)(x-x_1)\end{aligned}</script><p>可以验证，$f_2(x)$函数满足我们已知的三个点：</p><script type="math/tex; mode=display">f_2(x_0)=f(x_0),\quad f_2(x_1)=f(x_1),\quad f_2(x_2)=f(x_2)</script><p>可以推论出，如果要知道第$n$个点的信息，牛顿插值法的公式为：</p><script type="math/tex; mode=display">f_n(x)=f[x_0]+f[x_0,x_1](x-x_0)+\cdots+f[x_0,x_1,\ldots,x_n]\prod_{k=0}^{n-1}(x-x_k)</script></div></div><hr><h4 id="泰勒公式"><a href="#泰勒公式" class="headerlink" title="泰勒公式"></a>泰勒公式</h4><p>假设插值点之间是等距的：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220802195452931.png" alt="image-20220802195452931"></p><p>那么根据牛顿插值法：</p><script type="math/tex; mode=display">\begin{aligned} f_5(x)=&f[x_0]+f[x_0,x_1](x-x_0)\\ &+f[x_0,x_1,x_2](x-x_0)(x-x_1)\\ &+f[x_0,x_1,x_2,x_3](x-x_0)(x-x_1)(x-x_2)\\ &+f[x_0,x_1,x_2,x_3,x_4](x-x_0)(x-x_1)(x-x_2)(x-x_3)\\ &+f[x_0,x_1,x_2,x_3,x_4,x_5](x-x_0)(x-x_1)(x-x_2)(x-x_3)(x-x_4) \end{aligned}</script><p>其中：</p><script type="math/tex; mode=display">x_1=x_0+\Delta x,\quad x_2=x_0+2\Delta x,\quad\cdots,\quad x_5=x_0+5\Delta x</script><p>泰勒发现，当$\Delta x\to 0$时，$f_5(x)$变成了：</p><script type="math/tex; mode=display">\begin{aligned}\lim_{\Delta x\to 0}f_5(x)=f(x_0)+f'(x_0)(x-x_0)+\frac{f''(x_0)}{2!}(x-x_0)^2    +\frac{f^{(3)}(x_0)}{3!}(x-x_0)^3+\frac{f^{(4)}(x_0)}{4!}(x-x_0)^4    +\frac{f^{(5)}(x_0)}{5!}(x-x_0)^5\end{aligned}</script><p>对比之前的牛顿插值法：</p><script type="math/tex; mode=display">f_1(x)=f(x_0)+\frac{f(x_1)-f(x_0)}{x_1-x_0}(x-x_0)</script><p>将$x_1=x_0+\Delta x$,则表达式为</p><script type="math/tex; mode=display">f_1(x)=f(x_0)+\frac{f(x_0+\Delta x)-f(x_0)}{\Delta x}(x-x_0)</script><p>即</p><script type="math/tex; mode=display">\lim_{\Delta x\to 0}f_2(x)=f(x_0)+f'(x_0)(x-x_0)</script><p>而推广此结论，将所有的$x_n$都替换成$x_0+\Delta x$的形式，后面的$(x-x_n)$因为$\Delta x$ 可以忽略，则都是$x-x_0$的$n$次方，则可以得到泰勒公式：</p><script type="math/tex; mode=display">\begin{aligned} p_n(x)= &f(x_0)+f'(x_0)(x-x_0)+\frac{f''(x_0)}{2!}(x-x_0)^2+\cdots+\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n \end{aligned}</script><p>特别的，如果在$x=0$处生成的泰勒多项式，也称为$\color{Salmon}{n阶麦克劳林多项式}$：</p><script type="math/tex; mode=display">p_n(x)=f(0)+f'(0)x+\frac{f''(0)}{2!}x^2+\cdots+\frac{f^{(n)}(0)}{n!}x^n</script><hr><h4 id="余项"><a href="#余项" class="headerlink" title="余项"></a>余项</h4><p>假设$f(x)$在$x=x_0$处有$n$阶导数，则有：</p><script type="math/tex; mode=display">\overbrace{f(x)=\quad\underbrace{p_n(x)}_{泰勒多项式}\quad+\quad\underbrace{R_n(x)}_{\color{Salmon}{余项}}}^{\color{Salmon}{泰勒公式}}</script><p>其中：</p><script type="math/tex; mode=display">R_n(x)=o\left((x-x_0)^n\right)</script><p>称为$\color{Salmon}{皮亚诺余项}$。</p><hr><p>假设$f(x)$在$U(x_0)$内具有$n+1$阶导数，则在$U(x_0)$存在$n$阶泰勒多项式$p_n(x)$，同样有泰勒公式：</p><script type="math/tex; mode=display">f(x)=p_n(x)+R_n(x)</script><p>此时$R_n(x)$可以表示为：</p><script type="math/tex; mode=display">R_n(x)=\frac{f^{(n+1)}(\xi)}{(n+1)!}(x-x_0)^{n+1}</script><p>其中，$\xi$为$x_0$及$x$之间的某个值。该余项称为$\color{Salmon}{拉格朗日余项}$</p><hr><p>通常把皮亚诺余项当做局部的余项，在研究<strong>极值</strong>和<strong>极限</strong>的时候会用到</p><p>而拉格朗日余项是整体的余项，在研究<strong>最值</strong>和<strong>证明不等式</strong>的时候会用到，尤其是在要求证明$f(c)=x_0$，还有是$|f’(c)|$小于or大于某个具体的值</p><p>具体方法是利用泰勒公式，将$f(x)$在信息多的点展开，然后用拉格朗日余项表示出来，不同的点展开的拉格朗日余项中的$\xi$不同，然后根据题目条件(比如$f’’(x)&lt;a$）,证明不等式</p><hr><h4 id="常见的泰勒展开"><a href="#常见的泰勒展开" class="headerlink" title="常见的泰勒展开"></a>常见的泰勒展开</h4><script type="math/tex; mode=display">e^{x}=1+x+\frac{x^{2}}{2 !}+\cdots+\frac{x^{n}}{n !}+o\left(x^{n}\right)</script><script type="math/tex; mode=display">sin x=x-\frac{x^{3}}{3 !}+\frac{x^{5}}{5 !}-\cdots+(-1)^{n} \frac{x^{2 n+1}}{(2 n+1) !}+o\left(x^{2 n+2}\right)</script><script type="math/tex; mode=display">cos x=1-\frac{x^{2}}{2 !}+\frac{x^{4}}{4 !}-\frac{x^{6}}{6 !}+\cdots+(-1)^{n} \frac{x^{2 n}}{(2 n) !}+o\left(x^{2 n}\right)</script><script type="math/tex; mode=display">ln (1+x)=x-\frac{x^{2}}{2}+\frac{x^{3}}{3}-\cdots+(-1)^{n-1} \frac{x^{n}}{n}+o\left(x^{n}\right)</script><script type="math/tex; mode=display">\frac{1}{1-x}=1+x+x^{2}+\cdots+x^{n}+o\left(x^{n}\right)</script><script type="math/tex; mode=display">(1+x)^{m}=1+m x+\frac{m(m-1)}{2 !} x^{2}+\cdots+\frac{m(m-1)\cdots\left( m-n+1 \right)}{n!} x^{n}+o\left(x^{n}\right)</script><hr><h3 id="微分中值定理的证明题"><a href="#微分中值定理的证明题" class="headerlink" title="微分中值定理的证明题"></a>微分中值定理的证明题</h3><p>类型一：证明$G[\xi,f’(\xi),f(\xi)]$的函数等于$0$</p><p><strong>方法1</strong>：如果函数相对简单可以考虑直接用<strong>零点定理</strong>证明两端点值异号</p><p>特别是出现了<strong>唯一</strong>的情况下，一般是先构造函数，证明两端点值异号，再通过求函数的单调性，说明只有唯一的一个点</p><p><strong>方法2</strong>：先推导出原函数$F’(x)=G(x)$，如果$F(x)$的两端点值相等的话，用罗尔定理，则证明有$F’(\xi)=G(\xi)=0$</p><p>最难的一步就是求出$G(x)$的原函数，通常用微分方程求解，解出微分方程，使其变为$F(x)=C$的形式，最终得到$F’(x)=0$的结果，则$F(x)$就是原函数</p><p>以下是常见的形式：</p><script type="math/tex; mode=display">\xi f’(\xi)+nf(\xi)=0\qquad  F(x)=x^nf(x)</script><script type="math/tex; mode=display">\xi f’(\xi)-nf(\xi)=0\qquad  F(x)=\frac{f(x)}{x^n}</script><script type="math/tex; mode=display">f'(\xi)+\lambda f(\xi)=0\qquad F(x)=e^{\lambda x}f(x)</script><script type="math/tex; mode=display">\alpha f'(\xi)+\beta f(\xi)=0\qquad F(x)=e^{\frac{\alpha}{\beta} x}f(x)</script><script type="math/tex; mode=display">f'(\xi)+g'(\xi)f(\xi)=0\qquad F(x)=e^{g(x)}f(x)</script><script type="math/tex; mode=display">f'(\xi)+g(\xi)f(\xi)=0\qquad F(x)=e^{\int g(x)}f(x)</script><p>主要都是通过微分方程求解</p><p>当然题目给出的方程并不总是符合以上标准型，所以需要通过构造</p><hr><p>补充一个积分中常见的形式，要证明$\int_0^{\xi}f(x)dx=0$，可以将$F(x)$设置成如下形式：</p><script type="math/tex; mode=display">F(x)=\int_0^x(x-t)f(t)dt</script><p>可以根据题目条件进行改变，比如$F(x)=\int_0^x(x^2-t^2)f(t)dt$,那么$F’(x)=2x\int_0^{x}f(x)dx$，如果$F(x)$在两端点处等于$0$，一样可以证明结论</p><p>如果题目给出</p><script type="math/tex; mode=display">\int_a^bf(x)dx=0</script><p>那么可设</p><script type="math/tex; mode=display">F(x)=\int_a^xf(x)dx</script><p>这样构造满足：$F(a)=F(b)=0$，可以说明$F’(x)=f(\xi)=0$</p><hr><p>类型二：证明存在两个点$\xi，\eta \in(a,b)$，使$F[\xi,\eta,f(\xi),f(\eta),f’(\xi),f’(\eta)]=0$</p><p>方法：</p><ol><li>如果不要求$\xi≠\eta$，那么在同一区间$[a,b]$上用两次中值定理(拉格朗日，柯西)，比如只出现了$f’(\xi)$，那么用拉格朗日就行了，如果出来了$\eta f’(\eta)$之类的形式，就需要用到柯西</li><li>如果要求$\xi≠\eta$，将区间$[a,b]$分为两个子区间，在两个子区间上分别用拉格朗日中值定理，那么重要的是确定中间的分界点，诀窍是先假定点$c$使等式成立，然后再确定该点函数</li></ol><p>类型三：证明存在一个中值点$\xi \in (a,b)$，使$F[\xi,f^(n)(\xi)≥0(n≥2)]$</p><p>方法：</p><p>用带拉格朗日余项的泰勒公式，其中$x_0$点选题目中提供函数值和导数值信息多的点</p><hr><p>结论：设$f(x)$在$[a,b]$连续，且$f(a)=f(b)$，证明：至少存在一点$\xi \in (a,b)$，使得$f(\xi)=f(\xi+\frac{b-a}{n})$($n$为任意实数)</p><p>证明如下：</p><p>假设$g(x)=f(x)-f(x+\frac{b-a}{n})  ,x\in [a,b-\frac{b+a}{n}]$</p><p>$g(a)+g(\frac{b-a}{n})+···g(b-\frac{b-a}{n})=f(b)-f(a)=0$</p><p>若$g(a)+g(\frac{b-a}{n})+···g(b-\frac{b-a}{n})=f(a)-f(b)=0$，即结论易证，0=0</p><p>若$g(a)+g(\frac{b-a}{n})+···g(b-\frac{b-a}{n})$不全为0，则其中必有正值和负值，由零点定理，存在一点$\xi \in(a,b)$使得$g(\xi)=0$,即$f(\xi)=f(\xi+\frac{b-a}{n})$</p><p>如果给定了$n$的数值，则只需要解出$g(a)+g(b-\frac{b-a}{n})=0$即可</p><hr><p>如果要证明$f(x)=c$，可以先求$f’(x)=0$,说明$f(x)$恒为常数，然后代入某个好算的点求出常数$c$</p><hr><h2 id="导数的应用"><a href="#导数的应用" class="headerlink" title="导数的应用"></a>导数的应用</h2><h3 id="极值"><a href="#极值" class="headerlink" title="极值"></a>极值</h3><p>必要条件</p><p>若$f(x)$在$x_0$处可导，且在$x_0$处取得极值，则$f’(x_0)=0$</p><p>极值点可能是驻点，但是驻点不一定是极值点</p><script type="math/tex; mode=display">f(x_0)\ 是极值点\color{red}{\mathrel{\rlap{\hskip .5em/}}\Longleftarrow} f'(x_0)=0</script><p>极值可能出现在：驻点，没有定义的点</p><hr><p>第一充分条件(在$x_0$处导数变号)</p><p>设函数$f(x)$在$x_0$处连续，且在某去心邻域$\mathring{U}(x_0,\delta)$内可导(或$f(x)$在$x_0$处连续)，则：</p><ol><li><p>若$x\in(x_0-\delta,x_0)$时，$f’(x) &gt; 0$，而$x\in(x_0,x_0+\delta)$时，$f’(x) &lt; 0$，则$f(x)$在$x_0$处取得极大值；</p></li><li><p>若$x\in(x_0-\delta,x_0)$时，$f’(x) &lt; 0$，而$x\in(x_0,x_0+\delta)$时，$f’(x) &gt; 0$，则$f(x)$在$x_0$处取得极小值；</p></li><li><p>若$\mathring{U}(x_0,\delta)$时，$f’(x)$的符号保持不变，则$f(x)$在$x_0$处没有极值。</p></li></ol><hr><p>第二充分条件(观察二阶导数)</p><p>设函数$f(x)$在点$x_0$处二阶可导且$f’(x_0)=0$，则：</p><ol><li>$f’’(x_0) &lt; 0$，$f(x_0)$为极大值；</li><li>$f’’(x_0) &gt; 0$，$f(x_0)$为极小值。</li></ol><div class="hide-toggle" style="border: 1px solid #66c3ee"><div class="hide-button toggle-title" style="background-color: #66c3ee;color: black"><i class="fas fa-caret-right fa-fw"></i><span>证明过程</span></div>    <div class="hide-content"><p>由于二阶导数存在，写出$x_0$处的二阶泰勒多项式：</p><script type="math/tex; mode=display">f(x)=f(x_0)+f'(x_0)(x-x_0)+\frac{f''(x_0)}{2!}(x-x_0)^2+o((x-x_0)^2)</script><p>由于$f’(x_0)=0$，所以：</p><script type="math/tex; mode=display">f(x)-f(x_0)= \frac{f''(x_0)}{2!}(x-x_0)^2+o((x-x_0)^2)</script><p>再根据$f’’(x_0) &lt; 0$,则在$x_0$的某个充分小的邻域内：</p><script type="math/tex; mode=display">f(x)-f(x_0)\approx \frac{f''(x_0)}{2!}(x-x_0)^2 < 0</script><p>所以$x_0$处为极大值。</p></div></div><hr><p>第三充分条件(观察偶数阶导是否不等于0，是第二充分条件的推广)</p><p>设$f(x)$在$x_0$处$n(n≥2)$可导，且：</p><script type="math/tex; mode=display">f'(x_0)=f''(x_0)=···=f^{n-1}(x_0)\qquad f^n(x_0)≠0,</script><ol><li>当$n$为偶数时$f(x)$在$x_0$处取得极值，其中当$f^{n}(x_0)&gt;0$时取得极小值，当$f^{n}&lt;0$时取得最大值</li><li>当$n$为奇数时，$f(x)$在$x_0$处无极值</li></ol><hr><p>某区间上函数的最值只有三种情况：</p><ol><li>驻点</li><li>不可导的点</li><li>端点值</li></ol><hr><p>只须考察$f(x)$在$x = x_0$处的连续性及$f(x)$在$x = x_0$两侧$f’(x),f’’(x)$是否变号，而不须考虑$f’(x),f’’(x)$是否存在就可判定$x = x_0$是否是$f(x)$的极值点与拐点</p><p>$f(x)$在$x = x_0$不可导,$x = x_0$与$(x = f(x_0))$可以同时是$y=f(x)$的极值点与拐点，但对于可导函数，可以证明：若$x = f(x_0)$是$y=f(x)$的拐点，则$x = x_0$不可能是$f(x)$的极值点，因为第三充分条件</p><hr><h3 id="凹凸性"><a href="#凹凸性" class="headerlink" title="凹凸性"></a>凹凸性</h3><p>$f(x)$在$(a,b)$有定义。$\forall x_1,x_2\in(a,b)$，定义函数$f(\frac{x_1+x_2}{2})和\frac{f(x_2)+f(x_1)}{2}$：</p><ol><li>若$f(\frac{x_1+x_2}{2})&lt;\frac{f(x_2)+f(x_1)}{2}$，则称$f(x)$在$(a,b)$为$\color{salmon}{凹的(或凹弧)}$；</li><li>若$f(\frac{x_1+x_2}{2})&gt;\frac{f(x_2)+f(x_1)}{2}$，则称$f(x)$在(a,b)为$\color{salmon}{凸的(或凸弧)}$。</li></ol><p>导数定义：</p><p>设函数$f(x)$在$[a,b]$上连续，在$(a,b)$内具有一阶和二阶导数，那么：</p><ol><li>若在$(a,b)$内$f’’(x) &gt; 0$，则曲线$y=f(x)$在$[a,b]$上是凹的</li><li>在$(a,b)$内$f’’(x) &lt; 0$，则曲线$y=f(x)$在$[a,b]$上是凸的</li></ol><p>结合极值的第二充分条件理解，当$f’’(x)&lt;0$时有极大值，自然是凸的</p><hr><p>对于函数$f(x)$，如果在$x_0$点附近凹凸性发生了变化，则$x_0$点称为$\color{Salmon}{拐点}$</p><p>而求函数的拐点，则和求函数的极值点的步骤是一致的：</p><ol><li>求$f’’(x)$</li><li>求出$f’’(x)=0$的实根与二阶不可导点</li><li>检查$f’’(x)$在$x_i$左、右两侧邻近的符号，那么当两侧的符号相反时，点$(x_i,f(x_i))$是拐点；当两侧的符号相同时，点$(x_i,f(x_i))$不是拐点</li></ol><hr><h3 id="渐近线"><a href="#渐近线" class="headerlink" title="渐近线"></a>渐近线</h3><p>水平渐近线</p><p>如果有：</p><script type="math/tex; mode=display">\lim_{x\to-\infty}f(x)=L\qquad\text{或}\qquad\lim_{x\to+\infty}f(x)=L</script><p>那么直线$y=L$称为函数$y=f(x)$的 水平渐近线。</p><hr><p>垂直渐近线</p><p>如果有：</p><script type="math/tex; mode=display">\lim_{x\to x_0^-}f(x)=\pm\infty\qquad\text{或}\qquad\lim_{x\to x_0^+}f(x)=\pm\infty</script><p>那么直线$x=x_0$称为函数$y=f(x)$的 垂直渐近线。</p><hr><p>斜渐近线</p><p>如果有：</p><script type="math/tex; mode=display">\lim_{x\to -\infty}[\ f(x)-(ax+b)\ ]=0\ \ \text{或}\ \ \lim_{x\to +\infty}[\ f(x)-(ax+b)\ ]=0</script><p>那么直线$y=ax+b$称为函数$y=f(x)$的 斜渐近线 ，其中$a=\lim_{x\to \infty}\frac{f(x)}{x}\qquad b=\lim_{x\to \infty}(f(x)-ax)$</p><p>如果能直接把函数写成$ax+b+o(x)$的形式，那么可以更快的得出结论，常常和泰勒公式一起使用</p><p>当确定斜渐进线存在，并过零点时，可直接假设斜渐近线斜率为$\lim_{x\to \infty} \frac{y}{x}=k$，然后将$k$带入方程求出具体的值，探后$\lim_{x\to \infty} y-kx=c$求出$c$的值，最终的渐近线即为$y=kx+c$</p><hr><h3 id="曲率"><a href="#曲率" class="headerlink" title="曲率"></a>曲率</h3><script type="math/tex; mode=display">K=\frac{1}{r}=\frac{\left|f''(x_0)\right|}{\left(1+\left(f'(x_0)\right)^2\right)^\frac{3}{2}}</script>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.函数，极限，连续</title>
      <link href="/post/3946.html"/>
      <url>/post/3946.html</url>
      
        <content type="html"><![CDATA[<h1 id="函数，极限，连续"><a href="#函数，极限，连续" class="headerlink" title="函数，极限，连续"></a>函数，极限，连续</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>如果对于每个数$x\in D$，变量$y$按照一定的法则总有一个确定的$y$和它对应，则称$x$是$y$的函数，记作$y=f(x)$ </p><p>称$x$为自变量，$y$为因变量，$D$为定义域</p><p>定义域：$D_f=D$</p><p>值域：$R_f=f(D)=\left\{y|y=f(x),x\in D\right\}$</p><p>两个基本要素：<strong>定义域，对应法则</strong></p><hr><h3 id="常见函数"><a href="#常见函数" class="headerlink" title="常见函数"></a>常见函数</h3><p>符号函数：</p><script type="math/tex; mode=display">\operatorname{sgn} x=\left\{\begin{array}{ccc}-1 & : & x<0 \\ 0 & : & x=0 \\ 1 & : & x>0\end{array}\right.</script><p>取整函数：</p><p>设$x$为任意实数，不超过$x$的最大整数称为$x$的整数部分，记作$[x]$,函数$y=[x]$称为取整函数</p><hr><h3 id="复合函数"><a href="#复合函数" class="headerlink" title="复合函数"></a>复合函数</h3><p>假如有两个函数$f:X\to Y$以及$g: Y\to Z$，那么可以得到$X$到$Z$的函数，记作：</p><script type="math/tex; mode=display">g\circ f:X\to Z\quad 或\quad (g\circ f)(x)=g\Big(f(x)\Big)</script><p>这种运算称为函数的复合</p><p>复合运算的前提是$X$的值域要和$Y$的定义域的交集非空</p><hr><h3 id="反函数"><a href="#反函数" class="headerlink" title="反函数"></a>反函数</h3><p>设$y=f(x)$的定义域为$D$，值域为$R_y$，若对任意$y\in R_y$，有唯一确定的$x\in D$使得$y=f(x)$，则记为$x=f^{-1}(y)$，称其为函数$y=f(x)$的<strong>反函数</strong></p><blockquote><p>很容易联想到线性代数中的“可逆”概念，只有满足满射的情况下，矩阵才可逆，换句话说，才能有反函数</p></blockquote><ul><li><p>所以不是每个函数都有反函数，但单调函数一定有反函数</p></li><li><p>$y=f(x)$和$y=f^{-1}(x)$的图形关于$y=x$对称</p></li></ul><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220725221159137.png" alt="image-20220725221159137"></p><ul><li><p>$f^{-1}[f(x)]=x$，同样$f[f^{-1}(x)]=x$，本质上是将$x$映射到了$y$，然后$y$又映射回了$x$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/li.svg" alt=""></p></li></ul><hr><h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220805170224154.png" alt="image-20220805170224154"></p><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">算式</th><th style="text-align:center">图像</th></tr></thead><tbody><tr><td style="text-align:center">正弦函数 $sinx$</td><td style="text-align:center">$sinx=\frac{a}{c}$</td><td style="text-align:center"><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220805172636115.png" alt="image-20220805172636115" style="zoom: 67%;" /></td></tr><tr><td style="text-align:center">余弦函数 $cosx$</td><td style="text-align:center">$cosx=\frac{b}{c}$</td><td style="text-align:center"><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220805172651778.png" alt="image-20220805172651778" style="zoom:67%;" /></td></tr><tr><td style="text-align:center">正切函数 $tanx$</td><td style="text-align:center">$tanx=\frac{a}{b}$</td><td style="text-align:center"><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220805172723291.png" alt="image-20220805172723291" style="zoom:67%;" /></td></tr><tr><td style="text-align:center">余切函数 $cotx$</td><td style="text-align:center">$cotx=\frac{b}{a}$</td><td style="text-align:center"><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220805173105885.png" alt="image-20220805173105885" style="zoom:67%;" /></td></tr><tr><td style="text-align:center">正割函数 $secx$</td><td style="text-align:center">$secx=\frac{c}{b}$</td><td style="text-align:center"><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220805173126438.png" alt="image-20220805173126438" style="zoom:67%;" /></td></tr><tr><td style="text-align:center">余割函数 $cscx$</td><td style="text-align:center">$cscx=\frac{c}{a}$</td><td style="text-align:center"><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220805173226819.png" alt="image-20220805173226819" style="zoom:67%;" /></td></tr></tbody></table></div><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220805171147803.png" alt="image-20220805171147803"></p><p>如图，六边形的六个角分别代表六种三角函数，存在如下关系：</p><ol><li>对角相乘乘积为1，即$sinθ·cscθ=1$； $cosθ·secθ=1$； $tanθ·cotθ=1$</li><li>六边形任意相邻的三个顶点代表的三角函数，处于中间位置的函数值等于与它相邻两个函数值的乘积，如：$sinθ=cosθ·tanθ$；$tanθ=sinθ·secθ$</li><li>阴影部分的三角形，处于上方两个顶点的平方之和等于下顶点的平方值，如：$sin^2 x+cos^2 x=1$</li></ol><p>降幂公式：</p><script type="math/tex; mode=display">sin²α=\frac{[1-cos(2α)]}{2}</script><script type="math/tex; mode=display">cos²α=\frac{[1+cos(2α)]}{2}</script><script type="math/tex; mode=display">tan²α=\frac{[1-cos(2α)]}{[1+cos(2α)]}</script><p>和差化积公式：</p><script type="math/tex; mode=display">sina+sin\beta=2sin\frac{a+\beta}{2}cos\frac{a-\beta}{2}</script><script type="math/tex; mode=display">cosa+cos\beta=2cos\frac{a+\beta}{2}cos\frac{a-\beta}{2}</script><script type="math/tex; mode=display">sina-sin\beta=2cos\frac{a+\beta}{2}sin\frac{a-\beta}{2}</script><script type="math/tex; mode=display">cosa-cos\beta=-2sin\frac{a+\beta}{2}sin\frac{a-\beta}{2}</script><div class="hide-toggle" style="border: 1px solid #66c3ee"><div class="hide-button toggle-title" style="background-color: #66c3ee;color: black"><i class="fas fa-caret-right fa-fw"></i><span>证明过程</span></div>    <div class="hide-content"><p>证明第一个公式：$sina+sin\beta=2sin\frac{a+\beta}{2}cos\frac{a-\beta}{2}$</p><p>$sin(A+B)=sinAcosB+cosAsinB$</p><p>$sin(A-B)=sinAcosB-cosAsinB$</p><p>$sin(A+B)+sin(A-B)=2sinAcosB$</p><p>$A+B=a \qquad A-B=\beta \qquad  sina+sin\beta=2sin\frac{a+\beta}{2}cos\frac{a-\beta}{2}$</p></div></div><p>$tan(A+B)=\frac{(tanA+tanB)}{(1-tanA×tanB)}$</p><p>$tan(A-B)=\frac{(tanA-tanB)}{(1+tanA×tanB)}$</p><hr><h3 id="反三角函数"><a href="#反三角函数" class="headerlink" title="反三角函数"></a>反三角函数</h3><p>三角函数是一种基本初等函数。它是反正弦$arcsin x$，反余弦$arccos x$，反正切$arctan x$，反余切$arccot x$，反正割$arcsec x$，反余割$arccsc x$这些函数的统称，各自表示其正弦、余弦、正切、余切 ，正割，余割为$x$的<strong>角</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">定义域</th><th style="text-align:center">值域</th><th style="text-align:center">图像</th></tr></thead><tbody><tr><td style="text-align:center">$arcsinx$</td><td style="text-align:center">[-1,1]</td><td style="text-align:center">$[-\pi/2，\pi/2]$</td><td style="text-align:center"><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220805174921947.png" alt="image-20220805174921947" style="zoom:67%;" /></td></tr><tr><td style="text-align:center">$arccosx$</td><td style="text-align:center">[-1,1]</td><td style="text-align:center">[$0,\pi$]</td><td style="text-align:center"><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220805175009937.png" alt="image-20220805175009937" style="zoom:67%;" /></td></tr><tr><td style="text-align:center">$arctanx$</td><td style="text-align:center">$(-\infty，+\infty)$</td><td style="text-align:center">$(-\pi/2,\pi/2)$</td><td style="text-align:center"><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220805175040623.png" alt="image-20220805175040623" style="zoom:67%;" /></td></tr></tbody></table></div><p>运算：</p><p>类似 </p><script type="math/tex; mode=display">tan(x-y)=\frac{tanx-tany}{1+tanx·tany}</script><script type="math/tex; mode=display">arctanx-arctany=arctan\frac{x-y}{1+xy}</script><p>特别的，$arctanx+arctan\frac{1}{x}=\frac{\pi}{2}$</p><hr><h3 id="初等运算"><a href="#初等运算" class="headerlink" title="初等运算"></a>初等运算</h3><p>将幂函数，指数，对数，三角，反三角统称为基础初等函数</p><p>幂函数：$y=x^{\alpha}(\alpha 为实数)$</p><p>指数函数：$y=\alpha^{x}(a&gt;0,a≠1)$</p><p>对数函数：$y=log_{\alpha}x(a&gt;0,a≠1)$</p><p>三角函数：$y=sinx,y=cosx,y=tanx,y=cotx$</p><p>反三角函数：$y=arcsinx,y=arccosx,y=arctanx$</p><p><strong>初等函数</strong>：由常数和基本初等函数经过有限次加减乘除和复合所得到的且能用一个解析式表示的函数</p><hr><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><h4 id="单调性"><a href="#单调性" class="headerlink" title="单调性"></a>单调性</h4><p>如果对于区间$I$上任一两点$x_1&lt;x_2$恒有：</p><p>$f(x_1)&lt;f(x_2)$  则是单调增加</p><p>$f(x_1)&gt;f(x_2)$  则是单调减少</p><p>如果$f’(x_0)&gt;0$，只能说明在$x_0$的去心领域中，右领域上的点都能使$f(x)&gt;f(0)$成立，但是无法判断$f(x)$的右邻域内任意两点的大小，因为可导不能推出$f’(x_0)$连续，无法判定周围点的情况</p><p>可以依次类推出$f’’(x)&gt;0$，也无法推出其邻域内是凹函数，因为$f’’(x)$不一定连续</p><p>如果$f’(x_0)$连续的话，就可以推出在$f’(x_0)$的邻域内的点都符合$x_0$处的单调性</p><p>综上，$f’(x)＞0\Longrightarrow f(x)$ 单调增，但单调增只能推出，$f’(x_0)≥0$</p><p>应用：</p><ol><li>判断根的个数时，利用单调性</li><li>不等式：如果将不等式的项移动到同一边组成一个新的函数，判断该不等式的单调性，结合端点值，可让某些结论成立</li></ol><hr><h4 id="奇偶性"><a href="#奇偶性" class="headerlink" title="奇偶性"></a>奇偶性</h4><p>设$y=f(x)$的定义域$D$关于原点对称，$\forall x\in D$</p><p>$f(-x)=f(x)$  称为偶函数</p><p>$f(-x)=-f(x)$  称为奇函数</p><p>常见的奇函数有：$sinx，tanx，arcsinx，arctanx，ln\frac{1-x}{1+x}，ln(x+\sqrt{1+x^2})，\frac{e^x-1}{e^x+1}，f(x)-f(-x)$</p><p>常见的偶函数有：</p><p>$x^2，|x|，f(x)+f(-x)$</p><p>奇函数的图形关于原点对称，所以若$f(x)$在$x=0$处有定义，则$f(0)=0$</p><p>设下面所考虑的函数都是定义在区间$(-l,l)$上的</p><ul><li><p>偶+偶=偶，奇+奇=奇</p></li><li><p>偶×偶=偶，奇×奇=偶，奇×偶=奇  </p></li></ul><p>如果$f(x)$可导，则：</p><p>$f(x)$是奇函数$\implies f’(x)$是偶函数  但是反之则不成立，因为$f’(x)$是偶函数，那么$原函数=f(x)+C$，$f(x)$是奇函数，但是$C$是常数</p><p>$f(x)$是偶函数$\implies f’(x$)是奇函数，反之也成立，因为原函数=$f(x)+C$，$f(x)$是偶函数，$C$也是偶函数，所以反之成立</p><p>以上结论可以在<strong>泰勒公式</strong>中体现</p><p>在$x=0$点的泰勒展开式为：$f(x)=f(0)+f’(x)x+\frac{f’’(0)}{2!}x^2+o(x)$，根据性质，假设$f(x)$是奇函数，那么$f’’(x)=0$，假设$f(x)$是偶函数，那么$f’(x)=0$，然后可以根据$f(x)$在$0$点附近值直接判断其导数or二阶导的正负</p><p>连续的奇函数的原函数是偶函数，连续的偶函数的原函数之一是奇函数</p><p>任意一个函数都可以被分成<strong>奇函数+偶函数</strong></p><hr><h4 id="周期性"><a href="#周期性" class="headerlink" title="周期性"></a>周期性</h4><p>若存在实数$T&gt;0$，对于任意$x$，恒有$f(x+T)=f(x)$，则称$y=f(x)$为周期函数，使得上式成立的最小正数$T$称为函数$f(x)$的周期</p><ul><li>若$f(x)$以$T$为周期，则$f(ax+b)$以$\frac{T}{|a|}$为周期</li></ul><p>函数的积分性质：</p><script type="math/tex; mode=display">\int^{x+T}_xP(t)dt=\int^T_0P(t)dt</script><script type="math/tex; mode=display">\int^x_0P(t)dt(T为周期)\implies\int^T_0P(t)dt=0</script><p>针对第二条，易得$x=0$时，积分的值为$0$，所以$x=T$时，积分的值也为$0$</p><p>周期函数的导数仍然是周期函数，且周期一致</p><p>但是周期函数的原函数<strong>并不一定</strong>是周期函数</p><hr><h4 id="有界性"><a href="#有界性" class="headerlink" title="有界性"></a>有界性</h4><p>若存在$M&gt;0$，使得对任意$x\in X$，恒有$|f(x)|≤M$，则称$f(x)$在$X$为<strong>有界函数</strong></p><p>如果对任意$M&gt;0$，至少存在一个$x_0\in X$，使得$|f(x)|＞M$，则$f(x)$为$X$上的无界函数</p><p>$|arcsinx|≤\frac{π}{2}，|arctanx|&lt;\frac{π}{2}，|arctanx|&lt;π$</p><p>判定条件：</p><ol><li>定义</li><li>$f(x)$在$[a,b]$上连续，则在$[a,b]$上有界</li><li>$f(x)$在$(a,b)$上连续，且$f(a^+),f(b^-)$存在，则在$(a,b)$上有界</li><li>$f’(x)$在区间有限区间上有界，则$f(x)$在有限区间上有界</li></ol><p>第4点的证明：泰勒公式：$f(x)=f(x)-f(x_0)+f(x)=f’(\xi)(x-x_0)+f(x_0)$</p><p>$\xi$是在$(x,x_0)$区间内的一点，$f’(\xi)$有界，同样$(x-x_0)$也是一个有界值，而$f(x_0)$也是一个有界值，所以最终$|f(x)|$会小于等于某个值</p><hr><h2 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h2><h3 id="数列极限"><a href="#数列极限" class="headerlink" title="数列极限"></a>数列极限</h3><p>定义：设$\{x_n\}$为一数列。如果存在实数$a$，对于任意给定的正实数$\epsilon$（不论它多么小），总存在正整数$N$，使得对所有的$n &gt; N$​时，有：</p><script type="math/tex; mode=display">|x_n-a| < \epsilon,\quad a\in\mathbb{R}</script><p>那么就称$a$是数列$\{x_n\}$的 极限 ，或者称数列$\{x_n\}$ 收敛于 $a$，记作：</p><script type="math/tex; mode=display">\lim_{n\to\infty}x_n=a\quad或\quad x_n\to a(n\to \infty)</script><p>如果不存在这样的常数$a$，就说数列$\{x_n\}$没有极限，或者说数列$\{x_n\}$是 <strong>发散</strong> 的，习惯上也说$\lim_{n\to\infty}x_n$不存在。</p><ul><li>$\epsilon$的作用是表示说明$|x_n-a|$会无限接近于0，$N$的作用是说明在$N$之后有无穷项都会让$|x_n-a| &lt; \epsilon,\quad a\in\mathbb{R}$  等式成立</li><li>几何意义是：$a-\epsilon&lt;x_n&lt;a+\epsilon$，说明在$x$的$\epsilon$邻域中有无穷多项</li><li>数列${x_n}$的极限与前有限项无关</li><li>$\lim_{n\to\infty}x_n=a \iff \lim_{n\to\infty}x_{2k}=\lim_{n\to\infty}x_{2k-1}=a$</li></ul><ol><li><p>若$\lim_{n\to\infty}x_n=a$，则$\lim_{n\to\infty}|x_n|=|a|$，但反之不成立</p><div class="hide-toggle" style="border: 1px solid #66c3ee"><div class="hide-button toggle-title" style="background-color: #66c3ee;color: black"><i class="fas fa-caret-right fa-fw"></i><span>证明过程</span></div>    <div class="hide-content"><p>证明如下：</p><p>条件是：$\forall\epsilon&gt;0,∃N$，当$n&gt;N$，有$|x_n-a| &lt; \epsilon$</p><p>要证明的结论是：$\forall \epsilon&gt;0,∃ N$，当$n&gt;N$，有$||x_n|-|a|| &lt; \epsilon$</p><p>根据不等式的性质：$||a|-|b||&lt;|a-b|$，所以$||x_n|-|a||&lt;|x_n-a| &lt; \epsilon$</p><p>故证明完成</p></div></div></li><li><p>$\lim_{n\to\infty}x_n=0$的充分必要条件是$\lim_{n\to\infty}|x_n|=0$</p><p>仿照上式的证明过程：$||x_n|-0| &lt; \epsilon \iff |x_n| &lt; \epsilon$</p><p>该结论在夹逼原理时用的很多</p></li></ol><hr><h3 id="函数极限"><a href="#函数极限" class="headerlink" title="函数极限"></a>函数极限</h3><p>趋于无穷时的函数极限</p><p>$\forall \epsilon &gt;0，∃ X&gt;0，$当$|x|&gt;X$时,恒有$|f(x)-A|&lt;\epsilon$</p><script type="math/tex; mode=display">\begin{array}{c|c} \hline \quad 数列极限 \quad\quad&\quad x\to\infty\ 的函数极限\quad \\ \hline \\ 数列\ \{x_n\} &\quad 函数\ f(x)\ 当\ |x|\ 大于某正数时有定义\quad\\ \exists N\in\mathbb{Z}^{+} & \exists X > 0\\ \forall n > N & \forall |x| > X\\ \\ \hline \end{array}</script><p>定理1：</p><script type="math/tex; mode=display">\lim_{n\to\infty}f(x)=A \iff \lim_{n\to-\infty}f(x)=\lim_{n\to+\infty}f(x)=A</script><hr><p>邻域</p><p>定义：以$x_0$为中心、半径为$\delta（\delta &gt; 0）$的开区间$(x_0-\delta,x_0+\delta)$称为点$x_0$的邻域 ，记作$U(x_0,\delta)$。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220726160646657.png" alt="image-20220726160646657"></p><p>去心邻域</p><p>定义：在邻域$U(x_0,\delta)$中去掉中心$x_0$后，称为点$x_0$的 去心邻域，记作$\mathring{U}(x_0,\delta)$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220726160758403.png" alt="image-20220726160758403"></p><p>趋于有限值时函数的极限</p><script type="math/tex; mode=display">\lim_{x\to x_0}f(x)=A</script><p>定义：$\forall \epsilon &gt;0，\exists \delta&gt;0，$当$0&lt;|x-x_0|&lt;\delta$时,恒有$|f(x)-A|&lt;\epsilon$</p><ul><li>$\epsilon $的作用是说明$f(x)$会无限接近$A$</li><li>$\delta$的作用是$x_0$的去心邻域足够小，即$x_0$会无线接近$x$</li><li>$x\to x_0$，但是是去心邻域，$x≠x_0$</li></ul><p>极限就是研究的是$x_0$在其去心邻域的变化情况，如果$x=x_0$，则就没有研究的意义了</p><script type="math/tex; mode=display">\begin{array}{c|c} \hline \quad 数列的极限\quad&\quad 无穷函数的极限\quad&\quad 一般函数的极限\quad \\ \hline \\ 数列\ \{x_n\} &\quad f(x)\ 当\ |x|\ 大于某正数时有定义\quad&\quad f(x)\ 在\ \mathring{U}(x_0)\ 上有定义\quad\\\ \exists N\in\mathbb{Z}^{+} & \exists X > 0 & \exists \delta > 0\\ \forall n > N & \forall |x| > X & \forall x\in\mathring{U}(x_0,\delta)\\ \\ \hline \end{array}</script><hr><p>左极限</p><p>定义 .设函数$f(x)$在$(a,x_0)$上有定义，其中$a &lt; x_0$。如果$\forall\epsilon &gt; 0，\exists \delta &gt; 0，\forall x\in(x_0-\delta, x_0)$​，有：</p><script type="math/tex; mode=display">|f(x) - A| < \epsilon</script><p>那么就称$A$是函数$f(x)$当$x\to x_0^-$时的 左极限 ，或者称当$x\to x_0^-$时函数$f(x)$ 收敛于 $A$，记作：</p><script type="math/tex; mode=display">\lim_{x\to x_0^-}f(x)=A\quad 或\quad f(x)\to A(x\to x_0^-)</script><p>同理，右极限也可被定义为：</p><script type="math/tex; mode=display">\lim_{x\to x_0^+}f(x)=A\quad 或\quad f(x)\to A(x\to x_0^+)</script><p>存在的充要条件：</p><script type="math/tex; mode=display">\lim_{x\to x_0}f(x)=A \iff \lim_{x\to x_0^-}f(x)=\lim_{x\to x_0^+}f(x)=A</script><p>常用到左右极限的情况：</p><ol><li>分段函数在分界点的极限</li><li>$e^{\infty}$型极限(如$\lim_{x\to\infty}e^{x}$ ，此类极限的左右无穷趋近的值不一样,$\lim_{x\to+\infty}e^{x}=\infty$$\lim_{x\to-\infty}e^{x}=0$)</li><li>$arctan\infty$型极限($x \to +\infty$时,趋向于$π/2$，$x \to -\infty$时,趋向于 $-π/2$)</li></ol><hr><h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h3><ul><li>有界性</li></ul><p>（数列）如果数列${x_n}$收敛，那么数列${x_n}$一定有界 </p><p>（函数）如果$\lim_{x\to x_0}f(x)$存在，则$f(x)$在$x_0$某去心邻域有界</p><ul><li><p>保号性</p><p>(数列) </p><p>  $\lim_{n\to\infty}x_n=A$</p><p>如果$A &gt; 0$（或$A &lt; 0$），那么存在正整数$N&gt;0$，当$n&gt;N$时，有$x_n &gt; 0$（或$x_n &lt; 0$）。</p><p>推论：如果数列$\{x_n\}$从某项起有$x_n\ge 0$（或$x_n \le 0$），那么$A \ge 0$（或$A \le 0$）。</p><p>（函数）</p><p> $\lim_{x\to x_0}f(x)=A$</p><p>如果$A &gt; 0$（或$A &lt; 0$），那么存在$\delta&gt;0$时，有$x \in \mathring{U}(x_0,\delta)$时，$f(x)&gt;0$(或$f(x)&lt;0$)</p><p>推论：如果$\delta&gt;0$，当$x \in \mathring{U}(x_0,\delta)$时，$f(x)≥0$(或$f(x)≤0$)，那么$A≥0$(或$A≤0$)</p></li></ul><hr><h3 id="存在准则"><a href="#存在准则" class="headerlink" title="存在准则"></a>存在准则</h3><p>夹逼定理</p><p>如果：</p><p>（1）在相应的局部有$g(x)\leq f(x) \leq h(x)$</p><p>（2）$\lim g(x)=\lim h(x)=L$</p><p>那么$\lim f(x)=L$</p><hr><p>单调有界准则</p><p>单调有界数列必有极限：</p><p>单调增，有上界的数列必有极限</p><p>单调减，有下界的数列必有极限</p><hr><h3 id="无穷小量"><a href="#无穷小量" class="headerlink" title="无穷小量"></a>无穷小量</h3><p>定义 ：对于函数$f(x)$，如果满足$\lim f(x)=0$   则称函数$f(x)$为此自变量变化过程（指$x\to x_0，x\to\infty$等）的无穷小 </p><p>极限与无穷小的关系：</p><p>定理 .极限$\lim f(x)=L$​存在的充要条件为：</p><script type="math/tex; mode=display">f(x)=L+\alpha\iff \lim f(x)=L</script><p>其中$\alpha$为自变量的同一变化过程的无穷小，即有$\lim\alpha=0$</p><p>无穷小量的比较：</p><p>已知$\alpha$和$\beta$是同一自变量的变化过程中的无穷小，且在相应的局部有$\alpha\ne 0$，如果：</p><p>（1） $\lim\frac{\beta}{\alpha}=0$， 则称$\beta$是比$\alpha$ 高阶的无穷小，记作$\beta=o(\alpha)$；</p><p>（2） $\lim\frac{\beta}{\alpha}=\infty$， 则称$\beta$是比$\alpha$ 低阶的无穷小 </p><p>（3） $\lim\frac{\beta}{\alpha}=c\ne 0$， 则称$\beta$与$\alpha$是同阶无穷小 </p><p>（4） $\lim\frac{\beta}{\alpha^k}=c\ne 0,k &gt; 0$，则称$\beta$是关于$\alpha$的 $k$ 阶的无穷小 </p><p>（5） $\lim\frac{\beta}{\alpha}=1$，则称$\beta$与$\alpha$是 等价无穷小 ，$\alpha\sim\beta$</p><p>性质：</p><ol><li>有限个无穷小量的和仍然是无穷小量</li><li>有限个无穷小量的积仍然是无穷小量</li><li>无穷小量与有界量的积仍然是无穷小</li></ol><p>常见的等价无穷小量：</p><p>定理 .当$x\to 0$时有：</p><p>（1）$\sin x\sim x$ （2）$\tan x\sim x$  （3）$\arcsin x\sim x$  （4）$\arctan x\sim x$</p><p>（5）$\ln(1+x)\sim x$  （6）$e^x-1\sim x$  （7）$(1+x)^\alpha-1\sim \alpha x$</p><p>（8）$1-\cos x \sim \frac{1}{2} x^{2}$</p><hr><h3 id="无穷大量"><a href="#无穷大量" class="headerlink" title="无穷大量"></a>无穷大量</h3><p>定义：设函数$f(x)$在$\mathring{U}(x_0)$上有定义。如果$\forall M &gt; 0，\exists \delta &gt; 0，\forall x\in\mathring{U}(x_0,\delta)$，有：</p><script type="math/tex; mode=display">|f(x)| > M</script><p>那么就称函数$f(x)$是$x\to x_0$时的 无穷大。可记作：</p><script type="math/tex; mode=display">\lim_{x\to x_0}f(x)=\infty</script><p>无穷小量的比较：</p><p>当$n\to\infty$时：</p><script type="math/tex; mode=display">ln^{\alpha} n<< n^\beta <<a^n<<n!<<n^n  \quad \alpha>0,\beta>0,a>1</script><p>性质：</p><ol><li>两个无穷大量的积仍为无穷大量</li><li>无穷大量与有界变量的和为无穷大</li></ol><p>无穷大量和无界变量的关系：</p><p>无界变量：$\forall M&gt;0, \exists  N&gt;0 $，使得$|x_N|&gt;M$</p><p>显然无穷大量一定是无界变量，但是无界变量不一定是无穷大量，因为只要任意一个$|x_N|&gt;M$，就可以是无界变量，而无穷大量必须是一个序列</p><p>无穷大量和无穷小量的关系：</p><p>定理  在自变量的同一变化过程中：</p><p>若$f(x)$为无穷小，且在相应的局部有$f(x)\ne 0$，则$\frac{1}{f(x)}$为无穷大。该结论也记作$\frac{1}{0}=\infty$</p><p>若$f(x)$为无穷大，则$\frac{1}{f(x)}$为无穷小。该结论也记作$\frac{1}{\infty}=0$</p><p>$\lim_{n \to +\infty}x_ny_n=\infty$并不能推出$x_n$或$y_n$是无穷大量，有可能是两个错开的无界变量相乘</p><hr><h2 id="求极限（8种方法"><a href="#求极限（8种方法" class="headerlink" title="求极限（8种方法)"></a>求极限（8种方法)</h2><h4 id="1-基本极限"><a href="#1-基本极限" class="headerlink" title="1.基本极限"></a>1.基本极限</h4><script type="math/tex; mode=display">\lim_{x\to 0}\frac{sinx}{x}=1</script><script type="math/tex; mode=display">\lim_{x\to 0}(1+x)^\frac{1}{x}=e</script><script type="math/tex; mode=display">\lim_{x\to \infty}(1+\frac{1}{x})^{x}=e</script><script type="math/tex; mode=display">\lim_{x\to 0}\frac{a^x-1}{x}=lna</script><script type="math/tex; mode=display">\lim_{n\to \infty}\sqrt[n]{n}=1</script><script type="math/tex; mode=display">\lim_{n\to \infty}(a_1^n+a_2^n+\cdot\cdot\cdot+a_m^n)^\frac{1}{n}=a_1\qquad a_1=max(a_1,a_2,a_3....a_m)</script><script type="math/tex; mode=display">\lim_{n\to \infty}\sqrt[n]{a}=1，(a>0)</script><script type="math/tex; mode=display">\lim_{x\to 0^{+}}x^aln^\beta x=0\qquad\alpha>0,\beta>0</script><script type="math/tex; mode=display">lim_{x\rightarrow \infty}{\frac{a_{n}x^{n}+a_{n-1}x^{n-1}…+a_{1}x+a_{0}}{b_{m}x^{m}+b_{m-1}x^{m-1}+…+b_{1}x+b_{0}}}=\left\{ \begin{aligned} \frac{a^{n}}{b^{m}}& , & n=m\ \\ 0& , & n<m\ \\ \infty& , & n>m\ \end{aligned} \right.</script><p>针对最后一个公式，可以得出结论：在$x\to \infty$时，应对分式上下都是多项式和的情况下，只需要看分子和分母的<strong>最高次项</strong>即可。</p><p>而在$x\to 0$的情况下，只需要看分子分母的<strong>最低次项</strong>即可</p><p><strong>在判断敛散性的时候，在性质很有用</strong></p><p><strong>此结论可作为泰勒展开以及等价无穷小代换时的依据</strong></p><hr><p>$1^{\infty}$型极限的常用结论</p><p>若 $\lim{\alpha\left( x \right)}=0，\lim{\beta\left( x \right)}=\infty$， 且 $\lim{\alpha\left( x \right)}{\beta\left( x \right)}=A$,则</p><script type="math/tex; mode=display">\lim{\left[ 1+\alpha\left( x \right) \right]^{\beta\left( x \right)}}=e^{A}</script><p>可以归纳为以下三步：</p><p>（1）写标准形式：原式$= \lim{\left[ 1+\alpha\left( x \right) \right]^{\beta\left( x \right)}}$</p><p>（2）写极限： $\lim{\alpha\left( x \right)}{\beta\left( x \right)}=A$ </p><p>（3）写结果： 原式$=e^{A}$.</p><hr><h4 id="2-等价无穷小代换"><a href="#2-等价无穷小代换" class="headerlink" title="2.等价无穷小代换"></a>2.等价无穷小代换</h4><p>常见的等价无穷小：</p><script type="math/tex; mode=display">x\sim sinx\sim tanx \sim arctanx \sim arcsinx\sim ln\left( x+1 \right)\sim e^{x}-1</script><script type="math/tex; mode=display">\left( 1+x \right)^{\alpha}-1\sim ax，1-(cosx)^{\alpha}\sim \frac{\alpha}{2}x^{2}</script><script type="math/tex; mode=display">x-ln\left( 1+x \right)\sim \frac{1}{2}x^{2},a^{x}-1\sim xlna</script><script type="math/tex; mode=display">x-sinx\sim \frac{1}{6}x^{3}，tanx-x\sim \frac{1}{3}x^{3}，arcsinx-x\sim \frac{1}{6}x^{3}，x-arctanx\sim\frac{1}{3}x^{3}</script><hr><p>实际上，很多等价无穷小可以看做是泰勒公式的一 阶展开式</p><p>比如：</p><script type="math/tex; mode=display">(1+x)^{m}=1+m x+\frac{m(m-1)}{2 !} x^{2}+\cdots+\frac{m(m-1)\cdots\left( m-n+1 \right)}{n!} x^{n}+o\left(x^{2}\right)\\\left( 1+x \right)^{\alpha}-1\sim ax</script><script type="math/tex; mode=display">ln (1+x)=x-\frac{x^{2}}{2}+\frac{x^{3}}{3}-\cdots+(-1)^{n-1} \frac{x^{n}}{n}+o\left(x^{n}\right)\\x-ln\left( 1+x \right)\sim \frac{1}{2}x^{2}</script><script type="math/tex; mode=display">sin x=x-\frac{x^{3}}{3 !}+\frac{x^{5}}{5 !}-\cdots+(-1)^{n} \frac{x^{2 n+1}}{(2 n+1) !}+o\left(x^{2 n+2}\right)\\ x-sinx=\frac{1}{6}x^{3}</script><hr><p>关于$\left( 1+x \right)^{\alpha}-1\sim ax$​这一等价代换，实际上，可以写成</p><script type="math/tex; mode=display">\left( 1+\alpha(x) \right)^{\beta(x)}-1\sim \alpha(x)\beta(x)</script><p>只要满足条件$\alpha(x) \to 0$，$\alpha(x)\beta(x) \to0$</p><p>显然，这个结论建立在$1^{\infty}$型极限的解法，以及$e^x-1 \sim x$的等价无穷小代换之上</p><hr><p>等价无穷小实际有推广结论：</p><p>比如$ln\left( x+1 \right)\sim x$，实际上推广到$ln\left( f(x)+1 \right)\sim x$，只要满足$f(x)\to0$即可，可应用于多个等价无穷小上</p><hr><p>设$f(x)$和$g(x)$在$x=0$的某领域内连续，且$\lim_{x\to 0}\frac{f(x)}{g(x)}=1$​,，则</p><script type="math/tex; mode=display">\int^x_0f(t)dt\sim\int^x_0g(t)dt</script><hr><p>等价无穷小的替换：</p><p>乘除关系可以换：</p><p>设$\alpha\sim \alpha_1，\beta\sim \beta_1$，且$\displaystyle \lim_{}\frac{\alpha_1}{\beta_1}$存在，则$\displaystyle \lim_{}\frac{\alpha}{\beta}=\displaystyle \lim_{}\frac{\alpha_1}{\beta_1}$</p><p>加减关系在一定条件下可以换：</p><p>设$\alpha\sim \alpha_1，\beta\sim \beta_1$，且$\displaystyle \lim_{}\frac{\alpha_1}{\beta_1}=A≠1$存在，则$\alpha-\beta\sim \alpha_1-\beta_1$</p><p>设$\alpha\sim \alpha_1，\beta\sim \beta_1$，且$\displaystyle \lim_{}\frac{\alpha_1}{\beta_1}=A≠-1$存在，则$\alpha+\beta\sim \alpha_1+\beta_1$</p><p>并且这个结论甚至能推导到复合函数上：</p><p>若$f(x)$和$g(x)$为正的同阶无穷大(小)，则$ln(f(x))\sim ln(g(x))$，$(x\to a)$</p><p>证明如下</p><script type="math/tex; mode=display">\lim_{x\to a}\frac{ln(f(x))}{ln(g(x))}=\lim_{x\to a}\frac{ln(f(x))-g(x)+g(x)}{ln(g(x))}=\lim_{x\to a}\frac{ln(\frac{f(x)}{g(x)})}{ln(g(x))}+1=1</script><hr><p>在求三角函数的极限的时候，可以利用三角函数的<strong>周期性</strong>进行构造</p><p>如：</p><script type="math/tex; mode=display">\lim_{n\to \infty}ntan(\pi\sqrt{n^2+1})=ntan(\pi\sqrt{n^2+1}-n\pi)=ntan(n\pi\sqrt{\frac{1}{n^2}+1}-n\pi)=\\ntan(n\pi\frac{\frac{1}{n^2}}{\sqrt{1+\frac{1}{n^2}}+1})=\lim_{n\to\infty}n·\frac{\frac{\pi}{n}}{\sqrt{1+\frac{1}{n^2}}+1}</script><hr><h4 id="3-有理运算法则"><a href="#3-有理运算法则" class="headerlink" title="3.有理运算法则"></a>3.有理运算法则</h4><p>若 $\lim f\left( x \right)=A，\lim g\left( x \right)=B$. 那么：</p><script type="math/tex; mode=display">\lim \left [ f\left ( x \right ) \pm g\left ( x \right ) \right ] =\lim f\ \left ( x \right )\pm g\left ( x \right )</script><script type="math/tex; mode=display">\lim \left [ f\left ( x \right ) \ \cdot g\left ( x \right ) \right ]=\lim f\left ( x \right )\cdot \lim g\left ( x \right )</script><script type="math/tex; mode=display">\lim \left [ \frac{f\left ( x \right ) }{g\left ( x \right ) } \right ]=\lim \frac{f\left ( x \right ) }{g\left ( x \right ) } \left ( B\ne 0 \right )</script><p>$\lim_{x\to a}f(x)=A\qquad lim_{x\to a}g(x)$不存在</p><p>$\lim_{x\to a}f(x)+g(x)=$不存在</p><p>即</p><p>存在$\pm$不存在=不存在</p><p>不存在$\pm$不存在=不一定</p><p>若$A=0$，则$f(x)·g(x)$的极限可能存在，若$A≠0$,则$f(x)·g(x)$的极限不存在</p><hr><p>常用的结论： </p><script type="math/tex; mode=display">\left( 1 \right)\lim f\left ( x \right )=A\ne 0\Rightarrow limf\left ( x \right )g\left ( x \right ) =A\lim g\left ( x \right )；</script><p> 即：极限非零的因子的极限可先求出来.</p><script type="math/tex; mode=display">\left ( 2 \right ) \lim \frac{f\left ( x \right ) }{g\left ( x \right ) } 存在，limg\left ( x \right )=0\Rightarrow limf\left ( x \right )=0</script><script type="math/tex; mode=display">\left( 3 \right) \lim \frac{f\left ( x \right ) }{g\left ( x \right ) } =A\ne 0,limf(x)=0\Rightarrow limg(x)=0.</script><hr><h4 id="4-洛必达法则"><a href="#4-洛必达法则" class="headerlink" title="4.洛必达法则"></a>4.洛必达法则</h4><p>若 </p><p>$\left( 1 \right)\lim_{x \to x_{0} }f(x)= \lim_{x \to x_{0} }g(x)=0\left ( \infty \right )$<br>$\left ( 2 \right ) f\left ( x \right )和g\left ( x \right )$在$x_{0}$ 某去心邻域内可导，且$g{}’\left( x \right )\ne 0$<br>$\left ( 3 \right ) \lim_{x \to x_{0} } \frac{f{}’ \left ( x \right ){} }{g{}’ \left ( x \right ) }$ 存在$\left ( 或 \infty \right )$  </p><p>则</p><script type="math/tex; mode=display">\lim_{x \to x_{0} } \frac{f\left ( x \right ) }{g\left ( x \right ) } = \lim_{x \to x_{0} } \frac{f{}' \left ( x \right ){} }{g{}' \left ( x \right ) }</script><p>应用范围：</p><script type="math/tex; mode=display">\begin{array}{c|c|c} \hline \quad 类型\quad&\quad 条件\quad&\quad 转为\frac{0}{0}\quad\\ \hline \\ \quad\frac{\infty}{\infty}\quad&\lim f(x)=\infty,\lim g(x)=\infty\quad&\lim\frac{f(x)}{g(x)}=\lim\frac{1/g(x)}{1/f(x)}\\ \quad 0\cdot\infty\quad&\lim f(x)=0,\lim g(x)=\infty\quad&\lim f(x)g(x)=\lim\frac{f(x)}{1/g(x)}\\ \quad\infty-\infty\quad&\lim f(x)=\infty,\lim g(x)=\infty\quad&\lim[f(x)-g(x)]=\lim\frac{1/g(x)-1/f(x)}{1/[f(x)g(x)]}\\ \quad 0^0\ 或\ \infty^0\quad&\lim f(x)=0\ 或\ \infty,\lim g(x)=0\quad&\lim f(x)^{g(x)}=e^{\lim\frac{g(x)}{1/\ln f(x)}}\\ \quad 1^\infty \quad&\lim f(x)=1,\lim g(x)=\infty\quad&\lim f(x)^{g(x)}=e^{\lim\frac{\ln f(x)}{1/g(x)}}\\ \\ \hline \end{array}</script><p>应该注意的问题：</p><p>使用洛必达法则应该注意的几个问题</p><p>① 使用洛必达法则前，应检验条件是否满足； </p><p>② 使用洛必达法则之后，如果问题仍是未知定型极限，且仍符合洛必达法则条件，可以再次使用洛必达法则；</p><p>③ 如果“$\frac{\infty }{\infty }$ ”型或“$\frac{0}{0}$ ”型极限中的函数含有极限非零的因子，可以单独求极限，不必参与洛必达法则运算，以简化运算； </p><p>④如果能进行等价无穷小量代换或恒等变形配合洛必达法则使用，也可以简化运算.</p><p>如果$f(x)$在$n$阶可导，那么洛必达法则可用到$n-1$阶</p><p>如果$f(x)$在$n$阶连续可导，那么洛必达法则可用到$n$阶</p><p>因为$n$阶可导不能推出$n$阶导函数连续</p><p>求解等价无穷大的时候要考虑分子分母同时除以各项中最高阶的无穷大，可以简化运算</p><p>针对“$\infty—\infty$”型极限，常用的办法有3种：</p><ol><li>通分化为$\frac{0}{0}$（适用于分式差）</li><li>根式有理化(适用于根式差）</li><li>提无穷因子，然后等价代换或变量代换，泰勒公式等</li></ol><hr><h4 id="5-泰勒公式"><a href="#5-泰勒公式" class="headerlink" title="5.泰勒公式"></a>5.泰勒公式</h4><p>带有皮亚诺型余项的泰勒公式：若 $f\left( x \right)$ 在含有 $x_{0}$ 的某个开区间 $(a，b)$ 具有 $n$ 阶导数</p><p>则当属于$(a，b)$时， </p><script type="math/tex; mode=display">\begin{aligned} f(x)=f\left(x_{0}\right)+f^{\prime}\left(x_{0}\right)\left(x-x_{0}\right)+\frac{1}{2 !} f^{\prime \prime}\left(x_{0}\right)\left(x-x_{0}\right)^{2}+\cdots+\frac{1}{n !} f^{(n)}\left(x_{0}\right)\left(x-x_{0}\right)^{n} +o\left(\left|x-x_{0}\right|^{n}\right) \end{aligned}</script><p>特别地，当 $x_{0}=0$时，  </p><script type="math/tex; mode=display">f(x)=f(0)+f^{\prime}(0) x+\frac{1}{2 !} f^{\prime \prime}(0) x^{2}+\cdots+\frac{1}{n !} f^{(n)}(0) x^{n}+o\left(x^{n}\right)</script><p>常见函数的展开式</p><script type="math/tex; mode=display">e^{x}=1+x+\frac{x^{2}}{2 !}+\cdots+\frac{x^{n}}{n !}+o\left(x^{2}\right)</script><script type="math/tex; mode=display">sin x=x-\frac{x^{3}}{3 !}+\frac{x^{5}}{5 !}-\cdots+(-1)^{n} \frac{x^{2 n+1}}{(2 n+1) !}+o\left(x^{2 n+2}\right)</script><script type="math/tex; mode=display">cos x=1-\frac{x^{2}}{2 !}+\frac{x^{4}}{4 !}-\frac{x^{6}}{6 !}+\cdots+(-1)^{n} \frac{x^{2 n}}{(2 n) !}+o\left(x^{2 n}\right)</script><script type="math/tex; mode=display">ln (1+x)=x-\frac{x^{2}}{2}+\frac{x^{3}}{3}-\cdots+(-1)^{n-1} \frac{x^{n}}{n}+o\left(x^{n}\right)</script><script type="math/tex; mode=display">\frac{1}{1-x}=1+x+x^{2}+\cdots+x^{n}+o\left(x^{n}\right)</script><script type="math/tex; mode=display">(1+x)^{m}={\color{red}1+m x+\frac{m(m-1)}{2 !} x^{2}}+\cdots+\frac{m(m-1)\cdots\left( m-n+1 \right)}{n!} x^{n}+o\left(x^{2}\right)</script><hr><h4 id="6-夹逼原理"><a href="#6-夹逼原理" class="headerlink" title="6.夹逼原理"></a>6.夹逼原理</h4><p>(1)若 $x_{n} \leq y_{n} \leq z_{n}$，且 $\lim _{n \rightarrow \infty} x_{n}=\lim _{n \rightarrow \infty} z_{n}=a，则 \lim _{n \rightarrow \infty} y_{n}=a .$ </p><p>(2)若 $f(x) \leq \varphi(x) \leq g(x)，x \in U\left(x_{0}, \delta\right)-\left\{x_{0}\right\}$ ，且 $\lim _{x \rightarrow x_{0}} f(x)=\lim _{x \rightarrow x_{0}} g(x)=A，$ </p><p>则: $\quad \lim _{x \rightarrow x_{0}} \varphi(x)=A$ </p><p>夹逼原理是求解数列极限的一个常用定理</p><p>在求$n$项相加的时候，常用的方法有：</p><ol><li>夹逼原理</li><li>定积分定义</li></ol><p>而在求$n$项连乘的时候，常用的方法有：</p><ol><li>夹逼定理</li><li>取对数化为$n$项相加</li></ol><p>某些$n$项连乘可以主动化简</p><p>比如$(1+x)(1+x^n)···(1+x^{2^n})$形式，如果乘以$\frac{1-x}{1-x}$，分子即可用完全平方式一路化简得出答案</p><p>又比如$cos\frac{x}{2}cos\frac{x}{4}···cos\frac{x}{2^n}$形式，如果乘以$\frac{2^nsin\frac{x}{2^n}}{2^nsin\frac{x}{2^n}}$,分子即可用$sin2x=2cosxsinx$一路化简得出答案</p><hr><h4 id="7-单调有界准则"><a href="#7-单调有界准则" class="headerlink" title="7.单调有界准则"></a>7.单调有界准则</h4><script type="math/tex; mode=display">\left\{\begin{array}{l} 单调性\Leftarrow 1.求导，2.作差，3.作商\\ 有界性\Leftarrow1.放缩，2.借助不等式 \end{array}\right.\Leftarrow数学归纳法</script><p>一般应用在递推关系 $x_1=a，x_{n+1}=f(x_n)(n=1,2,…)$定义的数列</p><p>常用方法：</p><ol><li>先证${x_n}$收敛（单调有界准则），然后等式$x_{n+1}=f(x_n)$两端取极限得$A=f(A)$，由此得极限$A$</li><li>先令$\lim_{x \to \infty}=A$，然后等式$x_{n+1}=f(x_n)$，两端取极限解得$A$，最后再证明$\lim_{x \to \infty}=A$</li></ol><p>前提都需要用到<strong>单调性</strong>的判定</p><p>有三种方法：</p><ol><li>通过$x_{n+1}-x_{n}≥0$来判断</li><li>若$x_{n}$不变号，且$\frac{x_{n+1}}{x_n}≥1$</li><li>若数列由$x_1=a$，$x_{n+1}=f(x_n)$确定<ul><li>若$f(x)$单调增，则当$x_1≤x_2$时，$x_n$单调增，$x_1≥x_2$时，$x_n$单调减</li><li>若$f(x)$单调减，则$x_n$不单调</li></ul></li></ol><p>对于3性质的证明，需要分类讨论：</p><p>如果是$x_1≤x_2$，那么$x_1≤f(x_1)=x_2≤f(x_2)=x_3$，说明$x_n$是单调增加的</p><p>如果是$x_1≥x_2$，那么$x_1≥f(x_1)=x_2≥f(x_2)=x_3$，说明$x_n$是单调减少的</p><p>如果证明出$x_n$单调增加，可以先求出极限，然后通过数学归纳法说明$x_n$有上界</p><p>如果证明出$x_n$单调减少，则$x_1$的值就是极限，或者通过保号性判断$x_1$</p><hr><p>实际上，还可以利用<strong>逐差</strong>的思想来解数列证明题，假设$y_n=x_{n+1}-x_n，x_1=a$，那么</p><script type="math/tex; mode=display">x_n=x_1+(x_2-x_1)+(x_3-x_2+)···(x_n-x_{n-1})=x_1+y_1+y_2+···y_{n-1}</script><p>在$y_n$符合等差数列or等比数列的前提下，可直接求解出$x_n$</p><hr><p>证明常用的不等式：</p><p>$2ab≤a^2+b^2$</p><p>$sinx&lt;x&lt;tanx\qquad (0&lt;x&lt;\frac{\pi}{2})$  </p><p>$\frac{x}{1+x}&lt;ln(1+x)&lt;x$</p><p>$1+x≤e^x$</p><hr><h4 id="8-定积分定义"><a href="#8-定积分定义" class="headerlink" title="8.定积分定义"></a>8.定积分定义</h4><p>基本公式:</p><script type="math/tex; mode=display">\lim _{n \rightarrow \infty} \sum_{i=1}^{n} f\left(\frac{i}{n}\right) \frac{1}{n}=\int_{0}^{1} f(x) d x</script><p>公式的由来: 定积分的定义 $\int_{a}^{b} f(x) d x=\lim _{i \rightarrow 0} \sum_{i=1}^{n} f\left(\xi_{i}\right) \Delta x_{i},$  </p><p>[注] 这里区间是任意的区间. </p><p>$\xi_{i}$取自$x_{i}$和$x_{i-1}$之间.现在我们放低要求， 把整个区间均等分为$\mathrm{n}$个区间， </p><p>区间范围 规定是 $[0,1]$， $\xi_{i}$取自$x_{i}$处，那 么和式极限就可以表示为 </p><script type="math/tex; mode=display">\lim _{n \rightarrow \infty} \sum_{i=1}^{n} f\left(\frac{i}{n}\right) \frac{1}{n}=\int_{0}^{1} f(x) d x</script><p>实际上，在具体的化简过程中，存在有很多技巧，比如可以把同阶的有关$n$的分式提出表达式，还比如在极限中，使用等价无穷小代换等</p><p>也可以遇到不好算的积分，先通过放缩简化多项式，然后再用定义将其化为积分形式</p><hr><h4 id="9-拉格朗日中值定理"><a href="#9-拉格朗日中值定理" class="headerlink" title="9.拉格朗日中值定理"></a>9.拉格朗日中值定理</h4><script type="math/tex; mode=display">f'(\xi)({b-a})={f(b)-f(a)}</script><p>当遇到复合函数求导时，如果b和a之间是等价的，且易确定其中间的值，可用中值定理简化，比如</p><script type="math/tex; mode=display">\lim_{x\to \infty}x^2(arctan\frac{2}{x}-arctan\frac{2}{x+1})</script><p>$\frac{2}{x}$和$\frac{2}{x+1}$在$x\to \infty$是等价的，所以可以用拉格朗日中值定理</p><script type="math/tex; mode=display">\begin{align}\lim_{x\to \infty}x^2(arctan\frac{2}{x}-arctan\frac{2}{x+1})\implies\\\lim_{x\to \infty}x^2\frac{1}{1+\xi^2}(\frac{2}{x}-\frac{2}{x+1})(\xi\to0)\implies\\2\lim_{x\to \infty}x^2\frac{1}{x(x+1)}=2\end{align}</script><p>不仅仅是$arctanf(x)-arctang(x)$形式可以用，$cosf(x)-cosg(x)$，$a^{f(x)}-a^{g(x)}$形式的都可以考虑用</p><p>实际上，在遇到可以把$e^{f(x)}$，$\sqrt{f(x)}$等因子抽出来作为常数以简化运算的时候，常可以利用中值定理解题</p><p>积分中值定理：</p><p>如果函数$f(x)$在积分区间$[a,b]$连续，那么在$[a,b]$上至少存在一点$\xi$​，使下式成立：</p><script type="math/tex; mode=display">\int_a^bf(x)dx=f(\xi)(b-a),\xi\in[a,b]</script><p>可用于简化积分内复杂函数</p><hr><h2 id="函数的连续性"><a href="#函数的连续性" class="headerlink" title="函数的连续性"></a>函数的连续性</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>定义1：设函数$y=f(x)$在$x_0$​点的某一邻域内有定义，令：</p><script type="math/tex; mode=display">\Delta x=x-x_0,\quad \Delta y=f(x_0+\Delta x)-f(x_0)</script><p>如果：</p><script type="math/tex; mode=display">\lim_{\Delta x\to 0}\Delta y=\lim_{\Delta x\to 0}\left[f(x_0+\Delta x)-f(x_0)\right]=0</script><p>那么就称函数$f(x)$在$x_0$点 连续。</p><p>定义2：$\lim_{x\to x_0}f(x)=f(x_0)$，则称$y=f(x)$在点$x_0$处连续</p><p>定义3：$\lim_{x\to x_0^-}f(x)=f(x_0)$，则称$y=f(x)$在点$x_0$处左连续</p><p>​              $\lim_{x\to x_0^+}f(x)=f(x_0)$，则称$y=f(x)$在点$x_0$处右连续</p><p>定理：$f(x)$连续$\iff f(x)$左连续且右连续</p><blockquote><p>如果f(x)是分段函数，且f(x)是“光滑”曲线，那么，f(x)不仅在分段点的左右极限相同，而且在分段点的左右导数也相同</p></blockquote><p>注意：如果$f(x)$在$x_0$处连续，不一定存在$\delta&gt;0$，在$\mathring{U}(x_0,\delta)$内连续</p><p>实际上：连续和可导都是函数在一点的性质</p><hr><h3 id="间断点及其分类"><a href="#间断点及其分类" class="headerlink" title="间断点及其分类"></a>间断点及其分类</h3><p>定义</p><p>若$f(x)$在$x_0$某去心邻域有定义，但在$x_0$处不连续，则称$x_0$为$f(x)$的间断点</p><p>分类</p><p>第一类间断点：左，右极限都存在的点</p><ul><li>可去间断点：左极限=有极限</li><li>跳跃间断点：左极限≠有极限</li></ul><p>第二类间断点：左，右极限中至少有一个不存在</p><ul><li>无穷间断点：在$x_0$附近，某侧函数值趋向于无穷</li><li>震荡间断点：在$x_0$附近，某侧函数值一直变化</li></ul><hr><h3 id="连续性的运算和性质"><a href="#连续性的运算和性质" class="headerlink" title="连续性的运算和性质"></a>连续性的运算和性质</h3><p>定理1：设函数$f(x)$和$g(x)$在$x_0$点连续，则它们的和（差）$f\pm g$、积$f\cdot g$以及商$\frac{f}{g}（g(x_0)\ne 0）$都在$x_0$点连续</p><blockquote><p>但是无法判断不连续函数之间运算的结果，不连续函数相加，相乘的结果都有可能连续</p></blockquote><p>定理2：连续函数的复合仍为连续函数</p><p>定理3：基本初等函数在其定义域是连续的</p><p>定理4：初等函数在其定义区间内是连续的</p><hr><h3 id="闭区间上连续函数的性质"><a href="#闭区间上连续函数的性质" class="headerlink" title="闭区间上连续函数的性质"></a>闭区间上连续函数的性质</h3><p>定理5(有界性定理)：若$f(x)$在$[a,b]$上连续，则$f(x)$在$[a,b]$上有界</p><p>定理6(最值定理)：若$f(x)$在$[a,b]$上连续，则$f(x)$在$[a,b]$上必有最大值和最小值</p><p>定理7(介值定理)：设函数$f(x)$在闭区间$[a,b]$上连续，且在此区间的端点取不同的函数值：</p><script type="math/tex; mode=display">f(a)=A,\quad f(b)=B,\quad A\ne B</script><p>则对于$A$与$B$之间的任意一个数$C$，在开区间$(a,b)$内至少有一点$\xi$使得：</p><script type="math/tex; mode=display">f(\xi)=C,\quad \xi\in(a, b)</script><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220726235510662.png" alt="image-20220726235510662"></p><p>推论: 若$f(x)$在$[a,b]$上连续，则$f(x)$在$[a,b]$上可取到介于它在$[a,b]$上最小值与最小值之间的一切值</p><p>比如$f(a)=A$，$f(b)=B$，那么存在$f(\theta)=\frac{A+B}{2}$</p><p>定理8（零点定理）：设函数$y=f(x)$在闭区间$[a,b]$上连续，且$f(a)$与$f(b)$异号（即$f(a)\cdot f(b) &lt; 0$），则在开区间$(a,b)$内至少有一点$\xi$使得$f(\xi)=0$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220726235439516.png" alt="image-20220726235439516"></p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.660线代</title>
      <link href="/post/60884.html"/>
      <url>/post/60884.html</url>
      
        <content type="html"><![CDATA[<p>行列式的计算：</p><p>279：注意范德蒙特行列式</p><p>286：注意秩为1的行列式的高次幂求法</p><p>287：很经典的题，分块矩阵，然后不同的块用到了不同的性质</p><p>299：等价就是秩相同的意思</p><p>301：线性相关，即不满秩</p><p>306：有多个解，那么就是rank(系数矩阵)=rank(增广矩阵)&lt;n</p><p>307：不能线性表示，说明加上了$B$向量后，维度升高了</p><p>309：$\gamma$向量代表的是任意一个三维空间向量，而向量组不能表示出来说明其秩&lt;3，行列式为0，用算出的结果带入$\beta$，看是否符合要求</p><p>312：$\alpha_1$和$\alpha_2$就是最大线性无关组了，说明$\alpha_1$，$\alpha_2$，$\alpha_3$没有满秩</p><p>314：运用了秩运算的性质，不满秩矩阵×满秩矩阵=不满秩</p><p>316：根据秩零定理，基础解系的秩=列空间的秩-矩阵的秩</p><p>323：特征值同样可以参与多项式运算，如果$A$的特征值是4,3,2，那么$A-E$的特征值就是3,2,1</p><p>324：从定义入手，解$\lambda$和$a$的方程，从而解出了方程</p><p>325：算出特征值，再有$(A-\lambda E)x=0$方程求其基础解系</p><p>326：写出方程组，再将方程组化成$AX=\lambda X$的形式，就可求出特征值</p><p>327：因为是实对称阵，故特征向量两两正交，故可假设出未知的特征向量与已知的特征向量相乘，建立方程组，方程组的基础解系就是未知的特征向量</p><p>328：将特征值带入了方程</p><p>329：相似，说明行列式的值一致，并且特征值也一样</p><p>330：矩阵相似，那么秩也一样，所以可转换为矩阵$B$</p><p>332：矩阵方程可以化成相似对角化的标准形式，故可求出特征值</p><p>333：注意判定矩阵相似的概念</p><p>334：$A(\alpha_1,\alpha_2,\alpha_3)$可以化为$(\alpha_1,\alpha_2,\alpha_3)B$，将$(\alpha_1,\alpha_2,\alpha_3)$看做$P$，则方程化为化为$P^{-1}AP=B$</p><p>则$B$就是$A$的相似矩阵</p><p>335：是经典题，先利用327题正交矩阵的性质，将$\lambda=6$的特征向量求出来，然后对$\alpha_1，\alpha_2$进行施密特正交化，再单位化</p><p>338：注意正定的条件</p><p>340：如果知道了特征向量，可以列方程组来求解未知参数</p><hr><p>349：注意到矩阵运算也可以用三次方公式$x^3-1=(x-1)(x^2+x+1)$</p><p>352：如果要符合交换律，1.两个对角矩阵 2.两个互逆 3.有一个零矩阵 4.伴随矩阵和原矩阵</p><p>357：代数余子式的转置矩阵才是伴随矩阵</p><p>370：注意秩零定理</p><p>373：了解伴随矩阵$A^*$和$A$的秩的关系</p><p>382：升阶时候，信息会保留</p><p>384：两种思路：1. 观察法：ABC选项中的4个向量组，通过加减运算最终都可以化为0，而D不行，2.计算法：写出4阶矩阵的行列式，如果行列式的值≠0，即线性无关，具体做法为：$\alpha_1+\alpha_2$可以写成$(1,1,0,0)^T$，以此类推</p><p>385：用384思路</p><p>387：意思就是$\alpha_1,\alpha_1,\beta_1,\beta_2$的秩只有2</p><p>395：自由元的意思就是去掉自由元所在列后，行列式不能为0的主元</p><p>396：相减之后是$Ax=0$的解，而不是方程的解</p><p>400：如果向量能有基础解系表示出来，自然是解向量了</p><p>403：有非零解的前提是要有解，而有解的前提是先行满秩，而行满秩的前提是$m≤n$</p><p>404：等价，但是向量组的个数不一定是3，需要的是向量组个数相同，且彼此线性无关的向量组</p><p>405：首先可以得知秩为4-2=2，然后根据$A\eta_2=0$，推出$\alpha_2$和$\alpha_4$，线性相关</p><p>409：常规方法是算出A的特征值，再根据特征值算出其特征向量，而在此题并不需要这样做，只需要挨个将特征向量带入，观察$Ax=\lambda x$是否成立即可</p><p>412：无论$\alpha_2$倍乘多少，其$A\alpha_2=\lambda \alpha_2$的等式仍然成立，所以$\lambda$ 仍是其特征值</p><p>413：因为$\alpha_2$和$\alpha_3$是不同特征值的特征向量，那么$\alpha_2+\alpha_3$就不是$A$的特征向量</p><p>414：注意判断矩阵相似化的条件</p><p>417：都带入$A=PBP^{-1}$的形式中尝试，观察是否能符合这个形式</p><p>418：二次型可以不是标准差形式</p><p>419：注意正惯性系数的概念，是指为正数的特征值的个数</p><p>425：注意矩阵合同的概念</p><p>614：两个高次幂矩阵都是初等变换矩阵</p><p>616：有一个＞0的二阶子式，所以不需要对$a$做进一步判定了</p><p>624：基础解系的数量=$n-k$</p><p>628：可以交换，那么假设出该矩阵，然后$AX=XA$，可以得出$X$的形式</p><p>641：主要是关于伴随矩阵的性质</p><p>651：注意自由元的概念</p><p>652：列不满秩才会有非零解</p><p>656：特征值时3,3,0，说明$\alpha_1,\alpha_2$的组合仍然是线性无关的</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.相似矩阵及二次型</title>
      <link href="/post/20957.html"/>
      <url>/post/20957.html</url>
      
        <content type="html"><![CDATA[<h1 id="相似矩阵及二次型"><a href="#相似矩阵及二次型" class="headerlink" title="相似矩阵及二次型"></a>相似矩阵及二次型</h1><h2 id="特征值"><a href="#特征值" class="headerlink" title="特征值"></a>特征值</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>一般情况下，向量经过线性映射后，方向发生改变</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220712200734286.png" alt="image-20220712200734286"></p><p>不过，有可能部分向量，在线性映射后方向没有改变，只是发生了伸缩：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220712220851336.png" alt="image-20220712220851336"></p><p>这些没有发生方向改变的向量，称为特征向量，变换前后的伸缩比称为特征值，其严格定义如下：</p><p>设$A$是$n$阶方阵，$\boldsymbol{x}$为非零向量，若存在数$\lambda$使得下式成立：</p><script type="math/tex; mode=display">A\boldsymbol{x}=\lambda\boldsymbol{x}</script><p>那么将数$\lambda$称为$A$的特征值，非零向量$\boldsymbol{x}$称为$A$的对应于$\lambda$的特征向量。</p><hr><h3 id="单位阵"><a href="#单位阵" class="headerlink" title="单位阵"></a>单位阵</h3><p>对于$n$阶单位阵$I$始终有：</p><script type="math/tex; mode=display">\boldsymbol{I}\boldsymbol{x}=\boldsymbol{x},\quad \boldsymbol{x}\in\mathbb{R}^n</script><p>意味着向量空间$R^n$中所有向量(除了零向量)$x$都是单位阵$I$的特征向量</p><hr><h3 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h3><script type="math/tex; mode=display">A\boldsymbol{x}=\lambda\boldsymbol{x}</script><p>经过转换后：</p><script type="math/tex; mode=display">\begin{align} A\boldsymbol{x}=\lambda\boldsymbol{x} &\iff AI\boldsymbol{x}=\lambda I\boldsymbol{x}\\ &\iff (AI-\lambda I)\boldsymbol{x} = \boldsymbol{0}\\ &\iff (A-\lambda I)\boldsymbol{x} = \boldsymbol{0} \end{align}</script><p>假设存在特征值和特征向量，那么上述方程必然有非零解。因此根据解的个数可知，系数矩阵$A-\lambda I$必然不是满秩矩阵（否则$(A-\lambda I)\boldsymbol{x} = \boldsymbol{0}$只有唯一解，该唯一解就是零向量，根据定义，特征值和特征向量不能是零向量），再结合上满秩与行列式的关系，此时必然有：</p><script type="math/tex; mode=display">|A-\lambda I|=0</script><p>这样就有两个式子了，可以解出要求的两个未知数：</p><script type="math/tex; mode=display">\begin{cases}|A-\lambda I| = 0\\\\ (A-\lambda I)\boldsymbol{x} = \boldsymbol{0} \end{cases}\Longrightarrow \begin{cases}\lambda = ? \\\\ \boldsymbol{x} = ?\end{cases}</script><p>根据二阶行列式的计算方法可以直接算出$\lambda$的值，算出$\lambda$的值后，将$\lambda$带入到$(A-\lambda I)\boldsymbol{x} = 0$,利用求解集的方法，算出$x$的解集，带入不同的$\lambda$即可求出不同的特征向量</p><p>假设解集</p><script type="math/tex; mode=display">\boldsymbol{x}_{\lambda=0}=k\begin{pmatrix}-1\\1\end{pmatrix},k\in\mathbb{R}</script><p>意味着特征值为0对应的特征向量（零向量除外），将它画出来就是下图定义域中的绿线，其上的任意向量都会被映射到零点：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220712224323827.png" alt="image-20220712224323827"></p><p>很显然，图中的绿线是一个向量空间，因为其中都是特征值为 0 的特征向量（零向量除外），所以也称为特征值为 0 的特征空间</p><p>而判定向量$x$是否是矩阵$A$的特征向量的方式很简单，只需要将$Ax$相乘，如果结果可以化成$\lambda x$的形式，就是特征向量</p><p>已知$A$,某个特征向量$x$，可以根据$Ax=\lambda x$求列方程求解$\lambda$，以及$A$中的未知数</p><hr><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ol><li><strong>转置矩阵与原矩阵特征值相同</strong></li><li><strong>行列式的值=特征值的乘积</strong>，所以如果$|A|=0$，那么必有一个特征值为0</li><li><strong>矩阵的特征值等于逆矩阵特征值的倒数</strong></li><li>若$\lambda_1,\lambda_2,\cdots,\lambda_n$为$n$阶方阵$\boldsymbol{\boldsymbol{A}}$的特征值，则：</li></ol><script type="math/tex; mode=display">|\boldsymbol{A}|=\lambda_1\lambda_2\ldots\lambda_n</script><ol><li><p>矩阵的特征值和矩阵对角线元素之和(迹)相同，即：</p><script type="math/tex; mode=display">∑\lambda _i=∑a_{ii}</script><div class="hide-toggle" style="border: 1px solid #66c3ee"><div class="hide-button toggle-title" style="background-color: #66c3ee;color: black"><i class="fas fa-caret-right fa-fw"></i><span>证明过程</span></div>    <div class="hide-content"><p>证明如下：</p><p>$\boldsymbol{A}$的特征值多项式为：</p><script type="math/tex; mode=display">|\boldsymbol{A}-\lambda \boldsymbol{I}|=\begin{vmatrix}a_{11}-\lambda & a_{12} & \cdots & a_{1n}\\a_{21} & a_{22}-\lambda & \cdots & a_{2n}\\\vdots&\vdots&\quad&\vdots\\a_{n1}&a_{n2}&\cdots&a_{nn}-\lambda\end{vmatrix}</script><p>可以观察出，$\lambda^{n-1}$的项只能产生于主对角线的乘积。因为主对角线乘积为：</p><script type="math/tex; mode=display">(a_{11}-\lambda)(a_{22}-\lambda)\cdots (a_{nn}-\lambda)</script><p>根据二项式定理可得$\lambda^{n-1}$的系数为$(a_{11}+a_{22}+\cdots + a_{nn})$</p><p>由于$\lambda_1,\lambda_2,\cdots,\lambda_n$是该矩阵的特征值，所以：</p><script type="math/tex; mode=display">|\boldsymbol{A}-\lambda \boldsymbol{I}|=(\lambda_1-\lambda)(\lambda_2-\lambda)\cdots(\lambda_n-\lambda)</script><p>根据二项式定理可得$\lambda^{n-1}$的系数为$(\lambda_{1}+\lambda_{2}+\cdots + \lambda_{n})$</p><p>$\lambda^{n-1}$的系数必然是相等的，所以：</p><script type="math/tex; mode=display">tr(\boldsymbol{A})=a_{11}+a_{22}+\cdots +a_{nn}=\lambda_1+\lambda_2+\cdots +\lambda_n</script></div></div></li><li><p>根据特征多项式：若$λ$是矩阵$A$的特征值，则$f(λ)$就是多项式矩阵$f(A)$的特征值</p></li></ol><hr><p>定理：</p><p>已知$\lambda_1,\lambda_2,\cdots,\lambda_m$是$n$阶方阵$A$相异的特征值，以及$\boldsymbol{v}_1,\boldsymbol{v}_2,\cdots,\boldsymbol{v}_m$是$\lambda_1,\lambda_2,\cdots,\lambda_m$对应的特征向量，则向量组$\{\boldsymbol{v}_1,\boldsymbol{v}_2,\cdots,\boldsymbol{v}_m\}$线性无关。</p><p>反过来说，如果特征值$\lambda_1$对应了多个特征向量，那么这些特征向量的组合仍然是方阵$A$的特征向量</p><hr><p>如果矩阵A能被拆分成$A=(a-1)E+B$，利用$rank(B)=1$求$B$的特征值和特征向量比较方便</p><blockquote><p><strong>结论：n阶矩阵A，r(A)=1，则A的特征值一个是A的迹（主对角元素和），其余都是0</strong></p></blockquote><p><strong>证0是n-1重特征根：</strong></p><p>因为$r(A)=1$，$A$的行列式为0，又因为行列式等于特征值的乘积，所以0必为$A$特征值</p><p>求0对应的特征向量，$Ax=0x=0$，则求0对应的特征向量即求$Ax=0$的解</p><p>$r(A)=1，Ax=0$必有$n-1$个线性无关解向量，那么0至少为$n-1$重特征根</p><p><strong>证A的迹为一个特征值：</strong></p><p>$r(A)=1$，则$A$必可表示成一个列向量和一个行向量的乘积，设$α$和$β$为列向量 ($T$表示转置)（因为$A$的秩为1，所以α和β不可能为零向量）</p><p>则$A=αβ^T，Aα = αβ^Tα = α(β^Tα) = (β^Tα)α$</p><p>则$β^Tα$是$A$特征值，特征向量为$α$</p><hr><h2 id="相似矩阵"><a href="#相似矩阵" class="headerlink" title="相似矩阵"></a>相似矩阵</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>设$A$，$B$都是$n$阶方阵，若有可逆矩阵$P$，使得</p><script type="math/tex; mode=display">\boldsymbol{B}=\boldsymbol{P}^{-1}\boldsymbol{A}\boldsymbol{P}</script><p>则称$\boldsymbol{P}$为相似变换矩阵，称$\boldsymbol{B}$是$\boldsymbol{A}$​的相似矩阵，记作：</p><script type="math/tex; mode=display">\boldsymbol{A}\simeq \boldsymbol{B}</script><p>单解释下上述定义，如果$\boldsymbol{A}$和$\boldsymbol{B}$是相似矩阵，那么两者实际上是<strong>同一个线性映射在不同基下的代数表示</strong>(需要参考)：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220712174446294.png" alt="image-20220712174446294"></p><p>在自然基下，上述向量的坐标分别是$[\boldsymbol{x}]_\mathcal{E}$和$[\boldsymbol{y}]_\mathcal{E}$，上述线性映射可用矩阵$\boldsymbol{A}$来表示，即有$\boldsymbol{A}[\boldsymbol{x}]_\mathcal{E}=[\boldsymbol{y}]_\mathcal{E}$。或者图示如下：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220712175740663.png" alt="image-20220712175740663"></p><p>或者在基$\mathcal{P}$，上述向量的坐标分别是$[\boldsymbol{x}]_\mathcal{P}$和$[\boldsymbol{y}]_\mathcal{P}$，上述线性映射可用矩阵$\boldsymbol{B}$来表示，即有$\boldsymbol{B}[\boldsymbol{x}]_\mathcal{P}=[\boldsymbol{y}]_\mathcal{P}$。或者图示如下：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220712175934848.png" alt="image-20220712175934848"></p><p>上面的矩阵$A$和矩阵$B$就是同一个线性映射在不同基下的代数表示</p><hr><p>如果存在可逆矩阵$P$,也就是存在过渡矩阵$P$，通过坐标变换公式：</p><script type="math/tex; mode=display">[\boldsymbol{x}]_\mathcal{E}=\boldsymbol{P}[\boldsymbol{x}]_\mathcal{P},\quad [\boldsymbol{y}]_\mathcal{P}=\boldsymbol{P}^{-1}[\boldsymbol{y}]_\mathcal{E}</script><p>那么矩阵$\boldsymbol{A}$和矩阵$\boldsymbol{B}$就可通过过渡矩阵$\boldsymbol{P}$联系起来，此时$\boldsymbol{A}$和$\boldsymbol{B}$就是相似矩阵：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220712180123128.png" alt="image-20220712180123128"></p><p>相似矩阵集合了基变换和坐标变换</p><hr><p><strong>性质</strong></p><p>若$A\simeq B$，则：</p><script type="math/tex; mode=display">A^k\simeq B^k,\quad k\in\mathbb{Z}^+A^\mathrm{T}\simeq B^\mathrm{T}</script><p>若$A\simeq B$，且$A、B$可逆，则：</p><script type="math/tex; mode=display">A^{-1}\simeq B^{-1}A^*\simeq B^*</script><p>若$A\simeq B，B\simeq C$，那么：</p><script type="math/tex; mode=display">A\simeq C</script><hr><h3 id="相似对角化"><a href="#相似对角化" class="headerlink" title="相似对角化"></a>相似对角化</h3><p>当需要算矩阵的高次幂时$A^n$，直接计算会变得非常复杂,但是<strong>对角矩阵的高次幂</strong>就很好算：</p><script type="math/tex; mode=display">\Lambda^n=\begin{pmatrix}a_{11}&0\\0&a_{22}\end{pmatrix}^n=\begin{pmatrix}a_{11}^n&0\\0&a_{22}^n\end{pmatrix}</script><p>而把常规矩阵变为对角矩阵的步骤，叫做<strong>对角化</strong></p><hr><p><strong>条件</strong></p><ol><li>$\Lambda\sim A$，就直接说明了可相似对角化，即有$k$个线性无关的特征向量</li><li>实对称矩阵可相似对角化；</li><li>方阵的$n$个特征值彼此都不相同，也就是都是单根的话，则矩阵可相似对角化，如果有重根，看第三种情况；</li><li>验证$k$重根是不是具备$k$个线性无关的特征向量，也就是看$A-λE$或$λE-A$的秩是否等于$n-k$，若相等，则矩阵可相似对角化，不相等，则不能进行相似对角化。即几何重数＝代数重数才能对角化。单重特征根的几何重数＝代数重数＝1。</li></ol><hr><p><strong>步骤</strong></p><p>如果$n$阶方阵$A$有$n$个线性无关的特征向量$\boldsymbol{p_1},\boldsymbol{p_2},\cdots,\boldsymbol{p_n}$​，那么如下矩阵：</p><script type="math/tex; mode=display">P=(\boldsymbol{p_1},\boldsymbol{p_2},\cdots,\boldsymbol{p_n})</script><p>可以使得：</p><script type="math/tex; mode=display">A=P\Lambda P^{-1}</script><p>其中$\Lambda$为如下对角阵</p><script type="math/tex; mode=display">\Lambda=\left(\begin{array}{llll}\lambda_{1} & & & \\ & \lambda_{2} & & \\ & & \ddots & \\ & & & \lambda_{n}\end{array}\right)</script><p>其中的$\lambda_1,\lambda_2,\cdots,\lambda_n$为特征向量$\boldsymbol{p_1},\boldsymbol{p_2},\cdots,\boldsymbol{p_n}$对应的特征值，该过程称为对角化</p><hr><div class="hide-toggle" style="border: 1px solid #66c3ee"><div class="hide-button toggle-title" style="background-color: #66c3ee;color: black"><i class="fas fa-caret-right fa-fw"></i><span>证明过程</span></div>    <div class="hide-content"><p>具体证明如下：</p><p>已知：</p><script type="math/tex; mode=display">P=(\boldsymbol{p_1},\boldsymbol{p_2},\cdots,\boldsymbol{p_n})</script><p>根据矩阵乘法列观点、矩阵乘法的定义以及特征值和特征向量的定义($AP=\lambda P$)，可得：</p><script type="math/tex; mode=display">\begin{aligned}    AP        &=A(\boldsymbol{p_1},\boldsymbol{p_2},\cdots,\boldsymbol{p_n})=(A\boldsymbol{p_1},A\boldsymbol{p_2},\cdots,A\boldsymbol{p_n})\\\\        &=(\lambda_1\boldsymbol{p_1},\lambda_2\boldsymbol{p_2},\cdots,\lambda_n\boldsymbol{p_n})\\\\        &=(\boldsymbol{p_1},\boldsymbol{p_2},\cdots,\boldsymbol{p_n})\left(\begin{array}{llll}\lambda_{1} & & & \\ & \lambda_{2} & & \\ & & \ddots & \\ & & & \lambda_{n}\end{array}\right)\\\end{aligned}</script><p>令$\Lambda=\left(\begin{array}{llll}\lambda_{1} &amp; &amp; &amp; \\ &amp; \lambda_{2} &amp; &amp; \\ &amp; &amp; \ddots &amp; \\ &amp; &amp; &amp; \lambda_{n}\end{array}\right)$，上式可以改写为：</p><script type="math/tex; mode=display">AP=P\Lambda</script><p>因为特征向量$\boldsymbol{p_1},\boldsymbol{p_2},\cdots,\boldsymbol{p_n}$线性无关，所以$P$是可逆的，因此可以给上式两侧同时右乘逆矩阵$P^{-1}$，得：</p><script type="math/tex; mode=display">A=P\Lambda P^{-1}</script></div></div><p><strong>相似对角化之后，$A^n=P\Lambda^{n}P^{-1}$</strong>，这是一个显然的结论，比如$A^2=(P\Lambda P^{-1})(P\Lambda P^{-1})$，中间可以消掉，所以是$A^2=P\Lambda^{2}P^{-1}$，依次类推，所以可以得出这个结论</p><hr><p>所以具体步骤是</p><ol><li>求出矩阵$A$的特征值和特征向量，如果特征值不等，就可以完成对角化</li><li>根据特征向量构造特征矩阵，对角阵$\Lambda$的对角线元素由$\lambda $构成</li></ol><blockquote><p>对角阵并不唯一，通过$A^n=P\Lambda^{n}P^{-1}$可以轻松求解矩阵高次幂</p></blockquote><hr><h3 id="相似矩阵中的不变量"><a href="#相似矩阵中的不变量" class="headerlink" title="相似矩阵中的不变量"></a>相似矩阵中的不变量</h3><p>如果$A$和$B$是相似矩阵，那么，两者的特征值相同：</p><script type="math/tex; mode=display">A\simeq B\implies A,B的特征值相同</script><div class="hide-toggle" style="border: 1px solid #66c3ee"><div class="hide-button toggle-title" style="background-color: #66c3ee;color: black"><i class="fas fa-caret-right fa-fw"></i><span>证明过程</span></div>    <div class="hide-content"><p>证明如下：</p><p>因为$A$和$B$是相似矩阵，所以有：</p><script type="math/tex; mode=display">B=P^{-1}AP</script><p>那么结合上特征值和特征向量的定义，可以推出：</p><script type="math/tex; mode=display">\begin{aligned}    B\boldsymbol{x}=\lambda\boldsymbol{x}        &\implies P^{-1}AP\boldsymbol{x}=\lambda\boldsymbol{x}\\        &\implies AP\boldsymbol{x}=P\lambda\boldsymbol{x}\\        &\implies A(P\boldsymbol{x})=\lambda(P\boldsymbol{x})\end{aligned}</script><p>令$P\boldsymbol{x}=\boldsymbol{x’}$，可得：</p><script type="math/tex; mode=display">B\boldsymbol{x}=\lambda\boldsymbol{x},\quad A\boldsymbol{x'}=\lambda\boldsymbol{x'}</script></div></div><p>对比可知，$A$和$B$的特征值相同，但特征向量不同。但是：<strong>两个相似矩阵对应于同一个特征值的特征向量的个数是相等的</strong></p><p>那么通过相似矩阵将其变换为基$\mathcal{P}$下的矩阵函数$B=P^{-1}AP$，对该向量的拉伸依然是$\lambda$倍，也就是说特征值保持不变：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220713230650178.png" alt="image-20220713230650178"></p><hr><h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h3><ul><li>如果$A$和$B$是相似矩阵，那么两者的行列式相同：</li></ul><script type="math/tex; mode=display">\boldsymbol{A}\simeq \boldsymbol{B}\implies |\boldsymbol{A}|=|\boldsymbol{B}|</script><div class="hide-toggle" style="border: 1px solid #66c3ee"><div class="hide-button toggle-title" style="background-color: #66c3ee;color: black"><i class="fas fa-caret-right fa-fw"></i><span>证明过程</span></div>    <div class="hide-content"><p>证明如下：</p><p>因为$\boldsymbol{A}$和$\boldsymbol{B}$是相似矩阵，所以有：</p><script type="math/tex; mode=display">\boldsymbol{B}=\boldsymbol{P}^{-1}\boldsymbol{A}\boldsymbol{P}</script><p>两侧取行列式，结合行列式的运算性质$|\boldsymbol{A}\boldsymbol{B}|=|\boldsymbol{A}||\boldsymbol{B}|$以及$|\boldsymbol{P}^{-1}|=\frac{1}{|\boldsymbol{P}|}$，有：</p><script type="math/tex; mode=display">|\boldsymbol{B}|=|\boldsymbol{P}^{-1}\boldsymbol{A}\boldsymbol{P}|=|\boldsymbol{P}^{-1}||\boldsymbol{A}||\boldsymbol{P}|=|\boldsymbol{A}|</script></div></div><p>实际上就是基的变化并不会影响到面积的改变</p><ul><li><p>相似矩阵的迹相同</p></li><li><p>相似矩阵有相同的秩</p></li></ul><hr><p>对于$n$阶方阵$\boldsymbol{A}$，其主对角线（从左上方至右下方的对角线）的元素之和称为迹，记作$tr(\boldsymbol{A})$：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220713231641537.png" alt="image-20220713231641537"></p><p>若$\lambda_1,\lambda_2,\cdots,\lambda_n$为$n$阶方阵$\boldsymbol{\boldsymbol{A}}$的特征值，则：</p><script type="math/tex; mode=display">tr(\boldsymbol{A})=\lambda_{1}+\lambda_{2}+\cdots+\lambda_{n}</script><p>若$\boldsymbol{A}$和$\boldsymbol{B}$是相似矩阵，则两者的迹相同。即：</p><script type="math/tex; mode=display">\boldsymbol{A}\simeq\boldsymbol{B}\implies tr(\boldsymbol{A})=tr(\boldsymbol{B})</script><p>(反过来不一定成立)</p><hr><h3 id="判断矩阵相似"><a href="#判断矩阵相似" class="headerlink" title="判断矩阵相似"></a>判断矩阵相似</h3><ol><li>判定矩阵之迹 (相似矩阵的迹相同)</li><li>判定矩阵之秩（判定行列式是否为0）</li><li>判定特征值（求解特征值，相似矩阵的特征值相同）</li><li>判定对于同一个特征值，特征向量的个数是否相同，比如说特征值是3,2,2，那么特征值3就有两重根，则$\lambda=3$有两个线性无关的特征向量，说明$(\lambda E-A)x=0$有2个线性无关的解，则$Rank(\lambda E-A)=n-2$</li></ol><p>只能符合这4个条件，才能判定是矩阵相似，特征值相同≠相似</p><hr><h2 id="正交基与正交矩阵"><a href="#正交基与正交矩阵" class="headerlink" title="正交基与正交矩阵"></a>正交基与正交矩阵</h2><h3 id="正交基"><a href="#正交基" class="headerlink" title="正交基"></a>正交基</h3><p>已知$\boldsymbol{p}_1,\boldsymbol{p}_2,\cdots,\boldsymbol{p}_r$是向量空间$V$的一个基，如果两两正交，即满足：</p><script type="math/tex; mode=display">\boldsymbol{p}_i\cdot\boldsymbol{p}_j=0,\quad i\ne j</script><p>那么称其为<strong>正交基</strong>，如果还满足长度均为1，即:</p><script type="math/tex; mode=display">\boldsymbol{p}_1\cdot\boldsymbol{p}_1=\boldsymbol{p}_2\cdot\boldsymbol{p}_2=\cdots=\boldsymbol{p}_r\cdot\boldsymbol{p}_r=1</script><p>那么，就称为<strong>标准正交基</strong></p><p>如果基为正交基，那么求其正交基下的坐标就会变得很简单：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220713123053520.png" alt="image-20220713123053520"></p><p>正交基：</p><script type="math/tex; mode=display">\mathcal{M}:\boldsymbol{m_1}=\begin{pmatrix}\displaystyle\frac{1}{2}\\1\end{pmatrix},\quad\boldsymbol{m_2}=\begin{pmatrix}-2\\1\end{pmatrix}</script><p>并且已知向量在自然基下的坐标是$[\boldsymbol{a}]_\mathcal{E}=\begin{pmatrix}1\\2\end{pmatrix}$，求其在正交基下的坐标</p><p>本题当然可以用坐标变换公式求出，但是，因为是正交基下的特性，所以还要更简单的方法</p><p>根据坐标的定义有：</p><script type="math/tex; mode=display">\boldsymbol{a}=\begin{pmatrix}1\\2\end{pmatrix}=k_1\boldsymbol{m_1}+k_2\boldsymbol{m_2}</script><p>而$m_1$和$m_2$都是正交基，所以可以：</p><script type="math/tex; mode=display">\boldsymbol{a}\cdot\boldsymbol{m_1}=(k_1\boldsymbol{m_1}+k_2\boldsymbol{m_2})\cdot\boldsymbol{m_1}=k_1\boldsymbol{m_1}\cdot\boldsymbol{m_1}</script><p>根据上式可推出：</p><script type="math/tex; mode=display">k_1=\frac{\boldsymbol{a}\cdot\boldsymbol{m_1}}{\boldsymbol{m_1}\cdot\boldsymbol{m_1}}=\frac{1\cdot \displaystyle\frac{1}{2}+2\cdot 1}{\displaystyle\frac{1}{2}\cdot\frac{1}{2}+1\cdot 1}=2</script><p>同样的道理，有：</p><script type="math/tex; mode=display">k_2=\frac{\boldsymbol{a}\cdot\boldsymbol{m_2}}{\boldsymbol{m_2}\cdot\boldsymbol{m_2}}=\frac{1\cdot (-2)+2\cdot 1}{(-2)\cdot(-2)+1\cdot 1}=0</script><p>所以可以直接算出，坐标为</p><script type="math/tex; mode=display">[\boldsymbol{a}]_\mathcal{M}=\begin{pmatrix}2\\0\end{pmatrix}</script><hr><h3 id="正交矩阵"><a href="#正交矩阵" class="headerlink" title="正交矩阵"></a>正交矩阵</h3><p>假设$\boldsymbol{p}_1,\boldsymbol{p}_2,\cdots,\boldsymbol{p}_n$是向量空间$\mathbb{R}^n$的一个标准正交基，那么由它们构造的$n$阶方阵$P$也称为正交矩阵（Orthogonal Matrix）：</p><script type="math/tex; mode=display">P=(\boldsymbol{p}_1,\boldsymbol{p_2},\cdots,\boldsymbol{p}_n)</script><p>该方阵$P$必然满足：</p><script type="math/tex; mode=display">P^\mathrm{T}P=P^{-1}P=E</script><p>即$P^\mathrm{T}$就是$P$的逆矩阵。</p><div class="hide-toggle" style="border: 1px solid #66c3ee"><div class="hide-button toggle-title" style="background-color: #66c3ee;color: black"><i class="fas fa-caret-right fa-fw"></i><span>证明过程</span></div>    <div class="hide-content"><p>证明如下：</p><p>根据矩阵乘法的定义有</p><script type="math/tex; mode=display">\begin{aligned}    P^\mathrm{T}P        &=\begin{pmatrix}\boldsymbol{p}_1^\mathrm{T}\\\boldsymbol{p}_2^\mathrm{T} \\ \vdots \\\boldsymbol{p}_n^\mathrm{T}\end{pmatrix}(\boldsymbol{p}_1,\boldsymbol{p}_2\cdots \boldsymbol{p}_n)=\begin{pmatrix}    \boldsymbol{p}_1^\mathrm{T}\boldsymbol{p}_1&\boldsymbol{p}_1^\mathrm{T}\boldsymbol{p}_2&\cdots&\boldsymbol{p}_1^\mathrm{T}\boldsymbol{p}_n\\    \boldsymbol{p}_2^\mathrm{T}\boldsymbol{p}_1&\boldsymbol{p}_2^\mathrm{T}\boldsymbol{p}_2&\cdots&\boldsymbol{p}_2^\mathrm{T}\boldsymbol{p}_n\\    \vdots&\vdots&\ddots&\vdots\\    \boldsymbol{p}_n^\mathrm{T}\boldsymbol{p}_1&\boldsymbol{p}_n^\mathrm{T}\boldsymbol{p}_2&\cdots&\boldsymbol{p}_n^\mathrm{T}\boldsymbol{p}_n\\\end{pmatrix}\end{aligned}</script><p>根据矩阵的转置运算的性质可知，其中$\boldsymbol{p}_i^\mathrm{T}\boldsymbol{p}_j=\boldsymbol{p}_i\cdot\boldsymbol{p}_j$，所以上式可以改写为：</p><script type="math/tex; mode=display">P^\mathrm{T}P=\begin{pmatrix}    \boldsymbol{p}_1\cdot\boldsymbol{p}_1&\boldsymbol{p}_1\cdot\boldsymbol{p}_2&\cdots&\boldsymbol{p}_1\cdot\boldsymbol{p}_n\\    \boldsymbol{p}_2\cdot\boldsymbol{p}_1&\boldsymbol{p}_2\cdot\boldsymbol{p}_2&\cdots&\boldsymbol{p}_2\cdot\boldsymbol{p}_n\\    \vdots&\vdots&\ddots&\vdots\\    \boldsymbol{p}_n\cdot\boldsymbol{p}_1&\boldsymbol{p}_n\cdot\boldsymbol{p}_2&\cdots&\boldsymbol{p}_n\cdot\boldsymbol{p}_n\\\end{pmatrix}</script><p>因为标准正交基满足：</p><script type="math/tex; mode=display">\boldsymbol{p}_i\cdot\boldsymbol{p}_j=\begin{cases}1& &i=j\\0& &i\neq j\end{cases}$​</script><p>所以：</p><script type="math/tex; mode=display">\boldsymbol{P}^\mathrm{T}\boldsymbol{P}=\begin{pmatrix}    \boldsymbol{p}_1\cdot\boldsymbol{p}_1&\boldsymbol{p}_1\cdot\boldsymbol{p}_2&\cdots&\boldsymbol{p}_1\cdot\boldsymbol{p}_n\\    \boldsymbol{p}_2\cdot\boldsymbol{p}_1&\boldsymbol{p}_2\cdot\boldsymbol{p}_2&\cdots&\boldsymbol{p}_1\cdot\boldsymbol{p}_n\\    \vdots&\vdots&\ddots&\vdots\\    \boldsymbol{p}_n\cdot\boldsymbol{p}_1&\boldsymbol{p}_n\cdot\boldsymbol{p}_2&\cdots&\boldsymbol{p}_n\cdot\boldsymbol{p}_n\\\end{pmatrix}=\begin{pmatrix}    1&0&\cdots&0\\    0&1&\cdots&0\\    \vdots&\vdots&\ddots&\vdots\\    0&0&\cdots&1\\\end{pmatrix}=\boldsymbol{E}</script></div></div><hr><h3 id="施密特正交化"><a href="#施密特正交化" class="headerlink" title="施密特正交化"></a>施密特正交化</h3><p><strong>正交矩阵的逆矩阵很容易求出(因为转置矩阵就是其逆矩阵)</strong>，如果在对角化中将用转置矩阵代替逆矩阵，那么可以大大降低对角化的求解难度：</p><script type="math/tex; mode=display">\boldsymbol{A}=\boldsymbol{P}\boldsymbol{\Lambda}\boldsymbol{P}^{-1}=\boldsymbol{P}\boldsymbol{\Lambda}\boldsymbol{P}^{\mathrm{T}}</script><p>而构建正交矩阵的关键在于找到正交基，$R^2$和$R^3$的正交基很好找，就是各自的自然基，但是要寻找$R^3$中的平面的正交基，就需要利用到施密特正交化，此方法简单来说，就是借助该向量空间的一个基$\boldsymbol{x}_1,\boldsymbol{x}_2$，找到同一个向量空间的一个正交基$\boldsymbol{v}_1,\boldsymbol{v}_2：$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220713135242647.png" alt="image-20220713135242647"></p><hr><p>假设在二维空间中找到正交基</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220713194852683.png" alt="image-20220713194852683"></p><p>先确定一个向量作为标准基，比如说$x_1$，再作出$\boldsymbol{x_2}$在$\boldsymbol{v_1}$所在直线的投影向量$\overline{\boldsymbol{x_2}}$，连接$\boldsymbol{x_2}$和$\overline{\boldsymbol{x_2}}$就得到要求的垂线向量$\boldsymbol{v_2}$：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220713195029040.png" alt="image-20220713195029040"></p><p>在这个过程中：</p><script type="math/tex; mode=display">\boldsymbol{v_2}=\boldsymbol{x_2}-\overline{\boldsymbol{x_2}}=\boldsymbol{x_2}-k_1\boldsymbol{v_1}</script><p>因为$\boldsymbol{v_2}$和$\boldsymbol{v_1}$正交，所以：</p><script type="math/tex; mode=display">\begin{aligned}    \boldsymbol{v_2}\cdot\boldsymbol{v_1}=0        &\implies (\boldsymbol{x_2}-k_1\boldsymbol{v_1})\cdot\boldsymbol{v_1}=0\\        &\implies \boldsymbol{x_2}\cdot\boldsymbol{v_1}-k_1\boldsymbol{v_1}\cdot\boldsymbol{v_1}=0\\        &\implies k_1=\frac{\boldsymbol{x_2}\cdot\boldsymbol{v_1}}{\boldsymbol{v_1}\cdot\boldsymbol{v_1}}\end{aligned}</script><p>所以：</p><script type="math/tex; mode=display">\boldsymbol{v_2}=\boldsymbol{x_2}-k_1\boldsymbol{v_1}=\boldsymbol{x_2}-\frac{\boldsymbol{x_2}\cdot\boldsymbol{v_1}}{\boldsymbol{v_1}\cdot\boldsymbol{v_1}}\boldsymbol{v_1}</script><p>这样就得到了一组正交基$\boldsymbol{v}_1,\boldsymbol{v}_2$</p><p>总结如下：</p><script type="math/tex; mode=display">\boldsymbol{x_1},\boldsymbol{x_2} \xrightarrow{\quad\text{施密特正交化}\quad} \begin{cases} \boldsymbol{v_1}=\boldsymbol{x_1}\\ \quad\\ \boldsymbol{v_2}=\boldsymbol{x_2}-\frac{\boldsymbol{x_2}\cdot\boldsymbol{v_1}}{\boldsymbol{v_1}\cdot\boldsymbol{v_1}}\boldsymbol{v_1} \end{cases}</script><hr><p>在三维空间中，就是：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220713195529538.png" alt="image-20220713195529538"></p><p>先将其中两个向量施密特正交化：</p><script type="math/tex; mode=display">\boldsymbol{x_1},\boldsymbol{x_2} \xrightarrow{\quad\text{施密特正交化}\quad} \begin{cases} \boldsymbol{v_1}=\boldsymbol{x_1}\\ \quad\\ \boldsymbol{v_2}=\boldsymbol{x_2}-\frac{\boldsymbol{x_2}\cdot\boldsymbol{v_1}}{\boldsymbol{v_1}\cdot\boldsymbol{v_1}}\boldsymbol{v_1} \end{cases}</script><p>作出$\boldsymbol{x_3}$在$\boldsymbol{v_1},\boldsymbol{v_2}$张成平面上的投影向量$\overline{\boldsymbol{x_3}}$，连接$\boldsymbol{x_3}$和$\overline{\boldsymbol{x_3}}$就得到要求的垂线向量$\boldsymbol{v_3}$：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220713200001940.png" alt="image-20220713200001940"></p><p>求出：</p><script type="math/tex; mode=display">\boldsymbol{v_3}=\boldsymbol{x_3}-\frac{\boldsymbol{x_3}\cdot\boldsymbol{v_1}}{\boldsymbol{v_1}\cdot\boldsymbol{v_1}}\boldsymbol{v_1}-\frac{\boldsymbol{x_3}\cdot\boldsymbol{v_2}}{\boldsymbol{v_2}\cdot\boldsymbol{v_2}}\boldsymbol{v_2}</script><script type="math/tex; mode=display">\boldsymbol{x_1},\boldsymbol{x_2},\boldsymbol{x_3} \xrightarrow{\quad\text{施密特正交化}\quad} \begin{cases} \boldsymbol{v_1}=\boldsymbol{x_1}\\ \quad\\ \boldsymbol{v_2}=\boldsymbol{x_2}-\frac{\boldsymbol{x_2}\cdot\boldsymbol{v_1}}{\boldsymbol{v_1}\cdot\boldsymbol{v_1}}\boldsymbol{v_1}\\ \quad\\ \boldsymbol{v_3}=\boldsymbol{x_3}-\frac{\boldsymbol{x_3}\cdot\boldsymbol{v_1}}{\boldsymbol{v_1}\cdot\boldsymbol{v_1}}\boldsymbol{v_1}-\frac{\boldsymbol{x_3}\cdot\boldsymbol{v_2}}{\boldsymbol{v_2}\cdot\boldsymbol{v_2}}\boldsymbol{v_2} \end{cases}</script><p>这种方法就是<strong>施密特正交法</strong></p><hr><h3 id="正交对角化"><a href="#正交对角化" class="headerlink" title="正交对角化"></a>正交对角化</h3><p>已知<strong>对角化</strong>的过程是：</p><script type="math/tex; mode=display">A=P\Lambda P^{-1}</script><p>需要求逆矩阵，很复杂，而通过<strong>正交矩阵</strong>可以轻松求逆矩阵：</p><script type="math/tex; mode=display">A=P\Lambda P^{\mathrm{-1}}=P\Lambda P^{\mathrm{T}}</script><p>正交基构成了正交矩阵，但是，不是在标准空间里面的话，就需要用<strong>施密特正交化</strong>来求其正交基，继而求得求正交矩阵。</p><p>以上一整个过程叫做<strong>正交对角化</strong></p><hr><h3 id="实对称阵"><a href="#实对称阵" class="headerlink" title="实对称阵"></a>实对称阵</h3><p>如果矩阵$A$是对称阵(即其转置是其本身的矩阵)，且其中的每一个元素都是实数，那么称之为实对称阵。此时有如下性质：</p><p>若$\lambda_1,\lambda_2$是实对称阵$A$<strong>相异</strong>的特征值，$\boldsymbol{p}_1,\boldsymbol{p}_2$是$\lambda_1,\lambda_2$对应的特征向量，则有$\boldsymbol{p}_1$与$\boldsymbol{p}_2$正交，即：</p><script type="math/tex; mode=display">\boldsymbol{p_1}\cdot\boldsymbol{p_2}=0</script><p>根据上述性质就可以找到标准正交基中的第一个向量$\boldsymbol{\epsilon_1}$</p><blockquote><p>并不是所有的矩阵都能完成正交对角化，只有实对称阵才行</p></blockquote><p>找到第一个向量后，根据实对称阵的性质，将其作为基，与其他的特征向量是正交的</p><p>之后用施密特正交化其他的向量，使其正交，再单位化即可</p><hr><p>来道经典例题：</p><p>已知$A$是三阶实对称矩阵，若正交矩阵$Q$使得$Q^{-1}AQ=\begin{pmatrix}3&amp;0&amp;0\\0&amp;3&amp;0\\0&amp;0&amp;6\end{pmatrix}$，如果$a_1=(1,0,-1)^{T},a_2=(0,1,1)^{T}$是矩阵$A$属于特征值$\lambda=3$的特征向量，则$Q$是多少？</p><blockquote><p>如果已知两个特征向量，那么根据实对称矩阵的性质，可以求出第三个特征向量，再拓展一下，即使只知道一个特征向量$a_1$，如果另外两个特征向量对应的特征值相等，那么可以根据$a_2×a_1=0,a_3×a_1=0$，通过基础解系解出$a_2$和$a_3$</p></blockquote><p>解：已知实对称矩阵不同特征值两两正交，所以可以解出$a_3$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220907145641628.png" alt="image-20220907145641628"></p><p>因为$a_1,a_2$不正交，所以要用施密特正交化处理</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220907145733852.png" alt="image-20220907145733852"></p><p>将处理后的向量单位化</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220907145747477.png" alt="image-20220907145747477"></p><p>组合起来即是$Q$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220907145820668.png" alt="image-20220907145820668"></p><hr><p>正交变换中求正交矩阵的方法一共有2种，如下：</p><ol><li>利用特征值算出特征向量，如果特征值各不相同，只需要将各个特征向量单位化，组成的矩阵即是正交矩阵，如果特征值有相同的，则需要进行施密特正交化，然后再组成正交矩阵</li><li>直接利用拉格朗日配方法，写出$x$到$y$的变化的关系式，可以根据$x$到$y$的关系的相关系数，直接得到正交矩阵</li></ol><hr><h2 id="二次型"><a href="#二次型" class="headerlink" title="二次型"></a>二次型</h2><p>在数学中，关于一些变量的二次齐次多项式被称为二次型（Quadratic form）</p><script type="math/tex; mode=display">3x_1^2-7x_2^2,\quad 3x_1^2+2x_2^2+4x_1x_2,\quad x_1^2+4x_3^2+x_1x_2</script><p>$f$是一个定义在$\mathbb{R}^n$上的二次型，它可改写为：</p><script type="math/tex; mode=display">f=\boldsymbol{x}^T\boldsymbol{A}\boldsymbol{x}</script><p>其中$\boldsymbol{A}$是$n\times n$的对称阵，该矩阵$\boldsymbol{A}$称为$f$的二次型矩阵</p><hr><h3 id="二次型到矩阵"><a href="#二次型到矩阵" class="headerlink" title="二次型到矩阵"></a>二次型到矩阵</h3><p>判断矩阵的大小，应该为$n$阶方阵，$n$为变量的个数</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220713234716556.png" alt="image-20220713234716556"></p><p>将二次型的平方项保留，交叉项平分</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220713234800228.png" alt="image-20220713234800228"></p><p>平方项的系数自然是对角线上的数，而交叉项的系数是根据其下标交叉的值</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220713234936035.png" alt="image-20220713234936035"></p><p>剩下的位置置0</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220713234955663.png" alt="image-20220713234955663"></p><p>这样就完成了从二次型到矩阵，而从矩阵到二次型，只需要将过程反过来就行了</p><hr><h3 id="合同矩阵"><a href="#合同矩阵" class="headerlink" title="合同矩阵"></a>合同矩阵</h3><p>定义 ：设$\boldsymbol{A}和\boldsymbol{B}$是$n$阶方阵，若有可逆矩阵$\boldsymbol{P}$，使$\boldsymbol{B}=\boldsymbol{P}^\mathrm{T}\boldsymbol{A}\boldsymbol{P}$，则称矩阵$\boldsymbol{A}$和$\boldsymbol{B}$合同，或者称$\boldsymbol{B}$是$\boldsymbol{A}$的合同矩阵</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220714002513746.png" alt="image-20220714002513746"></p><p>合同矩阵适用于曲线的旋转，符合转置矩阵的意义</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220714002852981.png" alt="image-20220714002852981"></p><p>本题可通过三个步骤完成：</p><p>（1）将椭圆改写为$[\boldsymbol{x}]_\mathcal{E}^\mathrm{T}\boldsymbol{A}[\boldsymbol{x}]_\mathcal{E}=1$，得到其在自然基$\mathcal{E}$下的方程；</p><p>（2）利用合同矩阵，得到基$\mathcal{P}$下的椭圆方程$[\boldsymbol{x}]_\mathcal{P}^\mathrm{T}\boldsymbol{B}[\boldsymbol{x}]_\mathcal{P}=1；$</p><p>（3）将基$\mathcal{P}$下的方程$[\boldsymbol{x}]_\mathcal{P}^\mathrm{T}\boldsymbol{B}[\boldsymbol{x}]_\mathcal{P}=1$写回一般形式即可。</p><p><strong>条件</strong></p><p>矩阵合同的条件是：两个矩阵的正，负惯性系数相同</p><p>如果$A$是实对称矩阵，那么和$A$合同的矩阵也是实对称矩阵</p><hr><h3 id="标准形和合同对角化"><a href="#标准形和合同对角化" class="headerlink" title="标准形和合同对角化"></a>标准形和合同对角化</h3><p>判断二次型的曲线类型，可以通过合同对角化判断</p><p><strong>标准形</strong>：只含平方项的二次型</p><script type="math/tex; mode=display">k_1x_1^2+k_2x_2^2+\cdots+k_nx_n^2</script><p>称为二次型的标准形，或者简称为标准形。其二次型矩阵一定为$n$阶对角阵：</p><script type="math/tex; mode=display">\boldsymbol{\Lambda}=\begin{pmatrix}    k_1&0&\cdots&0\\    0&k_2&\cdots&0\\    \vdots&\vdots&\ddots&\vdots\\    0&0&\cdots&k_n\end{pmatrix}</script><p>合同矩阵只是对二次型进行坐标变换，并不会改变曲线类型，所以可借助合同矩阵来去掉交叉项。过程如下：</p><script type="math/tex; mode=display">x_1x_2=1\xrightarrow{\quad 改写 \quad}\boldsymbol{x}^\mathrm{T}\boldsymbol{A}\boldsymbol{x}=1\xrightarrow{\quad合同矩阵\quad}\boldsymbol{A}=\boldsymbol{P}^\mathrm{T}\boldsymbol{\Lambda}\boldsymbol{P}\xrightarrow{\quad去除交叉项\quad}\boldsymbol{y}^\mathrm{T}\boldsymbol{\Lambda}\boldsymbol{y}=1</script><p>比如判断$x_1x_2=1$的曲线类型：</p><p><strong>改写</strong>。根据二次型矩阵的构造方法，方程$x_1x_2=1$中的$x_1x_2$对应的二次型矩阵为：</p><script type="math/tex; mode=display">\boldsymbol{A}=\begin{pmatrix}0&\displaystyle\frac{1}{2}\\\displaystyle\frac{1}{2}&0\end{pmatrix}</script><p>令$\boldsymbol{x}=\begin{pmatrix}x_1\\x_2\end{pmatrix}$，那么方程$x_1x_2=1$可改写为：</p><script type="math/tex; mode=display">x_1x_2=\begin{pmatrix}x_1&x_2\end{pmatrix}\begin{pmatrix}0&\displaystyle\frac{1}{2}\\\displaystyle\frac{1}{2}&0\end{pmatrix}\begin{pmatrix}x_1\\x_2\end{pmatrix}=\boldsymbol{x}^\mathrm{T}\boldsymbol{A}\boldsymbol{x}=1</script><p><strong>通过合同矩阵，将$\boldsymbol{A}$化为对角阵$\boldsymbol{\Lambda}$</strong>。该二次型矩阵$\boldsymbol{A}$是实对称阵，所以必然可正交对角化，从而得到$\boldsymbol{A}$的合同矩阵$\boldsymbol{\Lambda}$：</p><script type="math/tex; mode=display">\begin{aligned}    \boldsymbol{A}        &=\begin{pmatrix}0&\displaystyle\frac{1}{2}\\\displaystyle\frac{1}{2}&0\end{pmatrix}=\boldsymbol{P}\boldsymbol{\Lambda}\boldsymbol{P}^{-1}=\boldsymbol{P}\boldsymbol{\Lambda}\boldsymbol{P}^\mathrm{T}\\        &=\begin{pmatrix}\displaystyle\frac{\sqrt{2}}{2}&-\displaystyle\frac{\sqrt{2}}{2}\\\displaystyle\frac{\sqrt{2}}{2}&\displaystyle\frac{\sqrt{2}}{2}\end{pmatrix}\begin{pmatrix}\displaystyle\frac{1}{2}&0\\0&-\displaystyle\frac{1}{2}\end{pmatrix}\begin{pmatrix}\displaystyle\frac{\sqrt{2}}{2}&\displaystyle\frac{\sqrt{2}}{2}\\-\displaystyle\frac{\sqrt{2}}{2}&\displaystyle\frac{\sqrt{2}}{2}\end{pmatrix}\end{aligned}</script><p>其中$\boldsymbol{P}=\begin{pmatrix}\displaystyle\frac{\sqrt{2}}{2}&amp;-\displaystyle\frac{\sqrt{2}}{2}\\\displaystyle\frac{\sqrt{2}}{2}&amp;\displaystyle\frac{\sqrt{2}}{2}\end{pmatrix}$是正交矩阵，有$\boldsymbol{P}^{-1}=\boldsymbol{P}^\mathrm{T}。$</p><p><strong>去除交叉项</strong>。因为$\boldsymbol{A}=\boldsymbol{P}\boldsymbol{\Lambda}\boldsymbol{P}^\mathrm{T}$，所以：</p><script type="math/tex; mode=display">\boldsymbol{x}^\mathrm{T}\boldsymbol{A}\boldsymbol{x}=   \boldsymbol{x}^\mathrm{T}\boldsymbol{P}\boldsymbol{\Lambda}\boldsymbol{P}^\mathrm{T}\boldsymbol{x}=(\boldsymbol{P}^\mathrm{T}\boldsymbol{x})^\mathrm{T}\boldsymbol{\Lambda}(\boldsymbol{P}^\mathrm{T}\boldsymbol{x})</script><p>令$\boldsymbol{y}=\boldsymbol{P^\mathrm{T}}\boldsymbol{x}=\begin{pmatrix}y_1\\y_2\end{pmatrix}$，则：</p><script type="math/tex; mode=display">(\boldsymbol{P}^\mathrm{T}\boldsymbol{x})^\mathrm{T}\boldsymbol{\Lambda}(\boldsymbol{P}^\mathrm{T}\boldsymbol{x})=1\implies \boldsymbol{y}^\mathrm{T}\boldsymbol{\Lambda}\boldsymbol{y}=1\implies \frac{1}{2}y_1^2-\frac{1}{2}y_2^2=1</script><p>因为是$x_1x_2=1$通过合同矩阵得到的去除交叉项后的$\frac{1}{2}y_1^2-\frac{1}{2}y_2^2=1$，所以两者对应的其实是同一个曲线，曲线类型没有发生变化。$\frac{1}{2}y_1^2-\frac{1}{2}y_2^2=1$的系数为一正一负，所以是双曲线，从而$x_1x_2=1$是双曲线。</p><p>这种方法叫做<strong>正交合同对角化</strong></p><p>实际上，其实对于任意的二次型, 为求得其标准型, 我们所需要做的就是求得<strong>二次型矩阵的特征值</strong>，并不需要求其正交矩阵</p><blockquote><p>由于对角阵并不唯一，所以标准型也不唯一，但是标准型的正，负惯性系数肯定是<strong>相同</strong>的</p></blockquote><hr><h3 id="拉格朗日配方法"><a href="#拉格朗日配方法" class="headerlink" title="拉格朗日配方法"></a>拉格朗日配方法</h3><p>具体步骤为：</p><ol><li><p>遇到二次型中的平方项$x_i^2$，就把含有$x_i$的项集中起来，然后配方；</p></li><li><p>遇到$x_ix_j$，且没有平方项$x_i^2或x_j^2$，则进行函数换元：</p></li></ol><script type="math/tex; mode=display">\begin{cases}x_i=y_i+y_j\\x_j=y_i-y_j\\x_k=y_k(k=1,2,\cdots,n,\quad k\neq i,j)\end{cases}</script><p>上述操作会产生平方项，再回到（1）去尝试配方；</p><p>不断重复（1）、（2），直至消去所有的交叉项。</p><p>例 请通过拉格朗日配方法来判断$x_1x_2=1$的曲线类型。<br>解 （1）完成拉格朗日配方法。首先对$x_1x_2$进行函数换元：</p><script type="math/tex; mode=display">\begin{cases}    x_1=y_1+y_2\\    x_2=y_1-y_2\end{cases}</script><p>则：</p><script type="math/tex; mode=display">x_1x_2=(y_1+y_2)(y_1-y_2)=y_1^2-y_2^2</script><p>这样就得到了$x_1x_2$的不同的标准形</p><script type="math/tex; mode=display">x_1x_2\quad\xrightarrow{\quad\large 拉格朗日配方法\quad}y_1^2-y_2^2</script><blockquote><p>只能适用于<strong>实对称矩阵的的秩为满秩的情况</strong>，拉格朗日正交法的本质是坐标变换，如果矩阵不满秩，自然不能进行坐标变换</p></blockquote><p>可以通过配方法来快速求出合同矩阵$P$​，比如二次型$2x_1x_3+x_2^2$​，令</p><script type="math/tex; mode=display">\begin{cases}    x_1=y_1+y_3\\    x_2=y_2\\    x_3=y_1-y_3\end{cases}</script><p>可以拆成是$2y_1+y_3(y_1-y_3)+y_2^2=2y_1^2+y_2^2-2y_3^2$，化为标准型，根据$x=Cy$，可以得出$C$的形式</p><script type="math/tex; mode=display">\begin{pmatrix}1&0&1\\0&1&0\\1&0&-1\end{pmatrix}</script><p>当然这个矩阵不唯一</p><hr><h3 id="惯性定理"><a href="#惯性定理" class="headerlink" title="惯性定理"></a>惯性定理</h3><p>对于某二次型$f$，通过合同对角化可化为多个标准形。这些标准形共同的特点为，其正系数的数目（也称为<strong>正惯性指数</strong>）、负系数的数目（也称为负惯性指数）以及 0 系数的数目都相同。该定理称为西尔维斯特惯性定理，简称<strong>惯性定理</strong>。</p><p>设二次型$f(\boldsymbol{x})=\boldsymbol{x}^TA\boldsymbol{x}$，则它是：</p><ul><li>正定的，如果对所有$\boldsymbol{x}\neq \boldsymbol{0}$，有$f(\boldsymbol{x}) &gt; 0$</li><li>半正定的，如果始终有$f(\boldsymbol{x}) \geq 0$</li><li>负定的，如果对所有$\boldsymbol{x}\neq \boldsymbol{0}$，有$f(\boldsymbol{x}) &lt; 0$</li><li>半负定的，如果始终有$f(\boldsymbol{x}) \leq 0$</li><li>不定的，如果$f(\boldsymbol{x})$既有正值又有负值</li></ul><p>判断<strong>正定矩阵</strong>的方法：</p><p>已知二次型$f(\boldsymbol{x})=\boldsymbol{x}^T\boldsymbol{A}\boldsymbol{x}$，其为正定的充分必要条件是，$\boldsymbol{A}$的各阶顺序主子式都为正，等同于正惯性系数$p=n$，即：</p><script type="math/tex; mode=display">a_{11} > 0,\quad \begin{vmatrix}a_{11}&a_{12}\\a_{21}&a_{22}\end{vmatrix} > 0,\cdots,    \begin{vmatrix}a_{11}&\cdots&a_{1n}\\    \vdots&&\vdots\\a_{n1}&\cdots&a_{nn}\end{vmatrix} > 0</script><p>为负定的充分必要条件是，奇数阶顺序主子式为负，而偶数阶顺序主子式为正，即:</p><script type="math/tex; mode=display">(-1)^r\begin{vmatrix}a_{11}&\cdots&a_{1r}\\    \vdots&\quad&\vdots\\a_{r1}&\cdots&a_{rr}\end{vmatrix} > 0    \quad (r=1,2,\cdots,n)</script><p>这个定理称为赫尔维茨定理</p><p>正定的<strong>必要条件</strong>：$a_{ii}&gt;0$，特征值都＞0</p><hr><p>求正惯性系数的方法：</p><p>方法1：对应的对称矩阵的<strong>正特征值</strong>的个数(重根算一个)</p><p>方法2：将二次型通过拉格朗日配方法转换为标准形</p><p>正惯性系数+负惯性系数=矩阵的秩</p><hr><p>设$x=(x_1,x_2,x_3)^T$，求$x^Tx=1$时，$x^TAx$的最大值</p><p>在已知$A$特征值的情况下，存在正交矩阵$P$,经正交变换$x=Py$化二次型$x^TAx$​为标准型</p><script type="math/tex; mode=display">y^Ty=y^TP^TPy=(Py)^T(Py)=x^Tx=1</script><script type="math/tex; mode=display">x^TAx=\lambda_1 y_1^2+\lambda _2y_2^2+\lambda _3y_3^2≤max[\lambda_1,\lambda_2,\lambda_3](y_1^2+y_2^2+y_3^2)=max[\lambda_1,\lambda_2,\lambda_3]</script><p>$(y_1^2+y_2^2+y_3^2)=1$因为模长为1，结论很好理解，因为$(y_1^2+y_2^2+y_3^2)=1$，所以让$max[\lambda]$之后的那个$y=1$即是最大值 </p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.线性方程的解</title>
      <link href="/post/5216.html"/>
      <url>/post/5216.html</url>
      
        <content type="html"><![CDATA[<h1 id="线性方程组的解"><a href="#线性方程组的解" class="headerlink" title="线性方程组的解"></a>线性方程组的解</h1><p>讨论线性方程组的解，主要讨论以下三点：</p><ul><li>解的存在性：在$Ax=b$中，是否有$x$与$b$对应</li><li>解的个数：在$Ax=b$中，有多少个$x$与$b$对应</li><li>解集：在$Ax=b$中，具体是$x$与$b$相对应</li></ul><hr><p>实际上，在矩阵函数的映射中，已经得出了结论了</p><div class="table-container"><table><thead><tr><th>单射（列）</th><th>满射（行）</th><th>结果</th></tr></thead><tbody><tr><td>√</td><td>√</td><td>必有解，且为唯一解</td></tr><tr><td>√</td><td>×</td><td>有可能有解，有可能无解，若有解，必为唯一解</td></tr><tr><td>×</td><td>√</td><td>必然有解，解必然不唯一</td></tr><tr><td>×</td><td>×</td><td>只有非零解</td></tr></tbody></table></div><p>针对齐次方程$Ax=O$，还有如下结论</p><div class="table-container"><table><thead><tr><th>单射（列）</th><th>满射（行）</th><th>结果</th></tr></thead><tbody><tr><td>√</td><td>√</td><td>必有解，且为唯一解</td></tr><tr><td>√</td><td>×</td><td>只有零解</td></tr><tr><td>×</td><td>√</td><td>必然有解，解必然不唯一</td></tr><tr><td>×</td><td>×</td><td>只有非零解</td></tr></tbody></table></div><p>但是只是部分条件，因为很多结论只是充分条件罢了</p><p>比如说行满秩(满射)可以推出必然有解，但是必然有解的情况，并不能推出行满秩</p><p>所以还需要进一步讨论线程方程组的解</p><hr><p>对于线性方程组$Ax=b$，它的增广矩阵为$B=(A|b)$，如果$A$为$m×n$的矩阵那么：</p><ul><li>有唯一解，当且仅当$rank(A)=rank(B)=n$</li><li>有无数解，当且仅当$rank(A)=rank(B)&lt;n$</li><li>无解，当且仅当$rank(A)&lt;rank(B)$</li></ul><blockquote><p>简洁的结论，如果增广矩阵的秩比系数矩阵的大，只能说明结果向量和系数矩阵线性不相关，当然无解</p></blockquote><hr><h2 id="方程组的解集-基础解系"><a href="#方程组的解集-基础解系" class="headerlink" title="方程组的解集(基础解系)"></a>方程组的解集(基础解系)</h2><p>对于线性方程组$Ax=b$而言：</p><ul><li>$b=0$时，即$Ax=0$时，称为齐次线性方程组</li><li>$b≠0$时，称为非齐次线性方程组</li></ul><p>求解集的步骤一般是：</p><ol><li><p>先写出线性方程组的增广矩阵</p><script type="math/tex; mode=display">\boldsymbol{B}=(\boldsymbol{A}\ |\ \boldsymbol{0})= \left( {\begin{array}{c|c} \begin{matrix} 1 & 1 \\ 1 & 1 \\ \end{matrix}& \begin{matrix} 0 \\ 0 \\ \end{matrix} \end{array}} \right)</script></li><li><p>变换为行最简形矩阵(<strong>关键</strong>)</p><script type="math/tex; mode=display">\left( {\begin{array}{c|c} \begin{matrix} 1 & 1 \\ 1 & 1 \\ \end{matrix}& \begin{matrix} 0 \\ 0 \\ \end{matrix} \end{array}} \right) \xrightarrow{\quad \boldsymbol{r}_2'=\boldsymbol{r}_2-\boldsymbol{r}_1\quad} \left( {\begin{array}{c|c} \begin{matrix} 1 & 1 \\ 0 & 0 \\ \end{matrix}& \begin{matrix} 0 \\ 0 \\ \end{matrix} \end{array}} \right)</script><p>可以通过观察行最简形矩阵，其中<strong>缺失的主元的系数</strong>会当做解(如该矩阵缺失了$x_2$做主元)</p></li><li><p>将解集改写为向量空间的形式</p><p>具体操作为：在方程组中移项，保证行最简形矩阵中的主元在最左边</p><script type="math/tex; mode=display">\left( {\begin{array}{c|c} \begin{matrix} 1 & 1 \\ 0 & 0 \\ \end{matrix}& \begin{matrix} 0 \\ 0 \\ \end{matrix} \end{array}} \right) \implies \begin{cases} x_1+x_2=0\\ 0+0=0 \end{cases}</script><script type="math/tex; mode=display">\begin{cases}x_1+x_2=0\\0+0=0\end{cases}\implies\begin{cases}x_1=-x_2\\0+0=0\end{cases}\implies\begin{cases}x_1=-x_2\\x_2=x_2\end{cases} \implies \begin{pmatrix}x_1\\x_2\end{pmatrix}=\begin{pmatrix}-x_2\\x_2\end{pmatrix}</script></li></ol><p>进一步改写为</p><script type="math/tex; mode=display">\begin{pmatrix}x_1\\x_2\end{pmatrix}=\begin{pmatrix}-x_2\\x_2\end{pmatrix}\implies\boldsymbol{x}=\begin{pmatrix}-x_2\\x_2\end{pmatrix}=x_2\begin{pmatrix}-1\\1\end{pmatrix}</script><p>用$k$代替$x_2$:</p><script type="math/tex; mode=display">\boldsymbol{x}=x_2\begin{pmatrix}-1\\1\end{pmatrix}\xrightarrow{\quad x_2\to k\quad}\boldsymbol{x}=k\begin{pmatrix}-1\\1\end{pmatrix}</script><p>解集为：</p><script type="math/tex; mode=display">\boldsymbol{x}=k\begin{pmatrix}-1\\1\end{pmatrix},\quad k\in\mathbb{R}</script><p>如果方程组是$AB=O$，且$B$和$A$是同阶矩阵的时候，$B$的每一列都是$AB=O$的解，所以要写成是$\begin{pmatrix}-k_1&amp;-k_2\\k_1&amp;k_2\end{pmatrix}$的矩阵形式了</p><p>如果是$BA=O$，已知$A$的值的话，就有通过$(BA)^T=O\implies A^T B^T=O$，来求出$B$，$B$的每一行都是$BA=O$的解</p><p>当然，以上结论也可以推导至$AX=B$的情形上，如果$X$只是列向量，只需要加上特解即可，如果$B$是另一个矩阵的话，就要需要列$(A|B)$的形式，根据求基础解系的方法，分别求出每一列对应的特解，然后合并成一个矩阵，即为$X$</p><p>AX=B情况下，如果是$r(A)=r(B)=n$，即唯一解的情况，即齐次解只能为0，变换后的特解就是方程的解了，无需加上$k$</p><hr><p>齐次线性方程组$Ax=0$的解集也称为零空间，记为$null(A)$，这是因为：</p><ul><li>$null(A)$齐次线性方程组$Ax=0$的解集</li><li>$null(A)$一定是向量空间</li></ul><p>而如果是非齐次线性方程$Ax=b$的解集为：</p><script type="math/tex; mode=display">\boldsymbol{x}=\boldsymbol{p}+null(\boldsymbol{A})</script><p>其中$p$为$Ax=b$的一个解，因为出现在解集中，所以是一个特殊的解，也称为特解</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220710222602054.png" alt="image-20220710222602054"></p><p>若两个方程组同解，说明将$A$的解集带入$B$中也完全成立，反之也成立</p><hr><p>特解实际上只是一个能让方程成立的解，如果$Aa_1=Aa_2=b$，那么$\frac{a_1+a_2}{2}$肯定是其特解，需要根据题目条件灵活求其特解</p><p>若只有基础解系，求矩阵的<strong>最大无关组</strong>时，需要先根据基础解系列出各个向量的关系，若题目说某两个向量构成了极大无关组，则假设$\alpha _1=k\alpha_2$，先带入基础解系，然后再带入矩阵里面，观察矩阵的秩是否满足条件</p><hr><h2 id="秩零定理"><a href="#秩零定理" class="headerlink" title="秩零定理"></a>秩零定理</h2><p>在之前的矩阵的秩有结论：值域的维度 $≤$ 定义域的维度</p><p>比如对于矩阵$\boldsymbol{A}=\begin{pmatrix}1&amp;1\\1&amp;1\end{pmatrix}$，其对应的函数矩阵如下：</p><script type="math/tex; mode=display">\begin{array}{c|c|c|c} \hline \quad自然定义域\quad&\quad 映射法则 \quad&\quad 值域维度 \quad&\quad 到达域 \quad\\\hline\\ \quad \mathbb{R}^2 \quad&\quad \boldsymbol{A} \quad&\quad rank(\boldsymbol{A})=1 \quad&\quad \mathbb{R}^2 \quad\\ \\ \hline \end{array}</script><p>其值域的维度就小于定义域的维度</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220710223945566.png" alt="image-20220710223945566"></p><p>而该矩阵表示的齐次线性方程组的零空间$null(A)$，为定义域中的一条直线，被映射到值域中的0</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220710224211458.png" alt="image-20220710224211458"></p><p>由解集的结构可知，与零空间平行的直线都会被映射为值域中的一个点</p><p>所有的直线都被缩为了点，所以导致定义域的维度缩小了一维，最终得到值域的维度为 1。用代数式表示就是：</p><script type="math/tex; mode=display">\underbrace{rank(定义域)}_{\large 定义域的维度}-\underbrace{rank\Big(null(\boldsymbol{A})\Big)}_{\large 零空间的维度}=\underbrace{rank(\boldsymbol{A})}_{\large 值域的维度}\implies 2-1=1</script><p>这个结论可以推广开，即秩零定理：</p><p>对于$m×n$矩阵$A$，那么有：</p><script type="math/tex; mode=display">rank(\boldsymbol{A})+rank(null(\boldsymbol{A}))=n</script><p>该定理说明矩阵的秩加上零空间的秩为定值$n$，所以该定理称为秩零定理</p><blockquote><p>秩零定理显然和秩的性质：$AB=O,rank(A)+rank(B)≤n$ 一致，由秩零可以知道零空间的维度肯定是$n-r$，但是组成零空间的是$k×\alpha_1$形式的解集，当$k=0$时，显然$rank(B)$的维度就下降了。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.向量</title>
      <link href="/post/30596.html"/>
      <url>/post/30596.html</url>
      
        <content type="html"><![CDATA[<h1 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>$n$个有序的数所组成的数组称为$n$维向量，这$n$个数称为该向量的$n$个分量，第$i$个数$a_i$称为第$i$个分量。$n$维向量可写成一列，或一行，分别称为列向量和行向量</p><ul><li><p>$n$维列向量</p><script type="math/tex; mode=display">\begin{pmatrix}a_1\\a_2\\\vdots\\a_n\end{pmatrix}</script></li><li><p>$n$维行向量</p><script type="math/tex; mode=display">(a_1,a_2,...,a_n)\quad 或\quad \begin{pmatrix}a_1&a_2&\cdots&a_n\end{pmatrix}</script></li></ul><p>$n$也称为该向量的维数</p><hr><h2 id="几何意义"><a href="#几何意义" class="headerlink" title="几何意义"></a>几何意义</h2><p>对于2维向量$\boldsymbol{u}=\begin{pmatrix}u_1\\u_2\end{pmatrix}$，其实就是直角坐标系中的一个点，也可以认为是原点指向$\boldsymbol{u}=\begin{pmatrix}u_1\\u_2\end{pmatrix}$的有向线段</p><div class="table-container"><table><thead><tr><th><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/456.svg" alt=""></th><th><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/3.svg" alt="img"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>对于3维向量，即是三维空间里面的一个点，或是原点指向它的有向线段，几何意义是等价的</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220906182030512.png" alt="image-20220906182030512"></p><p>当然，这一概念可以扩展到$n$维空间中去</p><p>如果两个向量的维数相同，且各个分量相等，那么这两个向量相等</p><script type="math/tex; mode=display">\begin{pmatrix}1\\2\end{pmatrix}=\begin{pmatrix}1\\2\end{pmatrix},\quad\begin{pmatrix}1\\2\end{pmatrix}\ne\begin{pmatrix}2\\4\end{pmatrix}</script><hr><h2 id="长度和方向"><a href="#长度和方向" class="headerlink" title="长度和方向"></a>长度和方向</h2><p>向量$u$的长度可以记作$||u||$，其方向可通过角度来表示</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/1.svg" alt="img"></p><p>根据向量的长度以及角度不同，还有如下定义：</p><ul><li>平行：方向相同或相反的两个向量称为平行，或者说两向量的夹角为$0$或$\pi$</li><li>正交：互相垂直的两个向量称为正交，或者说两向量的夹角为$\frac{\pi}{2}$</li><li>单位向量：长度为1的向量称为单位向量</li></ul><hr><h2 id="零向量"><a href="#零向量" class="headerlink" title="零向量"></a>零向量</h2><p>$n$维向量的所有分量都是0，那么就被称为0向量</p><script type="math/tex; mode=display">\text{2 维零向量}:\boldsymbol{0}=\begin{pmatrix}0\\0\end{pmatrix},\qquad \text{3 维零向量}:\boldsymbol{0}=\begin{pmatrix}0\\0\\0\end{pmatrix}</script><p>集合意义就是平面和空间中的原点</p><hr><h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><p>将向量的加法定义为</p><script type="math/tex; mode=display">\boldsymbol{a}+\boldsymbol{b}=\begin{pmatrix}a_1\\a_2\\\vdots\\a_n\end{pmatrix}+\begin{pmatrix}b_1\\b_2\\\vdots\\b_n\end{pmatrix}=\begin{pmatrix}a_1+b_1\\a_2+b_2\\\vdots\\a_n+b_n\end{pmatrix}</script><p>几何意义</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220706225609083.png" alt="image-20220706225609083"></p><p>将$v$平移，使$u$，$v$首尾相接，然后就可以得到$u+v$,该方法称为三角形法则</p><hr><p><strong>乘法</strong></p><p>将乘法定义为</p><script type="math/tex; mode=display">k\boldsymbol{a}=k\begin{pmatrix}a_1\\a_2\\...\\a_n\end{pmatrix}=\begin{pmatrix}ka_1\\ka_2\\...\\ka_n\end{pmatrix},\quad k\in\mathbb{R}</script><p>在几何意义上，该向量$a$的各个分量都扩大了$k$倍，所以$ku$的几何意义就是对$u$进行了伸缩，其中$k$的符合决定了伸缩的方向</p><p>根据乘法的几何意义可以看出，伸缩后的向量$ku$与原向量$u$平行，所以可以借助数乘来定义平行，即如果两向量满足乘法关系，则一定平行</p><p>向量$u$的数乘为$ku$，当$k$在实数范围变动时时候，可以表示该直线$f$上所有的点</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220706231430083.png" alt="image-20220706231430083"></p><p>因此，直接$f$可以通过数乘来表示:</p><script type="math/tex; mode=display">f=k\boldsymbol{u},\quad k\in\mathbb{R}</script><hr><h2 id="线性相关"><a href="#线性相关" class="headerlink" title="线性相关"></a>线性相关</h2><p>若干<strong>同维数</strong>的向量$a_1,a_2,···,a_m$所组成的集合$A$，被称为向量组，记作</p><script type="math/tex; mode=display">\mathcal{A}:\boldsymbol{a_1},\boldsymbol{a_2},...,\boldsymbol{a_m}\quad 或\quad \mathcal{A}=\{\boldsymbol{a_1},\boldsymbol{a_2},...,\boldsymbol{a_m}\}</script><p>给定向量组$\quad \mathcal{A}=\{\boldsymbol{a_1},\boldsymbol{a_2},…,\boldsymbol{a_m}\}$和向量$b$，如果存在一组实数$k_1,k_2,…,k_m$，使</p><script type="math/tex; mode=display">\boldsymbol{b_{}}=k_1\boldsymbol{a_1}+k_2\boldsymbol{a_2}+...+k_m\boldsymbol{a_m}</script><p>则称向量$b$能被向量组$A$<strong>线性表示</strong>，或称向量$b$是向量组$A$的线性组合</p><blockquote><p>显然，对于<strong>零向量</strong>，必然可以由和它同维数的向量组$A$线性表示，只需要将$k_1=0,k_2=0,\cdots,k_m=0$  即可</p></blockquote><hr><p>给定向量组$\quad \mathcal{A}=\{\boldsymbol{a_1},\boldsymbol{a_2},…,\boldsymbol{a_m}\}$，如果存在<strong>不全为0</strong>的实数$k_1,k_2,…,k_m$，使</p><script type="math/tex; mode=display">k_1\boldsymbol{a_1}+k_2\boldsymbol{a_2}+...+k_m\boldsymbol{a_m}=\boldsymbol{0}</script><p>则称向量组$A$是<strong>线性相关</strong>的，否则称为线性无关</p><blockquote><p>存在不全为0的实数，意味着向量组之间是可以互相消去的，所以线性相关，如果向量组里面有0向量，那么其一定线性相关</p></blockquote><hr><p>判断矩阵线性无关的方法：</p><ol><li><p>定义法</p><script type="math/tex; mode=display">k_1\boldsymbol{a_1}+k_2\boldsymbol{a_2}+...+k_m\boldsymbol{a_m}=\boldsymbol{0}</script><p>通过恒等变形证明$k_1=k_2=···k_s=0$</p></li><li><p>行列式≠0以及满秩</p></li><li><p>反证法</p></li></ol><hr><p>$A$为$n$维向量组，那么：</p><ol><li>如果$A$线性无关，则给向量组中的每个向量增加第$n+1$个分量后，该向量组依旧线性无关，或者简单叙述为：线性无关的向量组，升维后仍线性无关；</li><li>如果$A$线性相关，则去掉向量组中的每个向量的第$n$个分量后，该向量组依旧线性相关，或者简单叙述为：线性相关的向量组，降维后仍线性相关。</li></ol><blockquote><p>信息在升维时保留，但在降维时可能丢失</p></blockquote><hr><h2 id="向量空间"><a href="#向量空间" class="headerlink" title="向量空间"></a>向量空间</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>设$v$为一个向量组，且$v$对于向量的加法及数乘两种运算封闭，那么就称$v$为向量空间</p><p>所谓封闭，是指在$v$中向量进行数乘和加减，结果仍然在$v$中</p><ul><li>若$\boldsymbol{a}\in \mathcal{V},\boldsymbol{b}\in \mathcal{V}$，则$a+b\in \mathcal{V}$</li><li>若$\boldsymbol{a}\in \mathcal{V},k\in \mathbb{R}$，则$\boldsymbol{ka}\in \mathcal{V}$</li></ul><blockquote><p>向量空间肯定是要包含零向量的，因为向量组肯定可以通过运算得出零向量</p></blockquote><hr><p>直线</p><p>所有一维直线构成的集合是一个向量空间，记作$R^1$:</p><script type="math/tex; mode=display">\mathbb{R^1}=\{(x)|x\in\mathbb{R}\}</script><p>这个向量空间代表了全体实数</p><hr><p>平面</p><p>所有二维向量构成的集合是一个向量空间，记作$R^2$</p><script type="math/tex; mode=display">\mathbb{R^2}=\{(x_1,x_2)|x_{1,2}\in\mathbb{R}\}</script><p>这个向量空间代表了整个平面</p><hr><p>立方体</p><p>所有三维向量构成的集合是一个向量空间，记作$R^3$</p><script type="math/tex; mode=display">\mathbb{R^3}=\{(x_1,x_2,x_3)|x_{1,2,3}\in\mathbb{R}\}</script><p>这个向量空间代表了整个三维空间</p><hr><p>向量空间并不一定是$R^n$,也可以是它们的子集。比如$R^3$，中的一个点，一根直线，或者一个面(必须经过原点)</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/123.svg" alt=""></p><p>上面提到的向量空间是$R^3$的子集，也称为$R^3$的一个子空间</p><script type="math/tex; mode=display">\mathcal{V}\subset \mathbb{R^3}</script><hr><p>更一般的，某向量组的所有的线性组合一定构成向量空间：</p><p>某向量组$\mathcal{A}=\{\boldsymbol{v_1},\boldsymbol{v_2},…,\boldsymbol{v_p}\}$,其所有线性组合构成的集合称为向量空间，也称为张成空间，记为$\mathcal{span}\{\boldsymbol{v_1},\boldsymbol{v_2},…,\boldsymbol{v_p}\}$，即</p><script type="math/tex; mode=display">span(\boldsymbol{v_1},\boldsymbol{v_2},...,\boldsymbol{v_p})=\{k_1\boldsymbol{v_1}+k_2\boldsymbol{v_2}+...+k_p\boldsymbol{v_p},k_{1,2,...,p}\in\mathbb{R}\}</script><p>设两个向量组$\mathcal{A}=\{\boldsymbol{a_1},\boldsymbol{a_2},…,\boldsymbol{a_m}\}$和$\mathcal{B}=\{\boldsymbol{b_1},\boldsymbol{b_2},…,\boldsymbol{b_n}\}$，如果向量组$B$中的每个向量都能由向量组$A$线性表示，则称向量组$B$能由向量组$A$<strong>线性表示</strong></p><p>若向量组$A$与向量组$B$能相互线性表示，则称两个向量组等价，是等价向量组</p><blockquote><p>注意和矩阵的等价不同，向量组等价$\implies r(A)=r(B)$，但是$r(A)=r(B)\nRightarrow$ 向量组等价</p></blockquote><p><img src="https://matongxue.oss-cn-hangzhou.aliyuncs.com/attch/matex/1381/20220513161514879/5.png" alt="img" style="zoom:67%;" /></p><hr><h3 id="最大无关组"><a href="#最大无关组" class="headerlink" title="最大无关组"></a>最大无关组</h3><p>设有向量组$A$，如果在$A$中能选出r个向量$a_1,a_2,···,a_r$满足：</p><ul><li>向量组$\mathcal{A_0}=\{\boldsymbol{a_1},\boldsymbol{a_2},…,\boldsymbol{a_r}\}$线性无关</li><li>向量组$A$中任意$r+1$个向量都线性相关，那么称向量组$A_0$是向量组$A$的一个最大线性无关组，简称<strong>最大无关组</strong></li></ul><blockquote><p>如果把向量组中的向量看做搭建房子的柱子的话，向量空间就是房子，而最大无关组就是，用最少的柱子组成的向量组支撑起这个房子，也叫做该房子的基。线性相关说明某些柱子是可以被其他柱子替换的，而线性无关组就是里面的柱子都缺一不可</p></blockquote><p>虽然向量组的最大无关组并不唯一，但是最大无关组包含向量的数目是相同的，此不变的数目就称为<strong>秩</strong>（rank）</p><p>假设向量组$A$的最大无关组为：</p><script type="math/tex; mode=display">\mathcal{A}_0=\{a_1,a_2,\cdots,a_r\}</script><p>$A_0$的向量个数$r$称为向量组$A$的秩，记作$rank(A)$,也记作$r(A)$</p><p>不变的秩反映了向量组的复杂程度，只含有0向量的向量组，秩为0</p><p>向量空间也是向量组，这个特殊向量组的秩称为向量空间的维度，也就是最大无关组的秩</p><hr><p>可以通过构造行最简形矩阵，主元所在的列数即是最大线性无关组的组合</p><hr><h3 id="向量空间的基"><a href="#向量空间的基" class="headerlink" title="向量空间的基"></a>向量空间的基</h3><p>向量空间$v$由向量组$A$张成，如果向量组$A_0$是向量组$A$的最大无关组，那么将该最大无关组称为向量空间的<strong>基</strong></p><p>最大无关组不是惟一的，显然对于向量空间来说，基并不唯一</p><p>有了基之后就可以对向量空间里面的向量进行定位了，或者说是，可以根据基来确定向量空间的坐标</p><p>假设$\mathcal{A}_0=\{a_1,a_2,\cdots,a_n\}$是向量空间$v$的一个基，则$v$中每个向量$x$都可通过该基唯一表示出来</p><script type="math/tex; mode=display">\boldsymbol{x}=k_1\boldsymbol{a_1}+k_2\boldsymbol{a_2}+\cdots +k_n\boldsymbol{a_n}</script><p>上面的系统可以组成向量</p><script type="math/tex; mode=display">[\boldsymbol{x}]_\mathcal{A}=\begin{pmatrix}k_1\\k_2\\\vdots\\k_n\end{pmatrix}</script><p>我们将其称为$x$在基$A$下的坐标向量，或者简称为$x$在基$A$下的坐标</p><blockquote><p>最大无相关组才是基。零向量线性相关，所以零空间没有最大无相关组，也就是最大无相关组中向量的个数是0。空间的维度是基向量组的秩，零空间的维度是0。零空间只有零向量是任何向量空间的子集，也就是任何空间的子空间</p></blockquote><hr><p>选择不同的基，实际上就是在向量空间中建立了不同的坐标系</p><p>所有的$R^n$都有自然基，比如$R^2$的自然基就是</p><script type="math/tex; mode=display">\mathcal{E}:\boldsymbol{e_1}=\begin{pmatrix}1\\0\end{pmatrix},\quad \boldsymbol{e_2}=\begin{pmatrix}0\\1\end{pmatrix}</script><p>对应的其实是直角坐标系，依次类推$R^3$的自然基就是空间坐标系</p><p>任意3维列向量可由$A$的三个特征向量线性表示 $\Leftrightarrow A$的特征矩阵$|a_1,a_2,a_3|≠0$</p><hr><p>重要技巧：</p><p>假设向量组$A={a_1,a_2,a_3}$，如果向量$B$中的各个元素能通过$a_1，a_2，a_3$的初等列变化表示出来，那么向量组B一定能被拆分成一个矩阵和$A$的乘积</p><script type="math/tex; mode=display">B=AX</script><p>在求相似矩阵，以及线性方程组的解的时候，应用非常普遍</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.5.矩阵函数</title>
      <link href="/post/64845.html"/>
      <url>/post/64845.html</url>
      
        <content type="html"><![CDATA[<h1 id="矩阵函数"><a href="#矩阵函数" class="headerlink" title="矩阵函数"></a>矩阵函数</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>如果将矩阵左乘$Aa=b$中的常向量$a$，$b$变为位置向量$x$，$y$，就得到了矩阵函数$Ax=y$</p><p>相对于矩阵左乘这种运算而言，矩阵函数是更抽象、更核心的数学概念</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220708230118283.png" alt="image-20220708230118283"></p><hr><h2 id="旋转矩阵"><a href="#旋转矩阵" class="headerlink" title="旋转矩阵"></a>旋转矩阵</h2><script type="math/tex; mode=display">\boldsymbol{A}=\begin{pmatrix}\cos\theta&-\sin\theta\\\sin\theta&\cos\theta\end{pmatrix}</script><p>该矩阵左乘$Aa=b$的结果是，让$b$相对$a$逆时针旋转了$\theta$，所以称该矩阵为旋转矩阵</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220708230521412.png" alt="image-20220708230521412"></p><p>将旋转矩阵看做是</p><script type="math/tex; mode=display">\boldsymbol{c_1}=\begin{pmatrix}\cos\theta\\\sin\theta\end{pmatrix},\quad\boldsymbol{c_2}=\begin{pmatrix}-\sin\theta\\\cos\theta\end{pmatrix}</script><p>两个列向量，显然$e_1×c_1$会导致$e_1$逆时针旋转，而$e_2$在$y$轴上，根据三角公式</p><script type="math/tex; mode=display">\begin{cases} \sin(\frac{\pi}{2}+\theta)=\cos(\theta)\\ \cos(\frac{\pi}{2}+\theta)=-\sin(\theta) \end{cases}</script><p>所以也会逆时针旋转</p><hr><h2 id="镜像矩阵"><a href="#镜像矩阵" class="headerlink" title="镜像矩阵"></a>镜像矩阵</h2><p>从矩阵函数的观点看初等行变化，对换变化中的二阶矩阵就是镜像矩阵</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220708231914048.png" alt="image-20220708231914048"></p><hr><h2 id="伸缩矩阵"><a href="#伸缩矩阵" class="headerlink" title="伸缩矩阵"></a>伸缩矩阵</h2><p>从矩阵函数的观点看初等行变化，倍乘变化中的矩阵就是伸缩矩阵，格式为：</p><script type="math/tex; mode=display">\boldsymbol{A}=\begin{pmatrix}1&0\\0&k\end{pmatrix}</script><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220708232220080.png" alt="image-20220708232220080"></p><hr><h2 id="剪切矩阵"><a href="#剪切矩阵" class="headerlink" title="剪切矩阵"></a>剪切矩阵</h2><p>从矩阵函数的观点看初等行变化，倍加变化中的矩阵就是剪切矩阵，格式为：</p><script type="math/tex; mode=display">\boldsymbol{A}=\begin{pmatrix}1&k\\0&1\end{pmatrix}</script><p>列向量为：</p><script type="math/tex; mode=display">\boldsymbol{c_1}=\begin{pmatrix}1\\0\end{pmatrix}=\boldsymbol{e_1},\quad\boldsymbol{c_2}=\begin{pmatrix}k\\1\end{pmatrix}=\boldsymbol{e_2}+\begin{pmatrix}k\\0\end{pmatrix}=k\boldsymbol{e_1}+\boldsymbol{e_2}</script><p>在列向量的作用下，输出向量$y$在$e_1$方向上进行了平移</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/fsd.svg" alt=""></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220708232808525.png" alt="image-20220708232808525"></p><h2 id="秩"><a href="#秩" class="headerlink" title="秩"></a>秩</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>之前在向量一章中提到过：</p><blockquote><p>虽然向量组的最大无关组并不唯一，但是最大无关组包含向量的数目是相同的，此不变的数目就称为<strong>秩</strong>（rank）</p></blockquote><p>向量组的最大无关组中向量的数目就是秩，而在矩阵中，要分为列空间和行空间的秩进行讨论</p><hr><p>包含所有列向量的向量组称为列向量组，记作$colsp(A)$，即：</p><script type="math/tex; mode=display">\begin{aligned} colsp(\boldsymbol{A}) &=span(\{\boldsymbol{c_1},\boldsymbol{c_2},\cdots,\boldsymbol{c_n}\})=x_1\boldsymbol{c_1}+x_2\boldsymbol{c_2}+\cdots+x_n\boldsymbol{c_n},\quad x_{1,2,\cdots,n}\in\mathbb{R} \end{aligned}</script><p>列向量组的秩，也就是列空间的维度，称为列秩，如果列向量组线性无关，就称为列满秩</p><hr><p>包含所有行向量的向量组称为行向量组，记作$rowsp(A)$，即：</p><script type="math/tex; mode=display">\begin{aligned} rowsp(\boldsymbol{A}) &=span(\{\boldsymbol{r_1}^\mathrm{T},\boldsymbol{r_2}^\mathrm{T},\cdots,\boldsymbol{r_m}^\mathrm{T}\})=x_1\boldsymbol{r_1}^\mathrm{T}+x_2\boldsymbol{r_2}^\mathrm{T}+\cdots+x_m\boldsymbol{r_m}^\mathrm{T},\quad x_{1,2,\cdots,m}\in\mathbb{R} \end{aligned}</script><p>行向量组的秩，也就是行空间的维度，称为行秩，如果行向量组线性无关，就称为行满秩</p><hr><p>对任意矩阵，始终有<strong>列秩等于行秩，所以统称为矩阵的秩，矩阵$A$的秩记作$rank(A)$</strong></p><p>因为行秩=列秩=秩，所以在自然定义域下时，秩就是矩阵函数的值域的维度</p><script type="math/tex; mode=display">\begin{array}{c|c|c} \hline \quad \text{自然定义域}\quad&\quad \text{秩}\quad&\quad \text{值域维度}\quad \\ \hline \quad \mathbb{R}^2\quad&\quad\begin{aligned}rank(\boldsymbol{A})=2\\rank(\boldsymbol{A})=1\\ rank(\boldsymbol{A})=0\end{aligned}\quad&\quad\begin{aligned}\text{2 维}\\\text{1 维}\\\text{0 维}\end{aligned}\quad\\ \hline \end{array}</script><p>如果某个矩阵，既是列满秩，又是行满秩，那么就称该矩阵为满秩矩阵，或者称为<strong>满秩</strong>。<strong>满秩矩阵必为方阵</strong></p><script type="math/tex; mode=display">rank(AB)\leq\min\Big(rank(A),rank(B)\Big)</script><blockquote><p>两个矩阵等价$\Leftrightarrow$ 两个矩阵的秩相同</p></blockquote><hr><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul><li><p>秩的取值范围：</p><script type="math/tex; mode=display">0\le rank(A_{m\times n})\le\min(m,n)</script></li><li><p>矩阵经过转置后，秩不变</p></li><li><p>满秩矩阵复合的秩。假设$P$、$Q$为满秩矩阵，那么：</p><script type="math/tex; mode=display">rank(PA)=rank(AQ)=rank(PAQ)=rank(A)</script></li><li><p>矩阵相加的秩，假设$A$,$B$为同型矩阵，那么</p><script type="math/tex; mode=display">rank(A+B)\le rank(A)+rank(B)</script></li><li><p>复合函数的秩：</p><script type="math/tex; mode=display">rank(AB)\leq\min\Big(rank(A),rank(B)\Big)</script></li><li><p>如果$AB=O$，$A,B$为$n$阶矩阵，那么</p><script type="math/tex; mode=display">rank(A)+rank(B)≤n</script></li></ul><hr><h3 id="函数的四要素"><a href="#函数的四要素" class="headerlink" title="函数的四要素"></a>函数的四要素</h3><p>定义域：集合$X$</p><p>映射法则$f$：指明$X$中的元素怎么和$Y$元素关联</p><p>值域：通过映射法则$f$和定义域$X$决定，表示$X$映射到$Y$中的值</p><p>到达域：集合$Y$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/789.svg" alt=""></p><p>对于$m×n$的矩阵：</p><script type="math/tex; mode=display">\underbrace{A}_{m\times n}\quad\underbrace{\boldsymbol{x_{}}}_{n\times 1}\quad=\quad\underbrace{\boldsymbol{y_{}}}_{m\times 1}</script><ul><li><p>自然定义域为$R^n$，因为$n$维向量$\boldsymbol{x_{}}=\begin{pmatrix}x_1\\x_2\\\vdots\\x_n\end{pmatrix}$为$R^n$中的任意向量</p></li><li><p>映射法则为矩阵$A$以及矩阵乘法的规则</p></li><li><p>值域为$Ax$</p></li><li><p>到达域为$R^m$，因为$\boldsymbol{y_{}}=\begin{pmatrix}y_1\\y_2\\\vdots\\y_m\end{pmatrix}$是$m$维向量，所以值域必然在$R_m$中</p></li></ul><hr><p>映射法则分几种情况</p><p>单射：映射法则是单的，简称单射，当且仅当每一个$y$至多有一个$x$与之对应</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/p.svg" alt=""></p><p>满射：映射法则是满的，简称满射，当且仅当每一个$y$至多有一个$x$与之对应，此时值域与到达域相等</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/l.svg" alt=""></p><p>双射：即是单射又是满射</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/n.svg" alt=""></p><p>总结：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/z.svg" style="zoom:80%;" /></p><hr><p>列向量矩阵$Ax=y$的四要素</p><script type="math/tex; mode=display">\begin{array}{c|c|c|c} \hline \quad 自然定义域\quad&\quad 映射法则 \quad&\quad 值域 \quad&\quad 到达域 \quad\\\hline\\ \quad \mathbb{R}^n \quad&\quad \boldsymbol{A} \quad&\quad colsp(\boldsymbol{A}) \quad&\quad \mathbb{R}^m \quad\\ \\ \hline \end{array}</script><p>行向量矩阵$x^TA=y^T$的四要素</p><script type="math/tex; mode=display">\begin{array}{c|c|c|c} \hline \quad 自然定义域\quad&\quad 映射法则 \quad&\quad 值域 \quad&\quad 到达域 \quad\\\hline\\ \quad \mathbb{R}^m \quad&\quad \boldsymbol{A} \quad&\quad rowsp(\boldsymbol{A}) \quad&\quad \mathbb{R}^n \quad\\ \\ \hline \end{array}</script><hr><h3 id="函数的单射"><a href="#函数的单射" class="headerlink" title="函数的单射"></a>函数的单射</h3><p>定义域维度=值域维度时，才能形成单射</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220709140702099.png" alt="image-20220709140702099"></p><p>那么只要行满秩，或者列满秩的情况下，矩阵函数才会不改变函数的维度</p><script type="math/tex; mode=display">\begin{array}{c|c|c|c} \hline \quad矩阵函数\quad&\quad 单射的充要条件 \quad\\\hline\\ \quad \boldsymbol{A}\boldsymbol{x}=\boldsymbol{y} \quad&\quad 列满秩 \iff 单射 \quad\\ \quad \boldsymbol{x}^\mathrm{T}\boldsymbol{A}=\boldsymbol{y}^\mathrm{T} \quad&\quad 行满秩 \iff 单射\quad\\ \\ \hline \end{array}</script><p>只有单射情况下，线性方程才有唯一解，当然也有可能无解(解在值域外，到达域中)</p><hr><h3 id="函数的满射"><a href="#函数的满射" class="headerlink" title="函数的满射"></a>函数的满射</h3><p>只有值域$colsp(A)$和到达域$R^m$一样时，列向量$Ax=y$才会满射</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220710145951686.png" alt="image-20220710145951686"></p><p>假设$A$为$m×n$的矩阵，满射时，必有$Rank(colsp(A))$=$R^m$</p><p>那么就要求，矩阵的列秩必须是$m$，而行秩=列秩，所以行秩为$m$，行满秩</p><p>所以满射条件是：</p><script type="math/tex; mode=display">\boldsymbol{A}\ \text{是行满秩}\iff \boldsymbol{A}\boldsymbol{x}=\boldsymbol{y}\ \text{是满射}</script><script type="math/tex; mode=display">\begin{array}{c|c|c|c} \hline \quad矩阵函数\quad&\quad 满射的充要条件 \quad\\\hline\\ \quad \boldsymbol{A}\boldsymbol{x}=\boldsymbol{y} \quad&\quad 行满秩 \iff 满射 \quad\\ \quad \boldsymbol{x}^\mathrm{T}\boldsymbol{A}=\boldsymbol{y}^\mathrm{T} \quad&\quad 列满秩 \iff 满射\quad\\ \\ \hline \end{array}</script><p>只有函数在满射的情况下，方程才有解</p><hr><h3 id="函数的双射"><a href="#函数的双射" class="headerlink" title="函数的双射"></a>函数的双射</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220710152842245.png" alt="image-20220710152842245"></p><p>双射就是即是单射，又是满射，结合两者的成立条件：</p><script type="math/tex; mode=display">\begin{array}{c|c|c|c} \hline \quad矩阵函数\quad&\quad 单射的充要条件 \quad&\quad 满射的充要条件 \quad&\quad 双射的充要条件 \quad\\\hline\\ \quad \begin{aligned}A\boldsymbol{x}=\boldsymbol{y}\ \ \\\boldsymbol{x}^\mathrm{T}A=\boldsymbol{y}^\mathrm{T}\end{aligned} \quad&\quad \begin{aligned}列满秩\\行满秩\end{aligned} \quad&\quad \begin{aligned}行满秩\\列满秩\end{aligned} \quad&\quad 满秩\quad\\ \\ \hline \end{array}</script><p>总结</p><div class="table-container"><table><thead><tr><th>单射</th><th>满射</th><th>结果</th></tr></thead><tbody><tr><td>√</td><td>√</td><td>必有解，且为唯一解</td></tr><tr><td>√</td><td>×</td><td>有可能有解，有可能无解，若有解，必为唯一解</td></tr><tr><td>×</td><td>√</td><td>必然有解，解必然不唯一</td></tr></tbody></table></div><hr><h3 id="秩的求法"><a href="#秩的求法" class="headerlink" title="秩的求法"></a>秩的求法</h3><p>秩很容易求出来，可以将矩阵化为行阶梯形矩阵，秩就是非零行的个数</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220710161629037.png" alt="image-20220710161629037"></p><p>在行最简形矩阵的基础上，再执行若干次初等行变化，就可以得到形式更简单地矩阵，特点是左上角是单位阵</p><script type="math/tex; mode=display">\begin{pmatrix}1&2&0\\0&0&1\\0&0&0\end{pmatrix}\xrightarrow[\color{red}{\text{倍加}}]{\quad \boldsymbol{c}_2'=-2\boldsymbol{c}_1+\boldsymbol{c}_2\quad}\begin{pmatrix}1&0&0\\0&0&1\\0&0&0\end{pmatrix}\xrightarrow[\color{red}{\text{对换}}]{\quad \boldsymbol{c}_2\leftrightarrow \boldsymbol{c}_3\quad}\begin{pmatrix}1&0&0\\0&1&0\\0&0&0\end{pmatrix}</script><p>这种矩阵被称为<strong>标准形</strong></p><p>实际上标准型非常好求出来，只需要判断矩阵的秩，然后再对角线上填上等于秩个数的$1$即可</p><hr><h2 id="逆矩阵"><a href="#逆矩阵" class="headerlink" title="逆矩阵"></a>逆矩阵</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>如果函数只有单射，或只是满射，那么无法建立起逆矩阵，只有在双射情况下，矩阵才有逆矩阵</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220710153937920.png" alt="image-20220710153937920"></p><p>所以根据矩阵双射的条件有：</p><p>当矩阵$A$为<strong>满秩矩阵</strong>时，对应的矩阵函数为双射，此时$A$存在反函数，称为$A$可逆。其反函数记作$A^{-1}$，称为$A$的逆矩阵</p><p>之前提到过，单位阵$I$的定义如下</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220710154955223.png" alt="image-20220710154955223" style="zoom:80%;" /></p><p>而对图形先运用矩阵$A$，再运用逆矩阵$A^{-1}$，图形同样不会发生变化</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220710155100271.png" alt="image-20220710155100271"></p><p>逆矩阵定义如下：若存在两个$n$阶矩阵$A$，$C$，两者的乘积为$n$阶单位阵$I$：</p><script type="math/tex; mode=display">AC=I 且CA=I</script><p>那么$C$就是$A$的逆矩阵，即有$A^{-1}=C$，且$A^{-1}$是惟一的</p><hr><h3 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h3><p>如果可以通过一系列初等行矩阵$E^i$，将矩阵$A$变换成单位阵$I$，则$A$的逆矩阵就是这些初等行矩阵的乘积：</p><script type="math/tex; mode=display">\underbrace{\boldsymbol{E}_1\boldsymbol{E}_2...\boldsymbol{E}_n}_{\boldsymbol{A}^{-1}}\boldsymbol{A}=\boldsymbol{I}</script><p>实际上分为两步：</p><ul><li>先通过一系列初等行矩阵，将矩阵$A$变换成单位阵$I$</li><li>然后将这些初等行矩阵相乘得到逆矩阵</li></ul><p>联系到之前提到过的高斯消元法，可以将这两步合并在一起进行</p><p>首先将矩阵$A$和$I$合成一个矩阵$( A|I )$，然后在新矩阵$( A|I )$上运用一系列初等行矩阵。这样就可以在得到单位阵的同时，得到逆矩阵：</p><script type="math/tex; mode=display">( A|I )\xrightarrow{\quad E_1,E_2,...,E_n\quad }( I|A^{-1} )</script><p>实际上这里利用分块矩阵的方法，将一个矩阵成了两块，每块都乘以$A^{-1}$</p><hr><h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h3><ul><li><p>若$A，B$是同阶方阵且均可逆，则$AB$也可逆，且</p><script type="math/tex; mode=display">(\boldsymbol{A}\boldsymbol{B})^{-1}=\boldsymbol{B}^{-1}\boldsymbol{A}^{-1}</script></li><li><p>若$A$可逆，则$A^T$也可逆，且：</p><script type="math/tex; mode=display">(\boldsymbol{A}^\mathrm{T})^{-1}=(\boldsymbol{A}^{-1})^\mathrm{T}</script></li><li><p>分块矩阵的逆矩阵：</p><script type="math/tex; mode=display">\begin{pmatrix}A&O\\O&B\end{pmatrix}^{-1}=\begin{pmatrix}A^{-1}&O\\O&B^{-1}\end{pmatrix}</script><script type="math/tex; mode=display">\begin{pmatrix}O&A\\B&O\end{pmatrix}^{-1}=\begin{pmatrix}O&B^{-1}\\A^{-1}&O\end{pmatrix}</script></li></ul><hr><h2 id="分块矩阵"><a href="#分块矩阵" class="headerlink" title="分块矩阵"></a>分块矩阵</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>对于行数和列数较多的矩阵$A$，运算时采用分块法，将大矩阵的运算化为小矩阵的运算</p><script type="math/tex; mode=display">A=\left( {\begin{array}{c|c} \overbrace{ \begin{matrix} a_{11}&\cdots&a_{1r}\\ \vdots& &\vdots\\ a_{s1}&\cdots&a_{sr}\\ \end{matrix}}^{\Large 子块A_{11}} &\overbrace{ \begin{matrix} a_{1(r+1)}&\cdots&a_{1n}\\ \vdots& &\vdots\\ a_{s(r+1)}&\cdots&a_{sn}\\ \end{matrix}}^{\Large 子块A_{12}}\\ \hline \underbrace{ \begin{matrix} a_{(s+1)1}&\cdots&a_{(s+1)r}\\ \vdots& &\vdots\\ a_{m1}&\cdots&a_{mr}\\ \end{matrix}}_{\Large 子块A_{21}} &\underbrace{ \begin{matrix} a_{(s+1)(r+1)}&\cdots&a_{(s+1)n}\\ \vdots& &\vdots\\ a_{m(r+1)}&\cdots&a_{mn}\\ \end{matrix}}_{\Large 子块A_{22}} \end{array}} \right)</script><p>可以改写成如下形式：</p><script type="math/tex; mode=display">A=\begin{pmatrix}A_{11}&A_{12}\\A_{21}&A_{22}\end{pmatrix}</script><p>分块矩阵的形式多种多样，可以任意划分</p><hr><h3 id="运算规则"><a href="#运算规则" class="headerlink" title="运算规则"></a>运算规则</h3><p>分块矩阵的运算规则和普通矩阵的几乎一样</p><p>加法：</p><script type="math/tex; mode=display">A+B=\begin{pmatrix}A_{11}+B_{11}&\cdots&A_{1r}+B_{1r}\\ \vdots&&\vdots\\A_{s1}+B_{s1}&\cdots&A_{sr}+B_{sr} \end{pmatrix}</script><p>数乘：</p><script type="math/tex; mode=display">\lambda A=\begin{pmatrix}\lambda A_{11}&\cdots&\lambda A_{1r}\\\vdots&&\vdots\\\lambda A_{s1}&\cdots&\lambda A_{sr}\end{pmatrix},\lambda\in\mathbb{R}</script><p>乘法：</p><script type="math/tex; mode=display">A=\begin{pmatrix}A_{11}&\cdots&A_{1t}\\ \vdots&&\vdots\\A_{s1}&\cdots&A_{st}\end{pmatrix},\quad B=\begin{pmatrix}B_{11}&\cdots&B_{1r}\\\vdots&&\vdots\\ B_{t1}&\cdots&B_{tr}\end{pmatrix}=\begin{pmatrix}C_{11}&\cdots&C_{1r}\\ \vdots&&\vdots\\C_{s1}&\cdots&C_{sr}\end{pmatrix}</script><script type="math/tex; mode=display">C_{ij}=\sum_{k=1}^{t}A_{ik}B_{kj} \quad(i=1,\cdots,s;j=1,\cdots,r)</script><hr><h3 id="分块对角矩阵"><a href="#分块对角矩阵" class="headerlink" title="分块对角矩阵"></a>分块对角矩阵</h3><p>设$A$是方阵，若$A$的分块矩阵在对角线上的子块$A_i(i=1,2,\cdots,s)$都是方阵，其余子块都是零矩阵，那么称$A$为分块对角矩阵</p><script type="math/tex; mode=display">A=\begin{pmatrix}A_1&\quad&\quad&O\\ \quad&A_2&\quad&\quad\\ \quad&\quad&\ddots&\quad\\ O&\quad&\quad&A_s\end{pmatrix}</script><p>该分块对角矩阵$A$的秩等于对角线上子块的秩的和</p><script type="math/tex; mode=display">rank(A)=rank(A_1)+rank(A_2)+\cdots+rank(A_n)</script><p>当$A_i(i=1,2,\cdots,s)$不是方阵时，上述定理依然有效</p><hr>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.矩阵</title>
      <link href="/post/7061.html"/>
      <url>/post/7061.html</url>
      
        <content type="html"><![CDATA[<h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>英国数学家阿瑟·凯莱中提出，对于线性方程组：</p><script type="math/tex; mode=display">\begin{cases} \ \ x+2y=3\\ 3x+4y=5 \end{cases}</script><p>未知数的名字$x$,$y$根本就不重要，所以可把未知数的系数提出来，用一种称为矩阵(Matrix)的紧凑阵列来表示，该阵列称作<strong>系数矩阵</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220707222211948.png" alt="image-20220707222211948" style="zoom:80%;" /></p><p>如果把等号右边的数字一起提出来，那么称为<strong>增广矩阵</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220707222317927.png" alt="image-20220707222317927" style="zoom:80%;" /></p><p>严格定义如下：</p><p>由$m×n$个数$a_{ij}(i=1,2,…m;j=1,2…n)$排成的$m$行$n$列的数表称为$m$行$n$列矩阵，简称$m×n$矩阵。为了表示这些数字是一个整体，总是加一个括弧</p><script type="math/tex; mode=display">A=\underbrace{\begin{pmatrix}a_{11}&a_{12}&...&a_{1n}\\a_{21}&a_{22}&...&a_{2n}\\...&...&&...\\a_{m1}&a_{m2}&...&a_{mn}\end{pmatrix}}_{\large n列}\left.\begin{aligned}\\\\\\\\\end{aligned}\right\}m行</script><p>可以用$a_{ij}$表示该矩阵$A$的第$i$行$j$列的数字</p><p>矩阵$A_{m×n}$的第$i$行可以看做是行向量，同样的，第$j$列可以看做是列向量</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/9.svg" alt=""></p><p>如果行数列数相等，且都等于$n$，则称该矩阵为$n$阶方阵，简记为$A_n$</p><p>元素都是0的矩阵称为0矩阵，记作$O$</p><hr><p>矩阵的诞生就是为了解线性方程组的</p><script type="math/tex; mode=display">\begin{cases} \ \ x+2y=3\\ 3x+4y=5 \end{cases} \implies \begin{cases} \ \ x+0y=?\\ 0x+\ \ y=? \end{cases}</script><p>用矩阵表示就是</p><script type="math/tex; mode=display">\begin{pmatrix} 1&2&3\\ 3&4&5 \end{pmatrix} \implies \begin{pmatrix} 1&0&?\\ 0&1&? \end{pmatrix}</script><p>增广矩阵的某行是可以乘除任意常数的，同时增广矩阵内某行也能加减任意行的倍数，所以可以将该矩阵化成</p><script type="math/tex; mode=display">\begin{cases} \ \ x+0y=-1\\ 0x+\ \ y=\ \ 2 \end{cases} \qquad \begin{pmatrix} 1&0&-1\\ 0&1&2 \end{pmatrix}</script><p>从而解出方程</p><hr><h2 id="乘法的最初定义"><a href="#乘法的最初定义" class="headerlink" title="乘法的最初定义"></a>乘法的最初定义</h2><p>将增广矩阵的第一行，第二行表示为：</p><script type="math/tex; mode=display">\begin{pmatrix} 1&2&3\\ 3&4&5 \end{pmatrix} \quad \begin{matrix} \boldsymbol{r_1}\\ \boldsymbol{r_2} \end{matrix}</script><p>其中$r_1$,$r_2$都是行向量，那么刚才的简化过程中可以直接用矩阵表示：</p><script type="math/tex; mode=display">\begin{pmatrix} 1&2&3\\ 3&4&5 \end{pmatrix} \xrightarrow{\quad \boldsymbol{r_2}'=-3\boldsymbol{r_1}+\boldsymbol{r_2}\quad} \begin{pmatrix} 1&2&3\\ 0&-2&-4 \end{pmatrix}</script><p>仔细观察这个过程，实际上包含了两个步骤</p><ul><li>增广矩阵的第一行不变，即：$\boldsymbol{r_1}’=\boldsymbol{r_1}$</li><li>增广矩阵的第二行改变，即：$\boldsymbol{r_2}’=-3\boldsymbol{r_1}+\boldsymbol{r_2}$</li></ul><p>首先，增广矩阵的第一行不变，凯莱说，下面这种乘法得到的结果就是$r_1$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/a.svg" alt=""></p><p>其次，增广矩阵的第二行改变，凯莱又说，下面这种乘法得到的结果就是$\boldsymbol{r_2}’=-3\boldsymbol{r_1}+\boldsymbol{r_2}$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220707230356995.png" alt="image-20220707230356995"></p><p>将{1,0}，{-3,1}组成一个矩阵，就能直接简化运算过程</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220707230535522.png" alt="image-20220707230535522"></p><p>这就是矩阵乘法的最初定义</p><hr><p>而之间的线性方程组的化简过程，可以完全用矩阵乘法来表示</p><script type="math/tex; mode=display">\begin{aligned} \begin{pmatrix}1&2&3\\3&4&5\end{pmatrix} &\xrightarrow[\quad r_2'=-3r_1+r_2\quad]{\quad r_1'=1r_1+0r_2\quad} \begin{pmatrix}1&0\\-3&1\end{pmatrix}\begin{pmatrix}1&2&3\\3&4&5\end{pmatrix}=\begin{pmatrix}1&2&3\\0&-2&-4\end{pmatrix}\\ \qquad\\ &\qquad\xrightarrow[\quad r_2'=0r_1-\frac{1}{2}r_2\quad] {\quad r_1'=1r_1+0r_2\quad} \begin{pmatrix}1&0\\0&-\frac{1}{2}\end{pmatrix} \begin{pmatrix}1&2&3\\0&-2&-4\end{pmatrix}= \begin{pmatrix}1&2&3\\0&1&2\end{pmatrix}\\ \qquad\\ &\qquad\xrightarrow[\quad r_2'=0r_1+1r_2\quad ]{\quad r_1'=r_1-2r_2\quad} \begin{pmatrix}1&-2\\0&1\end{pmatrix} \begin{pmatrix}1&2&3\\0&1&2\end{pmatrix}= \begin{pmatrix}1&0&-1\\0&1&2\end{pmatrix} \end{aligned}</script><p>也可以将上述过程串在一起：</p><script type="math/tex; mode=display">\underbrace{\begin{pmatrix}1&-2\\0&1\end{pmatrix}\begin{pmatrix}1&0\\0&-\frac{1}{2}\end{pmatrix}\begin{pmatrix}1&0\\-3&1\end{pmatrix}}_{\large 注意顺序}\begin{pmatrix}1&2&3\\3&4&5\end{pmatrix}=\begin{pmatrix}1&0&-1\\0&1&2\end{pmatrix}</script><p>最终只需要一个矩阵，就可以解出线性方程组</p><script type="math/tex; mode=display">\begin{pmatrix}1&-2\\0&1\end{pmatrix}\begin{pmatrix}1&0\\0&-\frac{1}{2}\end{pmatrix}\begin{pmatrix}1&0\\-3&1\end{pmatrix}=\begin{pmatrix}-2&1\\1.5&-\frac{1}{2}\end{pmatrix}</script><hr><h2 id="高斯消元法"><a href="#高斯消元法" class="headerlink" title="高斯消元法"></a>高斯消元法</h2><p>即通过方程组之间的消元和回代可以达到解方程组的目的</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/b.svg" alt=""></p><p>非零矩阵若满足：</p><ul><li>非零行在零行（如果存在的话）的上面</li><li>非零行最左边的首非零元素在上一行（如果存在的话）的首非零元素的右面</li></ul><p>满足上述要求的矩阵看上去像是阶梯状：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/c.svg" alt=""></p><p>所以称为行阶梯形矩阵，非零行最左边的首非零元素称为主元</p><hr><h3 id="对角矩阵"><a href="#对角矩阵" class="headerlink" title="对角矩阵"></a>对角矩阵</h3><p>若$n$阶方阵如下：</p><script type="math/tex; mode=display">\Lambda_{n}=\begin{pmatrix}\lambda_1&0&...&0\\0&\lambda_2&...&0\\...&...&&...\\ 0&0&...&\lambda_n\end{pmatrix}</script><p>对角线以外元素都是0，这种方阵称为对角矩阵，也记作：</p><script type="math/tex; mode=display">\Lambda_{n}=diag(\lambda_1,\lambda_2,...,\lambda_n)</script><p>对角矩阵的乘法非常简单：</p><script type="math/tex; mode=display">\begin{pmatrix}a_{1}&&&\\&a_{2}&&\\&&\ddots &\\&&&a_{n} \end{pmatrix}\begin{pmatrix}b_{1}&&&\\&b_{2}&&\\&&\ddots &\\&&&b_{n}\end{pmatrix}=\begin{pmatrix}a_{1}b_{1}&&&\\&a_{2}b_{2}&&\\&&\ddots &\\&&&a_{n}b_{n}\end{pmatrix}</script><hr><h3 id="单位阵"><a href="#单位阵" class="headerlink" title="单位阵"></a>单位阵</h3><p>如果$n$阶对角阵的对角线上元素为1：</p><script type="math/tex; mode=display">I_n=\begin{pmatrix}1&0&...&0\\0&1&...&0\\...&...&&...\\ 0&0&...&1\end{pmatrix}</script><p>该对角阵称为$n$阶单位阵，或者简称为单位阵，用$E$表示</p><p>任何矩阵乘上单位阵之后结果不变</p><hr><h3 id="行最简形矩阵"><a href="#行最简形矩阵" class="headerlink" title="行最简形矩阵"></a>行最简形矩阵</h3><p>若$A$是行阶梯形矩阵，并且还满足</p><ul><li>主元为$1$</li><li>除主元外，其所在列其他元素均为0</li></ul><hr><h3 id="初等行变换"><a href="#初等行变换" class="headerlink" title="初等行变换"></a>初等行变换</h3><p><strong>在使用初等行变换之前，主要注意其目的</strong></p><p>矩阵的初等变换不能同时行变换和列变换同时使用的。<br>在使用时候，还是要分场合进行讨论：</p><ol><li>求矩阵的秩可以行初等变换和列初等变换混用，因为“经初等变换矩阵的秩不变”。（一定要用可逆变换，否则至少自己保证安全性。）</li><li>对于行列式求值而言，可以随便使用行变换和列变换，以及其它手段。行列式的计算只要得出结果出来就行了，是否使用哪种方法要结合行列式乘积定理来理解。</li><li>如果是解线性方程组只能用初等行变换，才能保证同解。</li><li>如果求矩阵的逆矩阵也只能用初等行变换。</li><li>解方程组$Ax=b$，那么两种变换都可以用，但不是无条件的。比如行变换就要同时作用于系数矩阵和右端项，列变换则需要保留信息，以便最后求解的时候用。</li></ol><hr><p>高斯消元法步骤虽然繁杂，实际上只需要三种操作就可以完成</p><p>完成高斯消元法只需要三种操作，这三种操作是作用在矩阵的行上的，所以又称为<strong>初等行变换</strong>。在单位阵上应用这三种初等行变换一次得到的矩阵称为<strong>初等行矩阵</strong>，也就是下列表格中最右的矩阵：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/d.svg" alt=""></p><p>初等行矩阵乘上矩阵$A$，即$XA$，就相当于对矩阵进行了初等行变化</p><p>在已知矩阵$AB$，矩阵$B$的情况下，利用初等行变换让$B=AB$，对过程中使用到的初等行矩阵相乘，即为矩阵$A$（实际上此方法就是求逆矩阵的一种方法）</p><hr><h3 id="初等列变化"><a href="#初等列变化" class="headerlink" title="初等列变化"></a>初等列变化</h3><p>有初等行变换就有初等列变化</p><script type="math/tex; mode=display">\begin{array}{c|c|c} \hline \quad 初等列变换\quad &\quad 操作\quad &\quad 初等列矩阵\quad\\ \hline \\ \quad \color{SkyBlue}{倍加变换}\quad &\quad \boldsymbol{c_1}'=\boldsymbol{c_1}+k\boldsymbol{c_2}\quad &\quad \begin{pmatrix}1&0&0\\{\color{red}{k}}&1&0\\0&0&1\end{pmatrix}\quad \\ \\ \hline \\ \quad \color{Goldenrod}{倍乘变换}\quad &\quad \boldsymbol{c_1}'=k\boldsymbol{c_1} (k\neq 0)\quad & \quad \begin{pmatrix}{\color{red}{k}}&0&0\\0&1&0\\0&0&1\end{pmatrix}\quad \\ \\ \hline \\ \quad \color{orange}{对换变换}\quad &\quad \boldsymbol{c_1}\leftrightarrow \boldsymbol{c_2}\quad & \quad \begin{pmatrix}{\color{red}{0}}&{\color{red}{1}}&0\\ {\color{red}{1}}&{\color{red}{0}}&0\\{\color{red}{0}}&{\color{red}{0}}&1\end{pmatrix}\quad \\ \\ \hline \end{array}</script><p>矩阵$A$乘上初等列矩阵，即$AX$，就相当于对矩阵进行了初等行变化</p><hr><h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><p>两个矩阵的行数相等、列数也相等时，就称它们是同型矩阵</p><p>若$A=(a_{ij})$与$B=(b_{ij})$是同型矩阵，并且他们对应元素都相等，则矩阵$A$和矩阵$B$相等</p><script type="math/tex; mode=display">A=B</script><p>只有同型矩阵之间才能相加</p><script type="math/tex; mode=display">A+B=\begin{pmatrix}a_{11}+b_{11}&a_{12}+b_{12}&...&a_{1n}+b_{1n}\\a_{21}+b_{21}&a_{22}+b_{22}&...&a_{2n}+b_{2n}\\ ...&...&&...\\a_{m1}+b_{m1}&a_{m2}+b_{m2}&...&a_{mn}+b_{mn}\end{pmatrix}</script><hr><h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><p>数$k$与矩阵$A$的乘积记作：</p><script type="math/tex; mode=display">kA</script><p>规定为：</p><script type="math/tex; mode=display">kA=Ak= \begin{pmatrix} ka_{11}&ka_{12}&\cdots&ka_{1n}\\ ka_{21}&ka_{22}&\cdots&ka_{2n}\\ \cdots&\cdots& &\cdots\\ ka_{m1}&ka_{m2}&\cdots&ka_{mn}\end{pmatrix}</script><hr><p>矩阵之间的相乘，是需要满足一定合法性的：</p><ul><li>$m×n$的矩阵只能和$n×p$矩阵相乘</li><li>相乘后矩阵大小为$m×p$</li></ul><p>结合乘法的最初定义其实很好理解，$A$矩阵的每一列都要对应到$B$矩阵的每一行</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/8.png" alt=""></p><hr><p><strong>行观点</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/e.svg" alt=""></p><p>在运算时，将按照行的顺序进行运算</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220708132539975.png" alt="image-20220708132539975"></p><p>假设有行向量$x$和矩阵$A$，如果计算$xA$，很适合用行观点来看待矩阵乘法，把结果看作$A$矩阵行向量的线性组合</p><script type="math/tex; mode=display">\boldsymbol{x}\boldsymbol{A}=\begin{pmatrix}\color{blue}{x_1}&\color{blue}{x_2}&\cdots&\color{blue}{x_m}\end{pmatrix} \begin{pmatrix}a_{11}&a_{12}&\cdots&a_{1n}\\ a_{21}&a_{22}&\cdots&a_{2n}\\ \vdots&\quad&\quad&\vdots\\ a_{m1}&a_{m2}&\cdots&a_{mn} \end{pmatrix}=</script><script type="math/tex; mode=display">\color{blue}{x_1}\begin{pmatrix}a_{11}&a_{12}&\cdots&a_{1n}\end{pmatrix}+ \color{blue}{x_2}\begin{pmatrix}a_{21}&a_{22}&\cdots&a_{2n}\end{pmatrix}+\cdots+ \color{blue}{x_m}\begin{pmatrix}a_{m1}&a_{m2}&\cdots&a_{mn}\end{pmatrix}</script><p>此时，$A$在行向量$x$的右边，所以可说<strong>$A$右乘$x$</strong></p><hr><p><strong>列观点</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/g.svg" alt=""></p><p>同行观点类似，如果右边是多列矩阵，可以看作多次运用矩阵列观点，并将结果放置在合适的位置：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220708133359885.png" alt="image-20220708133359885"></p><p>假设有行向量$x$和矩阵$A$，如果计算$Ax$，很适合用列观点来看待矩阵乘法，把结果看作$A$矩阵列向量的线性组合</p><script type="math/tex; mode=display">\boldsymbol{A}\boldsymbol{x}=\begin{pmatrix}a_{11}&a_{12}&\cdots&a_{1n}\\ a_{21}&a_{22}&\cdots&a_{2n}\\ \vdots&\quad&\quad&\vdots\\ a_{m1}&a_{m2}&\cdots&a_{mn} \end{pmatrix} \begin{pmatrix}\color{blue}{x_1}\\\color{blue}{x_2}\\\vdots\\\color{blue}{x_n}\end{pmatrix}=\color{blue}{x_1}\begin{pmatrix}a_{11}\\a_{21}\\\vdots\\a_{m1}\end{pmatrix} +\color{blue}{x_2}\begin{pmatrix}a_{12}\\a_{22}\\\vdots\\a_{m2}\end{pmatrix} +\cdots+ \color{blue}{x_n}\begin{pmatrix}a_{1n}\\a_{2n}\\\vdots\\a_{mn}\end{pmatrix}</script><p>此时，$A$在列向量$x$的左边，所以可说<strong>$A$左乘$x$</strong></p><hr><p><strong>点积观点</strong></p><p>设$A=(a_{ij})$是一个$m×s$矩阵，$B=(b_{ij})$是一个$s×n$矩阵，那么规定$A$与$B$的乘积是一个$</p><script type="math/tex; mode=display">c_{ij}=\boldsymbol{a}_{i*}\cdot\boldsymbol{b}_{*j}=a_{i1}b_{1j}+a_{i2}b_{2j}+...+a_{is}b_{sj}=\displaystyle \sum_{k=1}^s a_{ik}b_{kj}\\(i=1,\cdots,m;j=1,\cdots,n)</script><p>并把乘积记作</p><script type="math/tex; mode=display">C=AB</script><p>上述定义的意思是，用左侧矩阵的行向量点积上右侧矩阵的列向量可以得到矩阵中的每个元素：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220708134842326.png" alt="image-20220708134842326"></p><p>非常适合口算矩阵乘法</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/h.svg" alt=""></p><p>矩阵乘法在有些情况下满足交换律，比如：</p><ul><li>$A,B$互逆，即$B=A^{-1}$的情况下，$AB=AA^{-1}=E=A^{-1}A=BA$</li><li>或者是$AB$中有个矩阵为零矩阵</li><li>或者两个矩阵都是对角线矩阵</li><li>或者$B$是$A$的伴随矩阵，因为有性质：$AA^{*}=|A|E$</li></ul><hr><h3 id="幂"><a href="#幂" class="headerlink" title="幂"></a>幂</h3><p>设$A$是方阵，定义：</p><script type="math/tex; mode=display">A^1=A,\quad A^2=A^1A^1,\quad\cdots,\quad A^{k+1}=A^kA^1</script><p>其中$k$为正整数</p><p>对角阵的幂运算：</p><script type="math/tex; mode=display">\Lambda^n=\left(\begin{array}{ccccc}{\lambda_{1}^n} \\ {} & {\lambda_{2}^n} \\ {} & {} & {} \\ {} & {} & {} & {\ddots} \\ {} & {} & {} & {} & {\lambda_{m}^n}\end{array}\right)</script><p>求矩阵的幂有如下思路：</p><ol><li><p>若矩阵可以相似对角化后，那么先相似对角化再求$A^n$ ,此属于常规思路</p></li><li><p>若$A$是由一个行向量与一个列向量相乘所得 (此时矩阵特点为每一个行（列）向量都是其余行（列）向量的倍数，即秩为1的方阵)，则可按如下处理：</p><script type="math/tex; mode=display">l=\beta^{T}\alpha=\alpha^{T}\beta=∑a_{ii}</script><script type="math/tex; mode=display">A^m=l^{m-1}A</script><p>之所以这样算，是因为可以这样拆分：</p><script type="math/tex; mode=display">A^2=(\alpha\beta^{T})(\alpha\beta^{T})=\alpha(\beta^{T}\alpha)\beta^{T}=lA</script><p>关于这种特殊方阵，其计算有许多巧妙之处，可以通过其平方化进行有效化简的作用</p></li><li><p>利用分块矩阵来求幂</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220717192939268.png" alt="image-20220717192939268"></p></li></ol><hr><p>矩阵的高次幂和矩阵的基础解系是一样的，即$A^nx=0$和$Ax=0$同解</p><hr><h3 id="转置"><a href="#转置" class="headerlink" title="转置"></a>转置</h3><p>把矩阵$A$的行换成同序数的列，该操作称为矩阵的转置运算，转置运算后可以得到一个新矩阵，该矩阵称为A的转置矩阵，记作$A^T$</p><script type="math/tex; mode=display">A=(a_{ij}),\quad A^\mathrm{T}=(a_{ji})</script><p>容易得到转置运算有以下性质：</p><ul><li><script type="math/tex; mode=display">(A^\mathrm{T})^\mathrm{T}=A</script></li><li><script type="math/tex; mode=display">(AB)^\mathrm{T}=B^\mathrm{T}A^\mathrm{T}</script></li><li><script type="math/tex; mode=display">(A^\mathrm{T})^n=(A^n)^\mathrm{T}</script></li><li><script type="math/tex; mode=display">(A+B)^\mathrm{T}=A^\mathrm{T}+B^\mathrm{T}</script></li></ul><p>将$A^T=A$的矩阵称作对称矩阵，将$A^T=-A$的矩阵称为反对称矩阵</p><hr><h3 id="乘法的几何意义"><a href="#乘法的几何意义" class="headerlink" title="乘法的几何意义"></a>乘法的几何意义</h3><p>矩阵的左乘$Aa=b$的几何意义是，在矩阵$A$的帮助下，将$a$变换成了$b$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220708155652283.png" alt="image-20220708155652283"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/o.svg" alt=""></p><hr><p>根据转置运算的规则，可以得到矩阵的右乘：</p><script type="math/tex; mode=display">\boldsymbol{A}\boldsymbol{a}=\boldsymbol{b}\implies (\boldsymbol{A}\boldsymbol{a})^\mathrm{T}=\boldsymbol{b}^\mathrm{T}\implies\boldsymbol{a}^\mathrm{T}\boldsymbol{A}^\mathrm{T}=\boldsymbol{b}^\mathrm{T}</script><p>矩阵的右乘$a^TA^T=b^T$的几何意义是，在矩阵$A^T$的帮助下，将$a^T$变换成了$b^T$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220708155936370.png" alt="image-20220708155936370"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/k.svg" alt=""></p><hr><p>左乘、右乘的几何意义是完全一样的，只是代数形式不同：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220708160403550.png" alt="image-20220708160403550"></p><p>所以，我们可以认为转置运算在这里只会导致代数形式上的变化，没有具体的几何意义。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.行列式</title>
      <link href="/post/36739.html"/>
      <url>/post/36739.html</url>
      
        <content type="html"><![CDATA[<h1 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h1><h2 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h2><p>历史上，定义行列式的目的就是为了解<strong>线性方程组</strong>。对于一元二次方程组</p><script type="math/tex; mode=display">\begin{cases}a_{11}x_1+a_{12}x_2=b_1\\a_{21}x_1+a_{22}x_2=b_2\end{cases}</script><p>如果有唯一解，那么可以通过高斯消元法得到</p><script type="math/tex; mode=display">\begin{cases}     x_1=\displaystyle \frac{b_1a_{22}-a_{12}b_2}{a_{11}a_{22}-a_{12}a_{21}}\\     \quad \\     x_2=\displaystyle \frac{b_2a_{11}-a_{21}b_1}{a_{11}a_{22}-a_{12}a_{21}} \end{cases}</script><p>同样的，该结论可以推广到$n$元一次线性方程组，简化$n$元一次线性方程组的解，找出其中的规律，这个过程中产生了<strong>行列式</strong></p><hr><h2 id="低阶行列式"><a href="#低阶行列式" class="headerlink" title="低阶行列式"></a>低阶行列式</h2><h3 id="二阶行列式"><a href="#二阶行列式" class="headerlink" title="二阶行列式"></a>二阶行列式</h3><p>二阶行列式是这么定义的，交叉相乘，之后相减：</p><script type="math/tex; mode=display">\begin{vmatrix}a_{11}&a_{12}\\a_{21}&a_{22}\end{vmatrix}=a_{11}a_{22}-a_{12}a_{21}</script><p>再看刚才二元一次方程组的解：</p><script type="math/tex; mode=display">\begin{cases}     x_1=\displaystyle \frac{b_1a_{22}-a_{12}b_2}{a_{11}a_{22}-a_{12}a_{21}}\\     \quad \\     x_2=\displaystyle \frac{b_2a_{11}-a_{21}b_1}{a_{11}a_{22}-a_{12}a_{21}} \end{cases}</script><p>解的分母都是：</p><script type="math/tex; mode=display">a_{11}a_{22}-a_{12}a_{21}</script><p>带入行列式的规则，可以表示为</p><script type="math/tex; mode=display">\begin{vmatrix}a_{11}&a_{12}\\a_{21}&a_{22}\end{vmatrix}</script><p>而分子也可以表示为</p><script type="math/tex; mode=display">b_1a_{22}-a_{12}b_2=\begin{vmatrix}b_1&a_{12}\\b_2&a_{22}\end{vmatrix}</script><script type="math/tex; mode=display">b_2a_{11}-a_{21}b_1=\begin{vmatrix}a_{11}&b_1\\a_{21}&b_2\end{vmatrix}</script><p>而线性方程组的解可以用行列式来表示</p><script type="math/tex; mode=display">\begin{cases}     x_1=\displaystyle \frac{b_1a_{22}-a_{12}b_2}{a_{11}a_{22}-a_{12}a_{21}}\\     \quad \\     x_2=\displaystyle \frac{b_2a_{11}-a_{21}b_1}{a_{11}a_{22}-a_{12}a_{21}} \end{cases}\Longleftrightarrow \begin{cases}     x_1=\displaystyle \frac{\begin{vmatrix}b_1&a_{12}\\b_2&a_{22}\end{vmatrix}}{\begin{vmatrix}a_{11}&a_{12}\\a_{21}&a_{22}\end{vmatrix}}\\     \quad\\     x_2=\displaystyle \frac{\begin{vmatrix}a_{11}&b_1\\a_{21}&b_2\end{vmatrix}}{\begin{vmatrix}a_{11}&a_{12}\\a_{21}&a_{22}\end{vmatrix}}     \end{cases}</script><hr><h3 id="三阶行列式"><a href="#三阶行列式" class="headerlink" title="三阶行列式"></a>三阶行列式</h3><p>三阶行列式的定义比较复杂，可以用对角线法则定义</p><script type="math/tex; mode=display">\underbrace{\begin{vmatrix}a_{11}&a_{12}&a_{13}\\a_{21}&a_{22}&a_{23}\\a_{31}&a_{32}&a_{33}\end{vmatrix}}_{三阶行列式} =\underbrace{a_{11}a_{22}a_{33}+a_{12}a_{23}a_{31}+a_{13}a_{21}a_{32}-a_{11}a_{23}a_{32}-a_{12}a_{21}a_{33}-a_{13}a_{22}a_{31}}_{运算规则}</script><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/%E4%B8%8B%E8%BD%BD.png" style="zoom:80%;" /></p><p>三元方程组的解同样也可以通过行列式来表示</p><script type="math/tex; mode=display">x_1=\frac{\begin{vmatrix}b_1&a_{12}&a_{13}\\ b_2&a_{22}&a_{23}\\b_3&a_{32}&a_{33}\end{vmatrix}} {\begin{vmatrix}a_{11}&a_{12}&a_{13}\\a_{21}&a_{22}&a_{23}\\a_{31}&a_{32}&a_{33}\end{vmatrix}}\quad x_2=\frac{\begin{vmatrix}a_{11}&b_1&a_{13}\\ a_{21}&b_2&a_{32}\\a_{31}&b_3&a_{33}\end{vmatrix}} {\begin{vmatrix}a_{11}&a_{12}&a_{13}\\a_{21}&a_{22}&a_{23}\\a_{31}&a_{32}&a_{33}\end{vmatrix}}\quad x_3=\frac{\begin{vmatrix}a_{11}&a_{12}&b_1\\ a_{21}&a_{22}&b_2\\a_{31}&a_{32}&b_3\end{vmatrix}} {\begin{vmatrix}a_{11}&a_{12}&a_{13}\\a_{21}&a_{22}&a_{23}\\a_{31}&a_{32}&a_{33}\end{vmatrix}}</script><hr><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><p>把$n$个不同的元素排成一列，叫做这$n$元素的全排列（简称排列)。</p><p>数列$1,2,3$的全排列就有以下6种</p><script type="math/tex; mode=display">1,2,3\quad 1,3,2\quad 2,1,3 \quad 2,3,1\quad 3,1,2\quad 3,2,1</script><hr><h3 id="逆序数"><a href="#逆序数" class="headerlink" title="逆序数"></a>逆序数</h3><p>规定数列从小到大为正序，否则为逆序，在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个逆序。一个排列中逆序的总数就称为这个排列的<strong>逆序数</strong>。</p><p>比如数列$3,2,5,4,1$的逆序数为1+1+4=6</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/img.png" alt="img" style="zoom:80%;" /></p><hr><h3 id="奇排列和偶排列"><a href="#奇排列和偶排列" class="headerlink" title="奇排列和偶排列"></a>奇排列和偶排列</h3><p>逆序数为奇数的排列称为<strong>奇排列</strong>，逆序数为偶数的排列称为<strong>偶排列</strong>。</p><blockquote><p>一个排列中任意的两个元素对换，排列改变奇偶性。</p></blockquote><p>以三阶行列式为例：</p><script type="math/tex; mode=display">\begin{vmatrix}a_{11}&a_{12}&a_{13}\\a_{21}&a_{22}&a_{23}\\a_{31}&a_{32}&a_{33}\end{vmatrix} =a_{11}a_{22}a_{33}+a_{12}a_{23}a_{31}+a_{13}a_{21}a_{32}-a_{11}a_{23}a_{32}-a_{12}a_{21}a_{33}-a_{13}a_{22}a_{31}</script><p>观察每一项的下标，下标第一项都是以$1,2,3$排列，而第二项是$1,2,3$的全排列</p><script type="math/tex; mode=display">\begin{aligned} a_{1{\color{red}1}}a_{2{\color{red}2}}a_{3{\color{red}3}}&&1,2,3\implies t=0&&(-1)^t=+1\\ -a_{1{\color{red}1}}a_{2{\color{red}3}}a_{3{\color{red}2}}&&1,3,2\implies t=1&&(-1)^t=-1\\ -a_{1{\color{red}2}}a_{2{\color{red}1}}a_{3{\color{red}3}}&&2,1,3\implies t=1&&(-1)^t=-1\\ a_{1{\color{red}2}}a_{2{\color{red}3}}a_{3{\color{red}1}}&&2,3,1\implies t=2&&(-1)^t=+1\\ a_{1{\color{red}3}}a_{2{\color{red}1}}a_{3{\color{red}2}}&&3,1,2\implies t=2&&(-1)^t=+1\\ -a_{1{\color{red}3}}a_{2{\color{red}2}}a_{3{\color{red}1}}&&3,2,1\implies t=3&&(-1)^t=-1 \end{aligned}</script><p>如果是奇排列，那么带负号，如果是偶排列，则不带</p><p>三阶行列式有如下表示</p><script type="math/tex; mode=display">\begin{vmatrix}a_{11}&a_{12}&a_{13}\\a_{21}&a_{22}&a_{23}\\a_{31}&a_{32}&a_{33}\end{vmatrix}=\sum (-1)^t a_{1p_1}a_{2p_2}a_{3p_3}</script><p>其中 $t$ 表示排列 $p_1,p_2,p_3$ 的逆序数，$\sum$表示对所有排列求和</p><hr><p>将结论推广到所有的行列式中，$n$阶行列式的定义为：</p><script type="math/tex; mode=display">D=\begin{vmatrix} a_{11}&a_{12}&\cdots&a_{1n}\\ a_{21}&a_{22}&\cdots&a_{2n}\\ \vdots&\vdots&\quad&\vdots\\ a_{n1}&a_{n2}&\cdots&a_{nn} \end{vmatrix}</script><p>其值为</p><script type="math/tex; mode=display">D=\sum(-1)^ta_{1p_1}a_{2p_2}\cdots a_{np_n}</script><p>全排列的意义在于可以求解$n$($n&gt;3$)阶行列式，特定项的系数，比如$4$阶行列式里$x^4$项的系数</p><hr><h2 id="克拉默法则"><a href="#克拉默法则" class="headerlink" title="克拉默法则"></a>克拉默法则</h2><p>观察三元方程组的解</p><script type="math/tex; mode=display">x_1=\frac{\begin{vmatrix}b_1&a_{12}&a_{13}\\ b_2&a_{22}&a_{23}\\b_3&a_{32}&a_{33}\end{vmatrix}} {\begin{vmatrix}a_{11}&a_{12}&a_{13}\\a_{21}&a_{22}&a_{23}\\a_{31}&a_{32}&a_{33}\end{vmatrix}}\quad x_2=\frac{\begin{vmatrix}a_{11}&b_1&a_{13}\\ a_{21}&b_2&a_{32}\\a_{31}&b_3&a_{33}\end{vmatrix}} {\begin{vmatrix}a_{11}&a_{12}&a_{13}\\a_{21}&a_{22}&a_{23}\\a_{31}&a_{32}&a_{33}\end{vmatrix}}\quad x_3=\frac{\begin{vmatrix}a_{11}&a_{12}&b_1\\ a_{21}&a_{22}&b_2\\a_{31}&a_{32}&b_3\end{vmatrix}} {\begin{vmatrix}a_{11}&a_{12}&a_{13}\\a_{21}&a_{22}&a_{23}\\a_{31}&a_{32}&a_{33}\end{vmatrix}}</script><p>可以看到如下规律：</p><ul><li>分母都是系数组成的行列式</li><li>分子也是系数组成的行列式，只是对应于不同的$x_i$，第$i$列被替换为了常数项</li></ul><p>上面的规律推广到$n$元线性方程组的话，就是克拉默法则：</p><p>如果有$n$个未知数，$n$个方程组组成的线性方程式，他的系数矩阵$A$的行列式不等于0，即</p><script type="math/tex; mode=display">|A|=\begin{vmatrix}a_{11}&\cdots&a_{1n}\\\vdots&&\vdots\\ a_{n1}&\cdots&a_{nn}\end{vmatrix}\neq 0</script><p>则方程组有唯一解：</p><script type="math/tex; mode=display">\displaystyle x_1=\frac{|A_1|}{|A|}\quad x_2=\frac{|A_2|}{|A|}\quad...\quad x_n=\frac{|A_n|}{|A|}</script><p>其中$A_j$是把系数矩阵$A$中的第$j$元素用方程组右端的常数项代替后所得到的$n$阶矩阵</p><script type="math/tex; mode=display">A_j=\begin{pmatrix} a_{11}&\cdots&a_{1,j-1}&{\color{red}{b_1}}&a_{1,j+1}&\cdots&a_{1n}\\ \vdots&&\vdots&{\color{red}{\vdots}}&\vdots&&\vdots\\ a_{n1}&\cdots&a_{n,j-1}&{\color{red}{b_n}}&a_{n,j+1}&\cdots&a_{nn} \end{pmatrix}</script><hr><h2 id="几何意义"><a href="#几何意义" class="headerlink" title="几何意义"></a>几何意义</h2><p>行列式除了是一种运算法则外，更重要的意义是：对于某方阵$A$，它的行列式$|A|$,是列向量矩阵函数$Ax=y$的<strong>伸缩比例</strong></p><p>伸缩比例的意思是变换后和变换前的<strong>有向面积</strong>之比，假设有二阶方阵$A_2$，和行列式$|A_2|$​</p><script type="math/tex; mode=display">\boldsymbol{A}_2= \begin{pmatrix} a_{11}&a_{12}\\ a_{21}&a_{22} \end{pmatrix},\quad |\boldsymbol{A}_2|= \begin{vmatrix} a_{11}&a_{12}\\ a_{21}&a_{22} \end{vmatrix}</script><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220711103236179.png" alt="image-20220711103236179"></p><p>映射前和映射后面积之比，就是伸缩比例</p><p>行列式的值有三种情况：</p><ul><li>$|A_2|&gt;0$</li><li>$|A_2|=0$</li><li>$|A_2|&lt;0$</li></ul><p>当$|A_2|&gt;0$时，会导致映射图形正向伸缩</p><p>当$|A_2|=0$，会导致维度降低，实际上只有$A$不满秩，$|A|=0$</p><blockquote><p>显然，如果行列式为0，则$A$不满秩=$A$不可逆=$A$中的向量线性相关</p></blockquote><p>当$|A_2|&lt;0$时，会导致映射图形反向伸缩</p><hr><p>对于二阶行列式，其在变换前的基是自然基$e_1,e_2$，而变换后，$e_1,e_2$被映射成了$c_1,c_2$，即：</p><script type="math/tex; mode=display">\boldsymbol{A}_2\boldsymbol{e_1}=\boldsymbol{c_1},\quad \boldsymbol{A}_2\boldsymbol{e_2}=\boldsymbol{c_2}</script><p>也就是说$e_1,e_2$围成的正方形被映射成了$c_1,c_2$围成的平行四边形：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220711105203990.png" alt="image-20220711105203990"></p><p>可以算出$c_1,c_2$围成的平行四边形的有向面积就是二阶行列式：</p><script type="math/tex; mode=display">\boldsymbol{c_1}、\boldsymbol{c_2}围成的平行四边形的有向面积\ =\ |\boldsymbol{A}_2|</script><p>而到了三阶行列式，面积之比会变为有向体积之比</p><hr><h2 id="子式和余子式"><a href="#子式和余子式" class="headerlink" title="子式和余子式"></a>子式和余子式</h2><h3 id="子式"><a href="#子式" class="headerlink" title="子式"></a>子式</h3><p>在$m×n$矩阵$A$中，任取$k$行与$k$列，位于这些行，列交叉处的$k^2$个元素，不改变它们在$A$中所处的位置次序而得的$k$阶行列式，称为矩阵$A$的$k$阶子式</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220711120857415.png" alt="image-20220711120857415"></p><p>取一，三行和一，四列构成的行列式就是矩阵的一个子式</p><hr><h3 id="主子式"><a href="#主子式" class="headerlink" title="主子式"></a>主子式</h3><p>如果选取的行号和列号相同，取出来的子式就是<strong>主子式</strong>，如果取$n$阶矩阵的前$n$行$n$列，取出来的子式就是<strong>顺序主子式</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220711121230852.png" alt="image-20220711121230852"></p><p>而教科书中，是如此定义矩阵的秩的：</p><p>设在矩阵$A$中有一个不等于0的$r$阶子式$|B_r|$，且所有$r+1$阶子式全等于0，那么$|B_r|$称为矩阵$A$的最高阶非零子式，数$r$称为矩阵$A$的秩</p><blockquote><p>如果一个行列式对应的矩阵（方阵）不是满秩矩阵，则这个行列式的值为0</p></blockquote><hr><h3 id="余子式"><a href="#余子式" class="headerlink" title="余子式"></a>余子式</h3><p>在$n$阶行列式中，把$a_{ij}$所在的第$i$行和第$j$列划去后，留下来的$n-1$阶行列式叫做$a_{ij}$的余子式，记作$M_{ij}$</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220711122000405.png" alt="image-20220711122000405"></p><p>实际上在之前提到三阶行列式的计算方法中，就有余子式</p><script type="math/tex; mode=display">\begin{aligned} \begin{vmatrix}a_{11}&a_{12}&a_{13}\\a_{21}&a_{22}&a_{23}\\a_{31}&a_{32}&a_{33}\end{vmatrix} &=a_{11}\overbrace{\begin{vmatrix}a_{22}&a_{23}\\a_{32}&a_{33}\end{vmatrix}}^{a_{11}\text{的余子式}}-a_{21}\overbrace{\begin{vmatrix}a_{12}&a_{13}\\a_{32}&a_{33}\end{vmatrix}}^{a_{21}\text{的余子式}}+a_{31}\overbrace{\begin{vmatrix}a_{12}&a_{13}\\a_{22}&a_{23}\end{vmatrix}}^{a_{31}\text{的余子式}}\\ \\ &=a_{11}\boldsymbol{M}_{11}-a_{21}\boldsymbol{M}_{21}+a_{31}\boldsymbol{M}_{31} \end{aligned}</script><hr><p>在余子式的基础上，还可以定义$A_{ij}$，称为$a_{ij}$的代数余子式</p><script type="math/tex; mode=display">A_{ij}=(-1)^{i+j}M_{ij}</script><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220711122434314.png" alt="image-20220711122434314"></p><p>总结：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220711122527190.png" alt="image-20220711122527190"></p><hr><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ol><li><p>转置后行列式的值不变</p><p>记</p><script type="math/tex; mode=display">D= \begin{vmatrix} a_{11}&a_{12}&\cdots&a_{1n}\\ a_{21}&a_{22}&\cdots&a_{2n}\\ \vdots&\vdots&\quad&\vdots\\ a_{n1}&a_{n2}&\cdots&a_{nn} \end{vmatrix}, D^\mathrm{T}= \begin{vmatrix} a_{11}&a_{21}&\cdots&a_{n1}\\ a_{12}&a_{22}&\cdots&a_{n2}\\ \vdots&\vdots&\quad&\vdots\\ a_{1n}&a_{2n}&\cdots&a_{nn} \end{vmatrix}</script><p>其中行列式$D^T$称为行列式$D$的转置行列式</p><p>有如下结论 </p><script type="math/tex; mode=display">|D|=|D^T|</script><p>因为行列式$|A|$和$|A^T|$代表的是同一个映射，所以不变</p></li><li><p>某行（列）有公因数$k$，可以直接把$k$提出来</p><script type="math/tex; mode=display">D=\begin{vmatrix} ka_{11}&ka_{12}&\cdots&ka_{1n} \end{vmatrix}=k\begin{vmatrix} a_{11}&a_{12}&\cdots&a_{1n} \end{vmatrix}</script></li><li><p>两行（列）互换，行列式的值变号</p><script type="math/tex; mode=display">D=\begin{vmatrix}a_{11}&a_{12}&\cdots&a_{1n}\\a_{21}&a_{22}&\cdots&a_{2n}\end{vmatrix}=-\begin{vmatrix}a_{21}&a_{22}&\cdots&a_{2n}\\a_{11}&a_{12}&\cdots&a_{1n}\end{vmatrix}</script><p>可以从逆序数的角度理解，如果两行互换了，那么其每一项的逆序数都会反号，即减数变成被减数，被减数变成减数，则最后行列式的值会变号</p><blockquote><p>根据此性质，可以得出，如果行列式中有两行（列）相同，那么行列式的值为0，即交换(相等的)两行，|A| = -|A|，则|A| = 0</p></blockquote></li><li><p>对于$n$阶方阵$\boldsymbol{A}$，反复运用“行列式的数乘”可得：</p><script type="math/tex; mode=display">|k\boldsymbol{A}|=\begin{vmatrix}    {\color {blue}k}a_{11}&{\color {blue}k}a_{12}&\dots&{\color {blue}k}a_{1n}\\    \vdots &\vdots &\ddots &\vdots\\    {\color {blue}k}a_{i1}&{\color{blue}k}a_{i2}&\dots&{\color{blue}k}a_{in}\\    \vdots &\vdots &\ddots &\vdots \\    {\color {blue}k}a_{n1}&{\color {blue}k}a_{n2}&\dots &{\color {blue}k}a_{nn}\end{vmatrix}=k^n|\boldsymbol{A}|</script></li><li><p>如果行列式某行（列）每一项都是两个数的和，则可以把行列式拆成两个行列式之和</p><script type="math/tex; mode=display">\begin{vmatrix}a_{1}+b_{1}&a_{2}+b_{2}&a_{3}+b_{3}\\c_1&c_{2}&c_{3}\\d_{1}&d_{2}&d_{3}\end{vmatrix}=\begin{vmatrix}a_{1}&a_{2}&a_{3}\\c_1&c_{2}&c_{3}\\d_{1}&d_{2}&d_{3}\end{vmatrix}+\begin{vmatrix}b_{1}&b_{2}&b_{3}\\c_1&c_{2}&c_{3}\\d_{1}&d_{2}&d_{3}\end{vmatrix}</script><p>从展开式理解，每一项都会有$a_i+b_i$，所以可以拆开再合并同类项</p></li><li><p>把某行（列）的$k$倍加到另外一行，行列式的值不变</p><script type="math/tex; mode=display">D=\begin{vmatrix}a_{1}&a_{2}&a_{3}\\b_{1}&b_{2}&b_{3}\end{vmatrix}=\begin{vmatrix}a_{1}&a_{2}&a_{3}\\b_{1}+ka_1&b_{2}+ka_2&b_{3}+ka_3\end{vmatrix}</script><p>可以通过性质2,3,4来证明</p><script type="math/tex; mode=display">\begin{vmatrix}a_{1}&a_{2}&a_{3}\\b_{1}+ka_1&b_{2}+ka_2&b_{3}+ka_3\end{vmatrix}=\begin{vmatrix}a_{1}&a_{2}&a_{3}\\b_{1}&b_{2}&b_{3}\end{vmatrix}+k\begin{vmatrix}a_{1}&a_{2}&a_{3}\\a_1&a_2&a_3\end{vmatrix}</script><p>而</p><script type="math/tex; mode=display">k\begin{vmatrix}a_{1}&a_{2}&a_{3}\\a_1&a_2&a_3\end{vmatrix}=0</script><p>所以性质成立</p></li><li><p>对于同阶方阵$A$,$B$，有：</p><script type="math/tex; mode=display">|\boldsymbol{A}\boldsymbol{B}|=|\boldsymbol{A}||\boldsymbol{B}|</script></li></ol><hr><h3 id="三角行列式"><a href="#三角行列式" class="headerlink" title="三角行列式"></a>三角行列式</h3><script type="math/tex; mode=display">|\boldsymbol{A}|= \begin{vmatrix} a_{11}&&&\\ a_{21}&a_{22}&&0\\ \vdots &\vdots &\ddots &\\ a_{n1}&a_{n2}&\dots &a_{nn} \end{vmatrix} = a_{11}a_{22}\cdots a_{nn}</script><p>而对于反三角行列式：</p><script type="math/tex; mode=display">|\boldsymbol{A}|=\begin{vmatrix}&&&\lambda_1\\&&\lambda_2&\\&\mathstrut^{.^{.^{.}}}&&\\ \lambda_n&&&\end{vmatrix}</script><p>将行列式$|A|$的第$n$列和$n-1$列对换，再将$n-1$列和$n-2$列对换，以此类推，经过$n-1$次列变换，可以将第$n$列换到了第一列，得到如下行列式：</p><script type="math/tex; mode=display">|\boldsymbol{A}_1|=\begin{vmatrix}\lambda_1&\cdots&0&0&\\ 0&\cdots&0&\lambda_2&\\ 0&\cdots&\lambda_3&0&\\ \vdots&&\vdots&\vdots&\\ 0&\lambda_n&0&\cdots&\end{vmatrix}</script><p>根据上文提到的行列式对换性质，每换一次，正负号都会发生改变，这里对换了$n-1$次，所以：</p><script type="math/tex; mode=display">|\boldsymbol{A}_1|=(-1)^{n-1}|\boldsymbol{A}|</script><p>按上面的方法，将$|A_1|$j进行$n-2$次对换，将第$n$列换到第二列，以此类推，最终可以将反三角行列式换成三角行列式</p><p>一共发生了：$(n-1)+(n-2)+\cdots+1=\frac{1}{2}n(n-1)$对换</p><p>所以：</p><script type="math/tex; mode=display">|\boldsymbol{A}|=(-1)^{\frac{1}{2}n(n-1)}|\boldsymbol{A}_{n-1}|=(-1)^{\frac{1}{2}n(n-1)}\lambda_1\lambda_2\cdots\lambda_n</script><hr><p>应用到分块矩阵上：</p><script type="math/tex; mode=display">\boldsymbol{A}=\begin{pmatrix}\boldsymbol{B}&\boldsymbol{O}\\\boldsymbol{C}&\boldsymbol{D}\end{pmatrix}</script><p>则有：</p><script type="math/tex; mode=display">|\boldsymbol{A}|=|\boldsymbol{B}||\boldsymbol{D}|</script><script type="math/tex; mode=display">\boldsymbol{A}=\begin{pmatrix}\boldsymbol{B}&\boldsymbol{C}\\\boldsymbol{D}&\boldsymbol{O}\end{pmatrix}</script><p>则有：</p><script type="math/tex; mode=display">|\boldsymbol{A}|=(-1)^{mn}|\boldsymbol{C}||\boldsymbol{D}|</script><p>可以将此分块矩阵换成之前的形式，总共要经历$m×n$次交换</p><hr><h3 id="拉普拉斯展开"><a href="#拉普拉斯展开" class="headerlink" title="拉普拉斯展开"></a>拉普拉斯展开</h3><p>$n$阶方阵$A=(a{ij})$的行列式可以表示为该方阵$A$的某一行的各元素和其对应的代数余子式乘积之和</p><script type="math/tex; mode=display">|\boldsymbol{A}|=a_{i1}A_{i1}+a_{i2}A_{i2}+...+a_{in}A_{in}\quad (i=1,2,...,n)</script><p>或者说是某一列和其代数余子式的乘积之和：</p><script type="math/tex; mode=display">|\boldsymbol{A}|=a_{1j}A_{1j}+a_{2j}A_{2j}+...+a_{nj}A_{nj}\quad (j=1,2,...,n)</script><p>这种计算行列式的方法是<strong>拉普拉斯展开</strong></p><p>根据拉普拉斯展开，可以得到以下推论：</p><script type="math/tex; mode=display">a_{j1}A_{i1}+a_{j2}A_{i2}+...+a_{jn}A_{in}=0\quad (i\neq j)</script><p>就是说如果在某行的代数余子式前的系数刚好是另一行或列的系数，那么最后的结果为0</p><hr><h2 id="范德蒙行列式"><a href="#范德蒙行列式" class="headerlink" title="范德蒙行列式"></a>范德蒙行列式</h2><script type="math/tex; mode=display">|\boldsymbol{A}|=\begin{vmatrix} 1&1&1&\cdots&1\\ x_1&x_2&x_3&\cdots&x_n\\ x_1^2&x_2^2&x_3^2&\cdots&x_n^2\\ \vdots &\vdots&\vdots&\ddots&\vdots\\ x_1^{n-1}&x_2^{n-1}&x_3^{n-1}&\cdots&x_n^{n-1} \end{vmatrix} = \displaystyle \prod_{1\leq j < i \leq n}(x_i-x_j)</script><p>其中$\displaystyle \prod_{1\leq j &lt; i \leq n}(x_i-x_j)$代表连乘</p><p>范德蒙行列式主要是为了解决<strong>插值问题</strong>，即通过离散的数据求未知数据</p><p>通过假设曲线的方程组，类似于$y=a_0+a_1x+a_2x^2+a_3x^3$的形式，然后通过列出方程组的系数矩阵，矩阵的形式就是范德蒙行列式，最后利用克拉默法则求解</p><hr><h2 id="伴随矩阵"><a href="#伴随矩阵" class="headerlink" title="伴随矩阵"></a>伴随矩阵</h2><p>除了初等行变换以及高斯若尔当法之后，还可以通过行列式来求矩阵：</p><p>由$|A|$的代数余子式$A_{ij}$所构成的矩阵，称为$A$的代数余子式矩阵：</p><script type="math/tex; mode=display">\boldsymbol{C}= \begin{pmatrix} A_{11}&A_{12}&\cdots&A_{1n}\\ A_{21}&A_{22}&\cdots&A_{2n}\\ \vdots&\vdots&\ddots&\vdots\\ A_{n1}&A_{n2}&\cdots&A_{nn} \end{pmatrix}</script><p><strong>其转置称为$A$的伴随矩阵</strong>，记作$A^*$</p><script type="math/tex; mode=display">\boldsymbol{A}^{*}=\boldsymbol{C}^\mathrm{T}= \begin{pmatrix} A_{11}&A_{21}&\cdots&A_{n1}\\ A_{12}&A_{22}&\cdots&A_{n2}\\ \vdots&\vdots&\ddots&\vdots\\ A_{1n}&A_{2n}&\cdots&A_{nn} \end{pmatrix}</script><p>根据可逆和行列式的关系，若$|A|≠0$，则矩阵可逆，可证明：</p><script type="math/tex; mode=display">\boldsymbol{A}^{-1}=\frac{1}{|\boldsymbol{A}|}\boldsymbol{A}^{*}</script><div class="hide-toggle" style="border: 1px solid #66c3ee"><div class="hide-button toggle-title" style="background-color: #66c3ee;color: black"><i class="fas fa-caret-right fa-fw"></i><span>证明过程</span></div>    <div class="hide-content"><p>证明过程如下：</p><p>设$A=(a_{ij})$，记$AA^*=(b_{ij})$，</p><p>其中$A$的行向量可表示为：$(a_{i1},a_{i2},\cdots,a_{in})$，$A^*$的$j$列为列向量$\begin{pmatrix}A_{j1}\\A_{j2}\\\vdots\\A_{jn}\end{pmatrix}$所以：</p><script type="math/tex; mode=display">b_{ij}=a_{i1}A_{j1}+a_{i2}A_{j2}+...+a_{in}A_{jn}</script><p>根据拉普拉斯展开，代数余子式乘其他行的值为0</p><script type="math/tex; mode=display">b_{ij}=a_{i1}A_{j1}+a_{i2}A_{j2}+...+a_{in}A_{jn}= \begin{cases}|\boldsymbol{A}|,\quad i=j\\ 0, \quad i\neq j\end{cases}</script><p>所以最后的结果是</p><script type="math/tex; mode=display">\boldsymbol{A}\boldsymbol{A}^{*}=\begin{pmatrix}|\boldsymbol{A}|&0&\cdots&0\\ 0&|\boldsymbol{A}|&\cdots&0\\ \vdots&\vdots&\ddots&\vdots\\ 0&0&\cdots&|\boldsymbol{A}| \end{pmatrix}=|\boldsymbol{A}|\boldsymbol{I}</script><p>故：</p><script type="math/tex; mode=display">\frac{1}{|\boldsymbol{A}|}\boldsymbol{A}^{*}\boldsymbol{A}=\boldsymbol{I}</script><p>所以</p><script type="math/tex; mode=display">\boldsymbol{A}^{-1}=\frac{1}{|\boldsymbol{A}|}\boldsymbol{A}^{*}</script></div></div><hr><h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h3><p>伴随矩阵行列式和原矩阵行列式关系：</p><script type="math/tex; mode=display">AA^*=|A|E</script><p>如果$A$可逆，那么$A^*=|A|A^{-1}$，则：</p><script type="math/tex; mode=display">|A^*|=||A|A^{-1}|=|A|^{n}|A^{-1}|=|A|^{n-1}</script><p>多个矩阵的伴随矩阵：</p><script type="math/tex; mode=display">(AB)^{*}=B^*A^*</script><p>如果$A_{ij}=a_{ij}$，那么$A^*=A^T$</p><hr><p>设$\boldsymbol{A}$为$n$阶方阵，则：</p><ul><li><p>$rank(\boldsymbol{A})=n\iff rank(\boldsymbol{A}^*)=n$</p></li><li><p>$rank(\boldsymbol{A})=n-1\iff rank(\boldsymbol{A}^*)=1<br>$</p></li><li><p>$rank(\boldsymbol{A}) &lt; n-1\iff rank(\boldsymbol{A}^*) = 0$</p></li></ul><blockquote><p>根据秩的定义：设在矩阵$A$中有一个不等于0的$r$阶子式$|B_r|$，且所有$r+1$阶子式全等于0，那么$|B_r|$称为矩阵$A$的最高阶非零子式，数$r$称为矩阵$A$的秩</p><p>如果矩阵$A$满秩，那么$n$阶子式也满秩，所以$rank(\boldsymbol{A})=n\iff rank(\boldsymbol{A}^*)=n$</p><p>如果矩阵$rank(\boldsymbol{A})=n-1$，说明必有$n-1$阶子式非0，那么其代数余子式也非0，根据$A^*$的定义，其必不为0，又根据秩零定理，其秩必为1</p><p>如果$rank(A)&lt;n-1$，说明$n-1$阶子式全部为0，那么$A^*$就肯定是零矩阵$O$了</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统大题解析</title>
      <link href="/post/24355.html"/>
      <url>/post/24355.html</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统大题解析"><a href="#操作系统大题解析" class="headerlink" title="操作系统大题解析"></a>操作系统大题解析</h1><h2 id="进程同步问题"><a href="#进程同步问题" class="headerlink" title="进程同步问题"></a>进程同步问题</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>首先需要知道的是，进程同步问题大多都是从信号量机制出发，考查对一段程序进行PV操作</p><p>在阅读题目时，一定要想信号量机制的应用,找出并标记出来</p><ul><li>互斥问题</li><li>同步问题</li><li>前驱关系</li></ul><p>如同典型例题一样，PV问题分为3种：</p><p>生产者–消费者问题</p><p>步骤如下：</p><ol><li>确定有几类进程，每个进程对应一个函数</li><li>在函数内部，用中文描述动作（注意是只做一次or不断重复）</li><li>在做动作之前，是否需要进行P操作，如果要进行P操作，则同时把V操作也添加上去</li><li>所有的PV操作写完后，再去定义信号量</li><li>检查多个P操作是否会导致死锁</li></ol><div class="note primary flat"><p>一般来说，就是注意缓冲区的容量的信号量empty，和相关产品的信号量</p></div><hr><p>哲学家进餐问题</p><p>哲学家进餐问题有多种思路，最简单的思路就是：直接一次性拿走所有资源，然后判断是否满足条件，如果满足，则解锁，跳出while循环，如果不满足，则解锁，再进行while循环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Semophore Lock=<span class="number">1</span>;<span class="comment">//1. 定义互斥信号量</span></span><br><span class="line"><span class="keyword">int</span> a,b,c=XX;  <span class="comment">//2. 定义资源数int</span></span><br><span class="line"> Process()&#123;    <span class="comment">//3. 一口气拿所有资源</span></span><br><span class="line">     <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">         P(lock);</span><br><span class="line">         <span class="keyword">if</span>(所有资源都够)&#123;</span><br><span class="line">             所有资源<span class="keyword">int</span>值减少</span><br><span class="line">             取XXX资源</span><br><span class="line">             V(lock);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         V(lock)</span><br><span class="line">     &#125;</span><br><span class="line">    做进程该做的事（哲学家进餐）  <span class="comment">//4. 完成任务</span></span><br><span class="line">    P(lock);</span><br><span class="line">    归还所用资源，所有资源<span class="keyword">int</span>值增加    <span class="comment">//5.归还资源</span></span><br><span class="line">    V(lock);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><hr><p>读者–写者问题</p><p>特点是实现同类进程不互斥，异类进程互斥</p><p>实现方法是：第一个用之前负责上锁，最后一个用完之后负责解锁</p><hr><h3 id="408"><a href="#408" class="headerlink" title="408"></a>408</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/T594luQEyhnJgfc.png" alt=""></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>此题很明显的看可以初看，很像是生产者–消费者的变形，区别只是在于生产者生成的东西，只能给部分消费者使用</p><p>所以根据生成的数字，通知相应的进程即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 互斥关系 ：对缓冲区的使用 mutex=1</span></span><br><span class="line"><span class="comment">// 前驱关系：缓冲内有数字，才能取出  odd,even=0</span></span><br><span class="line"><span class="comment">//          缓冲区未满才能往里面放置   empty=N</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">semaphore mutex=<span class="number">1</span>;</span><br><span class="line">semaphore odd=<span class="number">0</span>,even=<span class="number">0</span>;  </span><br><span class="line">sempahore empty=N <span class="comment">// 空位为N</span></span><br><span class="line">    cobegin&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        x=produce();</span><br><span class="line">        P(empty);</span><br><span class="line">        P(mutex);</span><br><span class="line">        Put();</span><br><span class="line">        V(mutex);</span><br><span class="line">        <span class="keyword">if</span>(x%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">            V(even);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            V(odd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Process <span class="title">P2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span><span class="params">(True)</span></span>&#123;</span><br><span class="line">        P(odd);</span><br><span class="line">        P(mutex);</span><br><span class="line">        getodd();</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(empty);</span><br><span class="line">        countodd();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Process <span class="title">P3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span><span class="params">(True)</span></span>&#123;</span><br><span class="line">        P(even);</span><br><span class="line">        P(mutex);</span><br><span class="line">        geteven();</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(empty);</span><br><span class="line">        countodd();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/hJyaWC9K5FVXj8s.png" alt="image-20210813162810061"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>仅有一个进程，自然就没有进程之间的同步问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 互斥关系：对门的使用 mutex=1</span></span><br><span class="line"><span class="comment">// 前驱关系：只有博物馆人数未满才能进门  num=500</span></span><br><span class="line"></span><br><span class="line">cobegin</span><br><span class="line">    参观者进程i&#123;</span><br><span class="line">    P(num);  <span class="comment">//1. 进门前首先得有人，最多进500个人</span></span><br><span class="line">    P(mutex);  </span><br><span class="line">    进门</span><br><span class="line">    V(mutex);  </span><br><span class="line">    参观</span><br><span class="line">    P(mutex);</span><br><span class="line">    出门</span><br><span class="line">    V(mutex); </span><br><span class="line">    V(num);  <span class="comment">// 1.出门后人数才加</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/AgXWN1jFMSObaUf.png" alt="image-20210813163352677"></p><hr><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//互斥关系：对取号机的使用   mutex=1</span></span><br><span class="line"><span class="comment">//前驱关系：必须有位置，顾客才能坐下  seat=10</span></span><br><span class="line"><span class="comment">//         必须有顾客，营业员才能服务  cos=0</span></span><br><span class="line"><span class="comment">//同步关系：顾客被叫到服务和营业员叫顾客服务之间的同步 service=0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cobegin()&#123;</span><br><span class="line">    Process 顾客</span><br><span class="line">    &#123;</span><br><span class="line">        P(seat);  <span class="comment">// 1.得有位置才能坐下</span></span><br><span class="line">        P(mutex);</span><br><span class="line">        取号</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(<span class="built_in">cos</span>);     <span class="comment">//2.取了号，顾客+1</span></span><br><span class="line">        P(servive);   <span class="comment">//3.要开始服务了</span></span><br><span class="line">        接受服务</span><br><span class="line">    &#125;</span><br><span class="line">    Process 营业员</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(True)&#123;</span><br><span class="line">            P(<span class="built_in">cos</span>);      <span class="comment">//2. 等待顾客</span></span><br><span class="line">            V(seat);   <span class="comment">//1. 顾客去接受服务，就多了一个座位</span></span><br><span class="line">            叫号</span><br><span class="line">            V(service);  <span class="comment">//3.结束服务</span></span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;coend</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/Ek6pm3DJOGatjWZ.png" alt="image-20210813164949915"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>在原来的消费者生产者问题上，新加了一个限制条件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//互斥问题：对缓冲区的使用 mutex1=1</span></span><br><span class="line"><span class="comment">//         消费者之间的互斥 mutex2=1</span></span><br><span class="line"><span class="comment">//前驱关系：缓冲区必须有空，才能往里面放东西 empty=1000</span></span><br><span class="line"><span class="comment">//         缓冲区必须有产品，才能从里面拿东西 product=0</span></span><br><span class="line">producer()[</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        produce();</span><br><span class="line">        P(empty);</span><br><span class="line">        P(mutex2);</span><br><span class="line">        input;</span><br><span class="line">        V(mutex2);</span><br><span class="line">        V(product);</span><br><span class="line">    &#125;</span><br><span class="line">    comsumer()&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    P(mutex1)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            P(product);</span><br><span class="line">            P(mutex2);</span><br><span class="line">            output;</span><br><span class="line">            V(mutex2);</span><br><span class="line">            V(empty);</span><br><span class="line">            consumer;</span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex1);        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/mNBflvC7X5ysZWb.png" alt="image-20210813165921622"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相当于是两个生产者和消费者进程</span></span><br><span class="line"><span class="comment">/*互斥关系：对邮箱A和邮箱B的使用 mutex1=1,mutex2=1</span></span><br><span class="line"><span class="comment">  前驱关系:只有邮箱A有邮件才能从里面取出来 fullA=x</span></span><br><span class="line"><span class="comment">          只有邮件A未满才能往里面放邮件   emptyA=M-x</span></span><br><span class="line"><span class="comment">          只有邮箱B有邮件才能从里面取出来 fullB=y</span></span><br><span class="line"><span class="comment">          只有邮件B未满才能往里面放邮件   emptyB=N-y</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">A&#123;</span><br><span class="line">    <span class="keyword">while</span>(True)&#123;</span><br><span class="line">        P(fullA);</span><br><span class="line">        p(mutex1);</span><br><span class="line">        从A的信箱中取出一个邮件</span><br><span class="line">        V(mutex1);</span><br><span class="line">        V(emptyA);</span><br><span class="line">        回答问题并提出一个新问题</span><br><span class="line">        P(emptyB);</span><br><span class="line">        p(mutex2);</span><br><span class="line">        将新邮件放入B的信箱</span><br><span class="line">        V(mutex2);</span><br><span class="line">        V(fullB);</span><br><span class="line">           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">B&#123;</span><br><span class="line">    <span class="keyword">while</span>(True)&#123;</span><br><span class="line">        P(fullB);</span><br><span class="line">        p(mutex2);</span><br><span class="line">        从B的信箱中取出一个邮件</span><br><span class="line">        V(mutex2);</span><br><span class="line">        V(emptyB);</span><br><span class="line">        回答问题并提出一个新问题</span><br><span class="line">        P(emptyA);</span><br><span class="line">        p(mutex1);</span><br><span class="line">        将新邮件放入B的信箱</span><br><span class="line">        V(mutex1);</span><br><span class="line">        V(fullA);</span><br><span class="line">           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/3ZaRLC7ibtxnKXz.png" alt="image-20210813180656033"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>这种程序题首先要搞清楚的就是，修改变量的互斥关系</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只有线程3在修改变量，所以要关注线程12与3的</span></span><br><span class="line"><span class="comment">// 线程1和线程3关于y互斥 mutex1=1</span></span><br><span class="line"><span class="comment">// 线程2和线程3关于y，z互斥 mutex2=1 mutex3=1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">thread1&#123;</span><br><span class="line">    cnum w;</span><br><span class="line">    P(mutex1);</span><br><span class="line">    w=add(x,y);</span><br><span class="line">    V(mutex1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">thread2&#123;</span><br><span class="line">    cnum w;</span><br><span class="line">    P(mutex2);</span><br><span class="line">    P(mutex3);</span><br><span class="line">    w=add(y,z);</span><br><span class="line">    V(mutex3);</span><br><span class="line">    V(mutex2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">thread3&#123;</span><br><span class="line">    cnum w;</span><br><span class="line">    w.a=<span class="number">1</span>;</span><br><span class="line">    w.b=<span class="number">1</span>;</span><br><span class="line">    P(mutex3);</span><br><span class="line">    z=add(z,w);</span><br><span class="line">    V(mutex3);</span><br><span class="line">    P(mutex1);</span><br><span class="line">    P(mutex2);</span><br><span class="line">    y=add(y,w);</span><br><span class="line">    V(mutex1);</span><br><span class="line">    V(mutex2);</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/9HQFDgvl6Zu5SPI.png" alt="image-20210813184313765"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>哲学家问题的变种，解决问题的思路之一就是限制进餐的哲学家人数，从n人变为n-1人</p><ul><li>如果m&lt;n，那么碗(n)的数量就限制了可同时吃饭人的数量</li><li>如果m&gt;n，那么碗(n)至少要是人数-1，即n=m-1才能发挥作用</li></ul><p>所以将碗的数量定义为min(n-1,m)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以碗为核心，让碗的数量不超过n-1</span></span><br><span class="line"><span class="comment">//前驱关系，必须有碗才能吃饭，bowl=min(n-1,m)</span></span><br><span class="line"><span class="comment">//同步关系，必有同时有两只筷子 chopsticks[n]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    chopsticks[i]=<span class="number">1</span>;</span><br><span class="line">bowl=min(n<span class="number">-1</span>,m);</span><br><span class="line"></span><br><span class="line"><span class="function">CoBegin</span></span><br><span class="line"><span class="function"><span class="title">while</span><span class="params">(<span class="literal">true</span>)</span></span>&#123;</span><br><span class="line">    think;</span><br><span class="line">    P(bowl);</span><br><span class="line">    P(chopsticks[i]);</span><br><span class="line">    P(chopsticks[(i+<span class="number">1</span>)%n]);</span><br><span class="line">    就餐;</span><br><span class="line">    V(chopsticks[i]);</span><br><span class="line">    V(chopsticks[(i+<span class="number">1</span>)%n]);</span><br><span class="line">    V(bowl);</span><br><span class="line">&#125;</span><br><span class="line">CoEnd</span><br></pre></td></tr></table></figure></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221208191607063.png" alt="image-20221208191607063"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>PV操作可以控制操作的前后顺序：如果想要A操作在C之前，那么就在C之前加一个P操作，而在A操作之后加一个V操作，这样，C就必要在A之后了</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221208192224565.png" alt="image-20221208192224565"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Semaphore AC=<span class="number">0</span>;</span><br><span class="line">Semaphore BC=<span class="number">0</span>;</span><br><span class="line">Semaphore CE=<span class="number">0</span>;</span><br><span class="line">Semaphore DE=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">A()&#123;</span><br><span class="line">    进行A操作</span><br><span class="line">    V(AC);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">B()&#123;</span><br><span class="line">    进行B操作</span><br><span class="line">    V(BC);</span><br><span class="line">&#125;</span><br><span class="line">C()&#123;</span><br><span class="line">    P(AC);</span><br><span class="line">    P(BC);</span><br><span class="line">    进行c操作</span><br><span class="line">    V(CE);</span><br><span class="line">&#125;</span><br><span class="line">D()&#123;</span><br><span class="line">    进行D操作</span><br><span class="line">    V(DE);</span><br><span class="line">&#125;</span><br><span class="line">E()&#123;</span><br><span class="line">    P(CE);</span><br><span class="line">    P(DE);</span><br><span class="line">    进行E操作</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure></div></div><hr><h3 id="874"><a href="#874" class="headerlink" title="874"></a>874</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221208193431400.png" alt="image-20221208193431400"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>显示是生产者和消费者问题的变形，框中是缓冲区，而球是产品</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Semaphore wb=<span class="number">0</span>;</span><br><span class="line">Semaphore bb=<span class="number">0</span>;</span><br><span class="line">Semaphore empty=<span class="number">2</span>;</span><br><span class="line">Semaphore mutex=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">男教师&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    P(empty);</span><br><span class="line">    P(mutex);</span><br><span class="line">    放白球</span><br><span class="line">    V(mutex);    </span><br><span class="line">    V(wb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">女教师&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    P(empty);</span><br><span class="line">    P(mutex);</span><br><span class="line">    放黑球</span><br><span class="line">    V(mutex);</span><br><span class="line">    V(bb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">男学生&#123;</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">   P(wb);</span><br><span class="line">   P(mutex);</span><br><span class="line">   拿白球</span><br><span class="line">   V(mutex);</span><br><span class="line">   V(empty);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">女学生&#123;</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">   P(bb);</span><br><span class="line">   P(mutex);</span><br><span class="line">   拿黑球</span><br><span class="line">   V(mutex);    </span><br><span class="line">   V(empty); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221208202042340.png" alt="image-20221208202042340"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>和上一道题几乎一样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Semaphore empty=<span class="number">1</span></span><br><span class="line">Semaphore mutex=<span class="number">1</span></span><br><span class="line">Semaphore chao=<span class="number">0</span></span><br><span class="line">Semaphore rice=<span class="number">0</span></span><br><span class="line">    </span><br><span class="line">炒饭师傅&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"> P(empty);</span><br><span class="line"> P(mutex);</span><br><span class="line"> 做炒饭</span><br><span class="line"> V(mutex);</span><br><span class="line"> V(chao);   </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">炒面师傅&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"> P(empty);</span><br><span class="line"> P(mutex);</span><br><span class="line"> 做炒饭</span><br><span class="line"> V(mutex);</span><br><span class="line"> V(rice);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">炒饭学生&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  P(chao);  </span><br><span class="line">  P(mutex);</span><br><span class="line">  拿炒饭</span><br><span class="line">  V(mutex);</span><br><span class="line">  V(empty);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">炒面学生&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"> P(rice);</span><br><span class="line"> P(mutex);</span><br><span class="line"> 拿炒面</span><br><span class="line"> V(mutex);</span><br><span class="line"> V(empty);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><hr><h2 id="进程调度问题"><a href="#进程调度问题" class="headerlink" title="进程调度问题"></a>进程调度问题</h2><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/nhI7KeOji5CAFZQ.png" alt="`"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：</p><ol><li>由于采用了静态优先数，当就绪队列中总有优先数较小的进程时，优先数较大的进程一<br>直没有机会运行，因而会出现饥饿现象</li><li>优先数<code>priority</code>的计算公式为：<code>priority=nice+k1×cpuTime-k2×waitTime</code>，其中<code>k1&gt;0</code>，<code>k2&gt;0</code>，用来分别调整<code>cpuTime</code>和<code>waitTime</code>在<code>priority</code>中所占的比例。<code>waitTime</code>可使长时间等待的进程优先数减小，从而避免出现饥饿现象。</li></ol></div></div><hr><h2 id="页面转换问题"><a href="#页面转换问题" class="headerlink" title="页面转换问题"></a>页面转换问题</h2><h3 id="基础知识-1"><a href="#基础知识-1" class="headerlink" title="基础知识"></a>基础知识</h3><p>页面转换问题是常考问题，重点有两个，分别是二级页表和地址转换的过程</p><p>二级页表如下：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/ew5xI9gTEbiMmjU.png" alt="image-20210802211551250"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/184SPyOb5H6ltZE.png" alt="image-20210802211746583"></p><p>其中有如下概念需要说明：</p><p>一般题目会给出，<strong>二级页表</strong>的结构以及<strong>页表项</strong>，<strong>页目录项</strong>的大小，注意计算机系统是否用<strong>字节编址</strong></p><hr><p>一级页号又称<strong>页目录号</strong>，二级页号又称<strong>页号</strong>/页表索引，页内偏移量又称页内地址</p><p><strong>页表项</strong>：在页表中，一个页号与其对应的物理块号称之为一个页表项</p><p><strong>页目录项</strong>：在页目录表中，一个页号与其对应的二级页号号称之为一个页目录项</p><p>页目录表的起始物理地址：寄存在寄存器orPCB中</p><hr><p>系统的位数$\Leftrightarrow$虚拟地址空间大小$\Leftrightarrow$虚拟地址的总位数$\Leftrightarrow$一级页号+二级页号+页内偏移量的位数</p><p>页内偏移量$\Leftrightarrow$页面大小$\Leftrightarrow$页框大小</p><hr><p>有关页目录号(一级页号)的总结：</p><p>逻辑页号$\Longleftarrow$页目录号+页号</p><p>页目录表的大小$\Longleftarrow$页目录号/页目录项的大小</p><p>页目录项的物理地址$\Longleftarrow$页目录表的起始地址+页目录号×页目录项的大小</p><p>页表的起始物理地址$\Longleftarrow$页目录项的具体内容（即下一级页表存放的页框号）</p><hr><p>有关页号(二级页号)的总结：</p><p>二级页表的大小$\Longleftarrow$页号/页表项的大小</p><p>页表项的物理地址$\Longleftarrow$页表的起始物理地址(页框号)+页表项长度×页号</p><p>页表项的具体内容(物理地址存放的页框号)$\Longleftarrow$页表项的物理地址</p><hr><p>物理地址$\Longleftarrow$页框号+页内偏移量</p><div class="note primary flat"><p>注意区别<strong>物理地址</strong>和<strong>逻辑地址</strong>和<strong>页表项的物理地址</strong></p><p>物理地址的前x位表示页框号，后x位表示页内偏移量</p><p>逻辑地址的前x位表示页号，后x位表示页内偏移量</p><p>页表项的物理地址：页框号+页号×页表项大小</p><p>页目录项的物理地址：页目录表的起始地址+页目录号×页目录项的大小</p></div><p>最为复杂的是求二级页面中页表项的物理地址</p><p>需要的条件有：</p><ol><li>页目录项中对应此页表项的物理块中，所存放的页框号</li><li>该页表项在页表中页号</li><li>页表项的大小</li></ol><p>最终结果为页框号+页号×页表项大小</p><hr><p>带快表的一级页表的请求分页管理方式</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/yeXovTDz1fq3KiS.png" alt="image-20210803102256507"></p><p>访存时会优先查找快表，然后再查慢表，当发生缺页时，需要页面置换，同时更新快表和慢表，然后再重复流程，所以发生缺页到查找成功的时间为：</p><p>访问TLB(未命中)+访问慢表(未命中)+处理缺页+再次访问TLB(命中)+访问目标页面</p><p>CLOCK算法中页表的标志有：内存块号   状态位   访问字段    外存地址</p><p>改进型CLOCK算法中页表的标志有：内存块号  状态位   访问字段  <strong>修改位</strong>   外存地址</p><hr><h3 id="408-1"><a href="#408-1" class="headerlink" title="408"></a>408</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/q92AmunVWJxSYXb.png" alt="image-20210815105101897"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p><strong>页框：将内存划分成一块块的格式，每个物理叫做页框</strong></p><p><strong>页面：按照内存中划分形式，将进程划分成一个个块，每个块叫页面</strong></p><ol><li><p>页内偏移量为12位，则页的大小是$2^{12}B$,即4KB，页表占用的页表项的个数为$2^{32}/2^{12}=2^{20}$，即1MB，占用的字节为1×4=4MB</p></li><li><p>页目录号就是逻辑地址的前10位，页表索引就是逻辑地址的中间10位</p></li></ol><p>​       页目录号可以表示为(LA&gt;&gt;22)，页表索引可以表示为(LA&gt;&gt;12)&amp;0x3FF(0x3FF会自动补足0)</p><ol><li><p>已知代码段的起始逻辑地址为0000 8000H，可知他们的页号是8，计算得到物理地址1为</p><p>0020 0000H+8×4=0020 0020H，物理地址2为0020 0024H</p><p>页框号是物理块号，即是00900H和00901H</p><p>物理地址3为00901000H</p></li></ol></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/kfnRToyjeMc9PGY.png" alt="image-20210815135349120"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><ol><li>页的大小等于页框的大小，都为$2^{12}=4KB$，虚拟空间的大小为$2^{32}/2^{12}=2^{20}$页</li><li>页目录占$(2^{10}×4)/2^{12}=1$页，页表项占$(2^{20}×4)/2^{12}=1024$页，共占1024+1=1025页</li><li>访问的是同一个二级页表  页目录号010=0000 0001 00和 011=0000 0001 0001，前10位都相同</li></ol></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/WhX2HTUVPI4acf3.png" alt="image-20210815141055934"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><ol><li><p>根据页式管理的工作原理，应先考虑页面大小，以便将页面和页内位移分解出来，页面大小为4KB，即是$2^{12}$，占据了虚地址的低12位，虚地址剩余的位置即是页号</p><p> 2362的页号是2，快表中没有，两次访存，访问快表10ns+两次访问存时间为10+100+100=210ns</p><p>1565的页号是1，会产生缺页中断，时间为访问快表，访问内存，产生缺页中断并处理，访问快表，访问内存  总时间为10+100+$10^{8}$+10+100=100 000 220ns</p><p>25A5的页号是2，快表中已经记录有了，一次访存，时间为10+100=110ns</p></li></ol><ol><li>根据LRU的置换算法，会把0号页面淘汰，那么分配给1号页面的页框号为101H，则虚地址的1565H的565表示页内偏移量，物理地址为101565H</li></ol></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/MEULmrShucQVwn2.png" alt="image-20210815143944662"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><ol><li>页框号为21 起始驻留集为空，而0页对应的页表为空闲链表中的第三个空闲页框，对应的页框号是21</li><li>页框号为32，在第三轮扫描中，第二轮被换下的32页框被重新放入，所以是32</li><li>页框号为41，第2页从来没有被访问过，从空闲页框链表中取出链表头的页框41</li><li>适合，如果程序的时间局部性越好，从空闲页框链中重新取回的机会越大，该策略优势也就越明显</li></ol></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/8zscKUfLq6RhrSC.png" alt="image-20210815150245641"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><ol><li><p>逻辑地址空间占64KB，即是$2^{16}$，页的大小为1KB，则页偏移量占据后10位，17CAH=0001 0111 1100 1010 的前6位表示页号，页号为5</p></li><li><p>FIFO会将第0号页面淘汰，页框号为7，物理地址为0001 1111 1100 1010 即是1FCAH</p><p>Clock会将第2号页面淘汰，页框号为2，物理地址为0000 1011 1100 1010即是 0BCAH</p></li></ol></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/8bthO1AgQSc92k6.png" alt="image-20210815152510912" style="zoom:80%;" /></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/i5rUlQVxpLs4qzm.png" alt="image-20210815152526794"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><ol><li><p>前10位是页目录的号数，中间10是页表号，最后12位是页内偏移量</p><p>0000 0001 1000 0000 0110  0000 0000 1000        0180 6008H</p></li><li><p>物理，会，不会</p></li><li><p>访问，修改</p></li></ol></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221205184042718.png" alt="image-20221205184042718"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><ol><li><p>页面大小=2^12B=4KB，每个页面正好可以放下1024个数组元素，即一行，$a[1][2]$会存放在第2个页面，地址偏移量为2×4B=8B，虚拟地址为：页号+页内偏移量=10801  008H</p><p>10810 008H= 0001000010 0000000001 000000001000，前10位是042H，中间10位是001H，偏移量是008H    </p><p>对应的页目录项的物理地址为 0020 1000H+4×42H=0020 1108H</p><p>若页框号为00301H，则对应的页表项的物理地址为：00301 000H+1×4H=00301 004H</p></li><li><p>数组a在虚拟地址空间必须连续存放，由于数组a不止占用1页，相邻逻辑页在物理上不一定相邻，可以不连续</p></li><li><p>按行遍历的局部性更好，因为数组的一行被保存在同一个页面</p></li></ol></div></div><hr><h3 id="874-1"><a href="#874-1" class="headerlink" title="874"></a>874</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221205190626437.png" alt="image-20221205190626437"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><ol><li>8GB=$2^{33}$，即虚拟地址空间有33位，其中页内偏移=页框大小=页面大小为8KB即$2^{13}$B，要占据13位，剩下的地址空间为46-13=33位，一个页框能有$2^{13}/4=2^{11}$个页表，所以应该设计为$33/11=3$级页表</li><li>在请求分页存储中，PTE应该包括内存块号，有效位，访问位，修改位，外存地址</li></ol></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221205192916070.png" alt=""></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>此时的地址变换过程是：在 CPU给出有效地址后，由地址变换机构自动地将页号 P送入高速缓冲寄存器，并将此页号与高速缓存中的所有页号进行比较，若其中有与此相匹配的页号，便表示所要访问的页表项在快表中。于是，可直接从快表中读出该页所对应的物理块号，并送到物理地址寄存器中。如在快表中未找到对应的页表项，则还须再访问内存中的页表，找到后，把从页表项中读出的物理块号送往地址寄存器; 同时，再将此页表项存入快表的一个寄存器单元中，亦即，重新修改快表。</p><p>在请求分页存储中，PTE应该包括内存块号，有效位，访问位，修改位，外存地址</p><p>现对其中各字段说明如下;</p><ol><li>状态位（存在位）P∶由于在请求分页系统中，只将应用程序的一部分调入内存，还有一部分仍在外存磁盘上，故须在页表中增加一个存在位字段。由于该字段仅有一位，故又称位字。它用于指示该页是否已调入内存，供程序访问时参考。</li><li>访问字段 A∶ 用于记录本页在一段时间内被访问的次数，或记录本页最近已有多长时间未被访问，提供给置换算法（程序）在选择换出页面时参考。</li><li>修改位 M∶ 标识该页在调入内存后是否被修改过。由于内存中的每一页都在外存上保留一份副本，因此，在置换该页时，若未被修改，就不需再将该页写回到外存上，以减少系统的开销和启动磁盘的次数;若已被修改，则必须将该页重写到外存上，以保证外存中所保留的副本始终是最新的。简而言之，M 位供置换页面时参考。</li><li>外存地址∶ 用于指出该页在外存上的地址，通常是物理块号，供调入该页时参考。</li></ol></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221205193625079.png" alt="image-20221205193625079"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><ol><li><p>分页在储管理实现的基本思想：在分页存储管理中，将每个作业的逻辑地址空间分为大小相同的块，称为虚页面或页,通常页面大小为2的整数次幂（512K~4K）。同样地，将物理空间也划分为与页面大小相等的块，称之为存储块或页框，为作业分配存储空间时，总是以页框为单位。例如：一个作业的地址空间有M页，那么只要分配给它M个页框，每一页分别装入一个页框即可</p></li><li><p>为了确保每道程序都只在自己的内存区中运行，必须设置内存保护机制。一种比较简单的内存保护机制是设置两个界限寄存器，分别用于存放正在执行程序的上界和下界。在程序运行时，系统须对每条指令所要访问的地址进行检查，如果发生越界，便发出越界中断请求，以停止该程序的执行，即静态的界地址保护</p><p>而分页和分段采用的越界保护，需要根据界址寄存器储存起始地址，根据地址变换机构来判断是否越界</p></li><li><p>在内存中划出了一块共享存储区域，诸进程可通过对该共享区的读或写交换信息，实现通信，数据的形式和位置甚至访问控制都是由进程负责，而不是 OS。这种通信方式属于高级通信。需要通信的进程在通信前，先向系统申请获得共享存储区中的一个分区，并将其附加到自己的地址空间中，便可对其中的数据进行正常读、写，读写完成或不再需要时，将其归还给共享存储区。</p></li></ol></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221205193557733.png" alt="image-20221205193557733"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>64位虚拟地址空间，页面长4KB=$2^{12}$B，即占12位，剩下的64-12=52位，而一页能存储的页表项为4KB/4B=$2^{10}$，即占10位，所以至少需要6层分页策略才行</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221206221250985.png" alt="image-20221206221250985"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><ol><li>$2^{48}/2^{12}$=$2^{36}$，则36位作为页表位数，$4KB/8B=2^{9}$，1级页表占9位，36/9=4，需要4级页表</li><li>0.98×(10+100)+0.02×(10+100+100)=112ns</li><li>0.98×(10+100)+0.02×(10+100+100+100)=114ns</li><li>p×(10+100)+(1-p)×(10+100+100+100)&lt;120ns   p=95%</li><li>每段最大为$4GB=2^{32}$，则段内偏移量为32位，段号为16位，最多$2^{16}$段，多级页表的每级页表最多有9位，所以20/9=2.2&lt;3，段内采取3级页表</li></ol></div></div><hr><h2 id="文件存储问题"><a href="#文件存储问题" class="headerlink" title="文件存储问题"></a>文件存储问题</h2><h3 id="基础知识-2"><a href="#基础知识-2" class="headerlink" title="基础知识"></a>基础知识</h3><p>分配方式有3种</p><ol><li>连续分配</li><li>链接分配<ul><li>隐式链接</li><li>显式链接</li></ul></li><li>索引分配</li></ol><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220721164855509.png" alt="image-20220721164855509"></p><p>不同的分配方式会导致不同的结果，但精髓在于：如何存储器中块的数目？</p><p>显式链接：FAT的位数</p><p>隐式链接：链接指针的位数</p><p>直接索引：索引结点的位数</p><p>间接索引：每一个簇能存放索引结点的个数</p><p>计算如下：</p><ul><li><p>连续分配</p><p>起始块号和块数的平衡</p></li></ul><ul><li><p>链接分配</p><ul><li><p>显式链接</p><p>常给出的概念：<strong>FAT表项大小   簇的大小</strong></p><p>FAT表项位数$\Longleftarrow$FAT表项大小</p><p>FAT表项数目$\Longleftarrow$FAT表项位数</p><p>FAT的最大长度$\Longleftarrow$FAT表项大小×FAT表项数目</p><p>最大文件长度$\Longleftarrow$FAT的表项的数量×簇的大小</p></li></ul></li></ul><ul><li><p>隐式链接：</p><p>常给出的概念：<strong>簇的大小  链接指针的大小or链接数据区的大小</strong></p><p>磁盘块的位数$\Longleftarrow$链接指针的大小</p><p>磁盘块的数目$\Longleftarrow$磁盘块的位数</p><p>最大文件长度$\Longleftarrow$(块的大小-指针大小)×磁盘块的数目</p></li></ul><ul><li><p>索引分配</p><p>常给出的概念： <strong>磁盘块(簇)的大小</strong>    <strong>索引表区的大小</strong> </p><p>文件的数目$\Longleftarrow$索引表区的大小/索引结点的大小</p></li></ul><ul><li><p>直接索引</p><p><strong>文件系统空间的最大容量</strong> 常给出</p><p>磁盘块的数量$\Longleftarrow$文件系统容量/磁盘簇的大小</p><p>索引表项的位数$\Longleftarrow$磁盘块的数量</p><p>索引表项的大小$\Longleftarrow$索引表项的位数</p><p>索引表项的数量$\Longleftarrow$索引表区的大小/索引表项的大小</p><p>文件最大长度$\Longleftarrow$索引表项的数量×磁盘块的大小</p></li></ul><ul><li><p>间接索引</p><p><strong>索引结点的大小</strong>  常给出</p><p>簇内索引结点的数量$\Longleftarrow$簇的大小/索引结点的大小</p><p>文件最大长度$\Longleftarrow$（直接索引+一级索引×簇内索引结点的数量+二阶索引×簇内索引接地的数目²）×簇大小</p></li></ul><hr><h3 id="408-2"><a href="#408-2" class="headerlink" title="408"></a>408</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/TJbgc85xSKn1BeG.png" alt="image-20210815161434970"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>1.dir目录文件</p><div class="table-container"><table><thead><tr><th>文件名</th><th>簇号</th></tr></thead><tbody><tr><td>dir1</td><td>48</td></tr></tbody></table></div><p>dir1目录文件</p><div class="table-container"><table><thead><tr><th>文件名</th><th>簇号</th></tr></thead><tbody><tr><td>file1</td><td>100</td></tr><tr><td>file2</td><td>200</td></tr></tbody></table></div><p>2.2B也就是16位，FAT最多有$2^{16}$个表项，系统也最多有$2^{16}$个块，FAT的最大长度是$2^{16}×2B=128KB$，文件的最大长度是$2^{16}×4KB=256MB$</p><p>3.根据FAT的存放标准，每一个块指示下一个块的位置，file1的簇号106存放在FAT的100号表项中，簇号108存放在FAT的106号表项中</p><p>4.第5000个字节明显是在第106簇中，已经读入了dir了，所以需要读入dir1的目录文件48号簇和file1的106号簇</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/Uw4vjp6cIE1Lmqr.png" alt="image-20210815162546899"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><ol><li>采用直接索引结构，4TB/1KB=$2^{32}$，32位最少需要4B来表示，那么512B的索引表区最多存储128个表项，128×1KB=128KB，最大长度是128KB</li><li>块数占了2B，即是16位，$2^{16}$，可以表示$2^{16}$×1KB=$2^{16}$KB，剩下的504B采取直接索引的方式，可储存504/6=84个磁盘，即是84KB，一共是$2^{16}$KB+84KB</li></ol><p>​      扩展单个文件的长度，就是让块数所占的字节尽可能贴近最大块数，调整为4B，即占据32位，和文件里面的物理块数一样，达到文件系统空间上限</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/T3aGU4goO1rKSRv.png" alt="image-20210815165649844"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><ol><li>系统采用顺序分配方式时，插入记录需要移动其他的记录块，整个文件共有 200 条记录，要插入新记录作为第 30 条，而存储区前后均有足够的磁盘空间，且要求最少的访问存储块数，则要把文件前 29 条记录前移，若算访盘次数移动一条记录读出和存回磁盘各是一次访盘，29 条记录共访盘 58 次，存回第 30 条记录访盘 1 次，共访盘 59 次。F 的文件控制区的起始块号和文件长度的内容会因此改变。</li><li>文件系统采用链接分配方式时，插入记录并不用移动其他记录，只需找到相应的记录，修改指针即可。插入的记录为其第 30 条记录，那么需要找到文件系统的第 29 块，一共需要访盘 29 次，然后把第 29 块的下块地址部分赋给新块，把新块存回内存会访盘 1 次，然后修改内存中第 29 块的下块地址字段，再存回磁盘，一共访盘 31 次。 4 个字节共 32 位，可以寻址 $2^{32}$=4G 块存储块，每块的大小为 1KB，即 1024B，其中下块地址部分占 4B，数据部分占 1020B，那么该系统的文件最大长度是 4G×1020B=4080GB。</li></ol></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/71DM3VI9RSymduk.png" alt="image-20210815203424396"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><ol><li><p>关键在于一个簇内能放多少个地址项，4KB/4B=$2^{10}$，最大文件长度为8×4KB+$2^{10}$×10KB+</p><p>$2^{20}$×10KB+$2^{30}$×10KB</p></li><li><p>一个图像文件大小为5600B&gt;4KB，所以会占据两个簇，1个簇里面最多存放4096/64=64个索引节点，则最多有$2^{26}=64M$个索引结点，最大支持64M个图像文件</p></li><li><p>不相同，因为6KB<32KB,在直接索引结点内，而40KB>32KB，在一级索引结点内</p></li></ol></div></div><hr><h3 id="874-2"><a href="#874-2" class="headerlink" title="874"></a>874</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221206190317941.png" alt="image-20221206190317941"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221206190602166.png" alt="image-20221206190602166" style="zoom:67%;" /></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><ol><li><p>每个数据块可以保存的索引项的数目为：4KB/4B=$2^{10}$，所以能表示的最大文件长度为：</p><p>(10+$2^{10}$+$2^{20}$+$2^{30}$)×4KB≈4KB</p></li><li><p>该文件占用的2GB/4KB=512×1024个数据块</p><p>首先直接索引指向了10个数据块，一级间接指引指向了1024个数据块，需要1个索引块，二级索引指向剩下的数据块，即(512×1024-10-1024)个数据块,那么总共需要1+[(512×1024-10-1024)/1024]=512个索引块</p><p>索引块所占的空间为：（1+512）×4KB=2MB+4KB</p><p>另外，每个文件使用的i_node数据结构占13×4B=52B，故该文件时间占用的磁盘空间大小为2GB+2MB+4KB+52B</p></li></ol></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221206192804158.png" alt="image-20221206192804158"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>首先，簇大小为$2^8$B,每个簇内能放下256/4=64=$2^6$个索引项，所以</p><p>最大长度=$(4+2×2^6+2×2^{12})×2^8=1KB+32KB+2MB$</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221206211417022.png" alt="image-20221206211417022"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><ol><li>每个物理块可放4个目录项和2个记录，要正确读取到usr和you目录，都必须先读取前一个数据块，所以读写dir1的数据块至少要经过2×2+1=5次读取，由于链式存储不具有随机存储的特性，文件A有598条记录，则需要598/2=299块存取，需要299+5=304次存取磁盘</li><li>如果是连续文件，读写dir1的数据块的次数是一样的，即5次，但读取文件A的第487条记录时可以直接读取，只用1次，所以总的需要1+5=6次</li></ol></div></div><hr><h2 id="磁盘调度问题"><a href="#磁盘调度问题" class="headerlink" title="磁盘调度问题"></a>磁盘调度问题</h2><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/EKQDBorR8FhjgGZ.png" alt="image-20210815205503146"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/Edrvh7YQjWmMZnp.png" alt="image-20210815205511199"></p><ol><li>16384是$2^{14}$，而2KB的内存空间转为位，也是$2^{14}$位，所以正好可以用位示图法</li><li>移动磁道的时间为20+90+20+40=170ms，转速为100r/s，旋转延迟为5ms，总的旋转延迟为20ms，读100个扇区的时间为1/(100*100)=0.1ms,总读取时间为0.4ms，总时间为170+20+0.4=190.4ms</li><li>FCFS算法，因为Flash储存器不需要考虑寻道时间和旋转延迟，可以按I/O请求的先后顺序服务</li></ol></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/kQbG2t7v5LjdBrF.png" alt="image-20210815231148159"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><ol><li><p>300×10×200×512=300000MB</p></li><li><p>在85号柱面上，通过计算，85号柱面对应的簇号是85000~85999所以先到100260再到101660，然后访问110560，最后访问60005</p></li><li><p>物理地址由柱面号，磁头号，扇区号组成</p><p>柱面号=100530/1000=100</p><p>磁头号=530/100=60</p><p>扇区号=（530*2）%200=60</p><p>由磁盘驱动程序完成</p></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统选择题</title>
      <link href="/post/64748.html"/>
      <url>/post/64748.html</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统选择题"><a href="#操作系统选择题" class="headerlink" title="操作系统选择题"></a>操作系统选择题</h1><p>09~21</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220722224611538.png" alt="image-20220722224611538"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：根据单处理机系统的概念，系统里面只能运行一个进程，所以选D </p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220722232908556.png" alt="image-20220722232908556"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：概念问题，系统调用就是提供的接口，所以选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723004111953.png" alt="image-20220723004111953"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：编译后形成的目标文件可以理解为一个小块一个小块的程序碎片，这样的小块一般都是具有从0开始的逻辑地址。 在和相应的库函数链接以后形成一个可执行的文件，需要修改这些小块的逻辑地址，使之统一有序。 所以在链接的过程中又把每个小段的逻辑地址按照一定的顺序组装成一个统一的逻辑地址范围，用来标识出此程序。 虽然编辑后的目标文件形成的小块内的也叫逻辑地址，但是和链接后形成的逻辑地址是截然不同的。选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723005943338.png" alt="image-20220723005943338"></p><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723005943338.png" alt="image-20220723005943338"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：进程的切换一定在核心态，而系统调用是在用户态发送，缺页和外部中断都可以在用户态发生，然后再用中断处理进入核心态处理，所以选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723010018125.png" alt="image-20220723010018125"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：中断处理一定会保存PSW，因为程序状态字用来指示处理器状态、控制指令的执行顺序并且保留和指示与运行程序有关的各种信息，其主要作用是方便地实现程序状态的保护和恢复。而子程序调用不会,所以选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723142743159.png" alt="image-20220723142743159"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：系统调用和异常都会导致进程从用户态切换到内核态,所以选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723142905281.png" alt="image-20220723142905281"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：概念问题，显然会加载到RAM中去,选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723144318927.png" alt="image-20220723144318927"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：开中断是在用户态，关中断一定在核心态，选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723155716273.png" alt="image-20220723155716273"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：操作系统会保留PSW中的内容，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723155744078.png" alt="image-20220723155744078"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：A会产生除以0错误，中断就不用算了，D有可能产生越界错误，所以是C有错误</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723170220820.png" alt="image-20220723170220820"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：中断技术的出现使I/O设备可以和CPU并行工作，当一道程序因 I/O请求而暂停运行时，CPU便立即转去运行另一道程序，选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723180329061.png" alt="image-20220723180329061"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：概念问题，显然是要先传递参数后，才进行trap指令,选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723180858193.png" alt="image-20220723180858193"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：多道程序系统需要额外的开销来调度程序，所以开销比单道程序系统要大,选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723234044784.png" alt="image-20220723234044784"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：多任务操作系统并不需要在多CPU上运行,选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723235633084.png" alt="image-20220723235633084"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：所有的时间数据都需要更新,选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221130165903497.png" alt="image-20221130165903497"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：显然，不同的操作系统系统调用的接口不一样，所以选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221130203253117.png" alt="image-20221130203253117"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：硬件才负责保存中断程序的中断点（程序计数器PC），所以选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221201194147011.png" alt="image-20221201194147011"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：ACD都是用户指令，而IO是特权指令，只能在内核态执行，所以选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221210193150255.png" alt="image-20221210193150255"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：是分时系统的特征，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221210202405274.png" alt="image-20221210202405274"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：引入多道程序设计之后，程序的执行就丧失了封闭性和顺序性，转为了制约性和间断性，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221211030932604.png" alt="image-20221211030932604"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：</p><p>可执行码：指<strong>将目标代码连接后形成的代码</strong>，简单来说是机器能够直接执行的代码。</p><p>可重入码：也叫 纯代码 (Pure code)是一种允许多个进程同时访问的代码</p><p>可改变码：可以修改的代码</p><p>可再现码：再现性是指程序被重复执行时，只要初始条件相同，那么执行结果必然相同</p><p>所以选B</p></div></div><hr><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220722224652548.png" alt="image-20220722224652548"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：显然，高响应比调度算法进行了综合考虑，所以是D。<strong>响应比</strong>：<strong>(等待时间+要求服务时间)/要求服务时间</strong></p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220722225125618.png" alt="image-20220722225125618"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：资源X最少有$n*(m-1)+1$个，才能避免发生死锁，所以此题显然为C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220722233111623.png" alt="image-20220722233111623"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：设备分配显然是在给进程分配资源，不会涉及到创建进程，所以选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220722233231021.png" alt="image-20220722233231021"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：显然还能用的资源数为1，而1&gt;0，自然也无进程等待，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220722233332722.png" alt="image-20220722233332722"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：在进程从运行态到就绪态的时候降低优先级很好，选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220722233600842.png" alt="image-20220722233600842"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：Peterson法实现了互斥和避免饥饿，只是没有满足让权等待条件，选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723003258708.png" alt="image-20220723003258708"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：显然是高响应比优先算法不会产生饥饿，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723003404893.png" alt="image-20220723003404893"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：命令解释程序在用户态，是给用户态提供接口调用时运行的程序，选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723003449994.png" alt="image-20220723003449994"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：显然是具体线程的栈指针不能被共享,选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723003830858.png" alt="image-20220723003830858"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：P3和P2都需要3个R2，但是R2可以分配的只有2个，所以不存在安全序列,选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723004629010.png" alt="image-20220723004629010"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：因为是并发执行的，所以可能会有任意执行顺序，可能会出现0,1,2,选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723122210903.png" alt="image-20220723122210903"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：此时R1有2个，R2有3个，R3有3个资源，此时分配给P1，P3都合理，分配给P1后不能再分配给P0，所以选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723132725056.png" alt="image-20220723132725056"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：进程在临界区时当然能进行处理机调度，只有在内核状态临界区时才不能，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723132936952.png" alt="image-20220723132936952"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：概念问题，系统根本意识不到线程的存在，所以进程当然是资源分配的基本单位，所以选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723143059817.png" alt="image-20220723143059817"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：银行家算法是避免死锁，处于安全状态时，一定是没有死锁进程的，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723144155214.png" alt="image-20220723144155214"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：显然是A，短作业显然会导致饥饿</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723144232957.png" alt="image-20220723144232957"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：不发生死锁，那么最少为2+3+4+1=10，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723144401848.png" alt="image-20220723144401848"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：读取了之后，会切换到就绪态，而到了执行态才会分配用户内存空间，选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723145611218.png" alt="image-20220723145611218"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：关于管道通信，可以有一个写进程和多个读进程进行操作，按时只能单向数据传输，并且读写都有可能被阻塞，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723155949707.png" alt="image-20220723155949707"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：ABC都会到阻塞态，只有D会变为就绪态</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723161215912.png" alt="image-20220723161215912"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：死锁检测方法不会限制申请资源的顺序，只会限制分配的顺序，所以选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723170401899.png" alt="image-20220723170401899"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：计算步骤是：3*4+2+3=17ms</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723170455393.png" alt="image-20220723170455393"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：p1，p2，p3会互锁，所以至少为3</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723170701062.png" alt="image-20220723170701062"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：TSL不满足让权等待的原则，即进入临界区的进程不会主动放弃CPU，至于A，退出临界区的进程只会唤醒就绪态的进程，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723171141835.png" alt="image-20220723171141835"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：进程之间的参数并不会互相影响，而线程之间各自的定义不需要互斥进行，因为之后的操作并没有涉及到对a的运算，只有线程之间都涉及到了对进程变量的改变，此时需要互斥的进行操作，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723171427035.png" alt="image-20220723171427035"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：管程还能实现对进程的同步,选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723180224820.png" alt="image-20220723180224820"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：此时J4还没到，先排除，J1先到，所以先来先服务会选定J1，而此时J3的运行时间最短，短作业优先会选定J3，选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723180816209.png" alt="image-20220723180816209"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：时间片用完后，只会从运行态切换到就绪态，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723234203131.png" alt="image-20220723234203131"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p> 解析：因优先权值大的进程优先获得CPU，进程的执行顺序为P2 -&gt; P3 -&gt; P1。<br>P2的周转时间为：1+15+24=40 μs；<br>P3的周转时间为：18+1+24+1+36=80 μs；<br>P1的周转时间为：30+1+24+1+36+1+12=105 μs。<br>系统的平均周转时间为：（40+80+105）/ 3 = 225 / 3 =75 μs。</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723235415774.png" alt="image-20220723235415774"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：只有当线程1完全执行完，再执行线程2，或者反过来，才有可能出现2，所以选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723235430713.png" alt="image-20220723235430713"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：资源不够分，所以是A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723235535651.png" alt="image-20220723235535651"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：管程内只能有一个进程，所以wait操作会直接将其插入阻塞序列,选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723235502274.png" alt="image-20220723235502274"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：进程被抢占只会导致回到就绪态,选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723235945727.png" alt="image-20220723235945727"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：显然是信号量机制实现了让权等待，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221130165525252.png" alt="image-20221130165525252"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：操作系统都不知道用户级线程的存在，自然不可能为用户级线程建立一个线程块，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221130165625024.png" alt="image-20221130165625024"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：即将进程用阻塞态切换为就绪态，进程时间片用完会变为就绪态，所以错误，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221130170158575.png" alt="image-20221130170158575"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：P1等待时间为：10+10=20ms，P2等待时间为：10ms，故平均等待时间为（10+20）/2=15ms，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221130170739086.png" alt="image-20221130170739086"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：银行家算法是避免死锁，而不是检测死锁，所以选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221130203442596.png" alt="image-20221130203442596"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：显然是以下都需要被考虑到，所以选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221130203934447.png" alt="image-20221130203934447"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：显然是B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221130204111628.png" alt="image-20221130204111628"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：子进程和父进程本质上还是两个进程，所以当然不能共享虚拟地址空间，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221130204418321.png" alt="image-20221130204418321"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：满足互斥条件，即123都需要，而4是让权等待，并不是一定需要的，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221201194300869.png" alt="image-20221201194300869"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：12都是需要的，同时需要将进程设置为就绪态而非执行态，所以选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221201194520463.png" alt="image-20221201194520463"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：时间片轮转只需要就绪队列并非阻塞队列，所以选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221201194736478.png" alt="image-20221201194736478"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：显然都有可能，选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221201195533521.png" alt="image-20221201195533521"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：最少是C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221201195638088.png" alt="image-20221201195638088"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：只有创建新进程才需要系统调用，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221210202611143.png" alt="image-20221210202611143"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：先来先服务可以保证CPU繁忙且不会导致进程饥饿，但是对IO不利，所以选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221210202834762.png" alt="image-20221210202834762"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：概念问题，是指内核创建的用户线程，选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221211031658493.png" alt="image-20221211031658493"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：只会被其他进程所唤醒，选D</p></div></div><hr><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220722225338221.png" alt="image-20220722225338221"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：分区分配内存管理方式是保护措施是界地址保护，分页和分段采用的是越界保护，所以是A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220722225545689.png" alt="image-20220722225545689"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：根据定义，显然是C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220722233719605.png" alt="image-20220722233719605"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：最佳匹配算法会优先分配小的内存块，所以最后是15-6=9MB</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723003937383.png" alt="image-20220723003937383"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：显然是都有可能发生，选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723004008517.png" alt="image-20220723004008517"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：抖动现象是因为分配的物理数块过少导致的，所以只有撤销部分进程才能解决这一问题，选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723142935301.png" alt="image-20220723142935301"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：缺页和越界错没有关系，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723144457605.png" alt="image-20220723144457605"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：$10GB/4KB=2.5×2^{20}$，显然，位示图需要$2.5×2^{20}$位来表示，即需要$(2.5×2^{20})/8=320KB$，而簇的大小为4KB，所以需要80个簇来表示</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723144957020.png" alt="image-20220723144957020"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：显然增大快表和让页表常驻都能加快转换，而增大交换区并没有什么作用,，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723145529969.png" alt="image-20220723145529969"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：只有FIFO算法才会产生Belady异常</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723145713354.png" alt="image-20220723145713354"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>多级页表不仅不会加快地址的变换速度，还会因为增加更多的查表过程，使地址变换速度减慢；也不会减少缺页中断的次数，反而如果访问过程中多级的页表都不在内存中，会大大增加缺页的次数，也并不会减少页表项所占的字节数，而多级页表能够减少页表所占的连续内存空间，即当页表太大时，将页表再分级，可以把每张页表控制在一页之内，减少页表所占的连续内存空间，因此选D。</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723161357852.png" alt="image-20220723161357852"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：根据LRU的定义，从最后一位倒推，选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723163100872.png" alt="image-20220723163100872"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：全局置换和固定分配不兼容，所以选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723170851913.png" alt="image-20220723170851913"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：段长300，却要得到400的逻辑地址，明显是越界了</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723170941053.png" alt=""></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：在任一时刻t，都存在一个集合，它包含所有最近k次（即为窗口大小）内存访问所访问过的页面。这个集合w（k，t）即为工作集，去除掉重复的序号，所以选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723180526158.png" alt="image-20220723180526158"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：20K会和200K起始的一起合并了，所以只剩下3个分区，同时按最佳适应算法，此时第一个分区会是最小的分区，即是500K起始的分区，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723170543907.png" alt="image-20220723170543907"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：定义问题，选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220722233855337.png" alt="image-20220722233855337"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：页大小为$2^{10}$，而页表项的大小为2字节，说明一页最多存储$2^{9}$个页表项，而逻辑地址空间大小为$2^{16}$页，全部都需要用页表项来表示，所以页目录表至少需要$2^{16-9}=2^{7}=128$页来表示</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221130170329285.png" alt="image-20221130170329285"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：段S在P1，P2中的使用位置可能不同，所以段号自然也有可能不同，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221130170451991.png" alt="image-20221130170451991"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：一共为5次，在5,3,0,7,6，被访问时发生，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221130170845321.png" alt="image-20221130170845321"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：注意一点：页目录号和页号这些都是从低位到高位，高位不够的补0，所以选A </p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221130170944783.png" alt="image-20221130170944783"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：内存碎片也叫外部碎片，最佳适应算法容易产生，选C </p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221130204017095.png" alt="image-20221130204017095"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：显然都能影响访存时间，选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221201194803103.png" alt="image-20221201194803103"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：02A01H对应的页号在内存中不存在，所以需要交换，先替换页号3，页框号为60H，所以物理地址为C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221201195237389.png" alt="image-20221201195237389"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：基本概念，放的是一级页表的起始物理地址，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221210193354334.png" alt="image-20221210193354334"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：2586/1024&gt;2，所以在页号为2，块号为10的物理块，偏移量为2586-2048=538，物理地址为10×1024+538=10778，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221210193704292.png" alt="image-20221210193704292"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：核心考点就是：在FIFO中，只会根据第一次掉页的时机来判断是否该调出，所以选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221210204051073.png" alt="image-20221210204051073"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：覆盖技术是应用在早起单一连续存储管理上的一种技术，选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221211031849915.png" alt="image-20221211031849915"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：heap是表示内存动态分配的内存段，所以选D</p></div></div><hr><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220722225737500.png" alt="image-20220722225737500"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：要实现随机访问，排除链式结构，而且要易于文件拓展，所以采用B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220722230359233.png" alt="image-20220722230359233"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：概念问题，会放在FCB中，选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220722230419041.png" alt="image-20220722230419041"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：软链接在建立的时候直接复制当前引用次数，并且一直不变，硬链接在建立的时候会将引用计数值+1，并且删除文件后会修改应用计数值，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220722234410621.png" alt="image-20220722234410621"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：二级目录所能表示的文件大小最大为：$1×64×64×256=1024KB$，所以可以估算出是C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220722234843122.png" alt="image-20220722234843122"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：在内存中设置当前工作目录，不必每次都从磁盘读入，这样可以<strong>加快目录检索速度</strong>，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723004155684.png" alt="image-20220723004155684"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：单磁盘块在处理一个文件的时候就需要$150μs$，10个文件就是$1500μs$，再算上最后一个文件的处理时间，所以是$1550μs$，而双缓冲区，就可以不考虑缓冲区向CPU传输的时间，就是$10×100=1000μs$，1000+50+50=1100，显然可以减少时间，所以选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723132218707.png" alt="image-20220723132218707"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：read系统调用建立在open系统调用之上，所以并不需要文件的名称，所以选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723141857726.png" alt="image-20220723141857726"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：删除文件不会删除文件的目录，选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723142314294.png" alt="image-20220723142314294"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：要求随机播放，排除链式结构，要求快速，排除索引结构，所以选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723142625207.png" alt="image-20220723142625207"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：索引结点的个数和单个文件长度并没有关系，选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723145311711.png" alt="image-20220723145311711"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：首次打开即open系统调用，会先读取FCB，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723162052426.png" alt="image-20220723162052426"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：一个磁盘可以存放 1KB/4=256 个指针 直接索引指针为10个，代表偏移量在0－10240之间的都可以通过直接索引得到。 选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723163139637.png" alt="image-20220723163139637"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：每个盘块能表示1024*8个盘块号，即409612/(1024×8)=50余12，所以盘块号为32+50=82，剩下的第12位，块内地址是从0开始的，即是第1个字节的内容，所以答案是C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723180631881.png" alt="image-20220723180631881"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：簇的大小为1KB，而文件系统会按簇的大小为基本单位，所以至少需要2个簇的大小，即2KB，选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723181110740.png" alt="image-20220723181110740"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：需要注意的是，一个用户可以有多种状态，同时，此题是直接描述文件权限，意思就是需要用一个字符串来描述所有用户对其文件的所有权限，所以至少需要5*4=20种</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723181654562.png" alt="image-20220723181654562"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：读写指针肯定不会保持相同，因为不可能同时读写的都是同一块数据，其余的都一样，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723235921084.png" alt="image-20220723235921084"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：都能提高文件访问速度，选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221130165955496.png" alt="image-20221130165955496"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：文件系统中位图，空闲磁盘块链，FAT都可以表示空闲磁盘块，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221130202913557.png" alt="image-20221130202913557"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：A：当然可以写 C：位置不一定一样 D：但引用计数为0的时候才能删除，所以选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221130203108429.png" alt="image-20221130203108429"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：显然是A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221130204251802.png" alt="image-20221130204251802"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：文件目录用索引结点的方式存储，只需要考虑索引结点的个数即可，即索引结点号占了4B=32bit，那么能表示$2^{32}$个文件</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221201195328286.png" alt="image-20221201195328286"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：删除文件之后，快捷方式并不会被删，所以选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221210204240528.png" alt="image-20221210204240528"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：概念问题，目录结构中，一级目录最大的问题就是容易重名，选C</p></div></div><hr><h2 id="输入-输出管理"><a href="#输入-输出管理" class="headerlink" title="输入/输出管理"></a>输入/输出管理</h2><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220722225942844.png" alt="image-20220722225942844"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：根据SCAN算法，会持续往一个方向移动，然后再反方向移动，所以是A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220722230443258.png" alt="image-20220722230443258"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：概念问题，为了方便编程，使用的是逻辑设备名，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220722234947938.png" alt="image-20220722234947938"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：根据IO设备的层次划分，先是中断处理程序接受，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723003527630.png" alt="image-20220723003527630"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：概念问题，B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723010453212.png" alt="image-20220723010453212"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：概念问题，选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723132326488.png" alt="image-20220723132326488"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：P1先到达，显然是60+120+40+40=260ms，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723133853826.png" alt="image-20220723133853826"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：显然设置多个分区并不能改善性能，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723142524619.png" alt="image-20220723142524619"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：在设备驱动程序才会具体计算物理地址，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723142708110.png" alt="image-20220723142708110"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：显然，最短时间为105*2+90=300，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723143029172.png" alt="image-20220723143029172"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：应该让IO时间多的进程先计算，所以是B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723161845443.png" alt="image-20220723161845443"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：可以减少磁盘IO次数，选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723163715335.png" alt="image-20220723163715335"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：最外层是0，最里面是200，所以结果是(199-58)+(199-15)=325，选C</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723171338350.png" alt="image-20220723171338350"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：是操作系统控制设备与输出井之间的关系，所以选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723181024188.png" alt="image-20220723181024188"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：磁盘的逻辑格式化会在划定分区之后，物理格式化会确定校验码，所以选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723181831592.png" alt="image-20220723181831592"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：在开始DMA传输时，主机向内存写入DMA命令块，向DMA控制器写入该命令块的地址，启动 I/O 设备。然后，CPU继续其他工作，DMA控制器则继续直接操作内存总线，将地址放到总线上开始传输。整个传输完成后，DMA控制器中断CPU，即正确执行，选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220723235702877.png" alt="image-20220723235702877"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：只有先来先服务不会导致磁臂黏着，磁臂黏着：指磁盘长时间访问某一些磁道，比如100，50，99，98的顺序，扫描和循环扫描算法都会导致磁臂黏着，选A</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221130204210287.png" alt="image-20221130204210287"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：更换物理设备后只需要更换驱动即可，并不需要修改应用程序</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221201194631374.png" alt="image-20221201194631374"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：是优先寻找最接近的磁道，即0+2+5+11+23=41</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221210194015491.png" alt="image-20221210194015491"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：RAID的原理就是让各类磁盘并行，所以可以做到，选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221210204622648.png" alt="image-20221210204622648"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：SPOOLing技术并没有提高内存的利用率，所以选B</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221211014644923.png" alt="image-20221211014644923"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：当IO发生时，程序不管采用何种方式进行IO处理，都必须等待IO完成才可以继续执行，A、B、C三种方式是让CPU和IO并行。选D</p></div></div><hr><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221211031806915.png" alt="image-20221211031806915"></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: #5be7ff;">查看答案    </button><div class="hide-content"><p>解析：DMA方式是进程可以直接读取外部设备的数据，选A</p></div></div>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.输入输出系统</title>
      <link href="/post/20999.html"/>
      <url>/post/20999.html</url>
      
        <content type="html"><![CDATA[<h1 id="输入输出系统"><a href="#输入输出系统" class="headerlink" title="输入输出系统"></a>输入输出系统</h1><h2 id="I-O设备的概念和分类"><a href="#I-O设备的概念和分类" class="headerlink" title="I/O设备的概念和分类"></a>I/O设备的概念和分类</h2><p>I/O设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件</p><p>按使用特性分类：人机交互类，存储设备，网络通信设备</p><p>按信息交换的单位分类：块设备(可寻址)，字符设备(不可寻址，中断驱动)</p><hr><h2 id="I-O控制器"><a href="#I-O控制器" class="headerlink" title="I/O控制器"></a>I/O控制器</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>控制器分为机械部件和电子部件，机械部件主要用来执行具体的I/O操作，电子部件通常是一块插入主板扩充槽的印刷电路板</p><p><strong>I/O控制器</strong>：CPU无法直接控制I/O设备的机械部件，因此I/O设备还要有一个电子部件作为CPU和I/O设备机械部件之间的中介，用于实现CPU对设备的控制，这个电子部件就是I/O控制器，又称设备控制器</p><hr><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p><strong>接受和识别CPU发出的命令</strong></p><p>如CPU发来的<code>read/wirte</code>命令，I/O控制器中会有相应的控制寄存器来存放命令和参数</p><p><strong>向CPU报告设备的状态</strong></p><p>I/O控制器中会有相应的状态寄存器，用于记录I/O设备的当前状态</p><p><strong>数据交换</strong></p><p>I/O控制器中会设置相应的数据寄存器，输出时，数据寄存器用于暂存CPU发来的数据，之后再由控制器传送设备，输入时，数据寄存器用于暂存设备发来的数据，之后CPU从数据寄存器中取走数据</p><p><strong>地址识别</strong></p><p>类似于内存的地址，为了区分设备控制器中的各个寄存器，也需要给各个寄存器设置一个特定的地址，I/O控制器通过CPU提供的地址来判断CPU要读写的是哪个寄存器</p><hr><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>由CPU与控制器的接口，I/O逻辑，控制器与设备的接口</p><p>I/O逻辑负责接收和识别CPU的各种命令，并负责对设备发出命令</p><p>CPU与控制器的接口用于实现CPU与控制器之间的通信，CPU通过控制线发出命令，通过地址线指明要操作的设备，通过数据线来取出数据或放入数据</p><p>控制器与设备的接口，用于实现控制器与设备之间的通信</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/ujrAO7NEY2vZPph.png" alt="image-20210804162140721"></p><p>注意：一个I/O控制器可能会对应多个设备</p><p>既然I/O控制器可以对应多个设备，那么自然也会有多个寄存器，且这些寄存器都要有相应的地址，才能方便CPU操作，有的计算机会让这些寄存器占用内存地址的一部分，称为<strong>内存映像I/O</strong>；另一些计算机则采用I/O专用地址，即<strong>寄存器独立编址</strong></p><p>如果采用内存映像I/O，优点是简化了指令，可以采用对内存进行操作的指令来对控制器进行操作</p><p>采用寄存器独立编址，缺点是需要专门的指令来实现对寄存器的操作，不仅要指明寄存器的地址，还要指明控制器的编号</p><hr><h2 id="I-O控制方式"><a href="#I-O控制方式" class="headerlink" title="I/O控制方式"></a>I/O控制方式</h2><h3 id="程序直接控制方式"><a href="#程序直接控制方式" class="headerlink" title="程序直接控制方式"></a>程序直接控制方式</h3><p>完成一次读写操作的流程</p><ol><li>CPU向控制器发出读指令，并且将状态寄存器设为1(未就绪)</li><li><strong>轮询</strong>检查控制器状态</li><li>输入设备准备好数据后将数据传给控制器，并报告自身状态</li><li>控制器将输入的数据放到数据寄存器中，并将状态改为0</li><li>CPU从数据寄存器中读出数据</li></ol><p>CPU干预的频率：很频繁，I/O操作开始之前，完成之后需要CPU介入，并且在等待I/O完成的过程中CPU需要不断轮询检查</p><p>数据传输的单位：每次读写一个字</p><p>数据的流向：读操作：从I/O设备到CPU到内存，每个字的读写都需要CPU的帮助</p><p>优点：实现简单，在读写指令之后，加上实现循环检查的一系列指令即可</p><p>缺点：CPU和I/O设备只能串行工作，CPU需要一直轮询检查，长期处于忙等状态，CPU利用率低</p><hr><h3 id="中断驱动方式"><a href="#中断驱动方式" class="headerlink" title="中断驱动方式"></a>中断驱动方式</h3><p>引入中断机制，由于I/O设备速度很慢，因此在CPU发出读写命令后，可将等待I/O的进程阻塞，先切换到别的进程执行。</p><p>当I/O完成后，控制器会向CPU发出一个中断信号，CPU检测到中断信号后，会保存当前进程的运行环境信息，转去执行中断处理程序处理该中断。</p><p>处理中断的过程中，CPU从I/O控制器读一个字的数据到CPU寄存器，再写入主存。接着，CPU恢复等待I/O的进程的运行环境，然后继续执行</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/Vr1xmjSJXqvcfDp.png" alt="image-20210804165230989" style="zoom: 67%;" /></p><p>CPU会在每个指令周期的末尾检查中断</p><p>中断处理过程中需要保存，恢复进程的运行环境，这个过程需要一定的时间开销，如果中断发生的频率过高，也会降低系统性能</p><p><strong>CPU干预的频率</strong>：I/O操作开始之前，完成之后需要CPU介入，在等待I/O完成的过程中CPU可以切换到别的进程执行</p><p><strong>数据传输的单位</strong>：每次读写一个字</p><p><strong>数据的流向</strong>：读操作：从I/O设备到CPU到内存，每个字的读写都需要CPU的帮助</p><p><strong>优点</strong>：CPU和I/O设备可以并行工作，CPU利用率得到提升</p><p><strong>缺点</strong>：每个字在I/O设备与内存之间的运输，都要经过CPU，而频繁的中断处理会消耗较多的CPU时间</p><hr><h3 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h3><p>DMA方式(Direct Memory Access ,直接存储器存取)，主要用于块设备的I/O控制</p><ul><li>数据的传送单位是 <strong>块</strong> 不再是字传送</li><li>数据的流向是从设备直接放入内存，或者是内存直接到设备，不再需要CPU中转</li><li>仅在传送一个或多个数据块开始和结束时，才需要CPU干预</li></ul><p>在DMA控制器中，有4个寄存器：</p><p>DR(Data Reigster,数据寄存器)：暂存从设备到内存，或从内存到设备的数据</p><p>MAR(Memory Address Register,内存地址寄存器)：在输入时，MAR表示数据应放到内存中的什么位置</p><p>DC(Date Counter 数据计数器)：表示剩余要读/写的字节数</p><p>CR(Command Register,命令状态寄存器)：用于存放CPU发来的I/O命令，或设备状态</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/3O98DB2UKuhNIy6.png" alt="image-20210804171914731"></p><p>执行过程：</p><ol><li>初始化DMA控制器并启动磁盘</li><li>从磁盘传输一块数据到内存缓冲区</li><li>DMA控制器发送中断请求</li><li>执行DMA结束中断服务程序</li></ol><p><strong>CPU干预的频率</strong>：仅在传送一个或多个数据块的开始和结束时才需要CPU干预</p><p><strong>数据传输的单位</strong>：每次读写一个或多个块(每次读写只能是连续多个块，且这些读入内存中也必须连续的)</p><p><strong>数据的流向</strong>：读操作：从I/O设备直接到内存，</p><p><strong>优点</strong>：数据传输以块为单位，CPU介入频率进一步降低，传输效率进一步增加</p><p><strong>缺点</strong>：CPU每发出一条I/O指令，只能读写一个或多个数据块，如果要读写多个离散存储的数据块，或者要讲数据块写到不同的内存区域时，CPU要分别发出多条I/O指令，进行多次中断处理才能完成</p><hr><h3 id="通道控制方式"><a href="#通道控制方式" class="headerlink" title="通道控制方式"></a>通道控制方式</h3><p>通道：一种硬件，通道可以识别并执行一系列通道指令</p><p>执行过程：</p><ol><li>CPU向通道发出I/O指令，指明通道程序在内存中的位置，并指明要操作的是哪个I/O设备，之后CPU就切换到其他进程执行了</li><li>通道执行内存中的通道程序(其中指明了要读写多少数据，读写的数据应放在内存中的什么位置)</li><li>通道执行完规定任务后，向CPU发出中断信号，之后CPU对中断进行处理</li></ol><p>通道可以识别一系列通道指令，但是可以执行的指令很单一，并且通道程序是放在主机内存中的，也就是说通道和CPU共享内存</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/b1a2UqQTf8dvoAW.png" alt="image-20210804185035565"></p><p><strong>CPU干预的频率</strong>：极低，通道会根据CPU的指示执行相应的通道程序，只有完成一组数据块的读写后才需要发出中断信号</p><p><strong>数据传输的单位</strong>：每次读写一组数据块</p><p><strong>数据的流向</strong>：读操作：从I/O设备直接到内存</p><p><strong>优点</strong>：CPU，通道，I/O设备可以并行工作，资源利用率很高</p><p><strong>缺点</strong>：实现复杂，需要专门的通道硬件支持</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/ankYK5oAB1tURrx.png" alt="image-20210804185536944"></p><hr><h2 id="I-O软件的层次结构"><a href="#I-O软件的层次结构" class="headerlink" title="I/O软件的层次结构"></a>I/O软件的层次结构</h2><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/mkABsrK84nqahju.png" alt="image-20210804185922289" style="zoom:67%;" /></p><p>越上面的层次越接近用户，越下面的层次越接近硬件，中间的三层属于操作系统内核部分</p><hr><p><strong>用户层软件</strong></p><ol><li><p>实现了与用户交互的接口，用户可直接使用该层提供的，与I/O操作相关的库函数对设备进行操作</p></li><li><p>用户层软件将用户请求翻译成格式化的I/O请求，并通过系统调用请求操作系统内核的服务</p></li></ol><hr><p><strong>设备独立性软件</strong></p><p>又称设备无关性软件，与设备的硬件特性无关的功能都在这一层实现</p><p>主要功能是</p><ul><li>向上层提供统一的调用接口</li><li>同时实现对设备的保护</li><li>设备独立性软件要对一些设备的错误进行处理</li><li>设备的分配和回收</li><li>数据缓冲区管理</li><li>建立逻辑设备名到物理设备名的映射关系，根据设备类型选择调用相应的驱动程序，需要通过逻辑设备表(LUT)来确定物理设备名</li></ul><hr><p><strong>设备驱动程序</strong></p><p>主要负责对硬件设备的具体控制，将上层发出的一系列命令转化为特定设备能听得懂的一系列操作，包括设置设备寄存器，检测设备状态等</p><p>一般以一个独立进程方式存在</p><hr><p><strong>中断处理程序</strong></p><p>当I/O任务完成时，I/O控制器会发送一个中断信号，系统会根据中断信号类型找到相应的中断处理程序并执行。中断处理程序的处理流程如下：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/K4uANVTIUFQ6af2.png" alt="image-20210804195840756"></p><hr><p>总体结构示意图</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/ObV7KkNoSHcfq3r.png" alt="image-20210804225326944"></p><hr><p>功能实现示意图</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/T2VFDLGRwkxHrs3.png" alt="image-20210804225757931"></p><hr><h2 id="I-O管理"><a href="#I-O管理" class="headerlink" title="I/O管理"></a>I/O管理</h2><h3 id="输入输出应用程序接口"><a href="#输入输出应用程序接口" class="headerlink" title="输入输出应用程序接口"></a>输入输出应用程序接口</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220722215529401.png" alt="image-20220722215529401"></p><p>用户层的应用程序无法用一个统一的系统调用接口来完成所有类型设备的I/O</p><p>所以需要根据不同的设备设置不同的接口以方便系统调用</p><hr><p>字符设备(键盘)接口</p><p>get/put 系统调用：向字符设备读/写一个字符</p><hr><p>块设备(磁盘)接口</p><p>read/write 系统调用：向块设备的读写指针位置读写多个字符</p><p>seek系统调用：修改读写指针的位置</p><hr><p>网络设备接口</p><p>socket系统调用：创建一个网络套接字，需指明网络协议</p><p>bind:将套接字绑定到某个本地端口</p><p>connect：将套接字连接到远程地址</p><p>read/write：从套接字读写数据</p><hr><p>阻塞I/O：应用程序发出I/O系统调用，进程需转为阻塞态，比如字符设备接口，从键盘读一个字符</p><p>非阻塞I/O：应用程序发出I/O系统调用，系统调用可迅速返回，进程无需阻塞等待，比如块设备接口，往磁盘写数据write</p><hr><h3 id="设备驱动程序接口"><a href="#设备驱动程序接口" class="headerlink" title="设备驱动程序接口"></a>设备驱动程序接口</h3><p>如果各个公司开发的设备驱动程序接口不统一，则操作系统很难调用设备驱动程序，所以需要操作系统会要求厂商遵循一个统一的标准</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220722215709137.png" alt="image-20220722215709137"></p><hr><h2 id="假脱机技术"><a href="#假脱机技术" class="headerlink" title="假脱机技术"></a>假脱机技术</h2><p>用软件的方式模拟脱机技术</p><p> <img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/3nl6jzcDLfvBP47.png" alt="image-20210805151445612"></p><p>输入井用于收容I/O设备输入的数据</p><p>输出井用于收容I/O设备输出的数据</p><p>在输入进程的控制下，输入缓冲区用于暂存从输入设备输入的数据，之后再转存到输入井中</p><p>在输出进程的控制下，输出缓冲区用于暂存从输出设备输出的数据，之后再转存到输出井中</p><hr><p>假如有一台打印机，当多个用户进程提出输出打印的请求时，系统都会答应他们的要求，但是并不是真正把打印机分配给他们，而是由假脱机管理进程为每个进程做两件事：</p><ol><li>在磁盘输出井中为进程申请一个空闲缓冲区，并将要打印的数据送入其中</li><li>为用户进程申请一张空白的打印请求表，并将用户的打印请求填入表中，在将该表挂到假脱机文件队列上</li></ol><p>当打印机空闲时，输出进程会从文件队列的队头取出一张打印请求表，并根据表中的要求将要打印的数据从输出井传送到输出缓冲区，再输出到打印机进行打印</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/CpMRbELimzaUc4l.png" alt="image-20210805152358564"></p><hr><h2 id="设备的分配和回收"><a href="#设备的分配和回收" class="headerlink" title="设备的分配和回收"></a>设备的分配和回收</h2><p><strong>设备的固有属性</strong></p><p>可以分为三种：独占设备，共享设备，虚拟设备</p><p>独占设备：一个时段只能分配给一个进程</p><p>共享设备：可同时分配给多个进程使用，各进程往往是宏观上同时使用设备，而微观上交替使用</p><p>虚拟设备：采用SPOOLing技术将独占设备改造成虚拟的共享设备，可以给多个设备</p><hr><p><strong>设备分配算法</strong></p><p>安全分配：$为进程分配一个设备后就将进程阻塞$，本次I/O完成后才将进程唤醒，不会死锁，但是CPU和I/O设备只能串行工作</p><p>不安全分配方式：进程发出I/O请求后，系统为其分配I/O设备，进程可继续执行</p><p>静态分配：进程运行前就分配全部所需资源，运行结束后归还资源</p><p>动态分配：进程运行过程中动态申请设备资源</p><hr><p><strong>设备分配管理中的数据结构</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/FGoLmrgTAylfIaZ.png" alt="image-20210805153131127"></p><p><strong>设备控制表(DCT)</strong>：系统为每个设备配置一张DCT，用于记录设备情况</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/Gtq4LPYZmVvxnMy.png" alt="image-20210805153225584"></p><p><strong>控制器控制表(COCT)</strong>：每个设备控制器对应一张DCT，操作系统根据COCT信息对通道进行操作和管理</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/Am2tFp8BLT1qnMa.png" alt="image-20210805153827293"></p><p><strong>通道控制表(CHCT)</strong>：每个通道都会对应一张CHCT，操作系统根据CHCT的信息对通道进行操作和管理</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/IH4N2s6P17MSTvr.png" alt="image-20210805153411068"></p><p><strong>系统设备表(SDT)</strong>：记录了系统中全部设备的情况，每个设备对应一个表目</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/J2mTGrRfPjsxt9O.png" alt="image-20210805153535963"></p><hr><p><strong>设备分配的步骤</strong></p><ol><li>根据进程请求的物理设备名查找SDT</li><li>根据SDT找到DCT，若设备忙碌则将PCB挂到设备等待队列中，不忙碌则将设备分配给进程</li><li>根据DCT找COCT，若控制器忙碌则将PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程</li><li>根据COCT找CHCT，若通道忙碌则将PCB挂到通道等待队列中，不忙碌则将通道分配给进程</li></ol><p>缺点：用户编程必须使用物理设备名，不方便编程，若进程请求的物理设备正在忙碌，则即使系统中还有同类型的设备，进程也必须阻塞等待</p><p><strong>改进方法：建立逻辑设备名与物理设备名的映射机制，用户编程时只需要提供逻辑设备名</strong></p><p> 即在第2步的时候，查找SDT，找到用户进程指定类型的，并且空闲的设备，将其分配给该进程，操作系统在逻辑设备表中新增一个表项</p><p>如果之后用户进程再次通过相同的逻辑设备名请求设备，通过LUT表就可以知道对应的是什么物理设备，并且也知道该设备的驱动程序入口地址</p><hr><h2 id="缓冲区管理"><a href="#缓冲区管理" class="headerlink" title="缓冲区管理"></a>缓冲区管理</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>缓冲区是一个存储区域，可以用专门的硬件寄存器组成，也可利用内存作为缓冲区</p><p>使用硬件作为缓冲区的成本较高，容量也较小，一般仅用于对速度要求非常高的场合</p><p>一般用内存作为缓冲区，设备独立性软件的缓冲区管理就是要组织好这些缓冲区</p><hr><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li><p>缓和CPU和I/O设备之间速度不匹配的矛盾</p></li><li><p>减少对CPU中断频率，放宽对CPU中断响应时间的限制</p></li><li><p>解决数据粒度不匹配的问题</p></li><li><p>提高CPU与I/O设备的并行性</p></li></ul><hr><h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><p>单缓冲：当用户进程请求某种块设备读入若干块的数据，若采用单缓冲的策略，操作系统会在主存中为其分配一个缓冲区</p><p>当缓冲区数据非空时，不能往缓冲区加入数据，只能传出；当缓冲区为空时，可以往其中加入数据，但必须充满后，才能从缓冲区把数据传出</p><p>假定一个初始状态，分析下次到达相同状态需要多少时间，这就是处理一块数据平均所需时间</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/qgoEGIAc6NTkZH5.png" alt="image-20210805160744435"></p><p>采用单缓冲策略，处理一块数据平均耗时$Max(C,T)+M$</p><hr><p><strong>双缓冲</strong></p><p>采用双缓冲策略，进程会在主存中为其配置两个缓冲区</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/X13OYeiMBfrQwod.png" alt="image-20210805161243582"></p><p>采用双缓冲策略，处理一个数据块的平均耗时是$Max(T,C+M)$</p><hr><p><strong>使用单/双缓冲在通信时的区别</strong></p><p>如果两台通信的机器只设置单缓冲区的话，在任一时刻只能实现数据的单向传输</p><p>管道通信中的管道其实就是缓冲区，要实现数据的双向通信，必须设置两个管道</p><hr><h3 id="循环缓冲区"><a href="#循环缓冲区" class="headerlink" title="循环缓冲区"></a>循环缓冲区</h3><p>将多个大小相等的缓冲区链接成一个循环队列</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/G9uZg3ClASEhp5T.png" alt="image-20210805162619374"></p><hr><h3 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h3><p>缓冲池由系统中共用的缓冲区组成，缓冲区可以分为空缓冲队列，输入队列，输出队列</p><p>根据一个缓冲区在实际运算中扮演的功能不同，又设置了4种工作缓冲区，用于收容输入数据的工作缓冲区，用于提取输入数据的工作缓存区，用于收容输出数据的工作缓存区，用于提取输出数据的工作缓存区</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/XQ32rmEAgaGLNRb.png" alt="image-20210805163024368"></p><hr><h1 id="磁盘存储器的管理"><a href="#磁盘存储器的管理" class="headerlink" title="磁盘存储器的管理"></a>磁盘存储器的管理</h1><h2 id="磁盘的结构"><a href="#磁盘的结构" class="headerlink" title="磁盘的结构"></a>磁盘的结构</h2><p><strong>磁盘</strong>：表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据</p><p><strong>磁道</strong>：磁盘的盘面被划分成一个个磁道，这样的一个圈就是一个磁道</p><p><strong>扇区</strong>：一个磁道又被划分为一个个扇区，每个扇区就是一个磁盘块，每个磁盘块存放的数据量相同</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/oYBVzZWxgnprhc5.png" alt="image-20210809162010308"></p><p>最内侧磁道上的扇区面积最小，所以数据密度最大</p><p>将磁头移动到想要读写的扇区所在的磁道，磁盘会转起来，让目标扇区在磁头下面划过，完成对扇区的读写</p><p><strong>盘面</strong>：一个盘片可以有两个盘面，所有的磁头都连在同一个磁臂上，因此所有磁头只能共进退</p><p><strong>柱面</strong>：所有盘面中相对位置相同的磁道组成柱面</p><p><strong>磁盘的物理地址</strong>：可以使用(柱面号，盘面号，扇区号)来定位任意一个磁盘块。</p><p><strong>磁盘的分类</strong>：磁头可以移动的称为活动头磁盘，磁头不能移动的称为固定头磁盘，这种磁盘中每个磁道有一个磁头</p><hr><h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2><h3 id="一次磁盘读写需要的时间"><a href="#一次磁盘读写需要的时间" class="headerlink" title="一次磁盘读写需要的时间"></a>一次磁盘读写需要的时间</h3><p>寻找时间$T_S$：在读写数据前，将磁头移动到指定磁道所花的时间</p><ul><li>启动磁头臂需要的时间，假设为s</li><li>移动磁头需要的时间，假设磁头匀速移动，每跨越一个磁道耗时为m,总共需要跨越n条磁道</li></ul><p><strong>寻找时间</strong>$T_S=s+m×n$</p><p><strong>延迟时间</strong>$T_R$：通过旋转磁盘，使磁头定位转到目标扇区所需要的时间</p><p>假设磁盘转速为$r$，则平均延迟时间为$1/2r$</p><p>传输时间：从磁盘读出或向磁盘写入数据所经历的时间，假设磁盘转速为$r$，读写的字节数为$b$，每个磁道上的字节数为$N$</p><p><strong>传输时间</strong>$T_t=b/(rN)$</p><p>可以得知延迟时间和传输时间都和磁盘的转速线性相关，操作系统无法进行优化，所以磁盘调度算法的操作主要是影响<strong>寻找时间</strong></p><hr><h3 id="先来先服务算法-最先"><a href="#先来先服务算法-最先" class="headerlink" title="先来先服务算法(最先)"></a><strong>先来先服务算法(最先)</strong></h3><p>根据进程请求访问磁盘的先后顺序进行调度</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/E3Hs6PjkQoqVyYe.png" alt="image-20210809170455778"></p><p>优点：公平，如果请求访问的磁道比较集中的话，性能还算好</p><p>缺点：如果有大量进程竞争使用磁道，请求访问的磁道很分散，则FCFS在性能上很差，寻到时间长</p><hr><h3 id="最短寻找时间优先算法-最近"><a href="#最短寻找时间优先算法-最近" class="headerlink" title="最短寻找时间优先算法(最近)"></a>最短寻找时间优先算法(最近)</h3><p>SSTF算法会优先处理与当前磁头最近的磁道，可以保证每次的寻道时间最短，但是并不能保证总的寻道时间最短</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/UL16ixdVJjhCRnl.png" alt="image-20210809170443913"></p><p>优点：性能较好，平均寻道时间短</p><p>缺点：可能会饥饿</p><hr><h3 id="扫描算法-单向"><a href="#扫描算法-单向" class="headerlink" title="扫描算法(单向)"></a>扫描算法(单向)</h3><p>只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动，也叫电梯算法</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/oDgx76j5mCpl42U.png" alt="image-20210809170515784"></p><p>优点：性能较好，平均寻道时间较短，不会产生饥饿</p><p>缺点：只有到达最边上磁道才会改变移动方向，对于各个位置磁道的相应频率不平均</p><hr><h3 id="LOOK调度算法"><a href="#LOOK调度算法" class="headerlink" title="LOOK调度算法"></a>LOOK调度算法</h3><p>在SCAN的基础上，增加了一个特性，如果磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/pAkN14gChjFcOKV.png" alt="image-20210809170529250"></p><hr><h3 id="循环移动算法-C-SCAN"><a href="#循环移动算法-C-SCAN" class="headerlink" title="循环移动算法(C-SCAN)"></a>循环移动算法(C-SCAN)</h3><p>SCAN算法对于各个位置磁道的响应频率不平均，而C-SCAN算法就是为了解决这个问题，规定只有磁头朝向某个特定方向移动时才处理磁道访问请求，而返回时直接快速移动至起始端而不处理任何请求</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/NmX9cGaukrwn2Wo.png" alt="image-20210809170551266"></p><hr><h3 id="C-LOOK调度算法"><a href="#C-LOOK调度算法" class="headerlink" title="C-LOOK调度算法"></a>C-LOOK调度算法</h3><p>结合LOOK和循环移动，如果磁头移动方向上没有磁道访问请求了，就立刻让磁头返回，并且磁头只需要返回到有磁道访问请求的位置</p><p>如果题目未具体说明，则SCAN就是LOOK，C-SCAN就是C-LOOK</p><hr><h2 id="减少磁盘延迟时间的方法"><a href="#减少磁盘延迟时间的方法" class="headerlink" title="减少磁盘延迟时间的方法"></a>减少磁盘延迟时间的方法</h2><p>交替编号，让逻辑上相邻的扇区在物理上有一定的间隔，可以让读取连续的逻辑扇区所需要的延迟时间更小</p><p>读取地址连续的磁盘块时，采用(柱面号，盘面号，扇区号)的地址结构可以减少磁头移动消耗的时间</p><hr><h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><p><strong>磁盘初始化</strong></p><ol><li><p>进行物理格式化，将磁盘的各个磁道划分为扇区，同时初始化扇区的数据结构</p></li><li><p>将磁盘分区，每个分区由若干个柱面组成</p></li><li>进行逻辑格式化，创建文件系统。包括创建文件系统的根目录，初始化存储空间管理所用的数据结构</li></ol><p><strong>引导块</strong></p><p>计算机开机时需要进行一系列初始化工作，这么工作是通过执行初始化程序完成的</p><p>在ROM中存放很小的自举装入程序，完整的自举程序放在磁盘的启动块上，启动块位于磁盘的固定位置</p><p><strong>坏块的管理</strong></p><p>无法正常使用的扇区就是坏块，属于硬件故障，操作系统无法修复，应该标记出来，避免使用</p><p>对于简单磁盘，可以在逻辑格式化的时候进行检查，表明哪些是坏扇区</p><p>对于复杂磁盘，可以保留一些备用扇区用于替换坏块</p><hr><h2 id="提高磁盘I-O速度的方法"><a href="#提高磁盘I-O速度的方法" class="headerlink" title="提高磁盘I/O速度的方法"></a>提高磁盘I/O速度的方法</h2><ol><li><p>采用磁盘高速缓存</p></li><li><p>提前读</p><p>如果采用顺序访问方式，可以预知下一次要读的盘块，在读当前块的时候，同时将下一个盘块中的数据也读入缓冲区</p></li><li><p>延迟写</p><p>指缓冲区A中的数据本应立即写回磁盘，但是考虑到缓冲区中的数据可能会在不久之后再被访问，所以并不立即将缓冲区A中的数据写入磁盘，而是将它挂到空闲缓冲队列的末尾</p></li><li><p>优化物理块的分布</p></li><li><p>虚拟盘</p></li><li><p>调整I/O请求次序</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.文件管理</title>
      <link href="/post/63590.html"/>
      <url>/post/63590.html</url>
      
        <content type="html"><![CDATA[<h1 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>文件是指创建者所定义的，具有文件名的一组数据的集合，可分为有结构文件和无结构文件两种</p><p>在有结构的文件中，文件由若干个相关记录组成，而无结构文件则被看成一个字符流</p><p>文件属性包括：</p><ul><li>文件类型，可以从不同的角度来对规定文件的类型</li><li>文件长度，文件长度指文件的当前长度</li><li>文件的物理位置，通常用于指示文件所在的设备以及设备中地址的指针</li><li>文件的建立时间，指最后一次修改时间等</li></ul><hr><h2 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h2><p>流式文件：无结构的文件，数据不再组成记录，只是一串顺序的信息集合</p><p>有结构文件：由一组相似的记录组成，又称记录式文件，每条记录由若干个数据项组成，一般来说，每条记录有一个数据项作为关键字，根据各条记录的长度是否相等，又可分为定长记录和可变长记录</p><hr><h3 id="顺序文件"><a href="#顺序文件" class="headerlink" title="顺序文件"></a>顺序文件</h3><p>文件的记录按一个接一个顺序排列，记录可以是定长的或可变长的，各个记录在物理上可以<strong>顺序存储</strong>或<strong>链式存储</strong></p><p>顺序存储：逻辑上相邻的记录物理上也相邻</p><p>链式存储：逻辑上相邻的记录物理上不一定相邻</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/dE1cFBYKiyCjQ5e.png" alt="image-20210805204921561"></p><p>定长记录可以随机存取，可变长记录不可以随机存取</p><hr><h3 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h3><p>对于可变长记录文件，要找到第<code>i</code>个记录，必须先顺序查找到前<code>i-1</code>个记录，很不方便</p><p>如果建立一张索引表加快文件的检索速度，每条记录对应一个索引项</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/n9NqAu7MEswIjeB.png" alt="image-20210805205319391"></p><p><strong>索引表本身就是定长记录的顺序文件</strong>，因此可以迅速找到第<code>i</code>个记录对应的索引项</p><p>由于索引文件有很快的检索速度，因此主要用于对信息处理的及时性要求比较高的场所</p><p>缺点：每个记录对应一个索引表项，因此索引表可能会很大</p><hr><h3 id="索引顺序文件"><a href="#索引顺序文件" class="headerlink" title="索引顺序文件"></a>索引顺序文件</h3><p>索引顺序文件是索引文件和顺序文件思想的结合，在索引顺序文件中，同样会为文件建立一张索引表，但是，并不是每个记录都对应一个索引表项，而是一组记录对应一个索引表项</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/WNpAbtHyZsri1df.png" alt="image-20210805210155962" style="zoom:67%;" /></p><p> 为了进一步提高检索效率，可以为顺序文件建立多级索引表</p><hr><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><h3 id="文件控制块"><a href="#文件控制块" class="headerlink" title="文件控制块"></a>文件控制块</h3><p>目录本身就是一种有结构文件，由一条条记录组成，每条记录对应一个放在该目录下的文件</p><p>为了能对一个文件进行正确的存取，必须为文件设置用于描述和控制文件的数据结构，称之为文件控制块(FCB)</p><p><strong>FCB中包含了文件的基本信息(文件名，文件大小，物理地址，逻辑结构等)，存储控制信息，使用信息</strong></p><p>每当创建一个文件时，先建立一个FCB，用来记录文件属性，每当存取文件时，先找到FCB，再找到文件信息盘块号或索引表就能存取文件</p><hr><p>为了加快文件查找速度，将FCB汇集和组织在一起形成文件目录</p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p><strong>单级目录结构</strong></p><p>早期操作系统并不支持多级目录，整个系统中只建立一张目录表，每个文件占一个目录项</p><p>优点：</p><ul><li>单级目录实现了按名存取</li></ul><p>缺点：</p><ul><li>但是不允许文件重名，显然单级目录结构不适用于多用户操作系统</li></ul><hr><p><strong>两级目录结构</strong></p><p>早起的多用户操作系统，采用两级目录机构，分为主文件目录和用户文件目录</p><p>主文件目录记录用户名及相应的用户文件目录的存放位置</p><p>用户文件目录由该用户的文件FCB组成</p><p>优点：</p><ul><li>两级目录结构允许不同用户的文件重名，也可以在目录上实现访问限制</li></ul><p>缺点：</p><ul><li>但是两级目录结构依然缺乏灵活性，也不能对自己的文件进行分类</li></ul><hr><p><strong>多级目录结构</strong></p><p>用户要访问某个文件时要用文件路径名标识文件，文件路径是个字符串，各级目录之间用 / 隔开，从根目录出发的路径称为绝对路径</p><p>系统根据绝对路径一层一层地找到下一级目录。从外存读入根目录的目录表</p><p>每次从根目录找很低效，可以设置相对目录，减少磁盘I/O次数</p><p>优点：</p><ul><li>树形目录可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护。</li></ul><p>缺点</p><ul><li>树形结构不便于实现文件的共享。为此，提出了无环图目录结构</li></ul><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20221122181243735.png" alt="image-20221122181243735"></p><hr><p><strong>无环图目录结构</strong></p><p>在树形目录结构的基础上，增加一些指向同一节点的有向边，使整个目录成为一个有向无环图，可以更方便地实现多个用户间的文件共享</p><p>需要为每个共享结点设置一个<strong>共享计数器</strong>，用于记录此时有多少个地方在共享这个结点，用户提出删除结点的请求时，只是删除该用户的FCB，并将共享计数器<strong>减1</strong>，并不会删除共享结点，只有共享计数器为0时才被删除</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/oWu4aTLDxIAymEw.png" alt="image-20210809153136401"></p><hr><h3 id="索引结点"><a href="#索引结点" class="headerlink" title="索引结点"></a><strong>索引结点</strong></h3><p>索引结点是对<strong>FCB的优化</strong>，在查找各级目录的过程只需要文件名这个信息，只有文件名匹配的时候，才需要读出文件的其他信息</p><p>可以将除了文件之外的描述信息都放到索引结点，减少了IO次数</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/RIEVXlBZd5Uv2iM.png" alt="image-20210806183119195" style="zoom:50%;" /></p><hr><h2 id="文件的物理结构"><a href="#文件的物理结构" class="headerlink" title="文件的物理结构"></a>文件的物理结构</h2><p>类似内存分页，<strong>磁盘中的储存单元也会被分为一个个块</strong>，很多操作系统中，磁盘块的大小与内存块，页面的大小相同</p><p>在外存管理中，为了方便对文件数据的管理，文件的逻辑地址空间也被分为了一个一个的文件块，于是<strong>文件的逻辑地址也可以表示为(逻辑块号，块内地址)的形式</strong></p><p>用户通过逻辑地址操作自己的文件，操作系统负责实现<strong>从逻辑地址到物理地址的映射</strong></p><hr><h3 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h3><p>连续分配方式要求每个文件在磁盘上占有一组连续的块</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/jmoOZGz9htBSyxa.png" alt="image-20210807124526272"></p><p>文件目录中记录存放的起始块号和长度</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/A1nMouSi8QxaDwc.png" alt="image-20210807124607286"></p><p>用户给出了要访问的逻辑块号，操作系统找到该文件对应的目录项(FCB)</p><p>物理块号=起始块号+逻辑块号</p><p>优点：</p><ul><li><p>连续分配支持顺序访问和<strong>随机访问</strong></p></li><li><p>在读取某个磁盘块时，需要移动磁头，访问的两个磁盘块相隔越远，移动磁头所需时间就越长，<strong>所以，连续分配的文件在顺序读写时速度最快</strong></p></li></ul><p>缺点：</p><ul><li>连续分配方式的文件不方便扩展</li><li>物理上采用连续分配，存储空间利用率低，会产生难以利用的磁盘碎片</li></ul><hr><h3 id="链接分配"><a href="#链接分配" class="headerlink" title="链接分配"></a>链接分配</h3><h4 id="隐式链接"><a href="#隐式链接" class="headerlink" title="隐式链接"></a><strong>隐式链接</strong></h4><p>除了文件的最后一个磁盘块，每个磁盘块都会保存指向下一个盘块的指针，这些指针对用户是透明的</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/8xasMShYgFpNDtW.png" alt="image-20210807125455265"></p><p>在目录中记录了文件的起始块号和结束块号</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/GwOxVhFrSsfaTKI.png" alt="image-20210807125632597"></p><p>从目录项中找到起始块号，将0号逻辑块读入内存，由此知道1号逻辑块存放的物理块号，再找到2号逻辑块存放位置，以此类推</p><p>因此，读入<code>i</code>号逻辑块，总共需要<code>i+1</code>次磁盘I/O</p><p>优点：很方便文件拓展，不会有碎片问题，外存利用率高</p><p>缺点：采用链式分配方式的文件，只支持顺序访问，不支持随机访问，查找效率低</p><div class="note primary flat"><p>为了提高检索速度和减小指针所占用的存储空间，可以将几个盘块组成一个<strong>簇</strong>（cluster）。比如，一个簇可包含 4个盘块，在进行盘块分配时，是以簇为单位进行的。</p><p>在链接文件中的每个元素也是以簇为单位的。这样将会成倍地减小查找指定块的时间，而且也可减小指针所占用的存储空间，但却增大了内部碎片，而且这种改进也是非常有限的。</p></div><hr><h4 id="显式链接-FAT"><a href="#显式链接-FAT" class="headerlink" title="显式链接(FAT)"></a><strong>显式链接(FAT)</strong></h4><p>把用于链接文件各物理块的指针显示地存放在一张表中，即文件分配表(FAT，File Allocation Table)</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/U2SqhWrXsyFCK1u.png" alt="image-20210807130533901"></p><p>在目录中只需记录文件的起始块号</p><p>在FAT中，记录每个物理块号对应的下一块，如果物理块号是文件的末尾，可以记为-1</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/85zbaL72gkHvclm.png" alt="image-20210807130925006"></p><p>一个磁盘仅设置一张FAT，开机时，将FAT读入内存，并常驻内存，FAT的各个表项在物理上连续存储，且每一个表项长度相同，因此，物理块号字段可以是隐含的</p><p>逻辑块号转换成物理块号的过程不需要读磁盘操作</p><p>优点：采用显式链式分配的文件，支持顺序访问，也支持随机访问，由于块号转换不需要访问磁盘，因此相比于隐式链接来说，访问速度要快，也不会产生外部碎片，方便扩展</p><p>缺点：文件分配表需要占据一定空间</p><hr><h3 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h3><p>索引分配允许文件离散地分配在各个磁盘块中，系统会为<strong>每个文件建立一张索引表</strong>，索引表中记录了文件的各个逻辑块对应的物理块，索引块存放的磁盘块称为索引块，文件数据存放的磁盘块称为物理块</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/X7YN3uz96DWol8e.png" alt="image-20210807132630534"></p><p>在索引块中存放的是索引表</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/5UGVNI3AlERbBm2.png" alt="image-20210807132650573"></p><p>在显式链接中，<strong>文件分配表FAT是一张磁盘对应一张，而索引分配方式中，索引表是一个文件对应一张</strong></p><p>可以用固定长度表示物理块号，因此，索引表中的逻辑块号可以是隐含的</p><p>将索引表从外存读入内存，并查找索引表即可知道<code>i</code>号逻辑块在外存中的存放位置，可见，<strong>索引分配方式支持随机访问，也支持文件拓展</strong></p><hr><p>如果整张索引表的大小超过了一个磁盘块，该如何解决？</p><p><strong>链接方案</strong></p><p>如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/PW4TVcHGAENtqQl.png" alt="image-20210807133320820" style="zoom:67%;" /></p><p>但是，如果索引表过大，那么所要链接的索引块也就很多，如果要找最后一个索引块，那么必须先顺序地读入前面所有索引块，很低效</p><hr><p><strong>多层索引</strong></p><p>建立多层索引，事第一层索引块指向第二层索引块，还可根据文件的大小要求再建立第三层，第四层索引块</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220620144802976.png" alt="image-20220620144802976"></p><p>如果使用两层索引，则文件的最大长度可以达到256*256=64MB</p><p>缺点是，即使是小文件，访问一个数据块依然需要<code>k+1</code>次读磁盘</p><hr><p><strong>混合索引</strong></p><p>多种索引分配方式的结合，例如，一个文件的顶级索引表中，既包含直接地址索引，又包含一级间接索引，还包含两级间接索引</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/6lCV8msJwry49gf.png" alt="image-20210809140129781"></p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220721164855509.png" alt="image-20220721164855509"></p><hr><h2 id="文件存储空间管理"><a href="#文件存储空间管理" class="headerlink" title="文件存储空间管理"></a>文件存储空间管理</h2><p>存储空间的划分：将物理磁盘划分为一个个文件卷</p><p>存储空间的初始化：将各个文件卷划分为目录区，文件区</p><p>目录区主要存放文件目录信息，用于磁盘存储空间管理的信息</p><p>文件区用于存放文件数据</p><hr><h3 id="空闲表法"><a href="#空闲表法" class="headerlink" title="空闲表法"></a>空闲表法</h3><p>用一张表来记录空闲盘块和空闲盘块数，适用于<strong>连续分配方式</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center"><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/OJczBFxiAK5XGUs.png" alt="image-20210809141511435"  /></th><th style="text-align:center"><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/M1m4xfyFOg9jNRz.png" alt="image-20210809141501833"  /></th></tr></thead><tbody><tr><td style="text-align:center"></td></tr></tbody></table></div><p>分配磁盘：与内存管理中的动态分区分配类似，为一个分配连续的存储空间，同样可采用首次适应，最佳适应，最坏适应等算法决定为文件分配哪个区间</p><p>回收磁盘：和动态分区分配一样，需要考虑到不同情况</p><hr><h3 id="空闲链表法"><a href="#空闲链表法" class="headerlink" title="空闲链表法"></a>空闲链表法</h3><h4 id="空闲盘块链"><a href="#空闲盘块链" class="headerlink" title="空闲盘块链"></a>空闲盘块链</h4><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/R7Tp3AUCzq8ZiLW.png" alt="image-20210809143156559"></p><p>空闲盘块中存储着下一个空闲盘块的指针</p><p><strong>操作系统保存着链头和链尾指针</strong></p><p>分配：若某文件申请<code>K</code>个盘块，则从链头开始一次摘下<code>K</code>个盘块分配，并修改空闲链的链头指针</p><p>回收：回收的盘快挂到链尾，并修改空闲链的链尾指针</p><p>适用于<strong>离散分配</strong>的物理结构</p><hr><h4 id="空闲盘区链"><a href="#空闲盘区链" class="headerlink" title="空闲盘区链"></a>空闲盘区链</h4><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/woiSBfl15kTVCX9.png" alt="image-20210809143233807"></p><p>连续的空闲盘块组成一个空闲盘区</p><p>空闲盘区中第一个盘块记录了盘区的长度，下一个盘块的指针</p><p>分配：若某个文件申请K个盘块，则可以开始采用适应算法，从链头开始检索，找到一个大小符合要求的空闲盘区，如果没有合适的连续空闲块，也可以将不同盘区的盘块同时分配给一个文件</p><p>回收：如果回收区没有和任何空闲区相邻，将回收区作为单独的一个空闲盘区挂到链尾</p><p><strong>离散分配，连续分配</strong>都适用，为一个文件分配多个磁盘块时效率高</p><hr><h3 id="位示图法"><a href="#位示图法" class="headerlink" title="位示图法"></a>位示图法</h3><p>每个二进制对应一个盘块，比如0代表盘块空闲，1代表盘块已分配，位移图一般用连续的字来表示</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/AU5b2HilKZInJhB.png" alt="image-20210809145133667"></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/1qUtFgswGamXrfM.png" alt="image-20210809145411487"></p><p>分配：若文件需要<code>K</code>个块，先顺序扫描位示图，找到<code>K</code>个相邻或不相邻的0，根据字号，位号算出对应的盘块号，将相应盘块分配给文件，将相应位设置为1</p><p>回收：根据回收的盘块号计算出相应的字号，位号，将相应二进制设为0</p><p>要根据矩阵推算出位示图和盘块号的转化关系</p><hr><p>此外，在文件的显式分配中所使用的FAT表，由于标记了磁盘中各块的被使用情况，一样可以用在空闲空间的管理中</p><hr><h2 id="文件的基本操作"><a href="#文件的基本操作" class="headerlink" title="文件的基本操作"></a>文件的基本操作</h2><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><p>创建文件需要进行Create系统调用，需要提供的几个主要参数</p><ol><li>所需的外存大小</li><li>文件存放路径</li><li>文件名</li></ol><p>在处理系统调用时，主要有两步</p><ol><li>在外存中找到文件所需的空间</li><li>根据文件存放路径的信息找到该目录对应的目录文件，在目录文件创建该文件对应的目录项</li></ol><hr><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>通过Delete系统调用</p><p>处理系统调用时，主要有三步</p><ol><li>根据文件存放路径，找到文件名对应的目录项</li><li>根据目录项记录的文件位置，回收文件占用的磁盘块</li><li>从目录项中删除文件对应的目录项</li></ol><hr><h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p>通过open系统调用</p><p>需要提供的主要参数</p><ol><li>文件存放路径</li><li>文件名</li><li>要对文件的操作类型</li></ol><p>操作系统在处理open系统调用时，主要做了：</p><ol><li>根据文件存放路径找到文件名对应的目录项，并检查该文件是否有指定的操作权限</li><li>将目录项复制到内存中的打开文件表，并将对应的目的编号返回给用户，之后用户使用打开文件表的编号来指明要操作的文件</li></ol><p>之后用户进程A再操作文件就不需要每次都重新检查目录了，这样可以加快文件访问速度</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/tzKvfUM4Qw29IOT.png" alt="image-20210809151725333"></p><p>进程的打开文件表中，读写指针记录了该进程对文件读写所进行到的位置</p><p>访问权限标明了进程能对文件所进行的操作</p><p>系统表索引号指向了系统的打开文件表</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/viXnhdF6qG5s3mT.png" alt="image-20210809151916877" style="zoom: 80%;" /></p><p><strong>打开文件时并不会把文件数据直接读入内存，索引号也称文件描述符</strong></p><hr><h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><p>系统在处理close系统调用时</p><ol><li>将进程的打开文件表相应表项删除</li><li>回收分配给该文件的内存空间等资源</li><li>系统打开文件表的打开计数器count减1</li></ol><hr><h3 id="读文件与写文件"><a href="#读文件与写文件" class="headerlink" title="读文件与写文件"></a>读文件与写文件</h3><div class="note primary flat"><p>要读写文件，首先就是要先打开文件，进行open系统调用，所以read和write系统调用不需要文件的名称，因为在open系统调用中已经获取过了</p></div><p>进程在使用read系统调用时，需要的主要参数是</p><ol><li>指明是哪个文件(编号)</li><li>还需要指明要读入多少数据</li><li>读入的数据要放在内存中的什么位置</li></ol><p>在写文件时，需要的主要参数是</p><ol><li>指明是哪个文件(编号)</li><li>还需要指明要写出多少数据</li><li>写出的数据要放在内存中的什么位置</li></ol><hr><h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><h3 id="基于索引结点的共享方式-硬链接"><a href="#基于索引结点的共享方式-硬链接" class="headerlink" title="基于索引结点的共享方式(硬链接)"></a><strong>基于索引结点的共享方式(硬链接)</strong></h3><p>在索引结点中设置一个链接计数变量count，用于表示链接本索引结点上的用户目录项数</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/DLKy286tFET3ues.png" alt="image-20210809153408702"></p><p>特性：</p><ul><li>不能交叉文件系统进行硬链接的创建</li><li>不能对目录进行创建，只能对文件创建</li><li>删除一个硬链接文件不影响其他有相同inode号的文件，才有单级目录结构</li></ul><hr><h3 id="基于符号链的共享方式-软链接"><a href="#基于符号链的共享方式-软链接" class="headerlink" title="基于符号链的共享方式(软链接)"></a><strong>基于符号链的共享方式</strong>(<strong>软链接</strong>)</h3><p>概念：符号链接又叫软链接，和原文件不是一个文件，例如Windows的快捷方式，如果原始文件被删除，所有指向它的符号链接也就都被破坏了。</p><p>软链接有自己的inode，是Linux特殊文件的一种，作为一个文件，它的数据是它所连接的文件的路径。符号链接可以跨越文件系统，也可以为目录建立</p><p>操作系统根据路径一层层打开查找目录，最终找到共享文件，即使软链接指向的共享文件已被删除，Link型文件依然存在，只是通过Link型文件中的路径去查找共享文件会失败</p><hr><h2 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h2><p><strong>口令保护</strong></p><p>口令一般存放在文件对应的FCB或索引结点中，用户访问文件需要先输入口令，操作系统会将用户提供的口令与FCB中存储的口令进行对比，如果正确就允许访问</p><p>优点：保存口令的空间开销不多，验证口令的时间开销也很小</p><p>缺点：存放在系统内部不安全</p><hr><p><strong>加密保护</strong></p><p>使用某个密码对文件进行加密，在访问文件时需要提供正确的密码才能对文件进行正确的解密</p><p>优点：保密性强，不需要在系统中存储密码</p><p>缺点：加密和解密要花费一定时间</p><hr><p><strong>访问控制表</strong></p><p>在每个文件的FCB中增加一个访问控制列表，该表中记录了各个用户可以对该文件执行哪些操作</p><hr><h2 id="文件系统的全局结构"><a href="#文件系统的全局结构" class="headerlink" title="文件系统的全局结构"></a>文件系统的全局结构</h2><h3 id="外存结构"><a href="#外存结构" class="headerlink" title="外存结构"></a>外存结构</h3><p><strong>磁盘初始化</strong></p><ol><li><p>进行物理格式化，将磁盘的各个磁道划分为扇区</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220722002248693.png" alt="image-20220722002248693"></p></li><li><p>将磁盘分区，每个分区由若干个柱面组成</p></li><li><p>进行逻辑格式化，创建文件系统。包括创建文件系统的根目录，初始化存储空间管理所用的数据结构</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220722005137431.png" alt="image-20220722005137431"></p></li></ol><p>引导块是负责初始化操作系统(PBR→MBR)</p><p>超级块可以迅速找到磁盘中的空间块</p><p>结点区是集中存放索引结点的区</p><hr><h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><p> <img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220722005744767.png" alt="image-20220722005744767"></p><p>近期访问过的目录文件会缓存在内存中，不用每次都从磁盘读入，这样可以<strong>加快目录检索速度</strong></p><p>打开文件的步骤：</p><ol><li>根据路径读入目录</li><li>找到文件的FCB，复制到系统打开文件表</li><li>在进程打开文件表中新建一个条目，并返回文件描述符</li></ol><hr><h2 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>操作系统中可以有多个不同的文件系统，所以需要一个虚拟的文件系统来协调各个不同的文件系统</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220722010402404.png" alt="image-20220722010402404"></p><p>特点</p><ol><li>向上层用户进程提供同一标准的系统调用接口，屏蔽底层具体文件系统的实现差异</li><li>VFS要求下层的文件系统必须实现某些规定的函数，一个新的文件系统想要在某操作系统上被使用，就必须满足该操作系统VFS的要求</li><li>每打开一个文件，VFS就在主存中新建一个vnode，用统一的数据结构表示文件，无论该文件存储在哪个文件系统</li></ol><p>不同的文件系统目录项都不一样，在虚拟文件系统中，统一用vnode表示，vnode只存在于主存中，而inode既会被调入主存，也会在外存中存储</p><h3 id="文件系统的挂载"><a href="#文件系统的挂载" class="headerlink" title="文件系统的挂载"></a>文件系统的挂载</h3><p>即将一个文件系统挂载到操作系统的虚拟操作系统上</p><ol><li>在VFS中注册新挂载的文件系统。内存中的挂载表包含每个文件系统的相关信息，包括文件系统类型，容量大小等</li><li>新挂载的文件系统，要向VFS提供一个函数地址列表(即文件系统的基本函数(如open)的地址)</li><li>将新文件系统加到挂载点，也就是将新文件系统挂载到某个父目录下</li></ol><hr><h2 id="固态硬盘-SSD"><a href="#固态硬盘-SSD" class="headerlink" title="固态硬盘(SSD)"></a>固态硬盘(SSD)</h2><p>SSD基于闪存技术，属于电可擦除ROM，即EEPROM</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20220722013421997.png" alt="image-20220722013421997"></p><p>闪存翻译层：负责翻译逻辑块号，找到对应页</p><p>存储介质：多个闪存芯片，每个芯片代表多个块，每个块代表多个页</p><hr><h3 id="读写性能"><a href="#读写性能" class="headerlink" title="读写性能"></a>读写性能</h3><ul><li>以页为单位读写</li><li>以块为单位擦除，其中每页都可以写一次，读无限次，在擦除的时候会将块内除要擦除数据之外的数据，移动到空闲块中，然后将原来的块进行擦除，同时闪存翻译层修改逻辑块号的映射</li><li>支持随机访问，系统给定一个逻辑地址，闪存翻译层可通过电路迅速定位到对应的物理地址</li></ul><hr><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><p>读写速度快，随机访问性能高，用电路控制访问位置</p></li><li><p>安静无噪音，耐摔抗震，能耗低，造价贵</p></li><li><p>SSD的一个块被擦除次数过多可能会坏掉，而机械硬板的扇区不会因为写的次数太多而坏掉</p></li></ul><hr><h3 id="磨损均衡技术"><a href="#磨损均衡技术" class="headerlink" title="磨损均衡技术"></a>磨损均衡技术</h3><p>将擦除平均到各个块上，以提升使用寿命</p><p>动态磨损均衡：写入数据时，优先选择累计擦除次数少的新闪存块</p><p>静态磨损均衡：SSD监测并自动进行数据分配，迁移，让老旧的闪存块承担以读为主的存储任务，让新闪存块承担更多的写任务</p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客配置</title>
      <link href="/post/12559.html"/>
      <url>/post/12559.html</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo博客用到的一些配置"><a href="#Hexo博客用到的一些配置" class="headerlink" title="Hexo博客用到的一些配置"></a>Hexo博客用到的一些配置</h1><h2 id="1-分类磁贴"><a href="#1-分类磁贴" class="headerlink" title="1.分类磁贴"></a>1.分类磁贴</h2><p>参考以下链接中提到的方法</p><p><a href="https://fe32.top/articles/hexo1606">https://fe32.top/articles/hexo1606</a></p><p>效果图：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/MhlarxNvGpOUwL4.png" alt="image-20211223170308252"></p><ul><li>修改<code>BlogRoot/node_modules/hexo-theme-butterfly/layout/index.pug</code></li></ul><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  extends includes/layout.pug</span><br><span class="line">  block content</span><br><span class="line">    include ./includes/mixins/post-ui.pug</span><br><span class="line">    #recent-posts.recent-posts</span><br><span class="line"><span class="addition">+     if theme.categoryBar.enable</span></span><br><span class="line"><span class="addition">+       .recent-post-item(style=&#x27;height:auto;width:100%;padding:0px;&#x27;)</span></span><br><span class="line"><span class="addition">+         #categoryBar!= list_categories(site.categories,&#123;class: &#x27;categoryBar&#x27;,depth: 1&#125;)</span></span><br><span class="line">      +postUI</span><br><span class="line">      include includes/pagination.pug</span><br></pre></td></tr></table></figure><ul><li>新建<code>BlogRoot/node_modules/hexo-theme-butterfly/source/css/_layout/categoryBar.styl</code></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if hexo-config(&#x27;categoryBar<span class="selector-class">.enable</span>&#x27;)</span><br><span class="line">  <span class="selector-id">#categoryBar</span></span><br><span class="line">    <span class="attribute">width</span> <span class="number">100%</span>!important</span><br><span class="line">  <span class="selector-tag">ul</span></span><br><span class="line">    &amp;<span class="selector-class">.categoryBar-list</span></span><br><span class="line">      <span class="attribute">margin</span> <span class="number">5px</span> <span class="number">5px</span> <span class="number">0</span> <span class="number">5px</span>!important</span><br><span class="line">      <span class="attribute">padding</span> <span class="number">0</span>!important</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">li</span></span><br><span class="line">    &amp;<span class="selector-class">.categoryBar-list-item</span></span><br><span class="line">      <span class="attribute">font-weight</span> bold</span><br><span class="line">      <span class="attribute">display</span> inline-block</span><br><span class="line">      <span class="attribute">height</span> <span class="number">180px</span>!important</span><br><span class="line">      <span class="attribute">margin</span> <span class="number">5px</span> .<span class="number">5%</span> <span class="number">0</span> .<span class="number">5%</span>!important</span><br><span class="line">      <span class="attribute">background-image</span> linear-gradient(rgba(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.4</span>) <span class="number">25%</span>, rgba(<span class="number">16</span>, <span class="number">16</span>, <span class="number">16</span>, <span class="number">0</span>) <span class="number">100%</span>)</span><br><span class="line">      <span class="attribute">border-radius</span> <span class="number">10px</span></span><br><span class="line">      <span class="attribute">padding</span> <span class="number">25px</span> <span class="number">0</span> <span class="number">25px</span> <span class="number">25px</span>!important</span><br><span class="line">      <span class="attribute">box-shadow</span> rgba(<span class="number">50</span>, <span class="number">50</span>, <span class="number">50</span>, <span class="number">0.3</span>)  <span class="number">50px</span> <span class="number">50px</span> <span class="number">50px</span> <span class="number">50px</span> inset</span><br><span class="line">      <span class="attribute">overflow</span> hidden</span><br><span class="line">      <span class="attribute">background-size</span> <span class="number">100%</span>!important</span><br><span class="line">      <span class="attribute">background-position</span> center!important</span><br><span class="line">      &amp;<span class="selector-pseudo">:hover</span></span><br><span class="line">        <span class="attribute">background-size</span> <span class="number">110%</span>!important</span><br><span class="line">        <span class="attribute">box-shadow</span> inset <span class="number">500px</span> <span class="number">50px</span> <span class="number">50px</span> <span class="number">50px</span> rgba(<span class="number">50</span>,<span class="number">50</span>,<span class="number">50</span>, <span class="number">0.6</span>)</span><br><span class="line">        <span class="selector-tag">span</span></span><br><span class="line">          &amp;<span class="selector-class">.categoryBar-list-count</span></span><br><span class="line">            &amp;<span class="selector-pseudo">::after</span></span><br><span class="line">              <span class="attribute">transition</span> all .<span class="number">5s</span></span><br><span class="line">              <span class="attribute">transform</span> translate(-<span class="number">100%</span>, <span class="number">0</span>)</span><br><span class="line">  <span class="selector-tag">a</span></span><br><span class="line">    &amp;<span class="selector-class">.categoryBar-list-link</span></span><br><span class="line">      <span class="attribute">color</span> white!important</span><br><span class="line">      <span class="attribute">font-size</span> <span class="number">20px</span>!important</span><br><span class="line">      &amp;<span class="selector-pseudo">::before</span></span><br><span class="line">        <span class="attribute">content</span> &#x27;|&#x27;!important</span><br><span class="line">        <span class="attribute">color</span> white!important</span><br><span class="line">        <span class="attribute">font-size</span> <span class="number">20px</span>!important</span><br><span class="line">      &amp;:after</span><br><span class="line">        content <span class="string">&#x27;&#x27;</span></span><br><span class="line">        position relative</span><br><span class="line">        width <span class="number">0</span></span><br><span class="line">        bottom <span class="number">0</span></span><br><span class="line">        display block</span><br><span class="line">        height <span class="number">3px</span></span><br><span class="line">        border-radius <span class="number">3px</span></span><br><span class="line">        background-color white</span><br><span class="line">      &amp;:hover</span><br><span class="line">        &amp;:after</span><br><span class="line">          width <span class="number">90%</span></span><br><span class="line">          left <span class="number">1%</span></span><br><span class="line">          transition all <span class="number">0.5s</span></span><br><span class="line"></span><br><span class="line">  span</span><br><span class="line">    &amp;.categoryBar-list-count</span><br><span class="line">      display block<span class="meta">!important</span></span><br><span class="line">      color white<span class="meta">!important</span></span><br><span class="line">      font-size <span class="number">20px</span><span class="meta">!important</span></span><br><span class="line">      &amp;::before</span><br><span class="line">        content <span class="string">&#x27;\f02d&#x27;</span><span class="meta">!important</span></span><br><span class="line">        padding-right <span class="number">15px</span><span class="meta">!important</span></span><br><span class="line">        @extend .fontawesomeIcon</span><br><span class="line">      &amp;::after</span><br><span class="line">        padding <span class="number">5px</span></span><br><span class="line">        display block<span class="meta">!important</span></span><br><span class="line">        color white<span class="meta">!important</span></span><br><span class="line">        font-size <span class="number">20px</span><span class="meta">!important</span></span><br><span class="line">        position relative</span><br><span class="line">        right -<span class="number">100%</span></span><br><span class="line">  covers = <span class="built_in">hexo-config</span>(<span class="string">&#x27;categoryBar.cover&#x27;</span>)</span><br><span class="line">  for cover,i in covers</span><br><span class="line">    li.categoryBar-list-item:<span class="built_in">nth-child</span>(&#123;i+<span class="number">1</span>&#125;)</span><br><span class="line">      <span class="attribute">background</span> unquote(cover)</span><br><span class="line">  descrs = hexo-config(&#x27;categoryBar<span class="selector-class">.descr</span>&#x27;)</span><br><span class="line">  for descr,<span class="selector-tag">i</span> in descrs</span><br><span class="line">    <span class="selector-tag">li</span><span class="selector-class">.categoryBar-list-item</span><span class="selector-pseudo">:nth-child</span>(&#123;<span class="selector-tag">i</span>+<span class="number">1</span>&#125;)&gt;<span class="selector-tag">span</span><span class="selector-pseudo">::after</span></span><br><span class="line">      <span class="attribute">content</span> descr!important</span><br><span class="line">  if hexo-config(&#x27;categoryBar<span class="selector-class">.column</span>&#x27;) == &#x27;odd&#x27;</span><br><span class="line">    <span class="selector-tag">li</span></span><br><span class="line">      &amp;<span class="selector-class">.categoryBar-list-item</span></span><br><span class="line">        <span class="attribute">width</span> <span class="number">32.3%</span>!important</span><br><span class="line">  else if hexo-config(&#x27;categoryBar<span class="selector-class">.column</span>&#x27;) == &#x27;even&#x27;</span><br><span class="line">    <span class="selector-tag">li</span></span><br><span class="line">      &amp;<span class="selector-class">.categoryBar-list-item</span></span><br><span class="line">        <span class="attribute">width</span> <span class="number">24%</span>!important</span><br><span class="line">  <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">650px</span>)</span><br><span class="line">    li</span><br><span class="line">      &amp;.categoryBar-list-item</span><br><span class="line">        <span class="attribute">width</span> <span class="number">48%</span>!important</span><br><span class="line">        <span class="attribute">height</span> <span class="number">150px</span>!important</span><br><span class="line">        margin <span class="number">5px</span> <span class="number">1%</span> <span class="number">0</span> <span class="number">1%</span>!important</span><br><span class="line"></span><br><span class="line">  $caterow =  hexo-config(<span class="string">&#x27;categoryBar.row&#x27;</span>)?hexo-config(<span class="string">&#x27;categoryBar.row&#x27;</span>):<span class="number">2</span></span><br><span class="line">  .categoryBar-list</span><br><span class="line">    <span class="attribute">max-height</span> <span class="number">190px</span> * $caterow</span><br><span class="line">    overflow auto</span><br><span class="line">    &amp;::-webkit-scrollbar</span><br><span class="line">      <span class="attribute">width</span> <span class="number">0</span>!important</span><br><span class="line">  @media screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">650px</span>)</span><br><span class="line">    .categoryBar-list</span><br><span class="line">      <span class="attribute">max-height</span> <span class="number">160px</span> * $caterow</span><br></pre></td></tr></table></figure><ul><li>在主题配置文件<code>_config.butterfly.yml</code>中添加配置项：</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">YML</span></span><br><span class="line"><span class="attr">categoryBar:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">column:</span>  <span class="string">odd</span> <span class="comment"># 显示列数,odd：3列 | even：4列</span></span><br><span class="line">  <span class="attr">row:</span> <span class="number">2</span> <span class="comment">#显示行数，默认两行，超过行数切换为滚动显示</span></span><br><span class="line">  <span class="attr">descr:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Good</span> <span class="string">things</span> <span class="string">to</span> <span class="string">share</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Back</span> <span class="string">end</span> <span class="string">talk</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">personal</span> <span class="string">diary</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Front</span> <span class="string">end</span> <span class="string">serialization</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Butterfly</span> <span class="string">theme</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Other</span> <span class="string">items</span></span><br><span class="line">  <span class="attr">cover:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">url(&#x27;https://fastly.jsdelivr.net/npm/akilar-candyassets/image/cover1.webp&#x27;)</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;#abcdef&#x27;</span> <span class="comment"># HEX格式色值需要用&#x27;&#x27;包裹，不然会被识别成注释</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">rgba(45,67,89,0.7)</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">linear-gradient(rgba(0,</span> <span class="number">0</span><span class="string">,</span> <span class="number">0</span><span class="string">,</span> <span class="number">0.4</span><span class="string">)</span> <span class="number">25</span><span class="string">%,</span> <span class="string">rgba(200,16</span> <span class="string">,</span> <span class="number">16</span><span class="string">,</span> <span class="number">0</span><span class="string">)</span> <span class="number">100</span><span class="string">%)</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">url(&#x27;https://fastly.jsdelivr.net/npm/akilar-candyassets/image/cover5.webp&#x27;)</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">url(&#x27;https://fastly.jsdelivr.net/npm/akilar-candyassets/image/cover6.webp&#x27;)</span></span><br></pre></td></tr></table></figure><hr><h2 id="2-相关推荐置于侧边栏"><a href="#2-相关推荐置于侧边栏" class="headerlink" title="2.相关推荐置于侧边栏"></a>2.相关推荐置于侧边栏</h2><p>参考以下链接中的方法</p><p><a href="https://akilar.top/posts/194e1534/">https://akilar.top/posts/194e1534/</a></p><p>效果图：</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/aAflKdgGnEHic6N.png" alt="image-20211223170353902"></p><ul><li>修改<code>[Blogroot]\themes\butterfly\scripts\helpers\related_post.js</code>,从大概47行开始到70行的部分。</li></ul><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">  if (relatedPosts.length &gt; 0) &#123;</span><br><span class="line"><span class="deletion">-   result += &#x27;&lt;div class=&quot;relatedPosts&quot;&gt;&#x27;</span></span><br><span class="line"><span class="deletion">-   result += `&lt;div class=&quot;headline&quot;&gt;&lt;i class=&quot;fas fa-thumbs-up fa-fw&quot;&gt;&lt;/i&gt;&lt;span&gt;$&#123;headlineLang&#125;&lt;/span&gt;&lt;/div&gt;`</span></span><br><span class="line"><span class="deletion">-   result += &#x27;&lt;div class=&quot;relatedPosts-list&quot;&gt;&#x27;</span></span><br><span class="line"><span class="addition">+   result += &#x27;&lt;div class=&quot;card-widget card-recommend-post&quot;&gt;&#x27;</span></span><br><span class="line"><span class="addition">+   result += `&lt;div class=&quot;item-headline&quot;&gt;&lt;i class=&quot;fas fa-dharmachakra&quot;&gt;&lt;/i&gt;&lt;span&gt;$&#123;headlineLang&#125;&lt;/span&gt;&lt;/div&gt;`</span></span><br><span class="line"><span class="addition">+   result += &#x27;&lt;div class=&quot;aside-list&quot;&gt;&#x27;</span></span><br><span class="line">    for (let i = 0; i &lt; Math.min(relatedPosts.length, limitNum); i++) &#123;</span><br><span class="line">      const cover =</span><br><span class="line">        relatedPosts[i].cover <span class="comment">=== false</span></span><br><span class="line">          ? relatedPosts[i].randomcover</span><br><span class="line">          : relatedPosts[i].cover</span><br><span class="line"><span class="deletion">-     result += `&lt;div&gt;&lt;a href=&quot;$&#123;this.url_for(relatedPosts[i].path)&#125;&quot; title=&quot;$&#123;relatedPosts[i].title&#125;&quot;&gt;`</span></span><br><span class="line"><span class="deletion">-     result += `&lt;img class=&quot;cover&quot; src=&quot;$&#123;this.url_for(cover)&#125;&quot; alt=&quot;cover&quot;&gt;`</span></span><br><span class="line"><span class="addition">+     result += `&lt;div class=&quot;aside-list-item&quot;&gt;`</span></span><br><span class="line"><span class="addition">+     result += `&lt;a class=&quot;thumbnail&quot; href=&quot;$&#123;this.url_for(relatedPosts[i].path)&#125;&quot; title=&quot;$&#123;relatedPosts[i].title&#125;&quot;&gt;&lt;img src=&quot;$&#123;this.url_for(cover)&#125;&quot; alt=&quot;$&#123;relatedPosts[i].title&#125;&quot;&gt;&lt;/a&gt;`</span></span><br><span class="line"><span class="addition">+     result += `&lt;div class=&quot;content&quot;&gt;`</span></span><br><span class="line"><span class="addition">+     result += `&lt;a class=&quot;title&quot; href=&quot;$&#123;this.url_for(relatedPosts[i].path)&#125;&quot; title=&quot;$&#123;relatedPosts[i].title&#125;&quot;&gt;$&#123;relatedPosts[i].title&#125;&lt;/a&gt;`</span></span><br><span class="line">      if (dateType <span class="comment">=== &#x27;created&#x27;) &#123;</span></span><br><span class="line"><span class="deletion">-       result += `&lt;div class=&quot;content is-center&quot;&gt;&lt;div class=&quot;date&quot;&gt;&lt;i class=&quot;far fa-calendar-alt fa-fw&quot;&gt;&lt;/i&gt; $&#123;this.date(relatedPosts[i].created, hexoConfig.date_format)&#125;&lt;/div&gt;`</span></span><br><span class="line"><span class="addition">+       result += `&lt;time datetime=&quot;$&#123;this.date(relatedPosts[i].created, hexoConfig.date_format)&#125;&quot; title=&quot;发表于 $&#123;this.date(relatedPosts[i].created, hexoConfig.date_format)&#125;&quot;&gt;$&#123;this.date(relatedPosts[i].created, hexoConfig.date_format)&#125;&lt;/time&gt;`</span></span><br><span class="line">      &#125; else &#123;</span><br><span class="line"><span class="deletion">-       result += `&lt;div class=&quot;content is-center&quot;&gt;&lt;div class=&quot;date&quot;&gt;&lt;i class=&quot;fas fa-history fa-fw&quot;&gt;&lt;/i&gt; $&#123;this.date(relatedPosts[i].updated, hexoConfig.date_format)&#125;&lt;/div&gt;`</span></span><br><span class="line"><span class="addition">+       result += `&lt;time datetime=&quot;$&#123;this.date(relatedPosts[i].updated, hexoConfig.date_format)&#125;&quot; title=&quot;发表于 $&#123;this.date(relatedPosts[i].updated, hexoConfig.date_format)&#125;&quot;&gt;$&#123;this.date(relatedPosts[i].updated, hexoConfig.date_format)&#125;&lt;/time&gt;`</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="deletion">-     result += `&lt;div class=&quot;title&quot;&gt;$&#123;relatedPosts[i].title&#125;&lt;/div&gt;`</span></span><br><span class="line"><span class="deletion">-     result += &#x27;&lt;/div&gt;&lt;/a&gt;&lt;/div&gt;&#x27;</span></span><br><span class="line"><span class="addition">+     result += `&lt;/div&gt;&lt;/div&gt;`</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result += &#x27;&lt;/div&gt;&lt;/div&gt;&#x27;</span><br><span class="line">    return result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>因为原本的版块是在文章下方，而现在我们需要把它改到侧栏。所以需要修改<code>[Blogroot]\themes\butterfly\layout\post.pug</code>大约26行的位置先移除在文章底部的推荐版块。</li></ul><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  if theme.post_pagination</span><br><span class="line">    include includes/pagination.pug</span><br><span class="line"><span class="deletion">- if theme.related_post &amp;&amp; theme.related_post.enable</span></span><br><span class="line"><span class="deletion">-   != related_posts(page,site.posts)</span></span><br><span class="line"></span><br><span class="line">  if page.comments !== false &amp;&amp; theme.comments &amp;&amp; theme.comments.use</span><br></pre></td></tr></table></figure><ul><li>然后修改<code>[Blogroot]\themes\butterfly\layout\includes\widget\index.pug</code>,这个文件每个版本都长得不太一样，这里仅供参考。因为感觉文章也最新文章和推荐文章同时存在，最新文章就显得有点多余了，所以我把最新文章的侧栏卡片注释了。</li></ul><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#aside-content.aside-content</span><br><span class="line">  //- post</span><br><span class="line">  if is_post()</span><br><span class="line">    if showToc &amp;&amp; theme.toc.style_simple</span><br><span class="line">      .sticky_layout</span><br><span class="line">        include ./card_post_toc.pug</span><br><span class="line">    else</span><br><span class="line">      !=partial(&#x27;includes/custom/SAO_card_player&#x27;, &#123;&#125;, &#123;cache:theme.fragment_cache&#125;)</span><br><span class="line">      !=partial(&#x27;includes/widget/card_announcement&#x27;, &#123;&#125;, &#123;cache:theme.fragment_cache&#125;)</span><br><span class="line">      !=partial(&#x27;includes/widget/card_top_self&#x27;, &#123;&#125;, &#123;cache:theme.fragment_cache&#125;)  </span><br><span class="line">      .sticky_layout</span><br><span class="line">        if showToc</span><br><span class="line">          include ./card_post_toc.pug</span><br><span class="line"><span class="addition">+       if theme.related_post &amp;&amp; theme.related_post.enable</span></span><br><span class="line"><span class="addition">+         != related_posts(page,site.posts)</span></span><br><span class="line"><span class="deletion">-       - !=partial(&#x27;includes/widget/card_recent_post&#x27;, &#123;&#125;, &#123;cache:theme.fragment_cache&#125;)</span></span><br><span class="line"><span class="addition">+       //- !=partial(&#x27;includes/widget/card_recent_post&#x27;, &#123;&#125;, &#123;cache:theme.fragment_cache&#125;)</span></span><br><span class="line">        !=partial(&#x27;includes/widget/card_ad&#x27;, &#123;&#125;, &#123;cache:theme.fragment_cache&#125;)</span><br></pre></td></tr></table></figure><hr><h2 id="3-vercel-github-加速博客访问"><a href="#3-vercel-github-加速博客访问" class="headerlink" title="3.vercel+github 加速博客访问"></a>3.vercel+github 加速博客访问</h2><p><a href="https://vincentqin.tech/posts/speedup-gitpage/">https://vincentqin.tech/posts/speedup-gitpage/</a></p><hr><h2 id="4-typora-picgo-github-一键托管图片"><a href="#4-typora-picgo-github-一键托管图片" class="headerlink" title="4.typora+picgo+github 一键托管图片"></a>4.typora+picgo+github 一键托管图片</h2><p><a href="https://blog.csdn.net/weixin_45965432/article/details/108911937">https://blog.csdn.net/weixin_45965432/article/details/108911937</a></p><p>由于github不稳定，已经改成了腾讯云OSS存储，参考</p><p><a href="https://www.cnblogs.com/hackettt/p/15637743.html">https://www.cnblogs.com/hackettt/p/15637743.html</a></p><hr><h2 id="5-jsDeliver-github使用教程，免费的cdn"><a href="#5-jsDeliver-github使用教程，免费的cdn" class="headerlink" title="5.jsDeliver+github使用教程，免费的cdn"></a>5.jsDeliver+github使用教程，免费的cdn</h2><p><a href="https://www.cnblogs.com/zhsh666/p/11432956.html">https://www.cnblogs.com/zhsh666/p/11432956.html</a></p><hr><h2 id="6-背景效果，页脚渐变，滚动条效果"><a href="#6-背景效果，页脚渐变，滚动条效果" class="headerlink" title="6.背景效果，页脚渐变，滚动条效果"></a>6.背景效果，页脚渐变，滚动条效果</h2><p><a href="https://www.cnblogs.com/antmoe/p/12846393.html">https://www.cnblogs.com/antmoe/p/12846393.html</a></p><hr><h2 id="7-twikoo评论区以及部署到vercel"><a href="#7-twikoo评论区以及部署到vercel" class="headerlink" title="7.twikoo评论区以及部署到vercel"></a>7.twikoo评论区以及部署到vercel</h2><p><a href="https://twikoo.js.org/quick-start.html">https://twikoo.js.org/quick-start.html</a></p><hr><h2 id="8-HEXO永久链接"><a href="#8-HEXO永久链接" class="headerlink" title="8.HEXO永久链接"></a>8.HEXO永久链接</h2><p><a href="https://blog.csdn.net/xinruodingshui/article/details/105682550">https://blog.csdn.net/xinruodingshui/article/details/105682550</a></p><hr><h2 id="9-将jsDeliver替换为字节跳动的CDN"><a href="#9-将jsDeliver替换为字节跳动的CDN" class="headerlink" title="9.将jsDeliver替换为字节跳动的CDN"></a>9.将jsDeliver替换为字节跳动的CDN</h2><p><a href="https://blog.zhheo.com/p/790087d9.html">https://blog.zhheo.com/p/790087d9.html</a></p><p><a href="https://cdn.bytedance.com/">https://cdn.bytedance.com/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA之集合---Collection</title>
      <link href="/post/30509.html"/>
      <url>/post/30509.html</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA之集合—-Collection"><a href="#JAVA之集合—-Collection" class="headerlink" title="JAVA之集合—-Collection"></a>JAVA之集合—-Collection</h1><p>数组有很多的缺点，比如</p><ul><li>一旦初始化以后，其长度就不可修改。</li><li>数组中提供的方法非常有限，对于添加、删除、插入数据等操作，非常不便，同时效率不高。</li><li>获取数组中实际元素的个数的需求，数组没有现成的属性或方法可用</li><li>数组存储数据的特点：有序、可重复。对于无序、不可重复的需求，不能满足。</li></ul><p>所以我们使用<strong>集合</strong>来实现</p><p>集合分为<strong>Collection和Map</strong>两种体系</p><ul><li><strong>Collection</strong>：主要由List、Set、Queue接口组成，List代表有序、重复的集合；其中Set代表无序、不可重复的集合；Java 5 又增加了Queue体系集合，代表一种队列集合实现。</li><li><strong>Map</strong>：则代表具有映射关系的键值对集合。</li></ul><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20211130204408289.png" alt="image-20211130204408289"></p><h2 id="Collections方法"><a href="#Collections方法" class="headerlink" title="Collections方法"></a>Collections<strong>方法</strong></h2><p>所有的Collection下的实现类都能使用此方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;Integer&gt; coll = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Collection&lt;Integer&gt; coll = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">Collection&lt;Integer&gt; coll = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Elemtype  e)</span></span>;<span class="comment">//添加一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Elemtype e)</span></span>;<span class="comment">//检查集合中指定的元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Eletmtype e)</span></span>;<span class="comment">//移除集合中的元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">max</span><span class="params">(coll)</span> <span class="comment">//根据元素的自然顺序，返回给定集合中的最大元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">min</span><span class="params">(coll)</span><span class="comment">//根据元素的自然顺序，返回给定集合中的最小元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">frequency</span><span class="params">(coll，<span class="keyword">int</span> i)</span> <span class="comment">//返回指定集合中指定元素的出现次数</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure><p>不过有些限定了只能List使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;Integer&gt; coll = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span> <span class="params">(coll)</span></span>;<span class="comment">//反转 List 中元素的顺序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(coll,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>;<span class="comment">//将指定 list 集合中的 i 处元素和 j 处元素进行交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List)</span></span>;<span class="comment">//根据元素的自然顺序对指定 List 集合元素按升序排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List，Comparator)</span></span>;<span class="comment">//根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</span></span><br></pre></td></tr></table></figure><hr><p>Collection接口，是单列数据，定义了一组对象方法的集合</p><ul><li>List：元素有序，可重复的集合</li><li>Set：元素无序，不可重复的集合</li><li>Queue：Queue是一个队列集合，队列通常是指“先进先出”（FIFO）的容器。</li></ul><hr><h2 id="List（有序列表）"><a href="#List（有序列表）" class="headerlink" title="List（有序列表）"></a><strong>List（有序列表）</strong></h2><p>List集合的特点就是存取有序，可以存储重复的元素，可以用<strong>下标</strong>进行元素的操作</p><p>List方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Elemtype <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="comment">//获取此集合中指定索引位置的元素，E 为集合中元素的数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">index</span><span class="params">(Elemtype e)</span></span>;</span><br><span class="line"><span class="comment">//返回此集合中第一次出现指定元素的索引，如果此集合不包含该元素，则返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Elemtype e)</span></span>;</span><br><span class="line"><span class="comment">//返回此集合中最后一次出现指定元素的索引，如果此集合不包含该元素，则返回 -1</span></span><br><span class="line"><span class="function">Elemtype <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, Eelement)</span></span>;</span><br><span class="line"><span class="comment">//将此集合中指定索引位置的元素修改为 element 参数指定的对象。此方法返回此集合中指定索引位置的原元素</span></span><br><span class="line"><span class="function">List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromlndex, <span class="keyword">int</span> tolndex)</span></span>;</span><br><span class="line"><span class="comment">//返回一个新的集合，新集合中包含 fromlndex 和 tolndex 索引之间的所有元素。包含fromlndex 处的元素，不包含 tolndex 索引处的元素</span></span><br></pre></td></tr></table></figure><hr><h3 id="数组转换成List的方法"><a href="#数组转换成List的方法" class="headerlink" title="数组转换成List的方法"></a>数组转换成List的方法</h3><p>最简单的是，直接用一个<code>for</code>循环遍历数组，用<code>add</code>方法添加进<code>List</code>即可</p><p>首先将一个数组从<code>int</code>转换为<code>Integer</code>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化int数组</span></span><br><span class="line"><span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="comment">//将int数组转换为数值流</span></span><br><span class="line">IntStream stream = Arrays.stream(nums);</span><br><span class="line"><span class="comment">//流中的元素全部装箱，转换为Integer流 </span></span><br><span class="line">Stream&lt;Integer&gt; integerStream = stream.boxed();</span><br><span class="line"><span class="comment">//将流转换为数组</span></span><br><span class="line">Integer[] integers = integerStream.toArray(Integer[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure><p>实际上可用一行代码完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer newNums[] = Arrays.stream(nums).boxed().toArray(Integer[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure><hr><h3 id="ArrayList（动态数组）"><a href="#ArrayList（动态数组）" class="headerlink" title="ArrayList（动态数组）"></a><strong>ArrayList（动态数组）</strong></h3><p>ArrayList 是一个动态数组结构，支持随机存取，尾部插入删除方便，内部插入删除效率低（因为要移动数组元素）；如果内部数组容量不足则自动扩容，因此当数组很大时，效率较低。</p><p>ArrayList继承了List和Collection的所有方法</p><p>利用Arrays类方法<code>asList</code>可将数组转换为<code>ArrayList</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ArrayList <span class="title">asList</span><span class="params">(array)</span></span>;</span><br><span class="line"><span class="comment">//将一个数组转变成一个List，准确来说是ArrayList</span></span><br></pre></td></tr></table></figure><hr><h3 id="LinkedList（双向链表）"><a href="#LinkedList（双向链表）" class="headerlink" title="LinkedList（双向链表）"></a><strong>LinkedList（双向链表）</strong></h3><p>LinkedList 是一个双向链表结构，在任意位置插入删除都很方便，但是不支持随机取值，每次都只能从一端开始遍历，直到找到查询的对象，然后返回；不过，它不像 ArrayList 那样需要进行内存拷贝，因此相对来说效率较高，但是因为存在额外的前驱和后继节点指针，因此占用的内存比 ArrayList 多一些。</p><p>LinkedList除了继承了List和Collection的所有方法，根据其链表的特性，还特有几种方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span></span>; <span class="comment">//将指定元素添加到此集合的开头</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span></span>; <span class="comment">//将指定元素添加到此集合的末尾</span></span><br><span class="line"><span class="function">Elemtype <span class="title">getFirst</span><span class="params">()</span></span>;    <span class="comment">//返回此集合的第一个元素</span></span><br><span class="line"><span class="function">Elemtype <span class="title">getLast</span><span class="params">()</span></span>; <span class="comment">//返回此集合的最后一个元素</span></span><br><span class="line"><span class="function">Elemtype <span class="title">removeFirst</span><span class="params">()</span></span>; <span class="comment">//删除此集合中的第一个元素</span></span><br><span class="line"><span class="function">Elemtype <span class="title">removeLast</span><span class="params">()</span></span>;  <span class="comment">//删除此集合中的最后一个元素</span></span><br></pre></td></tr></table></figure><hr><h3 id="Vector（动态数组）"><a href="#Vector（动态数组）" class="headerlink" title="Vector（动态数组）"></a><del>Vector（动态数组）</del></h3><p>Vector 也是一个动态数组结构，一个元老级别的类，早在 jdk1.1 就引入进来类，之后在 jdk1.2 里引进 ArrayList，ArrayList 大部分的方法和 Vector 比较相似，两者是不同的，Vector 是允许同步访问的，<strong>Vector 中的操作是线程安全的</strong>，但是效率低，而 ArrayList 所有的操作都是异步的，执行效率高，但不安全！</p><p>因为ArrayList已经有了其他安全的方法，所以没有用Vector的必要</p><hr><h3 id="Stack（栈）"><a href="#Stack（栈）" class="headerlink" title="Stack（栈）"></a><del>Stack（栈）</del></h3><p>Stack 是 Vector 的一个子类，本质也是一个动态数组结构，不同的是，它的数据结构是先进后出，取名叫栈！</p><p>关于<code>Stack</code>，现在用的也很少，因为有个<code>ArrayDeque</code>双端队列，可以替代<code>Stack</code>所有的功能，并且执行效率比它高！</p><hr><h2 id="Queue（队列）"><a href="#Queue（队列）" class="headerlink" title="Queue（队列）"></a><strong>Queue（队列）</strong></h2><p>Queue是一个队列集合，队列通常是指“先进先出”（FIFO）的容器。新元素插入（offer）到队列的尾部，访问元素（poll）操作会返回队列头部的元素。通常，队列不允许随机访问队列中的元素</p><hr><h3 id="ArrayDeque-（双端队列）"><a href="#ArrayDeque-（双端队列）" class="headerlink" title="ArrayDeque （双端队列）"></a>ArrayDeque （双端队列）</h3><p>ArrayQueue是一个基于数组实现的<strong>双端队列</strong>，可以想象，在队列中存在两个指针，一个指向头部，一个指向尾部，因此它具有“FIFO队列”及“栈”的方法特性。</p><p>既可以先进先出，也可以先进后出</p><p>常用方法 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队列常用方法：</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;<span class="comment">//队列空返回真，否则返回假</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">peek</span><span class="params">()</span></span>;<span class="comment">//获取队头元素，但不出栈</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;<span class="comment">//入队</span></span><br><span class="line"><span class="function">Elemtype <span class="title">poll</span><span class="params">()</span></span>;<span class="comment">//出队，获取并移除队头元素，若为空则返回Null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//栈常用方法：</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;<span class="comment">//栈空返回真，否则返回假</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">peek</span><span class="params">()</span></span>;<span class="comment">//获取栈顶元素，但不出栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span></span>;<span class="comment">//入栈</span></span><br><span class="line"><span class="function">Elemtype <span class="title">pop</span><span class="params">(E e)</span></span>;<span class="comment">//出栈,获取并移除栈顶元素，若为空则返回Null</span></span><br></pre></td></tr></table></figure><hr><h3 id="PriorityQueue（优先队列）"><a href="#PriorityQueue（优先队列）" class="headerlink" title="PriorityQueue（优先队列）"></a>PriorityQueue（优先队列）</h3><p>PriorityQueue也是一个队列的实现类，此实现类中存储的元素排列并不是按照元素添加的顺序进行排列，而是内部会按元素的大小顺序进行排列，是一种能够自动排序的队列。</p><hr><h3 id="LinkedList（双向链表）-1"><a href="#LinkedList（双向链表）-1" class="headerlink" title="LinkedList（双向链表）"></a>LinkedList（双向链表）</h3><p>双向链表同样也实现了Queue类</p><hr><h2 id="Set-集"><a href="#Set-集" class="headerlink" title="Set(集)"></a><strong>Set(集)</strong></h2><p>Set集合的特点：元素不重复，存取无序，<strong>无下标</strong>；</p><p><strong>Set 集合的实现，基本都是基于 Map 中的键做文章，使用 Map 中键不能重复、无序的特性；所以，我们只需要重点关注 Map 的实现即可！</strong></p><hr><h3 id="Set转换为数组的办法"><a href="#Set转换为数组的办法" class="headerlink" title="Set转换为数组的办法"></a>Set转换为数组的办法</h3><p>方法1：采用<code>toArray(new Integer[] &#123;&#125;)</code>方法直接转为<code>Integer</code>数组，然后再转为整型数组；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] SetToInt(Set&lt;Integer&gt; allSet) &#123;</span><br><span class="line">        <span class="comment">// 先将set集合转为Integer型数组</span></span><br><span class="line">        Set&lt;Integer&gt; allSet = <span class="keyword">new</span> TreeSet&lt;Integer&gt;();</span><br><span class="line">        Integer[] temp = allSet.toArray(<span class="keyword">new</span> Integer[] &#123;&#125;);<span class="comment">//关键语句</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 再将Integer型数组转为int型数组</span></span><br><span class="line">        <span class="keyword">int</span>[] intArray = <span class="keyword">new</span> <span class="keyword">int</span>[temp.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">            intArray[i] = temp[i].intValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intArray;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="HashSet（哈希集）"><a href="#HashSet（哈希集）" class="headerlink" title="HashSet（哈希集）"></a>HashSet（哈希集）</h3><p>HashSet底层是基于 HashMap 的<code>k</code>实现的，元素不可重复，特性同 HashMap。</p><hr><h3 id="LinkedHashSet（链表哈希集）"><a href="#LinkedHashSet（链表哈希集）" class="headerlink" title="LinkedHashSet（链表哈希集）"></a>LinkedHashSet（链表哈希集）</h3><p>LinkedHashSet底层也是基于 LinkedHashMap 的<code>k</code>实现的，一样元素不可重复，特性同 LinkedHashMap。</p><hr><h3 id="TreeSet（树集）"><a href="#TreeSet（树集）" class="headerlink" title="TreeSet（树集）"></a>TreeSet（树集）</h3><p>同样的，TreeSet 也是基于 TreeMap 的<code>k</code>实现的，同样元素不可重复，特性同 TreeMap；</p><h4 id="独特方法"><a href="#独特方法" class="headerlink" title="独特方法"></a>独特方法</h4><p>因为TreeMap实现了具有一些独特方法，所以TreeSet同样也有</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Elemtype <span class="title">ceiling</span><span class="params">(E e)</span></span>;</span><br><span class="line"><span class="comment">//返回在这一组大于或等于e的最小元素，如果没有这样的元素则返回null。</span></span><br><span class="line"><span class="function">Elemtype <span class="title">higher</span><span class="params">(E e)</span></span>;</span><br><span class="line"><span class="comment">//返回Set中大于e的最小元素</span></span><br><span class="line"><span class="function">Elemtype <span class="title">floor</span><span class="params">(E e)</span></span>;</span><br><span class="line"><span class="comment">//返回在这一组中小于或等于e的最大元素,如果没有这样的元素则返回null</span></span><br><span class="line"><span class="function">Elemtype <span class="title">lower</span><span class="params">(E e)</span></span>;</span><br><span class="line"><span class="comment">// 返回Set中小于e的最大元素</span></span><br><span class="line"><span class="function">Elemtype <span class="title">first</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//返回第一个 （最小） 元素</span></span><br><span class="line"><span class="function">Elemtype <span class="title">last</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//返回最后一个(最高)元素</span></span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA之字符</title>
      <link href="/post/26759.html"/>
      <url>/post/26759.html</url>
      
        <content type="html"><![CDATA[<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="String的创建"><a href="#String的创建" class="headerlink" title="String的创建"></a>String的创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;Runoob&quot;</span>;</span><br><span class="line">String str2=<span class="keyword">new</span> String(<span class="string">&quot;Runoob&quot;</span>);</span><br></pre></td></tr></table></figure><p>同样也可以用<code>str.length()</code>来获取当前字符串的长度</p><hr><h2 id="String方法"><a href="#String方法" class="headerlink" title="String方法"></a>String方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="comment">//返回指定索引处的char值</span></span><br><span class="line"><span class="function">String <span class="title">concat</span><span class="params">(String str)</span></span>;</span><br><span class="line"><span class="comment">//将指定字符串连接到末尾</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span></span>;</span><br><span class="line"><span class="comment">//判断字符串是否相等</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch)</span></span>;</span><br><span class="line"><span class="comment">//返回第一次出现的下标，没有的话返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span></span>;</span><br><span class="line"><span class="comment">//返回指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1</span></span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span></span>;</span><br><span class="line"><span class="comment">//返回一个新的字符串，它是此字符串的一个子字符串。</span></span><br><span class="line"><span class="keyword">char</span>[] toCharArray();</span><br><span class="line"><span class="comment">//将此字符串转换为一个新的字符数组</span></span><br><span class="line"><span class="function">String <span class="title">valueOf</span><span class="params">(datatype x)</span></span>;</span><br><span class="line"><span class="comment">//返回给定datatype类型x参数的字符串表示形式。</span></span><br><span class="line">String [] split(String regex);</span><br><span class="line"><span class="comment">/*对现有的字符串按照正则表达式regex进行切割，并返回一个字符串数组</span></span><br><span class="line"><span class="comment">如果想要把字符串切成一个个字符，就split(&quot;&quot;)即可,如果想让字符串按照空格来进行切割就可以用split(&quot; &quot;)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String Sequence x)</span></span>;</span><br><span class="line"><span class="comment">//判断字符串里面是否有X子串</span></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> a,<span class="keyword">char</span> b)</span></span>;</span><br><span class="line"><span class="comment">//将字符串里面的所有a，都替换成b，并且返回一个替换后的String字符串</span></span><br><span class="line"><span class="function">String <span class="title">replaceFirst</span><span class="params">(String a,String b)</span></span>;</span><br><span class="line"><span class="comment">//将字符串中的第一个a，替换成b，并返回一个替换后的String字符串</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p>字符串转化为List</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="string">&quot;helloworld!&quot;</span></span><br><span class="line">String[] arr = str.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">ArrayList&lt;String&gt; list3 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">Collections.addAll(list3, arr);</span><br></pre></td></tr></table></figure><p>char转换为字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法1.直接在构造String时建立。</span></span><br><span class="line">    <span class="keyword">char</span> data[] = &#123;<span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;k&#x27;</span>&#125;; String str = <span class="keyword">new</span> String(data);</span><br><span class="line"><span class="comment">//方法2.使用String的方法</span></span><br><span class="line">    String.valueOf(<span class="keyword">char</span>[] chr);</span><br></pre></td></tr></table></figure><p>遍历字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="string">&quot;2019 come on&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法一 利用charAt方法，将字符串转换为单个字符输出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; str.length();i++) &#123;</span><br><span class="line"></span><br><span class="line"> System.out.println(str.charAt(i)); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二  用toCharArray方法，将字符串转化为字符数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>[]  c = str.toCharArray();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; c.length;i++) &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(c[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法三 用split()，将字符串转化为字符串数组</span></span><br><span class="line">String[]  s = str.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; s.length;i++) &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="操纵字符串的方法"><a href="#操纵字符串的方法" class="headerlink" title="操纵字符串的方法"></a>操纵字符串的方法</h2><p>如果频繁改变字符串变量，它会新开劈空间，再扔掉原本的空间，非常的浪费，和占用加载时间，但是StringBuffer不会，它会一直在一个空间里</p><p>StringBuffer和StringBuilder相比，保证了线程安全，但运行速度较慢</p><p>支持的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb=<span class="keyword">new</span> StringBuffer(String st); </span><br><span class="line">(StringBuffer) sb.append(<span class="string">&quot;s&quot;</span>);</span><br><span class="line"> <span class="comment">//将指定的字符串追加到此字符序列。</span></span><br><span class="line">(StringBuffer) sb.reverse();</span><br><span class="line"><span class="comment">//用反转形式取代</span></span><br><span class="line"> (<span class="keyword">void</span>)sb.insert(<span class="keyword">int</span> offset, <span class="keyword">int</span> i);</span><br><span class="line"><span class="comment">//将int参数的字符串插入到该序列中</span></span><br><span class="line">(String) toString();</span><br><span class="line"><span class="comment">// 返回此序列中数据的字符串表示形式，也就是将StringBuffer转换为String</span></span><br><span class="line">(StringBuffer) replace(<span class="keyword">int</span> start, <span class="keyword">int</span> end, String str);</span><br><span class="line"><span class="comment">//用指定的字符替换此序列的子字符串中的字符String。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCharAt</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">char</span> ch)</span></span>;</span><br><span class="line"><span class="comment">//指定索引处的字符设置为ch。</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">deleteCharAt</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="comment">//删除索引处的字符</span></span><br></pre></td></tr></table></figure><p>同样，StringBuilder也适用于这些方法</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA之数组</title>
      <link href="/post/50083.html"/>
      <url>/post/50083.html</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA之数组"><a href="#JAVA之数组" class="headerlink" title="JAVA之数组"></a>JAVA之数组</h1><h2 id="数组的创建"><a href="#数组的创建" class="headerlink" title="数组的创建"></a>数组的创建</h2><p>数组是JAVA的特殊队形，它们具有length的简单属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般来说，有两种形式</span></span><br><span class="line"><span class="keyword">int</span> [] a=<span class="keyword">new</span> <span class="keyword">int</span> [n];</span><br><span class="line"><span class="keyword">int</span> [] a=&#123;<span class="number">94</span>,<span class="number">45</span>,<span class="number">45</span>&#125;;</span><br></pre></td></tr></table></figure><p>如果要获取数组的长度，只需要使用<code>a.length</code>就可以了</p><hr><h2 id="For-Each循环"><a href="#For-Each循环" class="headerlink" title="For-Each循环"></a><strong>For-Each循环</strong></h2><p>能在不使用下标的情况下遍历数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Elemtype element:array)&#123;</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h2><p>Arrays类能够方便的操作数组，提供静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Elemtype array;</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">sort</span><span class="params">(array)</span></span>;</span><br><span class="line"><span class="comment">//sort 方法，对指定对象数组根据其元素的自然顺序进行升序排列。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(array,val)</span></span>;</span><br><span class="line"><span class="comment">//将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(array,array1)</span></span>;</span><br><span class="line"><span class="comment">//如果两个指定的 long 型数组彼此相等，则返回 true。</span></span><br><span class="line"><span class="comment">//换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(array,key)</span></span>;</span><br><span class="line"><span class="comment">//用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double等)。</span></span><br><span class="line"><span class="comment">//数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(插入点) - 1)。</span></span><br><span class="line"><span class="function">ArrayList <span class="title">asList</span><span class="params">(array)</span></span>;</span><br><span class="line"><span class="comment">//将一个数组转变成一个List，准确来说是ArrayList</span></span><br><span class="line"><span class="function">String <span class="title">toString</span><span class="params">(array)</span></span>;</span><br><span class="line"><span class="comment">//将一个数组转变成一个字符串，中间用,隔开</span></span><br><span class="line"><span class="keyword">int</span>[] copyOfRange(<span class="keyword">int</span> [] original ,<span class="keyword">int</span> from,<span class="keyword">int</span> to);</span><br><span class="line"><span class="comment">//复制出一个从from到to的左闭右开的数组</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA之集合---Map</title>
      <link href="/post/8465.html"/>
      <url>/post/8465.html</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA之集合—-Map"><a href="#JAVA之集合—-Map" class="headerlink" title="JAVA之集合—-Map"></a>JAVA之集合—-Map</h1><p>Map是一个双列集合，其中保存的是键值对<strong>(Key-Value)</strong>，键要求保持唯一性，值可以重复。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/image-20211130204437880.png" alt="image-20211130204437880"></p><p>Map的创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; Ages = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;(); </span><br></pre></td></tr></table></figure><h2 id="Map方法"><a href="#Map方法" class="headerlink" title="Map方法"></a>Map方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">Value <span class="title">get</span><span class="params">(K key)</span></span>; </span><br><span class="line"><span class="comment">//返回键映射的值，如果该键没有映射值，则返回null</span></span><br><span class="line"><span class="function">Value <span class="title">put</span><span class="params">(K key, V value)</span></span>; </span><br><span class="line"><span class="comment">//将键和值建立映射关系,如果键是第一次存储，就直接存储元素，返回null; 如果键不是第一次存在，就用值把以前的值替换掉，返回以前的值</span></span><br><span class="line"><span class="function">Value <span class="title">remove</span><span class="params">(K key)</span></span>; </span><br><span class="line"><span class="comment">//如果对应键存在映射关系的值，则将其移除，并返回值</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span><span class="title">containsKey</span><span class="params">(Object key)</span></span>; </span><br><span class="line"><span class="comment">//是否存在特定的key</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span><span class="title">containsValue</span><span class="params">(Object value)</span></span>; </span><br><span class="line"><span class="comment">//是否存在特定的value</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span><span class="title">isEmpty</span><span class="params">()</span></span>; </span><br><span class="line"><span class="comment">//判断集合是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>; </span><br><span class="line"><span class="comment">//移除所有的Entry(键值对)</span></span><br><span class="line">Set&lt;Map.Entry&lt;K,V&gt;&gt;entrySet();</span><br><span class="line"><span class="comment">//返回一个键值对的Set集合</span></span><br><span class="line"><span class="function">Set<span class="title">keySet</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//获取集合中所有键的集合</span></span><br><span class="line"><span class="function">Collection <span class="title">values</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//获取集合中所有值的集合</span></span><br><span class="line"><span class="function"><span class="keyword">int</span><span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//返回集合中的键值对的对数</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span></span>;</span><br><span class="line"><span class="comment">//Java8新特性，如果哈希表中有这个Key则获取这个值，如果没有则初始化Key的值为defaultValue</span></span><br></pre></td></tr></table></figure><hr><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>特点：</p><ul><li>无序</li><li>访问速度快</li><li>key不允许重复（只允许存在一个null Key）</li></ul><hr><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><ul><li>有序</li><li>先进先出</li><li>继承于HashMap</li></ul><p>LinkedHashMap它的特点主要在于linked，带有这个字眼的就表示底层用的是链表来进行的存储。</p><p>相对于其他的无序的map实现类，还有像TreeMap这样的排序类，linkedHashMap最大的特点在于有序，但是它的有序主要体现在先进先出FIFO上。没错，LinkedHashMap主要依靠双向链表和hash表来实现的。</p><hr><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a><strong>TreeMap</strong></h2><ul><li><p>对Key排序</p><p><code>TreeMap</code>也是一个很常用的<code>map</code>实现类，因为它实现了<code>SortMap</code>，所以会对<code>Key</code>进行排序，使用了<code>TreeMap</code>存储键值对，再使用<code>iterator</code>进行输出时，会发现其默认采用<code>key</code>由小到大的顺序输出键值对，如果想要按照其他的方式来排序，需要重写也就是<code>override</code> 它的<code>compartor</code>接口。</p></li></ul><p>因为只有<code>TreeMap</code>实现了<code>SortedMap</code>类，所以它具有一些独特方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Map.<span class="function">Entry&lt;K, V&gt; <span class="title">firstEntry</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//返回该TreeMap的第一个（最小的）映射</span></span><br><span class="line"><span class="function">K <span class="title">firstKey</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//返回该TreeMap的第一个（最小的）映射的key</span></span><br><span class="line">Map.<span class="function">Entry&lt;K, V&gt; <span class="title">lastEntry</span><span class="params">()</span></span>;</span><br><span class="line">/返回该TreeMap的最后一个（最大的）映射</span><br><span class="line"><span class="function">K <span class="title">lastKey</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//返回该TreeMap的最后一个（最大的）映射的key</span></span><br><span class="line"><span class="function">v <span class="title">get</span><span class="params">(K key)</span>：返回指定key对应的value</span></span><br><span class="line"><span class="function">SortedMap&lt;K, V&gt; <span class="title">headMap</span><span class="params">(K toKey)</span></span>;</span><br><span class="line"><span class="comment">//返回该TreeMap中严格小于指定key的映射集合</span></span><br><span class="line"><span class="function">SortedMap&lt;K, V&gt; <span class="title">subMap</span><span class="params">(K fromKey, K toKey)</span></span>;</span><br><span class="line"><span class="comment">//返回该TreeMap中指定范围的映射集合（大于等于fromKey，小于toKey）</span></span><br></pre></td></tr></table></figure><hr><h2 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a><del>Hashtable</del></h2><ul><li>无序</li><li>访问速度慢</li><li>同步</li><li>Key和Value都不能为null</li></ul><p>因为HashMap已经可以通过其他方法来保证安全，因此已经很少被使用</p><hr><h2 id="HashMap的遍历"><a href="#HashMap的遍历" class="headerlink" title="HashMap的遍历"></a>HashMap的遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapStudy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//一般来说,最好初始化一下, 小于12的就不要初始化了</span></span><br><span class="line">        <span class="comment">// 默认的就是16,因为加载因子是0.75,也就是到16*0.75=12的时候会扩容</span></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        map.put(<span class="string">&quot;welcome&quot;</span>,<span class="string">&quot;to&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;java&quot;</span>,<span class="string">&quot;study&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;wechat&quot;</span>,<span class="string">&quot;best396975802&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历方法1: 先遍历key , 再取出value</span></span><br><span class="line">        System.out.println(<span class="string">&quot;遍历方法1: 先遍历key , 再取出value&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;key is &quot;</span>+key);</span><br><span class="line">            System.out.println(<span class="string">&quot;value is &quot;</span>+ map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历方法2: 直接遍历value</span></span><br><span class="line">        System.out.println(<span class="string">&quot;遍历方法2: 直接遍历value&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String value : map.values()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;value is &quot;</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历方法3: 通过遍历entry来取Key和value,推荐的方法!!!</span></span><br><span class="line">        System.out.println(<span class="string">&quot;遍历方法3: 通过遍历entry来取Key和value,推荐的方法!!!&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;key is &quot;</span>+entry.getKey());</span><br><span class="line">            System.out.println(<span class="string">&quot;value is &quot;</span>+ entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历方法4: 通过forEach方法直接遍历key和value</span></span><br><span class="line">        System.out.println(<span class="string">&quot;遍历方法4: 通过forEach方法直接遍历&quot;</span>);</span><br><span class="line">        map.forEach((key,value)-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;key is &quot;</span>+ key);</span><br><span class="line">            System.out.println(<span class="string">&quot;value is &quot;</span>+ value);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>500.键盘行</title>
      <link href="/post/33235.html"/>
      <url>/post/33235.html</url>
      
        <content type="html"><![CDATA[<h1 id="500-键盘行"><a href="#500-键盘行" class="headerlink" title="500.键盘行"></a>500.键盘行</h1><p>给你一个字符串数组 <code>words</code> ，只返回可以使用在 <strong>美式键盘</strong> 同一行的字母打印出来的单词。键盘如下图所示。</p><p><strong>美式键盘</strong> 中：</p><ul><li>第一行由字符 <code>&quot;qwertyuiop&quot;</code> 组成。</li><li>第二行由字符 <code>&quot;asdfghjkl&quot;</code> 组成。</li><li>第三行由字符 <code>&quot;zxcvbnm&quot;</code> 组成。</li></ul><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/keyboard.png" alt="American keyboard"></p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [&quot;Hello&quot;,&quot;Alaska&quot;,&quot;Dad&quot;,&quot;Peace&quot;]</span><br><span class="line">输出：[&quot;Alaska&quot;,&quot;Dad&quot;]</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong>：</p><p>当然可以对比，根据<code>383.赎金信</code>的启发，可以使用<code>String</code>的<code>contains</code>以及<code>split(&quot;&quot;)</code>方法来判断单个字符是否在字符串中</p><p>以及<code>350.两个数组的交集2</code>中，用<code>Arrays</code>类的<code>copyofRange</code>方法快捷输出答案数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String[] findWords(String[] words) &#123;</span><br><span class="line">        String s1 = <span class="string">&quot;qwertyuiopQWERTYUIOP&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;asdfghjklASDFGHJKL&quot;</span>;</span><br><span class="line">        String [] ans=<span class="keyword">new</span> String [words.length];</span><br><span class="line">        <span class="keyword">int</span> count =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;words.length;i++)&#123;</span><br><span class="line">            String[] x=words[i].split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> n1 = <span class="number">0</span>, n2 = <span class="number">0</span> , n3 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; x.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s1.contains(x[j])) n1++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s2.contains(x[j])) n2++;</span><br><span class="line">                <span class="keyword">else</span>  n3++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(n1 == x.length || n2 == x.length || n3 == x.length) ans[count++]=words[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(ans,<span class="number">0</span>,count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 哈希表 </category>
          
          <category> 字符串 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>496.下一个更大元素</title>
      <link href="/post/56665.html"/>
      <url>/post/56665.html</url>
      
        <content type="html"><![CDATA[<h1 id="496-下一个更大元素"><a href="#496-下一个更大元素" class="headerlink" title="496.下一个更大元素"></a>496.下一个更大元素</h1><p>给你两个 <strong>没有重复元素</strong> 的数组 <code>nums1</code> 和 <code>nums2</code> ，其中<code>nums1</code> 是 <code>nums2</code> 的子集。</p><p>请你找出 <code>nums1</code> 中每个元素在 <code>nums2</code> 中的下一个比其大的值。</p><p><code>nums1</code> 中数字 <code>x</code> 的下一个更大元素是指 <code>x</code> 在 <code>nums2</code> 中对应位置的右边的第一个比 <code>x</code> 大的元素。如果不存在，对应位置输出 <code>-1</code> 。</p><p><strong>示例 1:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 = [<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>], nums2 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>].</span><br><span class="line">输出: [<span class="number">-1</span>,<span class="number">3</span>,<span class="number">-1</span>]</span><br><span class="line">解释:</span><br><span class="line">    对于 num1 中的数字 <span class="number">4</span> ，你无法在第二个数组中找到下一个更大的数字，因此输出 <span class="number">-1</span> 。</span><br><span class="line">    对于 num1 中的数字 <span class="number">1</span> ，第二个数组中数字<span class="number">1</span>右边的下一个较大数字是 <span class="number">3</span> 。</span><br><span class="line">    对于 num1 中的数字 <span class="number">2</span> ，第二个数组中没有下一个更大的数字，因此输出 <span class="number">-1</span> 。</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>我们可以先预处理 <code>nums2</code>，使查询<code>nums1</code>中的每个元素在<code>nums2</code>中对应位置的右边的第一个更大的元素值时不需要再遍历<code>nums2</code>。于是，我们将题目分解为两个子问题：</p><ul><li>第 1 个子问题：如何更高效地计算<code>nums2</code>中每个元素右边的第一个更大的值；</li><li>第 2 个子问题：如何存储第 1 个子问题的结果。</li></ul><p>针对第一个问题，我们可以逆序遍历<code>nums2</code>，同时将结果入栈，如当前元素大于栈顶元素，则让栈顶元素出栈，这种结构称为 单调栈</p><p>针对第二个问题，因为题目规定了<code>nums2</code>是没有重复元素的，所以我们可以使用哈希表来解决第 2个子问题，将元素值与其右边第一个更大的元素值的对应关系存入哈希表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums2.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = nums2[i];</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; num &gt;= stack.peek()) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(num, stack.isEmpty() ? -<span class="number">1</span> : stack.peek());</span><br><span class="line">            stack.push(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.length; ++i) &#123;</span><br><span class="line">            res[i] = map.get(nums1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 哈希表 </category>
          
          <category> 数组 </category>
          
          <category> 栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>495.提莫攻击</title>
      <link href="/post/10922.html"/>
      <url>/post/10922.html</url>
      
        <content type="html"><![CDATA[<h1 id="495-提莫攻击"><a href="#495-提莫攻击" class="headerlink" title="495.提莫攻击"></a>495.提莫攻击</h1><p>在《英雄联盟》的世界中，有一个叫 “提莫” 的英雄。他的攻击可以让敌方英雄艾希（编者注：寒冰射手）进入中毒状态。</p><p>当提莫攻击艾希，艾希的中毒状态正好持续 <code>duration</code> 秒。</p><p>正式地讲，提莫在 <code>t</code> 发起发起攻击意味着艾希在时间区间 <code>[t, t + duration - 1]</code>（含 <code>t</code> 和 <code>t + duration - 1</code>）处于中毒状态。如果提莫在中毒影响结束 <strong>前</strong> 再次攻击，中毒状态计时器将会 <strong>重置</strong> ，在新的攻击之后，中毒影响将会在 <code>duration</code> 秒后结束。</p><p>给你一个 <strong>非递减</strong> 的整数数组 <code>timeSeries</code> ，其中 <code>timeSeries[i]</code> 表示提莫在 <code>timeSeries[i]</code> 秒时对艾希发起攻击，以及一个表示中毒持续时间的整数 <code>duration</code> 。</p><p>返回艾希处于中毒状态的 <strong>总</strong> 秒数。</p><p><strong>示例 1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：timeSeries = [<span class="number">1</span>,<span class="number">4</span>], duration = <span class="number">2</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：提莫攻击对艾希的影响如下：</span><br><span class="line">- 第 <span class="number">1</span> 秒，提莫攻击艾希并使其立即中毒。中毒状态会维持 <span class="number">2</span> 秒，即第 <span class="number">1</span> 秒和第 <span class="number">2</span> 秒。</span><br><span class="line">- 第 <span class="number">4</span> 秒，提莫再次攻击艾希，艾希中毒状态又持续 <span class="number">2</span> 秒，即第 <span class="number">4</span> 秒和第 <span class="number">5</span> 秒。</span><br><span class="line">艾希在第 <span class="number">1</span>、<span class="number">2</span>、<span class="number">4</span>、<span class="number">5</span> 秒处于中毒状态，所以总中毒秒数是 <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong>：</p><p>考虑在<code>228.汇总区间</code>中出现过的双指针技巧,设置两个指针，中毒时间为高指针-低指针的值再加上持续时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPoisonedDuration</span><span class="params">(<span class="keyword">int</span>[] timeSeries, <span class="keyword">int</span> duration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;timeSeries.length)&#123;</span><br><span class="line">            low = i;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;timeSeries.length  &amp;&amp; (timeSeries[i-<span class="number">1</span>]+duration)&gt;timeSeries[i]) </span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            high = i - <span class="number">1</span>;</span><br><span class="line">            sum+=timeSeries[high]-timeSeries[low]+duration;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>492.构造矩形</title>
      <link href="/post/20472.html"/>
      <url>/post/20472.html</url>
      
        <content type="html"><![CDATA[<h1 id="492-构造矩形"><a href="#492-构造矩形" class="headerlink" title="492.构造矩形"></a>492.构造矩形</h1><p>作为一位web开发者， 懂得怎样去规划一个页面的尺寸是很重要的。 现给定一个具体的矩形页面面积，你的任务是设计一个长度为 L 和宽度为 W 且满足以下要求的矩形的页面。要求：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 你设计的矩形页面必须等于给定的目标面积。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 宽度 W 不应大于长度 L，换言之，要求 L &gt;= W 。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 长度 L 和宽度 W 之间的差距应当尽可能小。</span><br></pre></td></tr></table></figure><p>你需要按顺序输出你设计的页面的长度 L 和宽度 W。</p><p><strong>示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">4</span></span><br><span class="line">输出: [<span class="number">2</span>, <span class="number">2</span>]</span><br><span class="line">解释: 目标面积是 <span class="number">4</span>， 所有可能的构造方案有 [<span class="number">1</span>,<span class="number">4</span>], [<span class="number">2</span>,<span class="number">2</span>], [<span class="number">4</span>,<span class="number">1</span>]。</span><br><span class="line">但是根据要求<span class="number">2</span>，[<span class="number">1</span>,<span class="number">4</span>] 不符合要求; 根据要求<span class="number">3</span>，[<span class="number">2</span>,<span class="number">2</span>] 比 [<span class="number">4</span>,<span class="number">1</span>] 更能符合要求. 所以输出长度 L 为 <span class="number">2</span>， 宽度 W 为 <span class="number">2</span>。</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>利用sqrt(x)函数，在起附近内寻找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] constructRectangle(<span class="keyword">int</span> area) &#123;</span><br><span class="line">        <span class="keyword">int</span> w = (<span class="keyword">int</span>) Math.sqrt(area);</span><br><span class="line">        <span class="keyword">while</span> (area % w != <span class="number">0</span>) &#123;</span><br><span class="line">            --w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;area / w, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>485.最大连续1的个数</title>
      <link href="/post/37001.html"/>
      <url>/post/37001.html</url>
      
        <content type="html"><![CDATA[<h1 id="485-最大连续1的个数"><a href="#485-最大连续1的个数" class="headerlink" title="485.最大连续1的个数"></a>485.最大连续1的个数</h1><p>给定一个二进制数组， 计算其中最大连续 1 的个数。</p><p><strong>示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：开头的两位和最后的三位都是连续 <span class="number">1</span> ，所以最大连续 <span class="number">1</span> 的个数是 <span class="number">3.</span></span><br></pre></td></tr></table></figure><p>还是<code>53.最大子序和</code>的思路</p><hr><p><strong>Solution</strong>:</p><p>遍历数组，设置一个计数器，如果有连续1就加1，没有就直接清零，再设置一个值来记录计数器的最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x:nums)&#123;</span><br><span class="line">               <span class="keyword">if</span>(x==<span class="number">1</span>)&#123;</span><br><span class="line">                   count++;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   count=<span class="number">0</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               max=Math.max(count,max);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>482.密钥格式化</title>
      <link href="/post/5908.html"/>
      <url>/post/5908.html</url>
      
        <content type="html"><![CDATA[<h1 id="482-密钥格式化"><a href="#482-密钥格式化" class="headerlink" title="482.密钥格式化"></a>482.密钥格式化</h1><p>有一个密钥字符串 S ，只包含字母，数字以及 ‘-‘（破折号）。其中， N 个 ‘-‘ 将字符串分成了 N+1 组。</p><p>给你一个数字 K，请你重新格式化字符串，使每个分组恰好包含 K 个字符。特别地，第一个分组包含的字符个数必须小于等于 K，但至少要包含 1 个字符。两个分组之间需要用 ‘-‘（破折号）隔开，并且将所有的小写字母转换为大写字母。</p><p>给定非空字符串 S 和数字 K，按照上面描述的规则进行格式化。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：S = <span class="string">&quot;5F3Z-2e-9-w&quot;</span>, K = <span class="number">4</span></span><br><span class="line">输出：<span class="string">&quot;5F3Z-2E9W&quot;</span></span><br><span class="line">解释：字符串 S 被分成了两个部分，每部分 <span class="number">4</span> 个字符；</span><br><span class="line">     注意，两个额外的破折号需要删掉。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：S = <span class="string">&quot;2-5g-3-J&quot;</span>, K = <span class="number">2</span></span><br><span class="line">输出：<span class="string">&quot;2-5G-3J&quot;</span></span><br><span class="line">解释：字符串 S 被分成了 <span class="number">3</span> 个部分，按照前面的规则描述，第一部分的字符可以少于给定的数量，其余部分皆为 <span class="number">2</span> 个字符。</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">licenseKeyFormatting</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) != <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                ans.append(Character.toUpperCase(s.charAt(i)));<span class="comment">//如果不是破折号就添加进入ans里面，同时将其变为大写字母</span></span><br><span class="line">                <span class="keyword">if</span> (cnt % k == <span class="number">0</span>) &#123;</span><br><span class="line">                    ans.append(<span class="string">&quot;-&quot;</span>);  <span class="comment">//如果此时cnt可以%k，就添加一个-进去</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans.length() &gt; <span class="number">0</span> &amp;&amp; ans.charAt(ans.length() - <span class="number">1</span>) == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            ans.deleteCharAt(ans.length() - <span class="number">1</span>);<span class="comment">//如果最后是&#x27;-&#x27;就删除</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>476.数字的补数</title>
      <link href="/post/34946.html"/>
      <url>/post/34946.html</url>
      
        <content type="html"><![CDATA[<h1 id="476-数字的补数"><a href="#476-数字的补数" class="headerlink" title="476.数字的补数"></a>476.数字的补数</h1><p>对整数的二进制表示取反（<code>0</code> 变 <code>1</code> ，<code>1</code> 变 <code>0</code>）后，再转换为十进制表示，可以得到这个整数的补数。</p><ul><li>例如，整数 <code>5</code> 的二进制表示是 <code>&quot;101&quot;</code> ，取反后得到 <code>&quot;010&quot;</code> ，再转回十进制表示得到补数 <code>2</code> 。</li></ul><p>给你一个整数 <code>num</code> ，输出它的补数。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="number">5</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：<span class="number">5</span> 的二进制表示为 <span class="number">101</span>（没有前导零位），其补数为 <span class="number">010</span>。所以你需要输出 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>思路是找到num的二进制表示的第一个1，之后对每一位进行取反操作</p><p>如果num二进制表示的最高位的1是第<code>i</code>位，那么一定有$2^i≤num≤2^{i+1}$,因此可以用一次遍历找出<code>i</code>的值,之后，可以用过构造掩码的方式，进行异或运算，来得到答案</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(n - <span class="number">1</span> &lt; num)</span><br><span class="line">            n &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (n - <span class="number">1</span>) ^ num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 位运算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>463.岛屿的周长</title>
      <link href="/post/18969.html"/>
      <url>/post/18969.html</url>
      
        <content type="html"><![CDATA[<h1 id="463-岛屿的周长"><a href="#463-岛屿的周长" class="headerlink" title="463.岛屿的周长"></a>463.岛屿的周长</h1><p>给定一个 <code>row x col</code> 的二维网格地图 <code>grid</code> ，其中：<code>grid[i][j] = 1</code> 表示陆地， <code>grid[i][j] = 0</code> 表示水域。</p><p>网格中的格子 <strong>水平和垂直</strong> 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。</p><p>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/island.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">16</span></span><br><span class="line">解释：它的周长是上面图片中的 <span class="number">16</span> 个黄色的边</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>如果有陆地，周长就+4，同时检测其他边的情况，如果周围有相邻的方格，边就-2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//重点关注前面遍历过得方格，如果之前有相邻方格，就-2;</span></span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rsp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    rsp += <span class="number">4</span>;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; grid[i - <span class="number">1</span>][j] == <span class="number">1</span>) &#123;<span class="comment">//只对比一个方向</span></span><br><span class="line">                        rsp -= <span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; grid[i][j - <span class="number">1</span>] == <span class="number">1</span>) &#123;<span class="comment">//只对比一个方向</span></span><br><span class="line">                        rsp -= <span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rsp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>461.汉明距离</title>
      <link href="/post/3381.html"/>
      <url>/post/3381.html</url>
      
        <content type="html"><![CDATA[<h1 id="461-汉明距离"><a href="#461-汉明距离" class="headerlink" title="461.汉明距离"></a>461.汉明距离</h1><p>两个整数之间的 <a href="https://baike.baidu.com/item/汉明距离">汉明距离</a> 指的是这两个数字对应二进制位不同的位置的数目。</p><p>给你两个整数 <code>x</code> 和 <code>y</code>，计算并返回它们之间的汉明距离。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：x = <span class="number">1</span>, y = <span class="number">4</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line"><span class="number">1</span>   (<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>)</span><br><span class="line"><span class="number">4</span>   (<span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span>)</span><br><span class="line">       ↑   ↑</span><br><span class="line">上面的箭头指出了对应二进制位不同的位置。</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>具体地，记 $s =x⊕y$，我们可以不断地检查 <code>s</code> 的最低位，如果最低位为 1，那么令计数器加一，然后我们令 <code>s</code> 整体右移一位，这样 <code>s</code> 的最低位将被舍去，原本的次低位就变成了新的最低位。我们重复这个过程直到 <code>s=0</code> 为止。这样计数器中就累计了 <code>s</code> 的二进制表示中 1 的数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = x ^ y, ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (s != <span class="number">0</span>) &#123;</span><br><span class="line">            s = s &amp; (s-<span class="number">1</span>);</span><br><span class="line">            ret++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 位运算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>459.重复的子字符串</title>
      <link href="/post/53418.html"/>
      <url>/post/53418.html</url>
      
        <content type="html"><![CDATA[<h1 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459.重复的子字符串"></a>459.重复的子字符串</h1><p>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p><p><strong>示例 1:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">&quot;abab&quot;</span></span><br><span class="line"></span><br><span class="line">输出: True</span><br><span class="line"></span><br><span class="line">解释: 可由子字符串 <span class="string">&quot;ab&quot;</span> 重复两次构成。</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>一个原理，将字符串s复制一次，创建一个新的字符串T=s+s，然后去掉T的第一个和最后一个字符，如果s仍然是T的子串，那么说明s是重复的子字符串构成</p><p>子串匹配用KMP算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">repeatedSubstringPattern</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">           String x=s+s;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">return</span> KMP(x,s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">KMP</span><span class="params">(String S,String T)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> []a=<span class="keyword">new</span> <span class="keyword">int</span>[T.length()+<span class="number">1</span>];</span><br><span class="line">        Next(T,a);</span><br><span class="line">        <span class="keyword">while</span>(i&lt;S.length()-<span class="number">1</span>&amp;&amp;j&lt;=T.length())&#123;</span><br><span class="line">            <span class="keyword">if</span>(j==-<span class="number">1</span>||S.charAt(i)==T.charAt(j))&#123;</span><br><span class="line">                     i++;</span><br><span class="line">                     j++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               j=a[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j==T.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Next</span><span class="params">(String m,<span class="keyword">int</span> []next)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        next[<span class="number">0</span>]=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;m.length())&#123;</span><br><span class="line">             <span class="keyword">if</span>(k==-<span class="number">1</span>||m.charAt(j)==m.charAt(k))&#123;</span><br><span class="line">                 j++;</span><br><span class="line">                 k++;</span><br><span class="line">                 next[j]=k;</span><br><span class="line">             &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 k=next[k];</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>455.分发饼干</title>
      <link href="/post/41974.html"/>
      <url>/post/41974.html</url>
      
        <content type="html"><![CDATA[<h1 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455.分发饼干"></a>455.分发饼干</h1><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 <code>i</code>，都有一个胃口值 <code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 <code>j</code>，都有一个尺寸 <code>s[j]</code> 。如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 <code>j</code> 分配给孩子 <code>i</code> ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p><strong>示例 1:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: g = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], s = [<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: </span><br><span class="line">你有三个孩子和两块小饼干，<span class="number">3</span>个孩子的胃口值分别是：<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>。</span><br><span class="line">虽然你有两块小饼干，由于他们的尺寸都是<span class="number">1</span>，你只能让胃口值是<span class="number">1</span>的孩子满足。</span><br><span class="line">所以你应该输出<span class="number">1</span>。</span><br></pre></td></tr></table></figure><p><strong>Solution</strong>:</p><p>先排序，然后用双指针，如果饼干指针元素能满足胃口指针，那么两个指针都指向下一个，如果不能，那么让饼干指针指向下一个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="keyword">int</span>[] g, <span class="keyword">int</span>[] s)</span> </span>&#123;</span><br><span class="line">             Arrays.sort(g);</span><br><span class="line">             Arrays.sort(s);</span><br><span class="line">             <span class="keyword">int</span> need=<span class="number">0</span>;</span><br><span class="line">             <span class="keyword">int</span> food=<span class="number">0</span>;</span><br><span class="line">             <span class="keyword">while</span>(need&lt;g.length&amp;&amp;food&lt;s.length)&#123;</span><br><span class="line">                 <span class="keyword">if</span>(s[food]&gt;=g[need])&#123;</span><br><span class="line">                     need++;</span><br><span class="line">                     food++;</span><br><span class="line">                 &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                     food++;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> need;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>453.最小操作次数使数组元素相等</title>
      <link href="/post/35330.html"/>
      <url>/post/35330.html</url>
      
        <content type="html"><![CDATA[<h1 id="453-最小操作次数使数组元素相等"><a href="#453-最小操作次数使数组元素相等" class="headerlink" title="453.最小操作次数使数组元素相等"></a>453.最小操作次数使数组元素相等</h1><p>给你一个长度为 <code>n</code> 的整数数组，每次操作将会使 <code>n - 1</code> 个元素增加 <code>1</code> 。返回让数组所有元素相等的最小操作次数。</p><p><strong>示例 1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">只需要<span class="number">3</span>次操作（注意每次操作会增加两个元素的值）：</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]  =&gt;  [<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>]  =&gt;  [<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>]  =&gt;  [<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>换个方向思考？</p><hr><p><strong>Solution</strong>：</p><p>你们都增大了，不就相当于我减少了吗？</p><p>每个数减少到和最小值一样所需的次数，就是操作次数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMoves</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> minNum = Arrays.stream(nums).min().getAsInt();<span class="comment">//求出数组的最小值</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            res += num - minNum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>448.找到所有数组中消失的数字</title>
      <link href="/post/42765.html"/>
      <url>/post/42765.html</url>
      
        <content type="html"><![CDATA[<h1 id="448-找到所有数组中消失的数字"><a href="#448-找到所有数组中消失的数字" class="headerlink" title="448.找到所有数组中消失的数字"></a>448.找到所有数组中消失的数字</h1><p>给你一个含 <code>n</code> 个整数的数组 <code>nums</code> ，其中 <code>nums[i]</code> 在区间 <code>[1, n]</code> 内。请你找出所有在 <code>[1, n]</code> 范围内但没有出现在 <code>nums</code> 中的数字，并以数组的形式返回结果。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">5</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>和<code>268.丢失的数字</code>对应，不过在268中，只会有一个数字丢失，而在此题中丢失的数字可能有很多个</p><hr><p><strong>Solution</strong>：</p><p>一般的思路是用哈希表记录数组nums中的数字，然后查询缺失的数字，由于数字范围在1~n内，我们也可以用长度为n的数组来代替哈希表</p><p>nums的长度恰好为n，为什么不让nums自身来代替哈希表呢？</p><p>使用数组的下标来标记数字出现与否，出现了就将其下标对应的数组元素设置为负数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x=Math.abs(nums[i]); <span class="comment">//将nums[i]的绝对值标记为x，x-1就是它的下标</span></span><br><span class="line">            <span class="keyword">if</span> (nums[x- <span class="number">1</span>] &gt; <span class="number">0</span>) &#123;  <span class="comment">//如果它的下标没被修改过，那么就设置</span></span><br><span class="line">                nums[x- <span class="number">1</span>] = - nums[x - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                results.add(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 哈希表 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>441.排列硬币</title>
      <link href="/post/59130.html"/>
      <url>/post/59130.html</url>
      
        <content type="html"><![CDATA[<h1 id="441-排列硬币"><a href="#441-排列硬币" class="headerlink" title="441.排列硬币"></a>441.排列硬币</h1><p>你总共有 <code>n</code> 枚硬币，并计划将它们按阶梯状排列。对于一个由 <code>k</code> 行组成的阶梯，其第 <code>i</code> 行必须正好有 <code>i</code> 枚硬币。阶梯的最后一行 <strong>可能</strong> 是不完整的。</p><p>给你一个数字 <code>n</code> ，计算并返回可形成 <strong>完整阶梯行</strong> 的总行数。</p><p><strong>示例 1：</strong></p><p><img src="../../AppData/Roaming/Typora/typora-user-images/image-20211218193448782.png" alt="image-20211218193448782"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：因为第三行不完整，所以返回 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>可以用累加法，也可以根据求和公式用二分查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrangeCoins</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span>(n&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">         i++;</span><br><span class="line">         n-=i;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> i-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>434.字符串中的单词数</title>
      <link href="/post/13589.html"/>
      <url>/post/13589.html</url>
      
        <content type="html"><![CDATA[<h1 id="434-字符串中的单词数"><a href="#434-字符串中的单词数" class="headerlink" title="434.字符串中的单词数"></a>434.字符串中的单词数</h1><p>统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。</p><p>请注意，你可以假定字符串里不包括任何不可打印的字符。</p><p><strong>示例:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">&quot;Hello, my name is John&quot;</span></span><br><span class="line">输出: <span class="number">5</span></span><br><span class="line">解释: 这里的单词是指连续的不是空格的字符，所以 <span class="string">&quot;Hello,&quot;</span> 算作 <span class="number">1</span> 个单词。</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>通过检测空格来判断单词个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSegments</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> segmentCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i == <span class="number">0</span> || s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27; &#x27;</span>) &amp;&amp; s.charAt(i) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                segmentCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> segmentCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>或者直接使用内置的<code>split()</code>函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSegments</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">           String x[]=s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">           <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;x.length;i++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(x[i].equals(<span class="string">&quot;&quot;</span>)==<span class="keyword">false</span>)&#123;</span><br><span class="line">                   count++;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>415.字符串相加</title>
      <link href="/post/30422.html"/>
      <url>/post/30422.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415.字符串相加"></a>415.字符串相加</h1><p>给定两个字符串形式的非负整数 <code>num1</code> 和<code>num2</code> ，计算它们的和并同样以字符串形式返回。</p><p>你不能使用任何內建的用于处理大整数的库（比如 <code>BigInteger</code>）， 也不能直接将输入的字符串转换为整数形式。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：num1 = <span class="string">&quot;11&quot;</span>, num2 = <span class="string">&quot;123&quot;</span></span><br><span class="line">输出：<span class="string">&quot;134&quot;</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>应用在<code>67.二进制求和</code>中的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addStrings</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="keyword">null</span> || a.length() == <span class="number">0</span>) <span class="keyword">return</span> b;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="keyword">null</span> || b.length() == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line">        StringBuilder stb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> i = a.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = b.length() - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;  <span class="comment">// 进位</span></span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">0</span>) c += a.charAt(i --) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= <span class="number">0</span>) c += b.charAt(j --) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            stb.append(c % <span class="number">10</span>);   </span><br><span class="line">            <span class="keyword">if</span>(c&gt;<span class="number">9</span>)&#123;</span><br><span class="line">                c=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                c=<span class="number">0</span>;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125; </span><br><span class="line">        String res = stb.reverse().toString();</span><br><span class="line">        <span class="keyword">return</span> c &gt; <span class="number">0</span> ? <span class="string">&#x27;1&#x27;</span> + res : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>414.第三大的数</title>
      <link href="/post/38826.html"/>
      <url>/post/38826.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="414-第三大的数"><a href="#414-第三大的数" class="headerlink" title="414.第三大的数"></a>414.第三大的数</h1><p>给你一个非空数组，返回此数组中 <strong>第三大的数</strong> 。如果不存在，则返回数组中最大的数。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：第三大的数是 <span class="number">1</span> 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：第三大的数不存在, 所以返回最大的数 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong>：有序集合</p><p>因为是直接返回的数，使用TreeSet的性质</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">thirdMax</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        TreeSet&lt;Integer&gt; s = <span class="keyword">new</span> TreeSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            s.add(num);</span><br><span class="line">            <span class="keyword">if</span> (s.size() &gt; <span class="number">3</span>) &#123;</span><br><span class="line">                s.remove(s.first());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.size() == <span class="number">3</span> ? s.first() : s.last();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>Solution1</strong>：<strong>三个变量</strong></p><p>我们可以遍历数组，并用三个变量 <em>a</em>、<em>b</em> 和 <em>c</em> 来维护数组中的最大值、次大值和第三大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">thirdMax</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> a = Long.MIN_VALUE, b = Long.MIN_VALUE, c = Long.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt; a) &#123;</span><br><span class="line">                c = b;</span><br><span class="line">                b = a;</span><br><span class="line">                a = num;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a &gt; num &amp;&amp; num &gt; b) &#123;</span><br><span class="line">                c = b;</span><br><span class="line">                b = num;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b &gt; num &amp;&amp; num &gt; c) &#123;</span><br><span class="line">                c = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c == Long.MIN_VALUE ? (<span class="keyword">int</span>) a : (<span class="keyword">int</span>) c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>412. Fizz Buzz</title>
      <link href="/post/55931.html"/>
      <url>/post/55931.html</url>
      
        <content type="html"><![CDATA[<h1 id="412-Fizz-Buzz"><a href="#412-Fizz-Buzz" class="headerlink" title="412.Fizz Buzz"></a>412.Fizz Buzz</h1><p>给你一个整数 <code>n</code> ，找出从 <code>1</code> 到 <code>n</code> 各个整数的 Fizz Buzz 表示，并用字符串数组 <code>answer</code>（<strong>下标从 1 开始</strong>）返回结果，其中：</p><ul><li><code>answer[i] == &quot;FizzBuzz&quot;</code> 如果 <code>i</code> 同时是 <code>3</code> 和 <code>5</code> 的倍数。</li><li><code>answer[i] == &quot;Fizz&quot;</code> 如果 <code>i</code> 是 <code>3</code> 的倍数。</li><li><code>answer[i] == &quot;Buzz&quot;</code> 如果 <code>i</code> 是 <code>5</code> 的倍数。</li><li><code>answer[i] == i</code> （以字符串形式）如果上述条件全不满足。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span></span><br><span class="line">输出：[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;Fizz&quot;</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span></span><br><span class="line">输出：[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;Fizz&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;Buzz&quot;</span>]</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>似乎没什么好说的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">fizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; answer = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                sb.append(<span class="string">&quot;Fizz&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                sb.append(<span class="string">&quot;Buzz&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sb.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                sb.append(i);</span><br><span class="line">            &#125;</span><br><span class="line">            answer.add(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>409.最长回文串</title>
      <link href="/post/43435.html"/>
      <url>/post/43435.html</url>
      
        <content type="html"><![CDATA[<h1 id="409-最长回文串"><a href="#409-最长回文串" class="headerlink" title="409.最长回文串"></a>409.最长回文串</h1><p>给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。</p><p>在构造过程中，请注意区分大小写。比如 <code>&quot;Aa&quot;</code> 不能当做一个回文字符串。</p><p><strong>注意:</strong><br>假设字符串的长度不会超过 1010。</p><p><strong>示例 1:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line"><span class="string">&quot;abccccdd&quot;</span></span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"><span class="number">7</span></span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">我们可以构造的最长的回文串是<span class="string">&quot;dccaccd&quot;</span>, 它的长度是 <span class="number">7</span>。</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>这道题当然可以先统计字符出现次数，偶数对的次数×2+1或者就是偶数对的次数×2，不过排序也可以，虽然时间复杂度差了一点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.length()&lt;<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> s.length();</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">char</span> [] c=s.toCharArray();</span><br><span class="line">            Arrays.sort(c);</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(i&lt;c.length-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(c[i]==c[i+<span class="number">1</span>])&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    i+=<span class="number">2</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count*<span class="number">2</span>==s.length())&#123;</span><br><span class="line">                <span class="keyword">return</span> count*<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>  count*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 哈希表 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>405.数字转换为十六进制数</title>
      <link href="/post/54186.html"/>
      <url>/post/54186.html</url>
      
        <content type="html"><![CDATA[<h1 id="405-数字转换为十六进制数"><a href="#405-数字转换为十六进制数" class="headerlink" title="405.数字转换为十六进制数"></a>405.数字转换为十六进制数</h1><p>给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 <a href="https://baike.baidu.com/item/补码/6854613?fr=aladdin">补码运算</a> 方法。</p><p><strong>注意:</strong></p><ol><li>十六进制中所有字母(<code>a-f</code>)都必须是小写。</li><li>十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符<code>&#39;0&#39;</code>来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。 </li><li>给定的数确保在32位有符号整数范围内。</li><li><strong>不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。</strong></li></ol><p><strong>示例 1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line"><span class="number">26</span></span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"><span class="string">&quot;1a&quot;</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toHex</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">7</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">            <span class="keyword">int</span> val = (num &gt;&gt; (<span class="number">4</span> * i)) &amp; <span class="number">0xf</span>;</span><br><span class="line">            <span class="keyword">if</span> (sb.length() &gt; <span class="number">0</span> || val &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">char</span> digit = val &lt; <span class="number">10</span> ? (<span class="keyword">char</span>) (<span class="string">&#x27;0&#x27;</span> + val) : (<span class="keyword">char</span>) (<span class="string">&#x27;a&#x27;</span> + val - <span class="number">10</span>);</span><br><span class="line">                sb.append(digit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
          <category> 位运算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>404.左叶子之和</title>
      <link href="/post/27616.html"/>
      <url>/post/27616.html</url>
      
        <content type="html"><![CDATA[<h1 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404.左叶子之和"></a>404.左叶子之和</h1><p>计算给定二叉树的所有左叶子之和。</p><p><strong>示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">15</span>   <span class="number">7</span></span><br><span class="line"></span><br><span class="line">在这个二叉树中，有两个左叶子，分别是 <span class="number">9</span> 和 <span class="number">15</span>，所以返回 <span class="number">24</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>左叶子，那就只添加左孩子的左孩子为空以及左孩子的右孩子为空的节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right) </span><br><span class="line">           + (root.left!=<span class="keyword">null</span> &amp;&amp; root.left.left==<span class="keyword">null</span> &amp;&amp;                                 root.left.right==<span class="keyword">null</span> ? root.left.val : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>401.二进制手表</title>
      <link href="/post/62874.html"/>
      <url>/post/62874.html</url>
      
        <content type="html"><![CDATA[<h1 id="401-二进制手表"><a href="#401-二进制手表" class="headerlink" title="401.二进制手表"></a>401.二进制手表</h1><p>二进制手表顶部有 4 个 LED 代表 <strong>小时（0-11）</strong>，底部的 6 个 LED 代表 <strong>分钟（0-59）</strong>。每个 LED 代表一个 0 或 1，最低位在右侧。</p><ul><li>例如，下面的二进制手表读取 <code>&quot;3:25&quot;</code> 。</li></ul><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/03/29/binary_clock_samui_moon.jpg" alt="img"></p><p>给你一个整数 <code>turnedOn</code> ，表示当前亮着的 LED 的数量，返回二进制手表可以表示的所有可能时间。你可以 <strong>按任意顺序</strong> 返回答案。</p><p>小时不会以零开头：</p><ul><li>例如，<code>&quot;01:00&quot;</code> 是无效的时间，正确的写法应该是 <code>&quot;1:00&quot;</code> 。</li></ul><p>分钟必须由两位数组成，可能会以零开头：</p><ul><li>例如，<code>&quot;10:2&quot;</code> 是无效的时间，正确的写法应该是 <code>&quot;10:02&quot;</code> 。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：turnedOn = <span class="number">1</span></span><br><span class="line">输出：[<span class="string">&quot;0:01&quot;</span>,<span class="string">&quot;0:02&quot;</span>,<span class="string">&quot;0:04&quot;</span>,<span class="string">&quot;0:08&quot;</span>,<span class="string">&quot;0:16&quot;</span>,<span class="string">&quot;0:32&quot;</span>,<span class="string">&quot;1:00&quot;</span>,<span class="string">&quot;2:00&quot;</span>,<span class="string">&quot;4:00&quot;</span>,<span class="string">&quot;8:00&quot;</span>]</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>枚举</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">readBinaryWatch</span><span class="params">(<span class="keyword">int</span> turnedOn)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; <span class="number">12</span>; ++h) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; <span class="number">60</span>; ++m) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Integer.bitCount(h) + Integer.bitCount(m) == turnedOn) &#123;</span><br><span class="line">                    ans.add(h + <span class="string">&quot;:&quot;</span> + (m &lt; <span class="number">10</span> ? <span class="string">&quot;0&quot;</span> : <span class="string">&quot;&quot;</span>) + m);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 位运算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>392.判断子序列</title>
      <link href="/post/65372.html"/>
      <url>/post/65372.html</url>
      
        <content type="html"><![CDATA[<h1 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392.判断子序列"></a>392.判断子序列</h1><p>给定字符串 <strong>s</strong> 和 <strong>t</strong> ，判断 <strong>s</strong> 是否为 <strong>t</strong> 的子序列。</p><p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，<code>&quot;ace&quot;</code>是<code>&quot;abcde&quot;</code>的一个子序列，而<code>&quot;aec&quot;</code>不是）。</p><p><strong>示例 1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;abc&quot;</span>, t = <span class="string">&quot;ahbgdc&quot;</span></span><br><span class="line">输出：<span class="keyword">true</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>采用双指针的思想，一个指针指向s，另一个指向t，如果t中有s指针指向的字母，s指针指向下一个元素，判断s指针的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubsequence</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;t.length())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(t.charAt(i)==s.charAt(j))</span><br><span class="line">            &#123;     </span><br><span class="line">                   j++;</span><br><span class="line">                   <span class="keyword">if</span>(j==s.length())</span><br><span class="line">                   &#123;</span><br><span class="line">                       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 动态规划 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>389.找不同</title>
      <link href="/post/3008.html"/>
      <url>/post/3008.html</url>
      
        <content type="html"><![CDATA[<h1 id="389-找不同"><a href="#389-找不同" class="headerlink" title="389.找不同"></a>389.找不同</h1><p>给定两个字符串 <strong><em>s</em></strong> 和 <strong><em>t</em></strong>，它们只包含小写字母。</p><p>字符串 <strong><em>t\</em></strong> 由字符串 <strong><em>s\</em></strong> 随机重排，然后在随机位置添加一个字母。</p><p>请找出在 <strong><em>t</em></strong> 中被添加的字母。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;abcd&quot;</span>, t = <span class="string">&quot;abcde&quot;</span></span><br><span class="line">输出：<span class="string">&quot;e&quot;</span></span><br><span class="line">解释：<span class="string">&#x27;e&#x27;</span> 是那个被添加的字母。</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong>：求和</p><p>将每个字符用ASCII码相加起来，最后的差值就是多添加的数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">findTheDifference</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> as = <span class="number">0</span>, at = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            as += s.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); ++i) &#123;</span><br><span class="line">            at += t.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">char</span>) (at - as);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 哈希表 </category>
          
          <category> 字符串 </category>
          
          <category> 位运算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>387.字符串中的第一个唯一字符</title>
      <link href="/post/53571.html"/>
      <url>/post/53571.html</url>
      
        <content type="html"><![CDATA[<h1 id="387-字符串中的第一个唯一字符"><a href="#387-字符串中的第一个唯一字符" class="headerlink" title="387.字符串中的第一个唯一字符"></a>387.字符串中的第一个唯一字符</h1><p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p><p><strong>示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;leetcode&quot;</span></span><br><span class="line">返回 <span class="number">0</span></span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;loveleetcode&quot;</span></span><br><span class="line">返回 <span class="number">2</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>经典Map统计字符出现频数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">      String[] x=s.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">      Map&lt;String,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">       <span class="keyword">int</span> count = map.getOrDefault(x[i],<span class="number">0</span>)+<span class="number">1</span>;</span><br><span class="line">        map.put(x[i],count);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;s.length();j++)&#123;</span><br><span class="line">       <span class="keyword">if</span>(map.get(x[j])==<span class="number">1</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> j;</span><br><span class="line">       &#125;</span><br><span class="line">      &#125;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 哈希表 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>374.猜数字大小</title>
      <link href="/post/19295.html"/>
      <url>/post/19295.html</url>
      
        <content type="html"><![CDATA[<h1 id="374-猜数字大小"><a href="#374-猜数字大小" class="headerlink" title="374.猜数字大小"></a>374.猜数字大小</h1><p>猜数字游戏的规则如下：</p><ul><li>每轮游戏，我都会从 <strong>1</strong> 到 <strong><em>n</em></strong> 随机选择一个数字。 请你猜选出的是哪个数字。</li><li>如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。</li></ul><p>你可以通过调用一个预先定义好的接口 <code>int guess(int num)</code> 来获取猜测结果，返回值一共有 3 种可能的情况（<code>-1</code>，<code>1</code> 或 <code>0</code>）：</p><ul><li>-1：我选出的数字比你猜的数字小 <code>pick &lt; num</code></li><li>1：我选出的数字比你猜的数字大 <code>pick &gt; num</code></li><li>0：我选出的数字和你猜的数字一样。恭喜！你猜对了！<code>pick == num</code></li></ul><p>返回我选出的数字。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">10</span>, pick = <span class="number">6</span></span><br><span class="line">输出：<span class="number">6</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>二分查找答案</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">GuessGame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">guessNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = n;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 循环直至区间左右端点相同</span></span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>; <span class="comment">// 防止计算时溢出</span></span><br><span class="line">            <span class="keyword">if</span> (guess(mid) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                right = mid; <span class="comment">// 答案在区间 [left, mid] 中</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>; <span class="comment">// 答案在区间 [mid+1, right] 中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时有 left == right，区间缩为一个点，即为答案</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>383.赎金信</title>
      <link href="/post/37889.html"/>
      <url>/post/37889.html</url>
      
        <content type="html"><![CDATA[<h1 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383.赎金信"></a>383.赎金信</h1><p>为了不在赎金信中暴露字迹，从杂志上搜索各个需要的字母，组成单词来表达意思。</p><p>给你一个赎金信 (<code>ransomNote</code>) 字符串和一个杂志(<code>magazine</code>)字符串，判断 <code>ransomNote</code> 能不能由 <code>magazines</code> 里面的字符构成。</p><p>如果可以构成，返回 <code>true</code> ；否则返回 <code>false</code> 。</p><p><code>magazine</code> 中的每个字符只能在 <code>ransomNote</code> 中使用一次。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：ransomNote = <span class="string">&quot;a&quot;</span>, magazine = <span class="string">&quot;b&quot;</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>小写字母的词频统计</p><hr><p><strong>Solution</strong>：</p><p>只要统计字符串<code>magazine</code>中每个英文字母的频率，都大于等于<code>reansomNote</code>的频率，就可以成立</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ransomNote.length() &gt; magazine.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] cnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : magazine.toCharArray()) &#123;</span><br><span class="line">            cnt[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : ransomNote.toCharArray()) &#123;</span><br><span class="line">            cnt[c - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="keyword">if</span>(cnt[c - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Solution1</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初次提交的做法，可以说是熟练使用String方法了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> </span>&#123;</span><br><span class="line">        String[] arr = ransomNote.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ransomNote.length();i++)&#123;</span><br><span class="line">             <span class="keyword">if</span>(magazine.contains(arr[i]))&#123;</span><br><span class="line">                magazine=magazine.replaceFirst(arr[i],<span class="string">&quot;1&quot;</span>);</span><br><span class="line">             &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             &#125;</span><br><span class="line">           </span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 哈希表 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>367.有效的完全平方数</title>
      <link href="/post/20356.html"/>
      <url>/post/20356.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="367-有效的完全平方数"><a href="#367-有效的完全平方数" class="headerlink" title="367.有效的完全平方数"></a>367.有效的完全平方数</h1><p>给定一个 <strong>正整数</strong> <code>num</code> ，编写一个函数，如果 <code>num</code> 是一个完全平方数，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p><p><strong>进阶：不要</strong> 使用任何内置的库函数，如 <code>sqrt</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="number">16</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>二分查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = num;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">            <span class="keyword">long</span> square = (<span class="keyword">long</span>) mid * mid;</span><br><span class="line">            <span class="keyword">if</span> (square &lt; num) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (square &gt; num) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>350.两个数组的交集2</title>
      <link href="/post/1618.html"/>
      <url>/post/1618.html</url>
      
        <content type="html"><![CDATA[<h1 id="350-两个数组的交集2"><a href="#350-两个数组的交集2" class="headerlink" title="350.两个数组的交集2"></a>350.两个数组的交集2</h1><p>给你两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>], nums2 = [<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><hr><p>Solution：</p><p>根据<code>136：只出现一次的数字</code>的启发，可以用HashMap数据结构来储存nums1以及元素出现次数，然后对比nums2和Map中的元素，如果元素出现了就添加进答案数组里面，然后将元素出现次数-1，如果为0，直接移除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1.length &gt; nums2.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> intersect(nums2, nums1);</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums1) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">            map.put(num, count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] intersection = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums2) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = map.getOrDefault(num, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                intersection[index++] = num;</span><br><span class="line">                count--;</span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    map.put(num, count);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    map.remove(num);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(intersection, <span class="number">0</span>, index);</span><br><span class="line">        <span class="comment">//copyOfRange 直接输出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 哈希表 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>349.两个数组的交集</title>
      <link href="/post/15820.html"/>
      <url>/post/15820.html</url>
      
        <content type="html"><![CDATA[<h1 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349.两个数组的交集"></a>349.两个数组的交集</h1><p>给定两个数组，编写一个函数来计算它们的交集。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">输出：[2]</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong>：</p><p>用一个Set集合储存一个nums1，然后遍历nums2中的元素，来测出nums1和nums2交集，因为答案数组不能有重复元素，所以创建第二个Set来存储交集，如果Set1中包含了这一元素，说明是交集，添加进入Set2中</p><p>最后将Set转换为int数组输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">       Set &lt;Integer&gt; set=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums1.length;i++)&#123;</span><br><span class="line">           set.add(nums1[i]);</span><br><span class="line">       &#125;</span><br><span class="line">      </span><br><span class="line">       Set &lt;Integer&gt; a=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums2.length;j++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(set.contains(nums2[j])==<span class="keyword">true</span>)&#123;</span><br><span class="line">               a.add(nums2[j]);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">      </span><br><span class="line">      Integer[] array = a.toArray(<span class="keyword">new</span> Integer[<span class="number">0</span>]);</span><br><span class="line">      <span class="comment">// 再将Integer型数组转为int型数组</span></span><br><span class="line">        <span class="keyword">int</span>[] intArray = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            intArray[i] = array[i].intValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intArray;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 哈希表 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>345.反转字符串中的元音字母</title>
      <link href="/post/38257.html"/>
      <url>/post/38257.html</url>
      
        <content type="html"><![CDATA[<h1 id="345-反转字符串中的元音字母"><a href="#345-反转字符串中的元音字母" class="headerlink" title="345.反转字符串中的元音字母"></a>345.反转字符串中的元音字母</h1><p>给你一个字符串 <code>s</code> ，仅反转字符串中的所有元音字母，并返回结果字符串。</p><p>元音字母包括 <code>&#39;a&#39;</code>、<code>&#39;e&#39;</code>、<code>&#39;i&#39;</code>、<code>&#39;o&#39;</code>、<code>&#39;u&#39;</code>，且可能以大小写两种形式出现。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;hello&quot;</span></span><br><span class="line">输出：<span class="string">&quot;holle&quot;</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>先设置一个字符串来存储元音字符，然后设置双指针来遍历字符串s，把指针指向的字母和原因字符对比，就可以判断是否是元音字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseVowels</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">int</span> j=s.length()-<span class="number">1</span>;</span><br><span class="line">         StringBuilder sb=<span class="keyword">new</span> StringBuilder(s);</span><br><span class="line">      </span><br><span class="line">         <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">          <span class="keyword">while</span>(i&lt;j&amp;&amp;isVowel(sb.charAt(i))&lt;<span class="number">0</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              i++;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">         <span class="keyword">while</span>(j&gt;i&amp;&amp;!isVowel(sb.charAt(j))&lt;<span class="number">0</span>)</span><br><span class="line">         &#123;    </span><br><span class="line">              j--;</span><br><span class="line">         &#125;</span><br><span class="line">      </span><br><span class="line">        sb.setCharAt(i,s.charAt(j));</span><br><span class="line">        sb.setCharAt(j,s.charAt(i));</span><br><span class="line">       </span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    String x=sb.toString();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span>  <span class="title">vowel</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;aeiouAEIOU&quot;</span>.indexOf(ch);<span class="comment">//如果不是的话，就回返回-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>344.反转字符串</title>
      <link href="/post/53197.html"/>
      <url>/post/53197.html</url>
      
        <content type="html"><![CDATA[<h1 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344.反转字符串"></a>344.反转字符串</h1><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>s</code> 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须<strong><a href="https://baike.baidu.com/item/原地算法">原地</a>修改输入数组</strong>、使用 O(1) 的额外空间解决这一问题。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = [<span class="string">&quot;h&quot;</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;l&quot;</span>,<span class="string">&quot;l&quot;</span>,<span class="string">&quot;o&quot;</span>]</span><br><span class="line">输出：[<span class="string">&quot;o&quot;</span>,<span class="string">&quot;l&quot;</span>,<span class="string">&quot;l&quot;</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;h&quot;</span>]</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>原地修改，双指针就行了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>; left &lt; right; ++left, --right) &#123;</span><br><span class="line">            <span class="keyword">char</span> tmp = s[left];</span><br><span class="line">            s[left] = s[right];</span><br><span class="line">            s[right] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>342.4的幂</title>
      <link href="/post/25999.html"/>
      <url>/post/25999.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="342-4的幂"><a href="#342-4的幂" class="headerlink" title="342.4的幂"></a>342.4的幂</h1><p>给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>整数 <code>n</code> 是 4 的幂次方需满足：存在整数 <code>x</code> 使得 <code>n == 4x</code></p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">16</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>在2的幂的基础上，构造一个掩码<em>mask</em>=10101010101010101010101010101010，进行与操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span> &amp;&amp; (n &amp; <span class="number">0xaaaaaaaa</span>) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
          <category> 位运算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>338.比特位计数</title>
      <link href="/post/59365.html"/>
      <url>/post/59365.html</url>
      
        <content type="html"><![CDATA[<h1 id="338-比特位计数"><a href="#338-比特位计数" class="headerlink" title="338.比特位计数"></a>338.比特位计数</h1><p>给你一个整数 <code>n</code> ，对于 <code>0 &lt;= i &lt;= n</code> 中的每个 <code>i</code> ，计算其二进制表示中 <strong><code>1</code> 的个数</strong> ，返回一个长度为 <code>n + 1</code> 的数组 <code>ans</code> 作为答案。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">解释：</span><br><span class="line"><span class="number">0</span> --&gt; <span class="number">0</span></span><br><span class="line"><span class="number">1</span> --&gt; <span class="number">1</span></span><br><span class="line"><span class="number">2</span> --&gt; <span class="number">10</span></span><br></pre></td></tr></table></figure><hr><p><strong>Soluiton</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] bits = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            bits[i] = countOnes(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bits;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countOnes</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ones = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            x &amp;= (x - <span class="number">1</span>);</span><br><span class="line">            ones++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ones;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 动态规划 </category>
          
          <category> 位运算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>326.3的幂</title>
      <link href="/post/31275.html"/>
      <url>/post/31275.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="326-3的幂"><a href="#326-3的幂" class="headerlink" title="326.3的幂"></a>326.3的幂</h1><p>给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>整数 <code>n</code> 是 3 的幂次方需满足：存在整数 <code>x</code> 使得 <code>n == 3x</code></p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">27</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>试除法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span> &amp;&amp; n % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            n /= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>303. 区域和检索 - 数组不可变</title>
      <link href="/post/62527.html"/>
      <url>/post/62527.html</url>
      
        <content type="html"><![CDATA[<h1 id="303-区域和检索-数组不可变"><a href="#303-区域和检索-数组不可变" class="headerlink" title="303. 区域和检索 - 数组不可变"></a>303. 区域和检索 - 数组不可变</h1><p>给定一个整数数组  <code>nums</code>，求出数组从索引 <code>i</code> 到 <code>j</code>（<code>i ≤ j</code>）范围内元素的总和，包含 <code>i</code>、<code>j</code>两点。</p><p>实现 <code>NumArray</code> 类：</p><ul><li><code>NumArray(int[] nums)</code> 使用数组 <code>nums</code> 初始化对象</li><li><code>int sumRange(int i, int j)</code> 返回数组 <code>nums</code> 从索引 <code>i</code> 到 <code>j</code><em>（</em><code>i ≤ j</code>）范围内元素的总和，包含 <code>i</code>、<code>j</code>两点（也就是 <code>sum(nums[i], nums[i + 1], ... , nums[j])</code>）</li></ul><p><strong>示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">&quot;NumArray&quot;</span>, <span class="string">&quot;sumRange&quot;</span>, <span class="string">&quot;sumRange&quot;</span>, <span class="string">&quot;sumRange&quot;</span>]</span><br><span class="line">[[[<span class="number">-2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">-5</span>, <span class="number">2</span>, <span class="number">-1</span>]], [<span class="number">0</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">5</span>], [<span class="number">0</span>, <span class="number">5</span>]]</span><br><span class="line">输出：</span><br><span class="line">[null, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-3</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">NumArray numArray = <span class="keyword">new</span> NumArray([<span class="number">-2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">-5</span>, <span class="number">2</span>, <span class="number">-1</span>]);</span><br><span class="line">numArray.sumRange(<span class="number">0</span>, <span class="number">2</span>); <span class="comment">// return 1 ((-2) + 0 + 3)</span></span><br><span class="line">numArray.sumRange(<span class="number">2</span>, <span class="number">5</span>); <span class="comment">// return -1 (3 + (-5) + 2 + (-1)) </span></span><br><span class="line">numArray.sumRange(<span class="number">0</span>, <span class="number">5</span>); <span class="comment">// return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>题目要求是返回一个数组间从下标i到下标j元素之间的和，如果采用暴力算法，循环计算，由于每次检索的时间和检索的下标范围有关，因此时间复杂度较高</p><p>所以能实现计算出前缀和，那么可以将时间复杂度降低到O(1)</p><p>具体实现方面，假设数组 <em>nums</em> 的长度为 <em>n</em>，创建长度为 <em>n+1</em> 的前缀和数组<em>sums</em>，对于<em>0≤i＜n</em>都有sums[i+1]=sums[i]+nums[i]，sums[i]表示数组nums从下标0到下标i-1的前缀和</p><p>前缀和计算方法：sumRrage(i,j)=sums[j+1]-nums[i]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] sums;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        sums = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sums[i + <span class="number">1</span>] = sums[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> sums[right + <span class="number">1</span>] - sums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>292.Nim游戏</title>
      <link href="/post/229.html"/>
      <url>/post/229.html</url>
      
        <content type="html"><![CDATA[<h1 id="292-Nim游戏"><a href="#292-Nim游戏" class="headerlink" title="292.Nim游戏"></a>292.Nim游戏</h1><p>你和你的朋友，两个人一起玩 <a href="https://baike.baidu.com/item/Nim游戏/6737105">Nim 游戏</a>：</p><ul><li>桌子上有一堆石头。</li><li>你们轮流进行自己的回合，你作为先手。</li><li>每一回合，轮到的人拿掉 1 - 3 块石头。</li><li>拿掉最后一块石头的人就是获胜者。</li></ul><p>假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 <code>n</code> 的情况下赢得游戏。如果可以赢，返回 <code>true</code>；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span></span><br><span class="line">输出：<span class="literal">false</span> </span><br><span class="line">解释：如果堆中有 <span class="number">4</span> 块石头，那么你永远不会赢得比赛；</span><br><span class="line">     因为无论你拿走 <span class="number">1</span> 块、<span class="number">2</span> 块 还是 <span class="number">3</span> 块石头，最后一块石头总是会被你的朋友拿走。</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>不是4的倍数就好</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canWinNim</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n % <span class="number">4</span> != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>290.单词规律</title>
      <link href="/post/19901.html"/>
      <url>/post/19901.html</url>
      
        <content type="html"><![CDATA[<h1 id="290-单词规律"><a href="#290-单词规律" class="headerlink" title="290.单词规律"></a>290.单词规律</h1><p>给定一种规律 <code>pattern</code> 和一个字符串 <code>str</code> ，判断 <code>str</code> 是否遵循相同的规律。</p><p>这里的 <strong>遵循</strong> 指完全匹配，例如， <code>pattern</code> 里的每个字母和字符串 <code>str</code> 中的每个非空单词之间存在着双向连接的对应规律。</p><p><strong>示例1:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: pattern = <span class="string">&quot;abba&quot;</span>, str = <span class="string">&quot;dog cat cat dog&quot;</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入:pattern = <span class="string">&quot;abba&quot;</span>, str = <span class="string">&quot;dog cat cat fish&quot;</span></span><br><span class="line">输出: <span class="keyword">false</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>这道题显示是<code>205 同构字符串</code>的升级版本，当然也可以用其解法，难点在与需要以空格来隔断字符串，并且用<code>substring</code>函数来断开字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordPattern</span><span class="params">(String pattern, String str)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Character&gt; str2ch = <span class="keyword">new</span> HashMap&lt;String, Character&gt;();</span><br><span class="line">        Map&lt;Character, String&gt; ch2str = <span class="keyword">new</span> HashMap&lt;Character, String&gt;();</span><br><span class="line">        <span class="keyword">int</span> m = str.length();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; pattern.length(); ++p) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = pattern.charAt(p);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= m) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; m &amp;&amp; str.charAt(j) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            String tmp = str.substring(i, j);</span><br><span class="line">            <span class="keyword">if</span> (str2ch.containsKey(tmp) &amp;&amp; str2ch.get(tmp) != ch) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ch2str.containsKey(ch) &amp;&amp; !tmp.equals(ch2str.get(ch))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            str2ch.put(tmp, ch);</span><br><span class="line">            ch2str.put(ch, tmp);</span><br><span class="line">            i = j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i &gt;= m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>也正如<code>205</code>一样，该题也有更为简单的办法，因为是以空格断开字符，直接用JAVA中的<code>split(&quot; &quot;)</code>就可以断开字符串了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordPattern</span><span class="params">(String pattern, String str)</span> </span>&#123;</span><br><span class="line">        String[] words = str.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (words.length != pattern.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Object, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//巧妙的采取Object类，让char和String都能存储进去</span></span><br><span class="line">        <span class="keyword">for</span> (Integer i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.put(pattern.charAt(i), i) != map.put(words[i], i)) &#123;<span class="comment">//这里运用了put函数的特性，如果输入了已经拥有Key，那就返回之前的Key的value值</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 哈希表 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>283.移动零</title>
      <link href="/post/28494.html"/>
      <url>/post/28494.html</url>
      
        <content type="html"><![CDATA[<h1 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283.移动零"></a>283.移动零</h1><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>示例:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">12</span>]</span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><strong>说明</strong>:</p><ol><li>必须在原数组上操作，不能拷贝额外的数组。</li><li>尽量减少操作次数。</li></ol><hr><p><strong>Solution</strong>：</p><p>可以先将非零元素移动到数组前面，然后再给在给数组后端赋予0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span> low=<span class="number">0</span>;</span><br><span class="line">           <span class="keyword">int</span> high=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">           </span><br><span class="line">           <span class="keyword">while</span>(high&lt;nums.length)&#123;</span><br><span class="line">               <span class="keyword">if</span>(nums[high]!=<span class="number">0</span>)&#123;</span><br><span class="line">                   nums[low]=nums[high];</span><br><span class="line">                   low++;</span><br><span class="line">               &#125;</span><br><span class="line">               high++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=low;i&lt;high;i++)&#123;</span><br><span class="line">               nums[i]=<span class="number">0</span>;</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>278.第一个错误的版本</title>
      <link href="/post/8473.html"/>
      <url>/post/8473.html</url>
      
        <content type="html"><![CDATA[<h1 id="278-第一个错误的版本"><a href="#278-第一个错误的版本" class="headerlink" title="278.第一个错误的版本"></a>278.第一个错误的版本</h1><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p><p>假设你有 <code>n</code> 个版本 <code>[1, 2, ..., n]</code>，你想找出导致之后所有版本出错的第一个错误的版本。</p><p>你可以通过调用 <code>bool isBadVersion(version)</code> 接口来判断版本号 <code>version</code> 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p><p><strong>示例 1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, bad = <span class="number">4</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：</span><br><span class="line">调用 isBadVersion(<span class="number">3</span>) -&gt; <span class="keyword">false</span> </span><br><span class="line">调用 isBadVersion(<span class="number">5</span>) -&gt; <span class="keyword">true</span> </span><br><span class="line">调用 isBadVersion(<span class="number">4</span>) -&gt; <span class="keyword">true</span></span><br><span class="line">所以，<span class="number">4</span> 是第一个错误的版本。</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>二分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">VersionControl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = n;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 循环直至区间左右端点相同</span></span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>; <span class="comment">// 防止计算时溢出</span></span><br><span class="line">            <span class="keyword">if</span> (isBadVersion(mid)) &#123;</span><br><span class="line">                right = mid; <span class="comment">// 答案在区间 [left, mid] 中</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>; <span class="comment">// 答案在区间 [mid+1, right] 中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时有 left == right，区间缩为一个点，即为答案</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>268.丢失的数字</title>
      <link href="/post/46201.html"/>
      <url>/post/46201.html</url>
      
        <content type="html"><![CDATA[<h1 id="268-丢失的数字"><a href="#268-丢失的数字" class="headerlink" title="268. 丢失的数字"></a>268. 丢失的数字</h1><p>给定一个包含 <code>[0, n]</code> 中 <code>n</code> 个数的数组 <code>nums</code> ，找出 <code>[0, n]</code> 这个范围内没有出现在数组中的那个数。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：n = <span class="number">3</span>，因为有 <span class="number">3</span> 个数字，所以所有的数字都在范围 [<span class="number">0</span>,<span class="number">3</span>] 内。<span class="number">2</span> 是丢失的数字，因为它没有出现在 nums 中。</span><br></pre></td></tr></table></figure><ul><li><code>nums</code> 中的所有数字都 <strong>独一无二</strong></li></ul><hr><p><strong>Solution</strong>：排序</p><p>很容易想到先讲数组排序，然后直接输出下标的办法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">         Arrays.sort(nums);</span><br><span class="line">    </span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">             <span class="keyword">if</span>(i!=nums[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> nums.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>Solution1</strong>：位运算</p><p>数组 <em>nums</em> 中有 <em>n</em> 个数，在这 <em>n</em> 个数的后面添加从 0 到 <em>n</em> 的每个整数，则添加了 <em>n</em>+1 个整数，共有 2<em>n</em>+1 个整数。</p><p>在 2<em>n</em>+1 个整数中，丢失的数字只在后面 <em>n</em>+1 个整数中出现一次，其余的数字在前面 <em>n</em> 个整数中（即数组中）和后面 <em>n</em>+1 个整数中各出现一次，即其余的数字都出现了两次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> xor = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            xor ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            xor ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> xor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 哈希表 </category>
          
          <category> 数组 </category>
          
          <category> 位运算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>263.丑数</title>
      <link href="/post/34640.html"/>
      <url>/post/34640.html</url>
      
        <content type="html"><![CDATA[<h1 id="263-丑数"><a href="#263-丑数" class="headerlink" title="263.丑数"></a>263.丑数</h1><p>给你一个整数 <code>n</code> ，请你判断 <code>n</code> 是否为 <strong>丑数</strong> 。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>丑数</strong> 就是只包含质因数 <code>2</code>、<code>3</code> 和/或 <code>5</code> 的正整数。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">6</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：<span class="number">6</span> = <span class="number">2</span> × <span class="number">3</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>n反复除2,3,5就行了，最后的结果为1的话说明是丑数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] factors = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> factor : factors) &#123;</span><br><span class="line">            <span class="keyword">while</span> (n % factor == <span class="number">0</span>) &#123;</span><br><span class="line">                n /= factor;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>258.各位相加</title>
      <link href="/post/7256.html"/>
      <url>/post/7256.html</url>
      
        <content type="html"><![CDATA[<h1 id="258-各位相加"><a href="#258-各位相加" class="headerlink" title="258.各位相加"></a>258.各位相加</h1><p>给定一个非负整数 <code>num</code>，反复将各个位上的数字相加，直到结果为一位数。</p><p><strong>示例:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">38</span></span><br><span class="line">输出: <span class="number">2</span> </span><br><span class="line">解释: 各位相加的过程为：<span class="number">3</span> + <span class="number">8</span> = <span class="number">11</span>, <span class="number">1</span> + <span class="number">1</span> = <span class="number">2</span>。 由于 <span class="number">2</span> 是一位数，所以返回 <span class="number">2</span>。</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>$x×100+y×10+z=x×99+y×9+(x+y+z)$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addDigits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (num - <span class="number">1</span>) % <span class="number">9</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>257.二叉树的所有路径</title>
      <link href="/post/3179.html"/>
      <url>/post/3179.html</url>
      
        <content type="html"><![CDATA[<h1 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257.二叉树的所有路径"></a>257.二叉树的所有路径</h1><p>给你一个二叉树的根节点 <code>root</code> ，按 <strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,null,<span class="number">5</span>]</span><br><span class="line">输出：[<span class="string">&quot;1-&gt;2-&gt;5&quot;</span>,<span class="string">&quot;1-&gt;3&quot;</span>]</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>深度遍历，设置一个List数组，一个字符串，遍历一次就将字符串加入到List数组中去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; paths = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        StringBuilder s=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        dfs(paths, root,s );</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;String&gt; res, TreeNode node,  StringBuilder s)</span> </span>&#123;</span><br><span class="line">s.append(node.val);</span><br><span class="line"><span class="keyword">if</span> (node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">res.add(s.toString());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">         <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">dfs(res, node.left, <span class="keyword">new</span> StringBuilder(s).append(<span class="string">&quot;-&gt;&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">dfs(res, node.right, <span class="keyword">new</span> StringBuilder(s).append(<span class="string">&quot;-&gt;&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>242.有效的字母异位词</title>
      <link href="/post/44721.html"/>
      <url>/post/44721.html</url>
      
        <content type="html"><![CDATA[<h1 id="242-有效的字符异位词"><a href="#242-有效的字符异位词" class="headerlink" title="242.有效的字符异位词"></a>242.有效的字符异位词</h1><p>给定两个字符串 <code>*s*</code> 和 <code>*t*</code> ，编写一个函数来判断 <code>*t*</code> 是否是 <code>*s*</code> 的字母异位词。</p><p><strong>注意：</strong>若 <code>*s*</code> 和 <code>*t*</code> 中每个字符出现的次数都相同，则称 <code>*s*</code> 和 <code>*t*</code> 互为字母异位词。</p><p><strong>示例 1:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;anagram&quot;</span>, t = <span class="string">&quot;nagaram&quot;</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;rat&quot;</span>, t = <span class="string">&quot;car&quot;</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong>：哈希表</p><p>用一个Map记录字符串s中字符的出现次数，然后遍历字符串t，字符没出现一次就出现次数就-1，如果出现次数最后&lt;0，说明不匹配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Character, Integer&gt; table = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">            table.put(ch, table.getOrDefault(ch, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = t.charAt(i);</span><br><span class="line">            table.put(ch, table.getOrDefault(ch, <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (table.get(ch) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 哈希表 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>237.删除链表中的节点</title>
      <link href="/post/55675.html"/>
      <url>/post/55675.html</url>
      
        <content type="html"><![CDATA[<h1 id="237-删除链表中的节点"><a href="#237-删除链表中的节点" class="headerlink" title="237.删除链表中的节点"></a>237.删除链表中的节点</h1><p>请编写一个函数，用于 <strong>删除单链表中某个特定节点</strong> 。在设计函数时需要注意，你无法访问链表的头节点 <code>head</code> ，只能直接访问 <strong>要被删除的节点</strong> 。</p><p>题目数据保证需要删除的节点 <strong>不是末尾节点</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>], node = <span class="number">5</span></span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">1</span>,<span class="number">9</span>]</span><br><span class="line">解释：指定链表中值为 <span class="number">5</span> 的第二个节点，那么在调用了你的函数之后，该链表应变为 <span class="number">4</span> -&gt; <span class="number">1</span> -&gt; <span class="number">9</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>直接修改要被删除的结点，使之成为自己的下一个结点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        node.val = node.next.val;</span><br><span class="line">        node.next = node.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>235.二叉搜索树的最近公共祖先</title>
      <link href="/post/31100.html"/>
      <url>/post/31100.html</url>
      
        <content type="html"><![CDATA[<h1 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235.二叉搜索树的最近公共祖先"></a>235.二叉搜索树的最近公共祖先</h1><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p>例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/binarysearchtree_improved.png" alt=""></p><p><strong>示例 1:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [<span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,null,null,<span class="number">3</span>,<span class="number">5</span>], p = <span class="number">2</span>, q = <span class="number">8</span></span><br><span class="line">输出: <span class="number">6</span> </span><br><span class="line">解释: 节点 <span class="number">2</span> 和节点 <span class="number">8</span> 的最近公共祖先是 <span class="number">6</span>。</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>同时比较p，q和当前root的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        TreeNode ancestor = root;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.val &lt; ancestor.val &amp;&amp; q.val &lt; ancestor.val) &#123;</span><br><span class="line">                ancestor = ancestor.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.val &gt; ancestor.val &amp;&amp; q.val &gt; ancestor.val) &#123;</span><br><span class="line">                ancestor = ancestor.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ancestor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>234.回文链表</title>
      <link href="/post/55905.html"/>
      <url>/post/55905.html</url>
      
        <content type="html"><![CDATA[<h1 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234.回文链表"></a>234.回文链表</h1><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong>：</p><p>直接知道中间结点，将结点分成两份，利用<code>206 反转链表</code>中的方法，将后面的链表反转过来，对比是否一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到前半部分链表的尾节点并反转后半部分链表</span></span><br><span class="line">        ListNode firstHalfEnd = endOfFirstHalf(head);</span><br><span class="line">        ListNode secondHalfStart = reverseList(firstHalfEnd.next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否回文</span></span><br><span class="line">        ListNode p1 = head;</span><br><span class="line">        ListNode p2 = secondHalfStart;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (result &amp;&amp; p2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1.val != p2.val) &#123;</span><br><span class="line">                result = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;        </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 还原链表并返回结果</span></span><br><span class="line">        firstHalfEnd.next = reverseList(secondHalfStart);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode nextTemp = curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = nextTemp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">/* 用快慢指针寻找链表的中间结点</span></span><br><span class="line"><span class="comment"> slow指针走一步，而fast指针走两步，则最后fast指针为null的之后，slow指针就是链表的中间结点*/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">endOfFirstHalf</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 栈 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>232.用栈实现队列</title>
      <link href="/post/44966.html"/>
      <url>/post/44966.html</url>
      
        <content type="html"><![CDATA[<h1 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232.用栈实现队列"></a>232.用栈实现队列</h1><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p><p>实现 <code>MyQueue</code> 类：</p><ul><li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li><li><code>int pop()</code> 从队列的开头移除并返回元素</li><li><code>int peek()</code> 返回队列开头的元素</li><li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li></ul><p><strong>说明：</strong></p><ul><li>你只能使用标准的栈操作 —— 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。</li><li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li></ul><p><strong>进阶：</strong></p><ul><li>你能否实现每个操作均摊时间复杂度为 <code>O(1)</code> 的队列？换句话说，执行 <code>n</code> 个操作的总时间复杂度为 <code>O(n)</code> ，即使其中一个操作可能花费较长时间。</li></ul><p><strong>示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">&quot;MyQueue&quot;</span>, <span class="string">&quot;push&quot;</span>, <span class="string">&quot;push&quot;</span>, <span class="string">&quot;peek&quot;</span>, <span class="string">&quot;pop&quot;</span>, <span class="string">&quot;empty&quot;</span>]</span><br><span class="line">[[], [<span class="number">1</span>], [<span class="number">2</span>], [], [], []]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, <span class="number">1</span>, <span class="number">1</span>, <span class="literal">false</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyQueue myQueue = <span class="keyword">new</span> MyQueue();</span><br><span class="line">myQueue.push(<span class="number">1</span>); <span class="comment">// queue is: [1]</span></span><br><span class="line">myQueue.push(<span class="number">2</span>); <span class="comment">// queue is: [1, 2] (leftmost is front of the queue)</span></span><br><span class="line">myQueue.peek(); <span class="comment">// return 1</span></span><br><span class="line">myQueue.pop(); <span class="comment">// return 1, queue is [2]</span></span><br><span class="line">myQueue.empty(); <span class="comment">// return false</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>用两个栈，栈1用来和队列同步，当要出栈的时候，把栈1的元素全部转移到栈2中去，就和队列的结构一样了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; stack1;</span><br><span class="line">    Stack&lt;Integer&gt; stack2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> Stack&lt;&gt;(); <span class="comment">// 负责进栈</span></span><br><span class="line">        stack2 = <span class="keyword">new</span> Stack&lt;&gt;(); <span class="comment">// 负责出栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        dumpStack1();</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dumpStack1();</span><br><span class="line">        <span class="keyword">return</span> stack2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.isEmpty() &amp;&amp; stack2.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果stack2为空，那么将stack1中的元素全部放到stack2中</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dumpStack1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.isEmpty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>231.2的幂</title>
      <link href="/post/45900.html"/>
      <url>/post/45900.html</url>
      
        <content type="html"><![CDATA[<h1 id="231-2的幂"><a href="#231-2的幂" class="headerlink" title="231.2的幂"></a>231.2的幂</h1><p>给你一个整数 <code>n</code>，请你判断该整数是否是 2 的幂次方。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>如果存在一个整数 <code>x</code> 使得 <code>n == 2x</code> ，则认为 <code>n</code> 是 2 的幂次方。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：<span class="number">20</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><hr><p><strong>Soluiton</strong></p><p><code>n&amp;n-1</code>操作可以直接将<code>n</code>的二进制表示的最低一位1给移除掉，而2的幂的二进制表示只会有1个1，所以如果移除掉的结果是0的话，说明是2的幂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
          <category> 位运算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>228.汇总区间</title>
      <link href="/post/49776.html"/>
      <url>/post/49776.html</url>
      
        <content type="html"><![CDATA[<h1 id="228-汇总区间"><a href="#228-汇总区间" class="headerlink" title="228.汇总区间"></a>228.汇总区间</h1><p>给定一个无重复元素的有序整数数组 <code>nums</code> 。</p><p>返回 <strong>恰好覆盖数组中所有数字</strong> 的 <strong>最小有序</strong> 区间范围列表。也就是说，<code>nums</code> 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 <code>nums</code> 的数字 <code>x</code> 。</p><p>列表中的每个区间范围 <code>[a,b]</code> 应该按如下格式输出：</p><ul><li><code>&quot;a-&gt;b&quot;</code> ，如果 <code>a != b</code></li><li><code>&quot;a&quot;</code> ，如果 <code>a == b</code></li></ul><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>]</span><br><span class="line">输出：[<span class="string">&quot;0-&gt;2&quot;</span>,<span class="string">&quot;4-&gt;5&quot;</span>,<span class="string">&quot;7&quot;</span>]</span><br><span class="line">解释：区间范围是：</span><br><span class="line">[<span class="number">0</span>,<span class="number">2</span>] --&gt; <span class="string">&quot;0-&gt;2&quot;</span></span><br><span class="line">[<span class="number">4</span>,<span class="number">5</span>] --&gt; <span class="string">&quot;4-&gt;5&quot;</span></span><br><span class="line">[<span class="number">7</span>,<span class="number">7</span>] --&gt; <span class="string">&quot;7&quot;</span></span><br></pre></td></tr></table></figure><hr><p><strong>对比检查</strong>数组中的连续出现数组</p><p><strong>Solution</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">summaryRanges</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; ret = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">int</span> low = i;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] + <span class="number">1</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> high = i - <span class="number">1</span>;</span><br><span class="line">            String lows;</span><br><span class="line">            String highs;</span><br><span class="line">            lows= String.valueOf(nums[low]);</span><br><span class="line">            highs =String.valueOf(nums[high]);</span><br><span class="line">            <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">                ret.add(lows+<span class="string">&quot;-&gt;&quot;</span>+highs);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ret.add(lows);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>226.翻转二叉树</title>
      <link href="/post/20122.html"/>
      <url>/post/20122.html</url>
      
        <content type="html"><![CDATA[<h1 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226.翻转二叉树"></a>226.翻转二叉树</h1><p>翻转一棵二叉树。</p><p><strong>示例：</strong></p><p>输入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">4</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">2</span>     <span class="number">7</span></span><br><span class="line"> / \   / \</span><br><span class="line"><span class="number">1</span>   <span class="number">3</span> <span class="number">6</span>   <span class="number">9</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">4</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">7</span>     <span class="number">2</span></span><br><span class="line"> / \   / \</span><br><span class="line"><span class="number">9</span>   <span class="number">6</span> <span class="number">3</span>   <span class="number">1</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>采用递归的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode left = invertTree(root.left);</span><br><span class="line">        TreeNode right = invertTree(root.right);</span><br><span class="line">        root.left = right;</span><br><span class="line">        root.right = left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>225.用队列实现栈</title>
      <link href="/post/3630.html"/>
      <url>/post/3630.html</url>
      
        <content type="html"><![CDATA[<h1 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225.用队列实现栈"></a>225.用队列实现栈</h1><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（<code>push</code>、<code>top</code>、<code>pop</code> 和 <code>empty</code>）。</p><p>实现 <code>MyStack</code> 类：</p><ul><li><code>void push(int x)</code> 将元素 x 压入栈顶。</li><li><code>int pop()</code> 移除并返回栈顶元素。</li><li><code>int top()</code> 返回栈顶元素。</li><li><code>boolean empty()</code> 如果栈是空的，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li></ul><p><strong>注意：</strong></p><ul><li>你只能使用队列的基本操作 —— 也就是 <code>push to back</code>、<code>peek/pop from front</code>、<code>size</code> 和 <code>is empty</code> 这些操作。</li><li>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li></ul><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">&quot;MyStack&quot;</span>, <span class="string">&quot;push&quot;</span>, <span class="string">&quot;push&quot;</span>, <span class="string">&quot;top&quot;</span>, <span class="string">&quot;pop&quot;</span>, <span class="string">&quot;empty&quot;</span>]</span><br><span class="line">[[], [<span class="number">1</span>], [<span class="number">2</span>], [], [], []]</span><br><span class="line">输出：</span><br><span class="line">[<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="keyword">false</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyStack myStack = <span class="keyword">new</span> MyStack();</span><br><span class="line">myStack.push(<span class="number">1</span>);</span><br><span class="line">myStack.push(<span class="number">2</span>);</span><br><span class="line">myStack.top(); <span class="comment">// 返回 2</span></span><br><span class="line">myStack.pop(); <span class="comment">// 返回 2</span></span><br><span class="line">myStack.empty(); <span class="comment">// 返回 False</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = queue.size();</span><br><span class="line">        queue.offer(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            queue.offer(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>219.存在重复元素2</title>
      <link href="/post/65154.html"/>
      <url>/post/65154.html</url>
      
        <content type="html"><![CDATA[<h1 id="219-存在重复元素2"><a href="#219-存在重复元素2" class="headerlink" title="219.存在重复元素2"></a>219.存在重复元素2</h1><p>给定一个整数数组和一个整数 <em>k</em>，判断数组中是否存在两个不同的索引 <em>i</em> 和 <em>j</em>，使得 <strong>nums [i] = nums [j]</strong>，并且 <em>i</em> 和 <em>j</em> 的差的 <strong>绝对值</strong> 至多为 <em>k</em>。</p><p><strong>示例 1:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>], k = <span class="number">3</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>数组中的重复元素，并且相差不超过k</p><hr><p><strong>Solution</strong></p><p>在<code>217 存在重复元素</code>的基础上，基于Set的特性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; <span class="built_in">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">set</span>.contains(nums[i])) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">set</span>.add(nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">set</span>.size() &gt; k) &#123;</span><br><span class="line">            <span class="built_in">set</span>.remove(nums[i - k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 哈希表 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>217.存在重复元素</title>
      <link href="/post/60952.html"/>
      <url>/post/60952.html</url>
      
        <content type="html"><![CDATA[<h1 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217.存在重复元素"></a>217.存在重复元素</h1><p>给定一个整数数组，判断是否存在重复元素。</p><p>如果存在一值在数组中出现至少两次，函数返回 <code>true</code> 。如果数组中每个元素都不相同，则返回 <code>false</code> 。</p><p><strong>示例 1:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure><hr><p>有个元素会出现多次，而其他的<strong>仅有一次</strong></p><p><strong>Solution</strong>：排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>Solution1</strong>：HashSet</p><p>利用Set的特性，不会加入重复的元素，并且会返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">            HashSet&lt;Integer&gt; set=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x:nums)&#123;</span><br><span class="line">                <span class="keyword">if</span>(set.add(x)==<span class="keyword">false</span>)&#123; <span class="comment">//add添加失败会返回false</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 哈希表 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>206.反转链表</title>
      <link href="/post/47688.html"/>
      <url>/post/47688.html</url>
      
        <content type="html"><![CDATA[<h1 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h1><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p><strong>示例 1：</strong></p><p><a href="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg"><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/rev1ex1.jpg" alt="img"></a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>在指针转向的过程中，需要注意到几个问题</p><ol><li>如果表示要反转的2个结点?</li><li>假设结点从2指向了1，那么怎么找到3？</li></ol><p>答案是双指针和用临时变量储存3这个结点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;   <span class="comment">//前一个节点</span></span><br><span class="line">        ListNode curr = head;   <span class="comment">//当前指针</span></span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">           ListNode next = curr.next; <span class="comment">//临时变量储存当前结点的下一个结点，防止找不到</span></span><br><span class="line">           curr.next = prev;        <span class="comment">// 改变指针方向</span></span><br><span class="line">           prev = curr;            <span class="comment">// 前一个指针往后移动</span></span><br><span class="line">           curr = next;           <span class="comment">//当前指针向后移动</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;            <span class="comment">//最后是prev！=null</span></span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>205.同构字符串</title>
      <link href="/post/8001.html"/>
      <url>/post/8001.html</url>
      
        <content type="html"><![CDATA[<h1 id="205-同构字符串"><a href="#205-同构字符串" class="headerlink" title="205.同构字符串"></a>205.同构字符串</h1><p>给定两个字符串 <strong><em>s\</em></strong> 和 <strong>t</strong>，判断它们是否是同构的。</p><p>如果 <strong><em>s\</em></strong> 中的字符可以按某种映射关系替换得到 <strong>t</strong> ，那么这两个字符串是同构的。</p><p>每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。</p><p><strong>示例 1:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;egg&quot;</span>, t = <span class="string">&quot;add&quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;foo&quot;</span>, t = <span class="string">&quot;bar&quot;</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong>：</p><p>可以建立Map结构来建立映射，建立两个哈希表,分别检测映射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIsomorphic</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">     Map&lt;Character, Character&gt; s2t = <span class="keyword">new</span> HashMap&lt;Character, Character&gt;();</span><br><span class="line">     Map&lt;Character, Character&gt; t2s = <span class="keyword">new</span> HashMap&lt;Character, Character&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> x = s.charAt(i), y = t.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>  ((s2t.containsKey(x) &amp;&amp; s2t.get(x) != y) ||                               (t2s.containsKey(y) &amp;&amp; t2s.get(y) != x)) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s2t.put(x, y);    </span><br><span class="line">            t2s.put(y, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更好的办法有，用String类的indexOf函数，会返回该字符第一次出现的位置，如果不一样就说明对应不上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIsomorphic</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">              <span class="keyword">if</span>(s.indexOf(s.charAt(i)) != t.indexOf(t.charAt(i)))&#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;  </span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 哈希表 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>203.移除链表元素</title>
      <link href="/post/10634.html"/>
      <url>/post/10634.html</url>
      
        <content type="html"><![CDATA[<h1 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h1><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], val = <span class="number">6</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [], val = <span class="number">1</span></span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>], val = <span class="number">7</span></span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>参考<code>237.删除链表中的节点</code>，因为有可能要删除<code>head</code>，所以设置一个指针来指向<code>head</code>，其余的都是删除的常见操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        ListNode temp = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next.val == val) &#123;</span><br><span class="line">                temp.next = temp.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>202.快乐数</title>
      <link href="/post/37671.html"/>
      <url>/post/37671.html</url>
      
        <content type="html"><![CDATA[<h1 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202.快乐数"></a>202.快乐数</h1><p>编写一个算法来判断一个数 <code>n</code> 是不是快乐数。</p><p>「快乐数」定义为：</p><ul><li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li><li>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。</li><li>如果 <strong>可以变为</strong> 1，那么这个数就是快乐数。</li></ul><p>如果 <code>n</code> 是快乐数就返回 <code>true</code> ；不是，则返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">19</span></span><br><span class="line">输出：<span class="keyword">true</span></span><br><span class="line">解释：</span><br><span class="line"><span class="number">1</span>*<span class="number">1</span> + <span class="number">9</span>*<span class="number">9</span> = <span class="number">82</span></span><br><span class="line"><span class="number">8</span>*<span class="number">8</span> + <span class="number">2</span>*<span class="number">2</span> = <span class="number">68</span></span><br><span class="line"><span class="number">6</span>*<span class="number">6</span> + <span class="number">8</span>*<span class="number">8</span> = <span class="number">100</span></span><br><span class="line"><span class="number">1</span>*<span class="number">1</span> + <span class="number">0</span>*<span class="number">0</span> + <span class="number">0</span>*<span class="number">0</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/1.jpg" alt=""></p><p>最后都会进循环，可以通过快慢指针法来判断最后是否循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = n % <span class="number">10</span>;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">            totalSum += d * d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slowRunner = n;</span><br><span class="line">        <span class="keyword">int</span> fastRunner = getNext(n);</span><br><span class="line">        <span class="keyword">while</span> (fastRunner != <span class="number">1</span> &amp;&amp; slowRunner != fastRunner) &#123;</span><br><span class="line">            slowRunner = getNext(slowRunner);</span><br><span class="line">            fastRunner = getNext(getNext(fastRunner));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fastRunner == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
          <category> 哈希表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>191.位1的个数</title>
      <link href="/post/24827.html"/>
      <url>/post/24827.html</url>
      
        <content type="html"><![CDATA[<h1 id="191-位1的个数"><a href="#191-位1的个数" class="headerlink" title="191.位1的个数"></a>191.位1的个数</h1><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为<a href="https://baike.baidu.com/item/汉明重量">汉明重量</a>）。</p><p><strong>提示：</strong></p><ul><li>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li><li>在 Java 中，编译器使用<a href="https://baike.baidu.com/item/二进制补码/5295284">二进制补码</a>记法来表示有符号整数。因此，在上面的 <strong>示例 3</strong> 中，输入表示有符号整数 <code>-3</code>。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="number">00000000000000000000000000001011</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：输入的二进制串 <span class="number">00000000000000000000000000001011</span> 中，共有三位为 <span class="string">&#x27;1&#x27;</span>。</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>利用<code>x&amp;(x-1)</code>会让x中最低位的1变为0的技巧，不断反转x，直到x变为0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            n &amp;= n - <span class="number">1</span>;</span><br><span class="line">            ret++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 位运算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>190.颠倒二进制位</title>
      <link href="/post/17633.html"/>
      <url>/post/17633.html</url>
      
        <content type="html"><![CDATA[<h1 id="190-颠倒二进制位"><a href="#190-颠倒二进制位" class="headerlink" title="190.颠倒二进制位"></a>190.颠倒二进制位</h1><p>颠倒给定的 32 位无符号整数的二进制位。</p><p><strong>提示：</strong></p><ul><li>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li><li>在 Java 中，编译器使用<a href="https://baike.baidu.com/item/二进制补码/5295284">二进制补码</a>记法来表示有符号整数。因此，在 <strong>示例 2</strong> 中，输入表示有符号整数 <code>-3</code>，输出表示有符号整数 <code>-1073741825</code>。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">00000010100101000001111010011100</span></span><br><span class="line">输出：<span class="number">964176192</span> (<span class="number">00111001011110000010100101000000</span>)</span><br><span class="line">解释：输入的二进制串 <span class="number">00000010100101000001111010011100</span> 表示无符号整数 <span class="number">43261596</span>，</span><br><span class="line">     因此返回 <span class="number">964176192</span>，其二进制表示形式为 <span class="number">00111001011110000010100101000000</span>。</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>逐位颠倒</p><p><code>n&amp;1</code>是让n保留最后一位，<code>&lt;&lt;(31-i)</code>是让被改变位移动带rev的位置，|让rev和和n移动后的位相同</p><p>最后的<code>n&gt;&gt;&gt;=1</code>是让n右移，因为JAVA特性使用无符号右移</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span> &amp;&amp; n != <span class="number">0</span>; ++i) &#123;</span><br><span class="line">            rev |= (n &amp; <span class="number">1</span>) &lt;&lt; (<span class="number">31</span> - i);</span><br><span class="line">            n &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 位运算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>171.Excel表列序号</title>
      <link href="/post/38963.html"/>
      <url>/post/38963.html</url>
      
        <content type="html"><![CDATA[<h1 id="171-Excel表列序号"><a href="#171-Excel表列序号" class="headerlink" title="171.Excel表列序号"></a>171.Excel表列序号</h1><p>给你一个字符串 <code>columnTitle</code> ，表示 Excel 表格中的列名称。返回该列名称对应的列序号。</p><p>例如，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; <span class="number">1</span></span><br><span class="line">B -&gt; <span class="number">2</span></span><br><span class="line">C -&gt; <span class="number">3</span></span><br><span class="line">...</span><br><span class="line">Z -&gt; <span class="number">26</span></span><br><span class="line">AA -&gt; <span class="number">27</span></span><br><span class="line">AB -&gt; <span class="number">28</span> </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>示例 1:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: columnTitle = <span class="string">&quot;A&quot;</span></span><br><span class="line">输出: <span class="number">1</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>先将字符串转换为数组，然后计算sum，从最高位开始，按照其他进制转10进制的方法，值=26的n次方×本身字符的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">titleToNumber</span><span class="params">(String columnTitle)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">char</span> []a=columnTitle.toCharArray();</span><br><span class="line">         <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">                 sum+=(a[i]-<span class="string">&#x27;A&#x27;</span>+<span class="number">1</span>)*Math.pow(<span class="number">26</span>,a.length-<span class="number">1</span>-i);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>169.多数元素</title>
      <link href="/post/1059.html"/>
      <url>/post/1059.html</url>
      
        <content type="html"><![CDATA[<h1 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169.多数元素"></a>169.多数元素</h1><p>给定一个大小为 <em>n</em> 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure><hr><p>在数组中占比已经超过一半的数字</p><p><strong>Solution</strong>：排序查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">         Arrays.sort(nums);</span><br><span class="line">         <span class="keyword">return</span> nums[nums.length/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为元素在数组中的出现次数大于了n/2，所以下标为n/2的元素一定是多数元素</p><hr><p><strong>Solution1</strong>：Boyer-Moore 投票算法</p><p>Boyer-Moore 算法,我们首先给出 Boyer-Moore 算法的详细步骤：</p><ul><li>我们维护一个候选众数 <code>candidate</code> 和它出现的次数 <code>count</code>。初始时 <code>candidate</code> 可以为任意值，<code>count</code> 为 <code>0</code>；</li><li><p>我们遍历数组 <code>nums</code> 中的所有元素，对于每个元素 <code>x</code>，在判断 <code>x</code> 之前，如果 <code>count</code> 的值为 <code>0</code>，我们先将 <code>x</code> 的值赋予 <code>candidate</code>，随后我们判断 <code>x</code>：</p><ul><li>如果 <code>x</code> 与 <code>candidate</code> 相等，那么计数器 <code>count</code> 的值增加 <code>1</code>；</li><li>如果 <code>x</code> 与 <code>candidate</code> 不等，那么计数器 <code>count</code> 的值减少 <code>1</code>。</li></ul></li><li><p>在遍历完成后，<code>candidate</code> 即为整个数组的众数。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        Integer candidate = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                candidate = num;</span><br><span class="line">            &#125;</span><br><span class="line">            count += (num == candidate) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>投票算法证明：</p><ol><li>如果候选人不是<code>major</code>则<code>major</code>会和其他非候选人一起反对候选人,所以候选人一定会下台(<code>coumt==0</code>时发生换届选举)</li><li>如果候选人是<code>major</code> , 则<code>major</code> 会支持自己，其他候选人会反对，同样因为<code>major</code> 票数超过一半，所以<code>major</code> 一定会成功当选</li></ol>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 哈希表 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>168.Excel表列名称</title>
      <link href="/post/43063.html"/>
      <url>/post/43063.html</url>
      
        <content type="html"><![CDATA[<h1 id="168-Excel列名称"><a href="#168-Excel列名称" class="headerlink" title="168.Excel列名称"></a>168.Excel列名称</h1><p>给你一个整数 <code>columnNumber</code> ，返回它在 Excel 表中相对应的列名称。</p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; <span class="number">1</span></span><br><span class="line">B -&gt; <span class="number">2</span></span><br><span class="line">C -&gt; <span class="number">3</span></span><br><span class="line">...</span><br><span class="line">Z -&gt; <span class="number">26</span></span><br><span class="line">AA -&gt; <span class="number">27</span></span><br><span class="line">AB -&gt; <span class="number">28</span> </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：columnNumber = <span class="number">1</span></span><br><span class="line">输出：<span class="string">&quot;A&quot;</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>因为A代表的是1，所以将数字-1，然后%26，再加上ASCII码，经过char转换后最后就得到了字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> columnNumber)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span> (columnNumber != <span class="number">0</span>) &#123;</span><br><span class="line">            columnNumber--;</span><br><span class="line">            sb.append((<span class="keyword">char</span>)(columnNumber % <span class="number">26</span> + <span class="string">&#x27;A&#x27;</span>));</span><br><span class="line">            columnNumber /= <span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>167.两数之和2</title>
      <link href="/post/90.html"/>
      <url>/post/90.html</url>
      
        <content type="html"><![CDATA[<h1 id="167-两数之和2"><a href="#167-两数之和2" class="headerlink" title="167.两数之和2"></a>167.两数之和2</h1><p>给定一个已按照 <strong>非递减顺序排列</strong> 的整数数组 <code>numbers</code> ，请你从数组中找出两个数满足相加之和等于目标数 <code>target</code> 。</p><p>函数应该以长度为 <code>2</code> 的整数数组的形式返回这两个数的下标值<em>。</em><code>numbers</code> 的下标 <strong>从 1 开始计数</strong> ，所以答案数组应当满足 <code>1 &lt;= answer[0] &lt; answer[1] &lt;= numbers.length</code> 。</p><p>你可以假设每个输入 <strong>只对应唯一的答案</strong> ，而且你 <strong>不可以</strong> 重复使用相同的元素。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：numbers = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">解释：<span class="number">2</span> 与 <span class="number">7</span> 之和等于目标数 <span class="number">9</span> 。因此 index1 = <span class="number">1</span>, index2 = <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><hr><p>已经是<strong>非递减</strong>顺序的数组，求其中两个元素的和</p><p><strong>Solution</strong>：双指针</p><p>既然是非递减数组，那么考虑双指针法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> []a=&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=numbers.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&gt;left)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[right]+numbers[left]&gt;target)&#123;</span><br><span class="line">                right--;<span class="comment">// 和大于target就让右指针左移</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(numbers[right]+numbers[left]&lt;target)&#123;</span><br><span class="line">                left++; <span class="comment">// 和小于target就让左指针右移</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                a[<span class="number">0</span>]=left+<span class="number">1</span>;</span><br><span class="line">                a[<span class="number">1</span>]=right+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>160.相交链表</title>
      <link href="/post/45519.html"/>
      <url>/post/45519.html</url>
      
        <content type="html"><![CDATA[<h1 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160.相交链表"></a>160.相交链表</h1><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p><p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p><p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p><p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p><hr><p><strong>Solution</strong>：双指针</p><p>两个指针分别从两个链表起始处出发，同时增加，如果到了尽头，就从另一个链表起始处开始，如果两个链表相交，则指针必会在相交处相等，如果不相交，则必会同时到尽头</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pA = headA, pB = headB;</span><br><span class="line">        <span class="keyword">while</span> (pA != pB) &#123;</span><br><span class="line">            pA = pA == <span class="keyword">null</span> ? headB : pA.next;</span><br><span class="line">            pB = pB == <span class="keyword">null</span> ? headA : pB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 哈希表 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>155.最小栈</title>
      <link href="/post/20768.html"/>
      <url>/post/20768.html</url>
      
        <content type="html"><![CDATA[<h1 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155.最小栈"></a>155.最小栈</h1><p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p><ul><li><code>push(x)</code> —— 将元素 x 推入栈中。</li><li><code>pop()</code> —— 删除栈顶的元素。</li><li><code>top()</code> —— 获取栈顶元素。</li><li><code>getMin()</code> —— 检索栈中的最小元素。</li></ul><p><strong>示例:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">&quot;MinStack&quot;</span>,<span class="string">&quot;push&quot;</span>,<span class="string">&quot;push&quot;</span>,<span class="string">&quot;push&quot;</span>,<span class="string">&quot;getMin&quot;</span>,<span class="string">&quot;pop&quot;</span>,<span class="string">&quot;top&quot;</span>,<span class="string">&quot;getMin&quot;</span>]</span><br><span class="line">[[],[<span class="number">-2</span>],[<span class="number">0</span>],[<span class="number">-3</span>],[],[],[],[]]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[null,null,null,null,<span class="number">-3</span>,null,<span class="number">0</span>,<span class="number">-2</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MinStack minStack = <span class="keyword">new</span> MinStack();</span><br><span class="line">minStack.push(<span class="number">-2</span>);</span><br><span class="line">minStack.push(<span class="number">0</span>);</span><br><span class="line">minStack.push(<span class="number">-3</span>);</span><br><span class="line">minStack.getMin();   --&gt; 返回 <span class="number">-3.</span></span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 <span class="number">0.</span></span><br><span class="line">minStack.getMin();   --&gt; 返回 <span class="number">-2.</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution：辅助栈</strong></p><p>我们只需要设计一个数据结构，使得每个元素 <code>a</code> 与其相应的最小值 <code>m</code> 时刻保持一一对应。因此我们可以使用一个辅助栈，与元素栈同步插入与删除，用于存储与每个元素对应的最小值。</p><ul><li>当一个元素要入栈时，我们取当前辅助栈的栈顶存储的最小值，与当前元素比较得出最小值，将这个最小值插入辅助栈中；</li><li>当一个元素要出栈时，我们把辅助栈的栈顶元素也一并弹出；</li><li>在任意一个时刻，栈内元素的最小值就存储在辅助栈的栈顶元素中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    Deque&lt;Integer&gt; xStack;</span><br><span class="line">    Deque&lt;Integer&gt; minStack;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        xStack = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        minStack.push(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        xStack.push(x);</span><br><span class="line">        minStack.push(Math.min(minStack.peek(), x));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        xStack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> xStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>145.二叉树的后序遍历</title>
      <link href="/post/62169.html"/>
      <url>/post/62169.html</url>
      
        <content type="html"><![CDATA[<h1 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145.二叉树的后序遍历"></a>145.二叉树的后序遍历</h1><p>给定一个二叉树，返回它的 <em>后序</em> 遍历。</p><p><strong>示例:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,null,<span class="number">2</span>,<span class="number">3</span>]  </span><br><span class="line">   <span class="number">1</span></span><br><span class="line">    \</span><br><span class="line">     <span class="number">2</span></span><br><span class="line">    /</span><br><span class="line">   <span class="number">3</span> </span><br><span class="line"></span><br><span class="line">输出: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        postorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        postorder(root.left, res);</span><br><span class="line">        postorder(root.right, res);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List &lt;Integer&gt; list =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Stack &lt;TreeNode&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Map &lt;TreeNode,Integer&gt; flag =<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(root!=<span class="keyword">null</span>||stack.isEmpty()==<span class="keyword">false</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">               stack.push(root);</span><br><span class="line">               flag.put(root,<span class="number">1</span>);</span><br><span class="line">               root=root.left;</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">             root=stack.peek();</span><br><span class="line">               <span class="keyword">if</span>(flag.get(root)==<span class="number">1</span>)&#123;</span><br><span class="line">                   flag.put(root,<span class="number">2</span>);</span><br><span class="line">                   root=root.right;</span><br><span class="line">                   </span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   root=stack.pop();</span><br><span class="line">                   list.add(root.val);</span><br><span class="line">                   root=<span class="keyword">null</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>111.二叉树的前序遍历</title>
      <link href="/post/38853.html"/>
      <url>/post/38853.html</url>
      
        <content type="html"><![CDATA[<h1 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144.二叉树的前序遍历"></a>144.二叉树的前序遍历</h1><p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p><p><strong>示例 1：</strong><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/inorder_1-16395569119431.jpg" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>,null,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        preorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        preorder(root.left, res);</span><br><span class="line">        preorder(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() || node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">                res.add(node.val);</span><br><span class="line">                stack.push(node);</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = stack.pop();</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>141.环形链表</title>
      <link href="/post/17558.html"/>
      <url>/post/17558.html</url>
      
        <content type="html"><![CDATA[<h1 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141.环形链表"></a>141.环形链表</h1><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><a href="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/circularlinkedlist.png"><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/circularlinkedlist.png" alt="img"></a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">-4</span>], pos = <span class="number">1</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong>：<strong>快慢指针</strong></p><p>本方法需要读者对「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解。</p><p>假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</p><p>我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 <code>head</code>，而快指针在位置 <code>head.next</code>。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head.next;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 哈希表 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>136.只出现一次的数字</title>
      <link href="/post/18653.html"/>
      <url>/post/18653.html</url>
      
        <content type="html"><![CDATA[<h1 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136.只出现一次的数字"></a>136.只出现一次的数字</h1><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现<strong>两次</strong>。找出那个只出现了一次的元素。</p><p><strong>说明：</strong></p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p><strong>示例 1:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">1</span></span><br></pre></td></tr></table></figure><hr><p>数组中的元素<strong>出现次数</strong>，有特殊出现次数的数字</p><p><strong>Solution</strong>：位运算</p><p>考虑异或运算，相同为0，相异为1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> single = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            single ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> single;<span class="comment">//除了single以外的其他数，出现了两次，所以异或为0，而single和0异或，结果为</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>Solution2</strong>:Hash表</p><p>位运算只能说是取巧解法，假设其他数字出现两次以上，那么异或运算就不成立了，所以关于数组里面的元素出现次数的通用解法应该是HashMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Class Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">            map.put(num, count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Integer i:map.keySet())&#123;</span><br><span class="line">           Integer ans=map.get(i);</span><br><span class="line">           <span class="keyword">if</span>(ans==<span class="number">1</span>)&#123;</span><br><span class="line">               <span class="keyword">return</span> i;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数组 </category>
          
          <category> 位运算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>125.验证回文串</title>
      <link href="/post/12585.html"/>
      <url>/post/12585.html</url>
      
        <content type="html"><![CDATA[<h1 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125.验证回文串"></a>125.验证回文串</h1><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p><p><strong>说明：</strong>本题中，我们将空字符串定义为有效的回文串。</p><p><strong>示例 1:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">&quot;A man, a plan, a canal: Panama&quot;</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释：<span class="string">&quot;amanaplanacanalpanama&quot;</span> 是回文串</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>最简单的方法是对字符串s进行一次遍历，并将其中的字母和数字字符进行保留，放在另一个字符串 <em>sgood</em> 中。这样我们只需要判断 <em>sgood</em> 是否是一个普通的回文串即可。</p><p>判断的方法有两种。第一种是使用语言中的字符串翻转 API 得到 <em>sgood</em> 的逆序字符串 <em>sgood_rev</em>，只要这两个字符串相同，那么 <em>sgood</em> 就是回文串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuffer sgood = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (Character.isLetterOrDigit(ch)) &#123;</span><br><span class="line">                sgood.append(Character.toLowerCase(ch));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuffer sgood_rev = <span class="keyword">new</span> StringBuffer(sgood).reverse();</span><br><span class="line">        <span class="keyword">return</span> sgood.toString().equals(sgood_rev.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>121.买卖股票的最佳时机</title>
      <link href="/post/35908.html"/>
      <url>/post/35908.html</url>
      
        <content type="html"><![CDATA[<h1 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121.买卖股票的最佳时机"></a>121.买卖股票的最佳时机</h1><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：在第 <span class="number">2</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">5</span> 天（股票价格 = <span class="number">6</span>）的时候卖出，最大利润 = <span class="number">6</span><span class="number">-1</span> = <span class="number">5</span> 。</span><br><span class="line">     注意利润不能是 <span class="number">7</span><span class="number">-1</span> = <span class="number">6</span>, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure><hr><p>是否卖出股票，这要根据<strong>之前</strong>的最大利润来决定</p><p><strong>Solution</strong>：动态规划</p><p>可以采取动态规划的思想，首先从后往前遍历，记录股票最高的时候，用股票最高的时候去减当前的价格，记录利润最高的时候</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=prices.length;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max=prices[len-<span class="number">1</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=len-<span class="number">2</span>;i&gt;-<span class="number">1</span>;i--)&#123;        <span class="comment">//从倒数第二天开始遍历</span></span><br><span class="line">        max=Math.max(max,prices[i]);     <span class="comment">//股票最高的时候</span></span><br><span class="line">        ans=Math.max(max-prices[i],ans); <span class="comment">// 利润最多的时候</span></span><br><span class="line">           &#125;</span><br><span class="line">         <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>119.杨辉三角2</title>
      <link href="/post/65039.html"/>
      <url>/post/65039.html</url>
      
        <content type="html"><![CDATA[<h1 id="119-杨辉三角2"><a href="#119-杨辉三角2" class="headerlink" title="119.杨辉三角2"></a>119.杨辉三角2</h1><p>给定一个非负索引 <code>rowIndex</code>，返回「杨辉三角」的第 <code>rowIndex</code> 行。</p><p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/1626927345-DZmfxB-PascalTriangleAnimated2.gif" alt="img"></p><p><strong>示例 1:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: rowIndex = <span class="number">3</span></span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><hr><p><strong>Solution：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= rowIndex; ++i) &#123;</span><br><span class="line">            List&lt;Integer&gt; row = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span> || j == i) &#123;</span><br><span class="line">                    row.add(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    row.add(ret.get(i - <span class="number">1</span>).get(j - <span class="number">1</span>) + ret.get(i - <span class="number">1</span>).get(j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ret.add(row);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret.get(rowIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 动态规划 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>118.杨辉三角</title>
      <link href="/post/34917.html"/>
      <url>/post/34917.html</url>
      
        <content type="html"><![CDATA[<h1 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118.杨辉三角"></a>118.杨辉三角</h1><p>给定一个非负整数 <em><code>numRows</code>，</em>生成「杨辉三角」的前 <em><code>numRows</code></em> 行。</p><p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/1626927345-DZmfxB-PascalTriangleAnimated2.gif" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: numRows = <span class="number">5</span></span><br><span class="line">输出: [[<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong>：</p><p>每个数字等于上一行的左右两个数字之和，可用此性质写出整个杨辉三角。即第 n 行的第 i 个数等于第 n-1 行的第 i-1个数和第 i 个数之和。这也是组合数的性质之一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRows; ++i) &#123;</span><br><span class="line">            List&lt;Integer&gt; row = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span> || j == i) &#123;</span><br><span class="line">                    row.add(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    row.add(ret.get(i - <span class="number">1</span>).get(j - <span class="number">1</span>) + ret.get(i - <span class="number">1</span>).get(j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ret.add(row);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 动态规划 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>112.路径总和</title>
      <link href="/post/50084.html"/>
      <url>/post/50084.html</url>
      
        <content type="html"><![CDATA[<h1 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112.路径总和"></a>112.路径总和</h1><p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><p><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/pathsum1.jpg" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">11</span>,null,<span class="number">13</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,null,null,null,<span class="number">1</span>], targetSum = <span class="number">22</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：等于目标和的根节点到叶节点路径如上图所示。</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>从上到下，如果不是叶子结点，就减去当前结点的val值，如果是的话就判断值和val是否相等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sum == root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, sum - root.val) ||                                    hasPathSum(root.right, sum - root.val);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>111.二叉树的最小深度</title>
      <link href="/post/43318.html"/>
      <url>/post/43318.html</url>
      
        <content type="html"><![CDATA[<h1 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111.二叉树的最小深度"></a>111.二叉树的最小深度</h1><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p><strong>说明：</strong>叶子节点是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><p><a href="https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg"><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/ex_depth.jpg" alt="img"></a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,null,null,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> min_depth = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            min_depth = Math.min(minDepth(root.left), min_depth);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            min_depth = Math.min(minDepth(root.right), min_depth);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min_depth + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>110.平衡二叉树</title>
      <link href="/post/51902.html"/>
      <url>/post/51902.html</url>
      
        <content type="html"><![CDATA[<h1 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110.平衡二叉树"></a>110.平衡二叉树</h1><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><blockquote><p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 。</p></blockquote><p><strong>示例 1：</strong></p><p><a href="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg"><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/balance_1.jpg" alt="img"></a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,null,null,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>如何判断一棵二叉树是否平衡呢？需要比较其子树的深度差，采取从底向上的遍历方法，如果其子树不是平衡二叉树，那么会返回-1，如果是，那么就返回他的最大深度，只要结点的左子树，右子树，或者左右高度差大于1满足一个条件，就会返回-1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> height(root) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftHeight = height(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightHeight = height(root.right);</span><br><span class="line">        <span class="keyword">if</span> (leftHeight == -<span class="number">1</span> || rightHeight == -<span class="number">1</span> || Math.abs(leftHeight - rightHeight) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>108.将有序数组转换为二叉搜索树</title>
      <link href="/post/17864.html"/>
      <url>/post/17864.html</url>
      
        <content type="html"><![CDATA[<h1 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108.将有序数组转换为二叉搜索树"></a>108.将有序数组转换为二叉搜索树</h1><p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 <strong>高度平衡</strong> 二叉搜索树。</p><p><strong>高度平衡</strong> 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-10</span>,<span class="number">-3</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">9</span>]</span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">-3</span>,<span class="number">9</span>,<span class="number">-10</span>,null,<span class="number">5</span>]</span><br><span class="line">解释：[<span class="number">0</span>,<span class="number">-10</span>,<span class="number">5</span>,null,<span class="number">-3</span>,null,<span class="number">9</span>] 也将被视为正确答案：</span><br></pre></td></tr></table></figure><hr><p>有序数组转换为二叉树，需要<strong>创建二叉树</strong>，并且是<strong>有序的</strong></p><p><strong>Solution</strong>：中序遍历</p><p>相当于是根据中序遍历来还原平衡二叉搜索树,有点类似于二分查找和创建二叉树的结合，也就是利用二分查找来查找树以及其子树的根节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct TreeNode* <span class="title">helper</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 总是选择中间位置左边的数字作为根节点</span></span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">root</span> =</span> (struct TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TreeNode));</span><br><span class="line">    root-&gt;val = nums[mid];</span><br><span class="line">    root-&gt;left = helper(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">    root-&gt;right = helper(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> helper(nums, <span class="number">0</span>, numsSize - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 总是选择中间位置左边的数字作为根节点</span></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        root.left = helper(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">        root.right = helper(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>104.二叉树的最大深度</title>
      <link href="/post/5758.html"/>
      <url>/post/5758.html</url>
      
        <content type="html"><![CDATA[<h1 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104.二叉树的最大深度"></a>104.二叉树的最大深度</h1><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p><strong>示例：</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><p>返回它的最大深度 3 。</p><hr><p><strong>Solution</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> depthval;</span><br><span class="line">    <span class="keyword">if</span> ( root==<span class="keyword">null</span>) depthval = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> depthLeft = maxDepth( root.left );</span><br><span class="line">    <span class="keyword">int</span> depthRight= maxDepth( root.right);</span><br><span class="line">    depthval = <span class="number">1</span> + (depthLeft &gt; depthRight ?depthLeft : depthRight);</span><br><span class="line">         &#125; </span><br><span class="line">    <span class="keyword">return</span> depthval;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>101.对称二叉树</title>
      <link href="/post/46839.html"/>
      <url>/post/46839.html</url>
      
        <content type="html"><![CDATA[<h1 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101.对称二叉树"></a>101.对称二叉树</h1><p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">2</span></span><br><span class="line"> / \ / \</span><br><span class="line"><span class="number">3</span>  <span class="number">4</span> <span class="number">4</span>  <span class="number">3</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>可以通过递归调用的方式来解决问题，<code>check</code>函数应该在除去特殊情况后，返回对比后的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> check(root, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p.val == q.val &amp;&amp; check(p.left, q.right) &amp;&amp; check(p.right, q.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>100.相同的树</title>
      <link href="/post/61466.html"/>
      <url>/post/61466.html</url>
      
        <content type="html"><![CDATA[<h1 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100.相同的树"></a>100.相同的树</h1><p>给你两棵二叉树的根节点 <code>p</code> 和 <code>q</code> ，编写一个函数来检验这两棵树是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p><strong>示例 1：</strong></p><p><a href="https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg"><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/ex1.jpg" alt="img"></a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：p = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], q = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>如果两棵树都不为空，就遍历它们的左子树和右子树，可以使用递归的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="keyword">null</span> || q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.val != q.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>94.二叉树的中序遍历</title>
      <link href="/post/5409.html"/>
      <url>/post/5409.html</url>
      
        <content type="html"><![CDATA[<h1 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94.二叉树的中序遍历"></a>94.二叉树的中序遍历</h1><p>给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>中序</strong> 遍历。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,null,2,3]</span><br><span class="line">输出：[1,3,2]</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong>：递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList &lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    inorderTraversal(root.left);</span><br><span class="line">    list.add(root.val);</span><br><span class="line">    inorderTraversal(root.right);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Solution1</strong>: 栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stk = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span> || !stk.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stk.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.pop();</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>88.合并两个有序数组</title>
      <link href="/post/18592.html"/>
      <url>/post/18592.html</url>
      
        <content type="html"><![CDATA[<h1 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88.合并两个有序数组"></a>88.合并两个有序数组</h1><p>给你两个按 <strong>非递减顺序</strong> 排列的整数数组 <code>nums1</code> 和 <code>nums2</code>，另有两个整数 <code>m</code> 和 <code>n</code> ，分别表示 <code>nums1</code> 和 <code>nums2</code> 中的元素数目。</p><p>请你 <strong>合并</strong> <code>nums2</code> 到 <code>nums1</code> 中，使合并后的数组同样按 <strong>非递减顺序</strong> 排列。</p><p><strong>注意：</strong>最终，合并后数组不应由函数返回，而是存储在数组 <code>nums1</code> 中。为了应对这种情况，<code>nums1</code> 的初始长度为 <code>m + n</code>，其中前 <code>m</code> 个元素表示应合并的元素，后 <code>n</code> 个元素为 <code>0</code> ，应忽略。<code>nums2</code> 的长度为 <code>n</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], m = <span class="number">3</span>, nums2 = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>], n = <span class="number">3</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">解释：需要合并 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] 和 [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>] 。</span><br><span class="line">合并结果是 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>] ，其中斜体加粗标注的为 nums1 中的元素。</span><br></pre></td></tr></table></figure><hr><p>合并数组，并且让他们按<strong>非递减</strong>顺序，需要<strong>比较</strong>和遍历数组中的元素</p><p><strong>Solution1：先合并再排序</strong></p><p>先将两个数组合并，再采用排序方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设是快排</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != n; ++i) &#123;</span><br><span class="line">            nums1[m + i] = nums2[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Solution2</strong>：双指针比较，创造一个新的数组</p><p>方法一没有利用数组 <em>nums</em>1 与 <em>nums</em>2 已经被排序的性质。为了利用这一性质，我们可以使用双指针方法。这一方法将两个数组看作队列，每次从两个数组头部取出比较小的数字放到结果中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] sorted = <span class="keyword">new</span> <span class="keyword">int</span>[m + n];</span><br><span class="line">        <span class="keyword">int</span> cur;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt; m || p2 &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1 == m) &#123;         <span class="comment">// 如果p1到头了，那么剩下的元素都是p2</span></span><br><span class="line">                cur = nums2[p2++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p2 == n) &#123;</span><br><span class="line">                cur = nums1[p1++];    <span class="comment">//// 如果p2到头了，那么剩下的元素都是p1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[p1] &lt; nums2[p2]) &#123;</span><br><span class="line">                cur = nums1[p1++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = nums2[p2++];</span><br><span class="line">            &#125;</span><br><span class="line">            sorted[p1 + p2 - <span class="number">1</span>] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != m + n; ++i) &#123;</span><br><span class="line">            nums1[i] = sorted[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>Solution3</strong>：逆向双指针</p><p>方法2之所以需要辅助数组，是怕把<code>num1</code>数组直接覆盖掉，如果我们从后往前插入<code>nums1</code>数组中去，就不需要构造辅助数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = m - <span class="number">1</span>, p2 = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tail = m + n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cur;</span><br><span class="line">        <span class="keyword">while</span> (p1 &gt;= <span class="number">0</span> || p2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1 == -<span class="number">1</span>) &#123;</span><br><span class="line">                cur = nums2[p2--];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p2 == -<span class="number">1</span>) &#123;</span><br><span class="line">                cur = nums1[p1--];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[p1] &gt; nums2[p2]) &#123;</span><br><span class="line">                cur = nums1[p1--];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = nums2[p2--];</span><br><span class="line">            &#125;</span><br><span class="line">            nums1[tail--] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>83.删除链表中的重复元素</title>
      <link href="/post/30438.html"/>
      <url>/post/30438.html</url>
      
        <content type="html"><![CDATA[<h1 id="83-删除链表中的重复元素"><a href="#83-删除链表中的重复元素" class="headerlink" title="83.删除链表中的重复元素"></a>83.删除链表中的重复元素</h1><p>存在一个按升序排列的链表，给你这个链表的头节点 <code>head</code> ，请你删除所有重复的元素，使每个元素 <strong>只出现一次</strong> 。</p><p>返回同样按升序排列的结果链表。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/list1.jpg" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong>：</p><p>如果发现了当前结点和下个结点的值相同，就将当前结点指向下下个结点，遍历链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.val == cur.next.val) &#123;</span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>70.爬楼梯</title>
      <link href="/post/18439.html"/>
      <url>/post/18439.html</url>
      
        <content type="html"><![CDATA[<h1 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a>70.爬楼梯</h1><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： <span class="number">2</span></span><br><span class="line">输出： <span class="number">2</span></span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line"><span class="number">1.</span>  <span class="number">1</span> 阶 + <span class="number">1</span> 阶</span><br><span class="line"><span class="number">2.</span>  <span class="number">2</span> 阶</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>很经典的动态规划题目，每爬一阶楼梯的方法取决于前一节和前两节的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            p = q; </span><br><span class="line">            q = r; </span><br><span class="line">            r = p + q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>69.Sqrt(x)</title>
      <link href="/post/60532.html"/>
      <url>/post/60532.html</url>
      
        <content type="html"><![CDATA[<h1 id="69-Sqrt-x"><a href="#69-Sqrt-x" class="headerlink" title="69.Sqrt(x)"></a>69.Sqrt(x)</h1><p>给你一个非负整数 <code>x</code> ，计算并返回 <code>x</code> 的 <strong>算术平方根</strong> 。</p><p>由于返回类型是整数，结果只保留 <strong>整数部分</strong> ，小数部分将被 <strong>舍去 。</strong></p><p><strong>注意：</strong>不允许使用任何内置指数函数和算符，例如 <code>pow(x, 0.5)</code> 或者 <code>x ** 0.5</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = <span class="number">4</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>和<code>367 有效的完全平方数</code>一样，都是二分查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = x, ans = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">long</span>) mid * mid &lt;= x) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>67.二进制求和</title>
      <link href="/post/38912.html"/>
      <url>/post/38912.html</url>
      
        <content type="html"><![CDATA[<h1 id="67-二进制求和"><a href="#67-二进制求和" class="headerlink" title="67.二进制求和"></a>67.二进制求和</h1><p>给你两个二进制字符串，返回它们的和（用二进制表示）。</p><p>输入为 <strong>非空</strong> 字符串且只包含数字 <code>1</code> 和 <code>0</code>。</p><p><strong>示例 1:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: a = <span class="string">&quot;11&quot;</span>, b = <span class="string">&quot;1&quot;</span></span><br><span class="line">输出: <span class="string">&quot;100&quot;</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>模仿手算，用一个变量来表示进位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(a == <span class="keyword">null</span> || a.length() == <span class="number">0</span>) <span class="keyword">return</span> b;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="keyword">null</span> || b.length() == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line">        StringBuilder stb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> i = a.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = b.length() - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;  <span class="comment">// 进位</span></span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">0</span>) c += a.charAt(i --) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= <span class="number">0</span>) c += b.charAt(j --) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            stb.append(c % <span class="number">2</span>);   <span class="comment">//如果是2的话就会添加0,3的话就是1</span></span><br><span class="line">            c &gt;&gt;= <span class="number">1</span>;            <span class="comment">//c/2，如果是2的话会变成</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        String res = stb.reverse().toString();</span><br><span class="line">        <span class="keyword">return</span> c &gt; <span class="number">0</span> ? <span class="string">&#x27;1&#x27;</span> + res : res;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 位运算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>66.加1</title>
      <link href="/post/41236.html"/>
      <url>/post/41236.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="66-加一"><a href="#66-加一" class="headerlink" title="66.加一"></a>66.加一</h1><p>给定一个由 <strong>整数</strong> 组成的 <strong>非空</strong> 数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储<strong>单个</strong>数字。</p><p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line">解释：输入数组表示数字 <span class="number">123</span>。</span><br></pre></td></tr></table></figure><hr><p>+1，是从低位向高位开始</p><p><strong>Solution</strong>：</p><p>思路就是，先从末位开始+1，如果没有进位就是直接return，如果有，就让上一位+1，如果最后循环结束还没返回，说明每一位都是9，那么将数组的长度+1，首位设置为1，其他位设置为0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> len = digits.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            digits[i] = (digits[i] + <span class="number">1</span>) % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (digits[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> digits;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        digits = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>];</span><br><span class="line">        digits[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> digits;                                    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>58.最后一个单词的长度</title>
      <link href="/post/28928.html"/>
      <url>/post/28928.html</url>
      
        <content type="html"><![CDATA[<h1 id="58-最后一个单词的长度"><a href="#58-最后一个单词的长度" class="headerlink" title="58.最后一个单词的长度"></a>58.最后一个单词的长度</h1><p>给你一个字符串 <code>s</code>，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中最后一个单词的长度。</p><p><strong>单词</strong> 是指仅由字母组成、不包含任何空格字符的最大子字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>先把末尾的空格消去了，再从后往前遍历即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (s.charAt(index) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> wordLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &gt;= <span class="number">0</span> &amp;&amp; s.charAt(index) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            wordLength++;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> wordLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>53.最大子序和</title>
      <link href="/post/31352.html"/>
      <url>/post/31352.html</url>
      
        <content type="html"><![CDATA[<h1 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53.最大子序和"></a>53.最大子序和</h1><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：连续子数组 [<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>] 的和最大，为 <span class="number">6</span> 。</span><br></pre></td></tr></table></figure><hr><p><strong>每加入</strong>一个元素进入子序中，都需要<strong>判断</strong>其和</p><p><strong>Solution1</strong>:动态规划</p><p>问题的关键在于 <code>nums[i]</code>到底是单独成为一段，还是加入到<code>f&#123;i-1&#125;</code>对应的那一段中去</p><p>这取决于<code>nums[i]</code>和<code>f&#123;i-1&#125;+nums[i]</code>的大小，如果前者比后者大，那么就是单独成为一段</p><p><code>f&#123;i&#125;</code>只与<code>f&#123;i-1&#125;</code>有关，所以用一个变量pre来维护当前<code>f&#123;i&#125;</code>的<code>f&#123;i-1&#125;</code>的值</p><p>精髓在于段的选取，用pre标志表示了当前的段的和，而maxAns表示了所达到的最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>, maxAns = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            pre = Math.max(pre + x, x);</span><br><span class="line">            maxAns = Math.max(maxAns, pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxAns;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 动态规划 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>35.搜索插入位置</title>
      <link href="/post/30535.html"/>
      <url>/post/30535.html</url>
      
        <content type="html"><![CDATA[<h1 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35.搜索插入位置"></a>35.搜索插入位置</h1><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p><p><strong>示例 1:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], target = <span class="number">5</span></span><br><span class="line">输出: <span class="number">2</span></span><br></pre></td></tr></table></figure><hr><p><strong>寻找</strong>数组中的某个位置</p><p><strong>Solution</strong>:</p><p>既然题目要求了时间复杂度，那么只有用二分查找解决</p><p>如果nums数组内有target，那么二分查找可以找到并返回，如果没有target，那么最后的mid的值正好是其插入位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid =(left+right+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">       <span class="keyword">while</span>(right&gt;=left)&#123;</span><br><span class="line">          <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">              right=mid-<span class="number">1</span>;</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">              left=mid+<span class="number">1</span>;</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              <span class="keyword">return</span> mid;</span><br><span class="line">          &#125;</span><br><span class="line">          mid=(left+right+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> mid ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>27.移除元素</title>
      <link href="/post/50522.html"/>
      <url>/post/50522.html</url>
      
        <content type="html"><![CDATA[<h1 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27.移除元素"></a>27.移除元素</h1><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/原地算法">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并 <strong><a href="https://baike.baidu.com/item/原地算法">原地 </a>修改输入数组</strong>。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>], val = <span class="number">3</span></span><br><span class="line">输出：<span class="number">2</span>, nums = [<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">解释：函数应该返回新的长度 <span class="number">2</span>, 并且 nums 中的前两个元素均为 <span class="number">2</span>。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 <span class="number">2</span> ，而 nums = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>] 或 nums = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>]，也会被视作正确答案。</span><br></pre></td></tr></table></figure><hr><p>遍历并且<strong>移除</strong>数组中的某些元素，这肯定也需要<strong>对比</strong></p><p><strong>Solution1</strong>:双指针</p><p>由于题目要求删除数组中等于 <em>val</em> 的元素，因此输出数组的长度一定小于等于输入数组的长度，我们可以把输出的数组直接写在输入数组上。可以使用双指针：右指针 <em>right</em> 指向当前将要处理的元素，左指针 <em>left</em> 指向下一个将要赋值的位置。</p><ul><li>如果右指针指向的元素不等于 <em>val</em>，它一定是输出数组的一个元素，我们就将右指针指向的元素复制到左指针位置，然后将左右指针同时右移；</li><li>如果右指针指向的元素等于 <em>val</em>，它不能在输出数组里，此时左指针不动，右指针右移一位。</li></ul><p>整个过程保持不变的性质是：区间 [0,<em>left</em>) 中的元素都不等于 <em>val</em>。当左右指针遍历完输入数组以后，<em>left</em> 的值就是输出数组的长度。</p><p>这样的算法在最坏情况下（输入数组中没有元素等于<em>val</em>），左右指针各遍历了数组一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> right = <span class="number">0</span>; right &lt; n; right++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[right] != val) &#123;</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>28.实现strStr()</title>
      <link href="/post/19939.html"/>
      <url>/post/19939.html</url>
      
        <content type="html"><![CDATA[<h1 id="28-实现strStr"><a href="#28-实现strStr" class="headerlink" title="28.实现strStr()"></a>28.实现strStr()</h1><p>实现 <a href="https://baike.baidu.com/item/strstr/811469">strStr()</a> 函数。</p><p>给你两个字符串 <code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 <code>-1</code> 。</p><p><strong>说明：</strong></p><p>当 <code>needle</code> 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p><p>对于本题而言，当 <code>needle</code> 是空字符串时我们应当返回 0 。这与 C 语言的 <a href="https://baike.baidu.com/item/strstr/811469">strstr()</a> 以及 Java 的 <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String">indexOf()</a>) 定义相符。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：haystack = <span class="string">&quot;hello&quot;</span>, needle = <span class="string">&quot;ll&quot;</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><p>没什么好说的，KMP算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">char</span> []a=haystack.toCharArray();</span><br><span class="line">          <span class="keyword">char</span> []b=needle.toCharArray();</span><br><span class="line">          <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">          <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span> (needle.equals(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">int</span>  []next=<span class="keyword">new</span> <span class="keyword">int</span> [b.length+<span class="number">1</span>];</span><br><span class="line">          getNext(b,next);</span><br><span class="line">          <span class="keyword">while</span>(i&lt;a.length)&#123;</span><br><span class="line">              <span class="keyword">if</span>(j==-<span class="number">1</span>||a[i]==b[j])&#123;</span><br><span class="line">                  i++;</span><br><span class="line">                  j++;</span><br><span class="line">              &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  j=next[j];</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span>(j==b.length)&#123;</span><br><span class="line">                  <span class="keyword">return</span> i-j;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        </span><br><span class="line">          <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="keyword">char</span>[] b,<span class="keyword">int</span> []next )</span></span></span><br><span class="line"><span class="function">    </span>&#123;       <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> k=-<span class="number">1</span>;</span><br><span class="line">           </span><br><span class="line">            next[<span class="number">0</span>]=-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;b.length)&#123;</span><br><span class="line">                <span class="keyword">if</span>(k==-<span class="number">1</span>||b[j]==b[k])&#123;</span><br><span class="line">                    j++;</span><br><span class="line">                    k++;</span><br><span class="line">                    next[j]=k;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                     k=next[k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>26.删除有序数组中的重复项</title>
      <link href="/post/42071.html"/>
      <url>/post/42071.html</url>
      
        <content type="html"><![CDATA[<h1 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26.删除有序数组中的重复项"></a>26.删除有序数组中的重复项</h1><p>给你一个有序数组 <code>nums</code> ，请你<strong><a href="http://baike.baidu.com/item/原地算法"> 原地</a></strong> 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 <strong><a href="https://baike.baidu.com/item/原地算法">原地 </a>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">2</span>, nums = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">解释：函数应该返回新的长度 <span class="number">2</span> ，并且原数组 nums 的前两个元素被修改为 <span class="number">1</span>, <span class="number">2</span> 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><hr><hr><p>删除<strong>有序</strong>数组中的<strong>重复</strong>项目，<strong>遍历</strong>并且需要<strong>对比</strong>数组中的重复项</p><p><strong>Solution1</strong>：双指针</p><p>思路就是既然只需要输出不重复的项，那么遍历数组，将不一样的值放入数组前列，因为是有序数组，所以降低了难度。</p><p>定义两个指针 fast和 slow分别为快指针和慢指针，快指针表示遍历数组到达的下标位置，慢指针表示下一个不同元素要填入的下标位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> slow=<span class="number">0</span>;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> fast=<span class="number">1</span>;fast&lt;nums.length;fast++)&#123;</span><br><span class="line">              <span class="keyword">if</span>(nums[slow]!=nums[fast])&#123;</span><br><span class="line">                  nums[slow+<span class="number">1</span>]=nums[fast];</span><br><span class="line">                  slow++;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">       <span class="keyword">return</span> s+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21.合并两个有序链表</title>
      <link href="/post/29475.html"/>
      <url>/post/29475.html</url>
      
        <content type="html"><![CDATA[<h1 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21.合并两个有序链表"></a>21.合并两个有序链表</h1><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p><strong>示例 1：</strong></p><p><a href="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/merge_ex1.jpg"><img src="https://candle-1308820096.cos.ap-chengdu.myqcloud.com/typora/merge_ex1.jpg" alt="img"></a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>], l2 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure><ol><li>如何同时对比两个链表的值？</li><li>最后如何返回头结点？</li></ol><hr><p><strong>Solution</strong>：双指针</p><p>双指针+备份</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode prehead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode prev = prehead; </span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">                prev.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = prev.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span></span><br><span class="line">        prev.next = (l1 == <span class="keyword">null</span>) ? l2 : l1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prehead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20.有效的括号</title>
      <link href="/post/63451.html"/>
      <url>/post/63451.html</url>
      
        <content type="html"><![CDATA[<h1 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a>20.有效的括号</h1><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ol><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;()&quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;()[]&#123;&#125;&quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><hr><hr><p><strong>Solution</strong>：</p><p>首先考虑用栈的思想，如果遇到左括号，就入栈，碰到了右括号，就出栈，对比栈顶元素和右括号是否匹配</p><p>注意到括号都是对应的，所以可以用Map简化操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;Character, Character&gt; pairs = <span class="keyword">new</span> HashMap&lt;Character, Character&gt;() &#123;&#123;</span><br><span class="line">            put(<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            put(<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">            put(<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        Deque&lt;Character&gt; stack = <span class="keyword">new</span> LinkedList&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (pairs.containsKey(ch)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty() || stack.peek() != pairs.get(ch)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14.最长公共前缀</title>
      <link href="/post/14407.html"/>
      <url>/post/14407.html</url>
      
        <content type="html"><![CDATA[<h1 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14.最长公共前缀"></a>14.最长公共前缀</h1><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：strs = [<span class="string">&quot;flower&quot;</span>,<span class="string">&quot;flow&quot;</span>,<span class="string">&quot;flight&quot;</span>]</span><br><span class="line">输出：<span class="string">&quot;fl&quot;</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：strs = [<span class="string">&quot;dog&quot;</span>,<span class="string">&quot;racecar&quot;</span>,<span class="string">&quot;car&quot;</span>]</span><br><span class="line">输出：<span class="string">&quot;&quot;</span></span><br><span class="line">解释：输入不存在公共前缀。</span><br></pre></td></tr></table></figure><p>问题：</p><ol><li>在比较各个字符串的前缀中，如果保证数组不越界？最后返回的有几种情况？</li></ol><hr><p><strong>Solution</strong></p><ol><li><p>首先以第一个字符串的长度为标准，只有两种情况，比第一个字符串短，或者长，每次在对比其他字符串的字符时，首先确认当前遍历的字符没有超过其长度，如果超过，直接以其最短长度返回前缀，</p><p>对于比第一字符串长的情况，如果当最后都相同，那么直接返回第一个字符</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = strs[<span class="number">0</span>].length();</span><br><span class="line">        <span class="keyword">int</span> count = strs.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = strs[<span class="number">0</span>].charAt(i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; count; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == strs[j].length() || strs[j].charAt(i) != c) &#123;</span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13.罗马数字转整数</title>
      <link href="/post/57416.html"/>
      <url>/post/57416.html</url>
      
        <content type="html"><![CDATA[<h1 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13.罗马数字转整数"></a>13.罗马数字转整数</h1><p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             <span class="number">1</span></span><br><span class="line">V             <span class="number">5</span></span><br><span class="line">X             <span class="number">10</span></span><br><span class="line">L             <span class="number">50</span></span><br><span class="line">C             <span class="number">100</span></span><br><span class="line">D             <span class="number">500</span></span><br><span class="line">M             <span class="number">1000</span></span><br></pre></td></tr></table></figure><p>例如， 罗马数字 <code>2</code> 写做 <code>II</code> ，即为两个并列的 1 。<code>12</code> 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 <code>27</code> 写做 <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p><ul><li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li><li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。</li><li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个罗马数字，将其转换成整数。</p><hr><p><strong>Solution</strong></p><p>这种特殊字符对应值的问题，首先考虑用Map结构，然后在观察罗马数字的结构，小的数字一般都在大的数字的右边</p><p>若存在小的数字在大的数字的左边的情况，根据规则需要减去小的数字。</p><p>从右到左遍历，记录当前遇到的最大的数字，遇到更大的就加，并且更新最大数，遇到小的就减</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">      HashMap &lt;Character,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&#x27;I&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;V&#x27;</span>, <span class="number">5</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;X&#x27;</span>, <span class="number">10</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;L&#x27;</span>, <span class="number">50</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;C&#x27;</span>, <span class="number">100</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;D&#x27;</span>, <span class="number">500</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;M&#x27;</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> highestLevel = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> [] c=s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=c.length-<span class="number">1</span>;i&gt;-<span class="number">1</span>;i--)&#123;</span><br><span class="line">             <span class="keyword">int</span> level=map.get(c[i]);</span><br><span class="line">             <span class="keyword">if</span> (level&gt;=highestLevel)&#123;</span><br><span class="line">             result+=level;</span><br><span class="line">             highestLevel=level;</span><br><span class="line">             &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             result-=level;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">             <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
          <category> 哈希表 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.回文数</title>
      <link href="/post/15753.html"/>
      <url>/post/15753.html</url>
      
        <content type="html"><![CDATA[<h1 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9.回文数"></a>9.回文数</h1><p>给你一个整数 <code>x</code> ，如果 <code>x</code> 是一个回文整数，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，<code>121</code> 是回文，而 <code>123</code> 不是。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = <span class="number">121</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：x = <span class="number">-121</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：从左向右读, 为 <span class="number">-121</span> 。 从右向左读, 为 <span class="number">121</span>- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure><hr><p><strong>Solution</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">bool <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况：</span></span><br><span class="line">        <span class="comment">// 如上所述，当 x &lt; 0 时，x 不是回文数。</span></span><br><span class="line">        <span class="comment">// 同样地，如果数字的最后一位是 0，为了使该数字为回文，</span></span><br><span class="line">        <span class="comment">// 则其第一位数字也应该是 0</span></span><br><span class="line">        <span class="comment">// 只有 0 满足这一属性</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> revertedNumber = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; revertedNumber) &#123;</span><br><span class="line">            revertedNumber = revertedNumber * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。</span></span><br><span class="line">        <span class="comment">// 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，</span></span><br><span class="line">        <span class="comment">// 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。</span></span><br><span class="line">        <span class="keyword">return</span> x == revertedNumber || x == revertedNumber / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.两数之和</title>
      <link href="/post/52823.html"/>
      <url>/post/52823.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h1><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">解释：因为 nums[<span class="number">0</span>] + nums[<span class="number">1</span>] == <span class="number">9</span> ，返回 [<span class="number">0</span>, <span class="number">1</span>] 。</span><br></pre></td></tr></table></figure><hr><p>检索某几个数组元素之间<strong>关系</strong>，并且要求返回它们对应的<strong>下标</strong></p><ol><li>需要返回的是两个数组的下标，也就是要遍历很多遍数组</li><li>有没有办法只遍历一次数组？</li></ol><p><strong>Solution 1</strong>：bp算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bp算法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> []a=&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]==target)&#123;</span><br><span class="line">                       a[<span class="number">0</span>]=i;</span><br><span class="line">                       a[<span class="number">1</span>]=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单设置两个for循环来遍历数组</p><hr><p><strong>Solution2</strong>：HashMap</p><p>因为要返回的是数组下标，所有用HashMap求解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//key值是nums[i],Value值是下标</span></span><br><span class="line">        HashMap&lt;Integer,Integer&gt; hashmap=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hashmap.containsKey(target-nums[i])) <span class="comment">//如果key值有target-nums[i]</span></span><br><span class="line">        &#123;      </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span> []&#123;hashmap.get(target-nums[i]),i&#125;;<span class="comment">//返回下标</span></span><br><span class="line">        &#125;</span><br><span class="line">            hashmap.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> 哈希表 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
